<!-- PoppySuite v2.0 | Released: 2026-02-10 | Changes: Quiz output display fix, LLM intent detection, enhanced chat rendering, improved export reliability, input persistence -->
<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poppy Suite - Unified CX Intelligence</title>


    <script>
        (function () {
            const earlyWarn = console.warn;
            console.warn = function (...args) {
                const msg = args && args[0] ? String(args[0]) : "";
                if (msg.includes('cdn.tailwindcss.com')) return;
                if (msg.includes('in-browser Babel transformer')) return;
                return earlyWarn.apply(console, args);
            };
        })();
    </script>


    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>


    <!-- html2canvas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <!-- FIX: html2canvas crash on gradients (non-finite values) -->
    <script>
        (function () {
            if (window.CanvasGradient) {
                const originalAddColorStop = window.CanvasGradient.prototype.addColorStop;
                window.CanvasGradient.prototype.addColorStop = function (offset, color) {
                    if (typeof offset !== 'number' || !isFinite(offset)) return;
                    if (offset < 0) offset = 0;
                    if (offset > 1) offset = 1;
                    originalAddColorStop.call(this, offset, color);
                };
            }
        })();
    </script>


    <!-- JSZip -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>


    <!-- SheetJS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <!-- Marked for Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>


    <!-- Mammoth.js for DOCX parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>


    <!-- Import Map -->
    <script type="importmap">
    {
    "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom": "https://esm.sh/react-dom@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
        "lucide-react": "https://esm.sh/lucide-react@0.294.0",
        "recharts": "https://esm.sh/recharts@2.12.2?bundle&target=es2019&external=react,react-dom"
    }
    }
    </script>


    <!-- React UMD for Babel -->
    <script src="https://unpkg.com/react@18.2.0/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-is@18.2.0/umd/react-is.production.min.js" crossorigin></script>

    <!-- ES Modules will be used instead of UMD -->

    <!-- Babel 7.23.6 for stable ES module support -->
    <script src="https://unpkg.com/@babel/standalone@7.23.6/babel.min.js" crossorigin></script>

    <!-- Immediate Babel override -->
    <script>
        // Consolidated Babel initialization and auto-processing prevention
        (function () {
            function disableAuto(b) {
                if (!b) return;
                if (b.transformScriptTags) {
                    b.transformScriptTags = function () {
                        return;
                    };
                }
                if (b.pendingScripts) b.pendingScripts = [];
            }

            if (window.Babel) {
                disableAuto(window.Babel);
            } else {
                let _babel = undefined;
                Object.defineProperty(window, 'Babel', {
                    get: () => _babel,
                    set: (v) => {
                        _babel = v;
                        disableAuto(v);
                    },
                    configurable: true,
                    enumerable: true
                });
            }
        })();

        // Global error handler to suppress Babel require errors
        window.addEventListener('error', function (e) {
            if (e.message && e.message.includes('require is not defined')) {
                console.warn('Suppressed Babel require error:', e.message);
                e.preventDefault();
                return false;
            }
        });
    </script>

    <!-- Disable Babel auto-processing -->
    <script>
        // Create a fake require function to prevent errors
        window.require = function () {
            console.warn("require() called but not available in browser environment");
            return {};
        };

        // Completely disable Babel auto-processing before it loads
        window.__DISABLE_BABEL_AUTO_PROCESSING__ = true;

        // Prevent any script tags from being processed by Babel
        const scriptObserver = new MutationObserver(function (mutations) {
            mutations.forEach(function (mutation) {
                mutation.addedNodes.forEach(function (node) {
                    if (node.nodeType === 1 && node.tagName === 'SCRIPT') {
                        // Remove any Babel-related attributes that might trigger processing
                        if (node.type === 'text/babel' || node.type === 'text/jsx') {
                            node.type = 'text/javascript';
                        }
                        node.removeAttribute('data-presets');
                        node.removeAttribute('data-plugins');
                    }
                });
            });
        });

        // Start observing before DOM is ready
        scriptObserver.observe(document.documentElement, {
            childList: true,
            subtree: true
        });

    </script>


    <!-- Marked.js for fast Markdown parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/12.0.0/marked.min.js"></script>


    <!-- Console Warning Suppressor -->
    <script>
        const originalConsoleError = console.error;
        console.error = function (...args) {
            const msg = args.map(String).join(' ');
            if (msg.includes('deoptimised the styling') || msg.includes('exceeds the max of 500KB')) {
                return;
            }
            originalConsoleError.apply(console, args);
        };
    </script>


    <!-- Markdown Styles -->
    <style type="text/tailwindcss">
        .markdown-content h1 { @apply font-bold text-lg text-slate-900 mb-2 border-b border-slate-200 pb-1; }
            .markdown-content h2 { @apply font-bold text-base text-slate-800 mt-4 mb-2 uppercase tracking-wide; }
            .markdown-content h3 { @apply font-bold text-sm text-slate-700 mt-3 mb-1; }
            .markdown-content p { @apply mb-2 last:mb-0 whitespace-pre-wrap; }
            .markdown-content ul { @apply list-disc pl-5 mb-2 space-y-1; }
            .markdown-content ol { @apply list-decimal pl-5 mb-2 space-y-1; }
            .markdown-content li { @apply pl-1; }
            .markdown-content strong { @apply font-bold text-slate-900; }
            .markdown-content em { @apply italic text-slate-600; }
            .markdown-content blockquote { @apply border-l-4 border-slate-200 pl-3 italic text-slate-500 my-2; }
            .markdown-content code { @apply bg-slate-100 px-1 py-0.5 rounded text-xs font-mono text-rose-500; }
            .markdown-content pre { @apply bg-slate-100 p-2 rounded text-xs font-mono overflow-x-auto; }
            .markdown-content table { @apply w-full text-xs text-left border-collapse my-2 border border-slate-200 rounded-lg; }
            .markdown-content th { @apply p-2 font-bold text-slate-700 bg-slate-50 border-b border-slate-200; }
            .markdown-content td { @apply p-2 border-b border-slate-50 last:border-0; }
        </style>


    <!-- Tailwind Config -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        glass: {
                            100: 'rgba(255, 255, 255, 0.2)',
                            200: 'rgba(255, 255, 255, 0.4)',
                            300: 'rgba(255, 255, 255, 0.6)',
                            border: 'rgba(255, 255, 255, 0.4)'
                        }
                    },
                    animation: {
                        'fade-in': 'fadeIn 0.5s ease-out forwards',
                        'slide-up': 'slideUp 0.5s ease-out forwards',
                    }
                }
            }
        }
    </script>


    <style>
        @import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@300;400;500;600;700;800&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap');


        /* Animation Utilities (Compatibility with tailwindcss-animate) */
        .animate-in {
            animation-duration: 0.5s;
            animation-timing-function: ease-out;
            animation-fill-mode: forwards;
        }


        .fade-in {
            animation-name: fadeIn;
        }


        .slide-in-from-bottom-4 {
            animation-name: slideUp;
        }


        .slide-in-from-top-2 {
            animation-name: slideDown;
        }


        @keyframes fadeIn {
            from {
                opacity: 0;
            }


            to {
                opacity: 1;
            }
        }


        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(1rem);
            }


            to {
                opacity: 1;
                transform: translateY(0);
            }
        }


        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-0.5rem);
            }


            to {
                opacity: 1;
                transform: translateY(0);
            }
        }


        /* Sunrise Toolbar - Floating Out Design */
        .sunrise-toolbar {
            position: absolute;
            top: -38px;
            /* MOVES IT OUTSIDE */
            right: 0;
            z-index: 99999 !important;
            /* Forces it above ALL elements including filters */
            opacity: 0;
            transform: translateY(10px) scale(0.9);
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none;

            /* Visual Tweaks */
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(4px);
            padding: 4px;
            border-radius: 999px;
            border: 1px solid rgba(226, 232, 240, 0.8);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .group:hover .sunrise-toolbar,
        .sunrise-toolbar:focus-within {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }

        .table-wrapper {
            overflow-x: auto;
            overflow-y: visible;
            width: 100%;
            -webkit-overflow-scrolling: touch;
            padding: 0 !important;
            margin: 0 !important;
        }

        .table-wrapper {
            position: relative;
            z-index: 1;
        }

        .table-wrapper table {
            position: relative;
            min-width: 100%;
        }

        .table-wrapper thead {
            position: relative;
            z-index: 10;
        }

        thead.sticky,
        thead.sticky th {
            background-color: rgb(248 250 252);
        }

        thead.sticky {
            z-index: 30;
        }

        .table-wrapper>table {
            min-width: max-content;
        }

        td ul,
        td ol {
            text-align: left;
        }

        /* Grid containers for KPI, Chart, Table, Text blocks - overflow visible for toolbar */
        .kpi-grid,
        .chart-grid-2,
        .chart-grid-3,
        .bento-grid {
            overflow: visible !important;
        }

        /* Animation line for all card types - Chart, Table, Text blocks */
        .block-card-animated:not(button):not(a),
        .glass-card,
        div:has(> table).custom-scrollbar,
        /* FIX Issue 1: Apply animation line to all card containers */
        .glass-card>div[class*="rounded-xl"],
        .glass-card>div[class*="rounded-2xl"],
        .recharts-wrapper,
        .recharts-wrapper~div,
        .table-scroll-container {
            position: relative;
            overflow: visible;
        }

        .block-card-animated:not(button):not(a)::before,
        .glass-card::before,
        div:has(> table).custom-scrollbar::before,
        /* FIX Issue 1: Apply animation line pseudo-element to all card containers */
        .glass-card>div[class*="rounded-xl"]::before,
        .glass-card>div[class*="rounded-2xl"]::before,
        [id$="-chart"]::before,
        .glass-card:has([id$="-table"])::before,
        .glass-card:has([id$="-chart"])::before,
        .glass-card:has(.recharts-wrapper)::before,
        .glass-card:has(table)::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6, #ec4899);
            background-size: 200% 200%;
            opacity: 1;
            transition: opacity 0.3s ease;
            animation: gradientShift 6s ease infinite;
            z-index: 10;
        }

        .block-card-animated:not(button):not(a):hover::before,
        .glass-card:hover::before,
        div:has(> table).custom-scrollbar:hover::before,
        /* FIX Issue 1: Hover state for all card containers */
        .glass-card:hover>div[class*="rounded-xl"]::before,
        .glass-card:hover>div[class*="rounded-2xl"]::before,
        [id$="-chart"]:hover::before,
        .glass-card:has([id$="-table"]):hover::before,
        .glass-card:has([id$="-chart"]):hover::before,
        .glass-card:has(.recharts-wrapper):hover::before,
        .glass-card:has(table):hover::before {
            opacity: 1;
        }

        /* Issues #5/#9 Fix: Tighter AI content spacing & Bullet Visibility */
        .ai-response-content p,
        .markdown-content p {
            margin-bottom: 0.75em;
            line-height: 1.6;
        }

        .ai-response-content ul,
        .markdown-content ul {
            list-style-type: disc !important;
            padding-left: 1.5rem !important;
            margin-bottom: 0.75em;
            margin-left: 0.5rem;
        }

        .ai-response-content ol,
        .markdown-content ol {
            list-style-type: decimal !important;
            padding-left: 1.5rem !important;
            margin-bottom: 0.75em;
            margin-left: 0.5rem;
        }

        .ai-response-content li,
        .markdown-content li {
            margin-bottom: 0.25em;
            display: list-item !important; /* Force list-item display */
        }



        /* PDF Export Optimization */
        /* PDF Export Optimization - Critical Fixes */
        .pdf-export-mode * {
            animation: none !important;
            transition: none !important;
            box-shadow: none !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }


        /* FIX 1: Prevent Title Cut-off */
        /* Resets the negative margins that cause headers to bleed out of the capture area */
        .pdf-export-mode .card-header-tint {
            margin: 0 !important;
            width: 100% !important;
            border-radius: 12px 12px 0 0 !important;
            background: #f8fafc !important;
            border-bottom: 2px solid #e2e8f0 !important;
            padding: 12px 20px !important;
        }


        /* Adjust card padding since header is no longer negative */
        .pdf-export-mode .glass-card {
            padding: 0 !important;
            border: 1px solid #cbd5e1 !important;
            background: #ffffff !important;
            overflow: visible !important;
            page-break-inside: avoid !important;
            break-inside: avoid !important;
        }


        /* FIX Issue 5: PDF export table handling - expand for print */
        .pdf-export-mode .glass-card:has([id$="-table"])>div:last-child,
        .pdf-export-mode .glass-card:has(table)>div:last-child {
            max-height: none !important;
            overflow: visible !important;
            height: auto !important;
        }


        /* Ensure content inside card has breathing room */
        .pdf-export-mode .card-header-tint+div {
            padding: 24px !important;
        }


        .pdf-export-mode .shadow-sm,
        .pdf-export-mode .shadow-md,
        .pdf-export-mode .shadow-lg,
        .pdf-export-mode .shadow-xl,
        .pdf-export-mode .shadow-2xl {
            box-shadow: none !important;
            border: 1px solid #e2e8f0 !important;
        }


        /* Glassmorphism */
        .glass-panel {
            background: rgba(255, 255, 255, 0.65);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.05);
        }

        .glass-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.6);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
            overflow: visible !important;
        }

        /* Global Table Alignment Rule */
        table th,
        table td {
            text-align: left;
        }

        table th.text-center,
        table td.text-center {
            text-align: center;
        }

        table th.text-right,
        table td.text-right {
            text-align: right;
        }

        table td ul,
        table td ol {
            text-align: left;
            margin: 0;
            padding-left: 1.25rem;
        }

        /* Fix for Score/Impact columns which might have specific alignment needs but user said center */
        .text-right {
            text-align: right !important;
        }

        .text-left:first-child {
            text-align: left !important;
        }


        /* Card header area */
        .glass-card>div:first-child {
            padding-bottom: 8px !important;
        }

        /* Card content area - remove bottom padding */
        .glass-card>div:last-child {
            padding-top: 8px !important;
        }

        /* Card header area */
        .glass-card>div:first-child {
            padding-bottom: 8px !important;
        }





        body {
            /* Force Light Mode & Table Fixes */
            background: #f8fafc !important;
            color: #0f172a !important;

            /* Table Styling Fixes */
        }

        table td,
        table th {
            padding: 8px 12px !important;
        }

        table {
            width: 100% !important;
            border-collapse: collapse;
        }

        .overflow-x-auto {
            overflow-x: auto !important;
        }

        /* Remove Dark Mode */
        .dark {
            display: none !important;
        }

        /* Fix Layout Spacing */
        main,
        .app-container {
            padding-bottom: 0 !important;
            margin-bottom: 0 !important;
        }


        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            color: #0f172a;
            min-height: 100vh;
            overflow-x: hidden;
        }


        main {
            max-width: 100%;
            margin: 0 auto;
            padding: 1rem;
            padding-bottom: 0 !important;
            /* FIX Issue 34: Remove blank space at bottom */
        }


        /* FIX Issue 34: App container remove extra bottom space */
        .app-container {
            padding-bottom: 0 !important;
        }


        .chart-container {
            width: 100%;
            height: 400px;
        }


        /* Legend toggle support (works for Recharts default legend) */
        .legend-hidden .recharts-default-legend {
            display: none !important;
        }


        /* Table search highlight */
        .table-search-highlight {
            background-color: #fde68a;
            color: inherit;
            border-radius: 4px;
            padding: 0 2px;
        }


        /* --- Color System Variables --- */
        :root {
            --color-primary: #3b82f6;
            --color-success: #10b981;
            --color-warning: #f59e0b;
            --color-danger: #ef4444;
            --color-info: #8b5cf6;

            --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --gradient-success: linear-gradient(135deg, #10b981 0%, #059669 100%);
            --gradient-danger: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);

            /* CSS Variables for theming (Phase 5.6 - Dark Mode Preparation) */
            --color-bg-primary: #ffffff;
            --color-bg-secondary: #f8fafc;
            --color-text-primary: #0f172a;
            --color-text-secondary: #64748b;
            --color-border: #e2e8f0;
        }

        [data-theme="dark"] {
            --color-bg-primary: #0f172a;
            --color-bg-secondary: #1e293b;
            --color-text-primary: #f1f5f9;
            --color-text-secondary: #94a3b8;
            --color-border: #334155;
        }


        /* --- PDF & Export Hardening --- */
        .export-atomic {
            break-inside: avoid !important;
            page-break-inside: avoid !important;
            overflow: visible !important;
        }


        .pdf-export-mode .export-atomic {
            margin-bottom: 2rem !important;
        }


        /* Hide excluded elements during PDF export */
        .pdf-export-mode [data-html2canvas-ignore],
        .pdf-export-mode .no-export,
        .pdf-export-mode .no-capture,
        .pdf-export-mode .sunrise-toolbar,
        .pdf-export-mode #ai-floating-btn,
        .pdf-export-mode #ai-chat-panel,
        .pdf-export-mode #ai-assistant-btn {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }


        /* --- Unified Sticky Navigation Bar --- */


        /* --- Dynamic Percentage-Based Resizing --- */
        /* Base font size for percentage calculations */
        html {
            font-size: 16px;
            /* Base size */
        }


        /* Main App Container */
        .app-container {
            width: 100%;
            min-height: 100vh;
            background-color: #f8fafc;
        }

        :root {
            --app-max-width: 1440px;
            --app-side-padding: 1.5rem;
        }

        [id$="-view-container"] {
            max-width: 100%;
            margin-left: auto;
            margin-right: auto;
            padding-left: 1rem;
            padding-right: 1rem;
            width: 100%;
        }


        /* --- Unified Sticky Navigation Bar --- */
        .unified-sticky-nav {
            position: sticky;
            top: 0;
            z-index: 80;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(8px);
            border-bottom: 1px solid #e2e8f0;
            box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            transition: all 0.3s ease;
        }


        .unified-sticky-nav .nav-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 1.5rem;
            padding-left: max(1.5rem, calc((100vw - var(--app-max-width)) / 2));
            padding-right: max(1.5rem, calc((100vw - var(--app-max-width)) / 2));
            height: 56px;
            min-height: 56px;
            border-bottom: 1px solid #e2e8f0;
            gap: 1rem;
            width: 100%;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px) saturate(180%);
            position: relative;
            z-index: 70;
            flex-wrap: nowrap;
        }

        /* Mission 3: View Selector Dynamic Space */
        .unified-sticky-nav .nav-header > div:last-child > div:first-child {
            flex: 1 1 auto;
            overflow-x: auto;
            scrollbar-width: none;
        }
        
        .unified-sticky-nav .nav-header > div:last-child > div:first-child::-webkit-scrollbar {
            display: none;
        }

        /* Baseline tab button sizing to ensure consistent height/alignment across views */
        .unified-sticky-nav .nav-header button {
            font-size: 10px;
            padding: 0.375rem 0.75rem;
            flex-shrink: 0;
            white-space: nowrap;
        }

        .nav-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
            background: rgba(255, 255, 255, 0.95);
            border-bottom: 1px solid #e2e8f0;
            padding: 0.375rem 1.5rem;
            padding-left: max(1.5rem, calc((100vw - var(--app-max-width)) / 2));
            padding-right: max(1.5rem, calc((100vw - var(--app-max-width)) / 2));
            width: 100%;
        }


        /* --- Responsive Design --- */


        /* 1024px Breakpoint */
        @media (max-width: 1024px) {
            .grid-cols-4 {
                grid-template-columns: repeat(2, 1fr) !important;
            }


            .grid-cols-3 {
                grid-template-columns: repeat(2, 1fr) !important;
            }


            .grid-cols-2 {
                grid-template-columns: 1fr !important;
            }


            .unified-sticky-nav .nav-header button {
                font-size: 11px !important;
                padding: 0.45rem 0.6rem !important;
            }
        }


        /* 768px Breakpoint */
        @media (max-width: 768px) {


            .nav-filters {
                flex-wrap: wrap;
                gap: 0.5rem !important;
            }


            .nav-filters>* {
                flex: 1 1 auto;
                min-width: 120px;
            }


            .grid {
                grid-template-columns: 1fr !important;
            }


            table {
                font-size: 10px !important;
            }


            .text-2xl {
                font-size: 1.25rem !important;
            }


            .text-xl {
                font-size: 1rem !important;
            }


            .text-lg {
                font-size: 0.875rem !important;
            }


            .p-6 {
                padding: 1rem !important;
            }


            .p-8 {
                padding: 1.5rem !important;
            }


            .gap-8 {
                gap: 1rem !important;
            }


            .gap-6 {
                gap: 0.75rem !important;
            }


            /* Modal and Charts */
            .z-modal>div {
                max-width: 95vw !important;
                max-height: 95vh !important;
                padding: 0.5rem !important;
            }


            .recharts-wrapper {
                width: 100% !important;
            }


            .recharts-surface {
                width: 100% !important;
            }
        }


        /* Ensure view switch buttons are always visible (general rule) */
        .unified-sticky-nav .nav-header>div:last-child {
            display: flex !important;
            flex-wrap: nowrap;
            gap: 0.5rem;
            align-items: center;
            min-width: 0;
        }


        /* --- Utilities --- */
        table {
            width: 100%;
            display: table;
            min-width: max-content;
        }

        .ai-response-content li {
            margin-bottom: 0 !important;
            padding-bottom: 0 !important;
            line-height: 1.4;
        }


        .overflow-x-auto {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            position: relative;
            z-index: 1;
        }


        /* Specific override for tab bar to prevent scrollbar when possible */
        .tab-bar-container {
            overflow-x: auto;
            display: flex;
            gap: 0.25rem;
            flex: 1 1 auto;
            scrollbar-width: none;
        }

        .tab-bar-container button {
            flex-shrink: 0;
            white-space: nowrap;
        }


        @media (max-width: 1200px) {
            .tab-bar-container {
                gap: 0.125rem;
            }


            .tab-bar-container button {
                padding-left: 0.35rem !important;
                padding-right: 0.35rem !important;
                font-size: 8px !important;
            }
        }


        .bg-white.border.rounded-2xl {
            min-width: 0;
        }


        .whitespace-pre-wrap {
            white-space: pre-wrap;
        }


        .select-text {
            user-select: text !important;
        }


        .compact-ui {
            font-size: 10px !important;
        }


        .z-dropdown {
            z-index: 60;
        }


        .z-modal {
            z-index: 10000;
        }


        button,
        a {
            cursor: pointer;
        }


        * {
            text-decoration: none !important;
        }


        /* Scrollbar */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }


        .custom-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }


        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 99px;
        }


        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }


        /* Effects */
        .tab-active {
            background: #1e293b;
            color: #ffffff;
            border: 1px solid #1e293b;
            font-weight: 700;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
        }


        .card-shadow {
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
        }


        .card-hover:hover {
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1);
            transform: translateY(-1px);
            transition: all 0.2s ease;
        }


        /* Grids */
        .bento-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 1.5rem;
            width: 100%;
            overflow: visible;
        }


        .kpi-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1.5rem;
            overflow: visible;
        }


        .chart-grid-2 {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 2rem;
            overflow: visible;
        }


        .chart-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            overflow: visible;
        }


        /* Modern Card Design */
        .bg-white.border.rounded-2xl {
            background: white;
            border: 1px solid rgb(226 232 240 / 0.6);
            border-radius: 1rem;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.05), 0 1px 2px -1px rgb(0 0 0 / 0.05);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }


        .bg-white.border.rounded-2xl::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6, #ec4899);
            opacity: 0;
            transition: opacity 0.3s ease;
        }


        .bg-white.border.rounded-2xl:hover::before {
            opacity: 1;
        }


        .bg-white.border.rounded-2xl:hover {
            box-shadow: 0 10px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            transform: translateY(-2px);
            border-color: rgb(203 213 225);
        }


        /* Modern Table */
        .modern-table {
            width: 100%;
            border-collapse: collapse !important;
            border-spacing: 0;
            min-width: max-content;
        }


        .modern-table thead {
            background: linear-gradient(to bottom, #f8fafc, #f1f5f9);
            position: sticky;
            top: 0;
            z-index: 40;
            margin: 0;
            padding: 0;
            background-color: #ffffff;
        }


        .modern-table thead th {
            padding: 1rem;
            text-align: left;
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            color: #64748b;
            border-bottom: 2px solid #e2e8f0;
            letter-spacing: 0.05em;
            position: sticky;
            top: 0;
            z-index: 40;
            background-color: #ffffff;
        }


        table thead {
            background-color: #ffffff;
            position: sticky;
            top: 0;
            z-index: 40;
            margin: 0;
            padding: 0;
        }


        table thead th {
            position: sticky;
            top: 0;
            z-index: 40;
            background-color: #ffffff;
            box-shadow: inset 0 -1px 0 #e2e8f0;
        }
        
        /* Mission 3: Table Wrapper & Filter Container */
        .table-wrapper, .overflow-x-auto {
            position: relative;
            z-index: 1;
        }
        
        .filter-container, .filters {
            flex-wrap: wrap;
        }
        
        /* Mission 3: AI Bullet Points Whitespace */
        .ai-response-content li { margin-bottom: 0 !important; padding-bottom: 0 !important; line-height: 1.4; }


        table tbody td {
            text-align: center;
        }


        table tbody td.text-left {
            text-align: left;
        }


        table tbody td ul,
        table tbody td ol,
        table tbody td li {
            text-align: left;
        }


        .modern-table tbody tr {
            transition: all 0.2s ease;
        }


        .modern-table tbody tr:hover {
            background: linear-gradient(to right, #f8fafc, #ffffff);
            transform: scale(1.01);
            box-shadow: 0 2px 8px -2px rgb(0 0 0 / 0.1);
        }


        .modern-table tbody td {
            padding: 1rem;
            border-bottom: 1px solid #f1f5f9;
            font-size: 0.875rem;
        }


        .modern-table tbody tr:nth-child(even) {
            background: #fafafa;
        }


        /* Typography */
        .text-display {
            font-size: 3rem;
            font-weight: 900;
            line-height: 1.1;
            letter-spacing: -0.02em;
        }


        .text-heading {
            font-size: 1.5rem;
            font-weight: 800;
            line-height: 1.2;
            letter-spacing: -0.01em;
        }


        .text-subheading {
            font-size: 1.125rem;
            font-weight: 700;
            line-height: 1.3;
        }


        .text-body {
            font-size: 0.875rem;
            font-weight: 500;
            line-height: 1.5;
        }


        .text-caption {
            font-size: 0.75rem;
            font-weight: 600;
            line-height: 1.4;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }


        /* ============================================
            ANIMATED UPLOAD PAGE DESIGN
            ============================================ */


        /* Animated gradient background */
        @keyframes gradientShift {

            0%,
            100% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }
        }

        /* Enhanced gradient animation for glass cards */
        .glass-card::before {
            background: linear-gradient(90deg,
                    #3b82f6 0%,
                    #8b5cf6 25%,
                    #ec4899 50%,
                    #f59e0b 75%,
                    #3b82f6 100%);
            background-size: 300% 300%;
        }

        /* Shimmer animation for loading states */
        @keyframes shimmer {
            0% {
                background-position: -1000px 0;
            }

            100% {
                background-position: 1000px 0;
            }
        }

        .loading-skeleton {
            background: linear-gradient(90deg,
                    #f1f5f9 25%,
                    #e2e8f0 50%,
                    #f1f5f9 75%);
            background-size: 1000px 100%;
            animation: shimmer 2s infinite;
            border-radius: 8px;
        }

        .chart-loading,
        .table-loading {
            min-height: 200px;
            background: linear-gradient(90deg,
                    #f1f5f9 25%,
                    #e2e8f0 50%,
                    #f1f5f9 75%);
            background-size: 1000px 100%;
            animation: shimmer 2s infinite;
            border-radius: 8px;
        }

        /* Semantic status colors */
        .status-excellent {
            color: #059669;
            background: #d1fae5;
        }

        .status-good {
            color: #0284c7;
            background: #dbeafe;
        }

        .status-warning {
            color: #d97706;
            background: #fef3c7;
        }

        .status-poor {
            color: #dc2626;
            background: #fee2e2;
        }

        /* Enhanced typography */
        body {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }

        h1,
        h2,
        h3,
        h4 {
            letter-spacing: -0.02em;
        }

        .card-title {
            font-weight: 600;
            color: #0f172a;
        }

        .text-xs {
            letter-spacing: 0.01em;
        }


        @keyframes float {


            0%,
            100% {
                transform: translateY(0px) rotate(0deg);
            }


            50% {
                transform: translateY(-20px) rotate(5deg);
            }
        }


        @keyframes floatReverse {


            0%,
            100% {
                transform: translateY(0px) rotate(0deg);
            }


            50% {
                transform: translateY(20px) rotate(-5deg);
            }
        }


        @keyframes pulse {


            0%,
            100% {
                opacity: 0.4;
                transform: scale(1);
            }


            50% {
                opacity: 0.8;
                transform: scale(1.05);
            }
        }


        @keyframes spin {
            from {
                transform: rotate(0deg);
            }


            to {
                transform: rotate(360deg);
            }
        }


        @keyframes glow {


            0%,
            100% {
                box-shadow: 0 0 40px rgba(99, 102, 241, 0.3);
            }


            50% {
                box-shadow: 0 0 80px rgba(99, 102, 241, 0.6);
            }
        }


        .upload-page-bg {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(-45deg, #0f172a, #1e1b4b, #0f172a, #172554);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            overflow: hidden;
            z-index: 0;
        }


        /* Fixed orbs to prevent page stretching */
        .orbs-container {
            position: fixed;
            inset: 0;
            overflow: hidden;
            pointer-events: none;
            z-index: 0;
        }


        .upload-page-bg::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(99, 102, 241, 0.1) 0%, transparent 50%);
            animation: spin 60s linear infinite;
        }


        /* Floating orbs */
        .floating-orb {
            position: absolute;
            border-radius: 50%;
            filter: blur(40px);
            pointer-events: none;
        }


        .orb-1 {
            width: 400px;
            height: 400px;
            background: radial-gradient(circle, rgba(99, 102, 241, 0.4) 0%, transparent 70%);
            top: 10%;
            left: 10%;
            animation: float 8s ease-in-out infinite;
        }


        .orb-2 {
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, rgba(167, 139, 250, 0.4) 0%, transparent 70%);
            top: 60%;
            right: 10%;
            animation: floatReverse 10s ease-in-out infinite;
        }


        .orb-3 {
            width: 250px;
            height: 250px;
            background: radial-gradient(circle, rgba(59, 130, 246, 0.4) 0%, transparent 70%);
            bottom: 20%;
            left: 30%;
            animation: float 12s ease-in-out infinite;
        }


        .orb-4 {
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(236, 72, 153, 0.3) 0%, transparent 70%);
            top: 30%;
            right: 30%;
            animation: pulse 6s ease-in-out infinite;
        }


        /* Update the .upload-card class */
        .upload-card {
            background: rgba(30, 41, 59, 0.6);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 2rem;
            padding: 2.5rem;
            /* Reduced from 3rem */
            max-width: 480px;
            width: 100%;
            text-align: center;
            position: relative;
            z-index: 10;
            animation: glow 4s ease-in-out infinite;
        }


        /* Add this NEW Media Query immediately after .upload-card */
        @media (max-height: 800px) {
            .upload-card {
                padding: 1.5rem;
            }


            .upload-icon {
                width: 60px;
                height: 60px;
                margin-bottom: 1rem;
            }


            .feature-badge {
                padding: 0.25rem 0.75rem;
            }
        }


        .upload-card:hover {
            border-color: rgba(99, 102, 241, 0.5);
            transform: translateY(-4px);
            transition: all 0.3s ease;
        }


        /* Gradient text */
        .gradient-text {
            background: linear-gradient(135deg, #a78bfa 0%, #60a5fa 50%, #34d399 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }


        /* Upload icon animation */
        .upload-icon {
            width: 80px;
            height: 80px;
            margin: 0 auto 1.5rem;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(167, 139, 250, 0.2));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid rgba(99, 102, 241, 0.3);
            animation: pulse 3s ease-in-out infinite;
        }


        /* File upload button */
        .upload-btn {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
            font-weight: 700;
            padding: 1rem 2.5rem;
            border-radius: 1rem;
            cursor: pointer;
            border: none;
            transition: all 0.3s ease;
            box-shadow: 0 8px 32px rgba(99, 102, 241, 0.4);
        }


        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(99, 102, 241, 0.6);
        }


        /* Clean Slate Aesthetic */
        body {
            background-color: #f8fafc;
            /* Lighter slate/white mix */
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            -webkit-font-smoothing: antialiased;
        }


        .glass-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(12px);
            border: 1px solid #e2e8f0;
            /* Light slate border */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
            /* Soft shadow */
        }


        /* Glassmorphism / Card Styles - HIGH CONTRAST FLATTENED */
        .glass-card {
            background: #ffffff;
            border: 1px solid #e2e8f0;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: visible;
            position: relative;
            padding: 1.5rem;
            /* Equivalent to p-6 */
        }

        /* Purple animation line for glass-card */
        .glass-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6, #ec4899);
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 50;
        }

        .glass-card:hover::before {
            opacity: 1;
        }


        .glass-card:hover {
            box-shadow:
                0 10px 15px -3px rgba(0, 0, 0, 0.1),
                0 4px 6px -2px rgba(0, 0, 0, 0.05),
                0 0 0 1px rgba(59, 130, 246, 0.1);
            transform: translateY(-2px);
            border-color: #cbd5e1;
        }

        .glass-card:hover::before {
            height: 4px;
        }


        .sunrise-toolbar {
            position: absolute;
            top: -36px;
            right: 0;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(148, 163, 184, 0.35);
            border-radius: 0.5rem;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.18);
            opacity: 0;
            transform: translateY(10px) scale(0.9);
            transform-origin: bottom right;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none;
            will-change: transform, opacity;
            z-index: 99999 !important;
            white-space: nowrap;
            min-width: auto;
        }

        /* Enhanced hover detection area for sunrise toolbar */
        .sunrise-toolbar::before {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            pointer-events: auto;
            z-index: -1;
        }

        /* Button press feedback */
        .sunrise-toolbar button:active {
            transform: scale(0.95);
            transition: transform 0.05s ease;
        }


        .group:hover .sunrise-toolbar,
        .sunrise-toolbar:focus-within {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }


        /* PDF export mode - hide toolbar */
        .pdf-export-mode .sunrise-toolbar {
            display: none !important;
        }


        /* FIX Issue 21: Grid layouts prevent overlapping */
        .grid:has(>.glass-card) {
            display: grid;
            grid-auto-rows: min-content;
        }


        /* Section Tints */
        .section-secondary {
            background-color: #f1f5f9;
            border-radius: 1.5rem;
            padding: 1.5rem;
            border: 1px solid #e2e8f0;
        }


        /* High Density Overrides */
        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            letter-spacing: -0.025em;
            font-weight: 800;
            /* Extra bold for stronger hierarchy */
            color: #0f172a;
            /* Slate 900 */
        }


        .card-header-tint {
            background: linear-gradient(to right, #f8fafc, #ffffff);
            border-bottom: 1px solid #f1f5f9;
            margin: -1.5rem -1.5rem 1.5rem -1.5rem;
            padding: 1rem 1.5rem;
            border-radius: 1rem 1rem 0 0;
        }

        /* Fix: ID 11 - Flat header for p-0 cards to prevent clipping */
        .card-header-flat {
            background: linear-gradient(to right, #f8fafc, #ffffff);
            border-bottom: 1px solid #f1f5f9;
            margin: 0;
            padding: 0.75rem 1rem;
            border-radius: 1rem 1rem 0 0;
        }


        /* Modern Scrollbar */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }


        .custom-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }


        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }


        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }


        /* Feature Badges - Refined */
        .feature-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.35rem 0.75rem;
            background: #eef2ff;
            border: 1px solid #e0e7ff;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
            color: #6366f1;
        }

        /* ============================================
           ENHANCED AI CHATBOT STYLES
           ============================================ */

        /* Resizable panel cursor styles */
        .resize-handle-n {
            cursor: ns-resize;
        }

        .resize-handle-s {
            cursor: ns-resize;
        }

        .resize-handle-e {
            cursor: ew-resize;
        }

        .resize-handle-w {
            cursor: ew-resize;
        }

        .resize-handle-ne {
            cursor: nesw-resize;
        }

        .resize-handle-nw {
            cursor: nwse-resize;
        }

        .resize-handle-se {
            cursor: nwse-resize;
        }

        .resize-handle-sw {
            cursor: nesw-resize;
        }

        /* Typing indicator animation */
        @keyframes bounce {

            0%,
            80%,
            100% {
                transform: scale(0.8);
                opacity: 0.5;
            }

            40% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Message bubble transitions */
        .message-bubble {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .message-bubble:hover {
            transform: translateY(-1px);
        }

        /* Expandable content */
        .expandable-content {
            position: relative;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .expandable-content::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(to bottom, transparent, white);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .expandable-content.collapsed::after {
            opacity: 1;
        }

        /* Code block syntax highlighting colors */
        .syntax-keyword {
            color: #c678dd;
            font-weight: 600;
        }

        .syntax-string {
            color: #98c379;
        }

        .syntax-number {
            color: #d19a66;
        }

        .syntax-comment {
            color: #5c6370;
            font-style: italic;
        }

        .syntax-function {
            color: #61afef;
        }

        /* Reaction button animations */
        .reaction-btn {
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .reaction-btn:hover {
            transform: scale(1.2);
        }

        .reaction-btn.active {
            animation: reactionPop 0.3s ease;
        }

        @keyframes reactionPop {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.4);
            }

            100% {
                transform: scale(1.2);
            }
        }

        /* Streaming text cursor */
        .streaming-cursor::after {
            content: '|';
            animation: cursorBlink 1s infinite;
            color: #6366f1;
        }

        @keyframes cursorBlink {

            0%,
            50% {
                opacity: 1;
            }

            51%,
            100% {
                opacity: 0;
            }
        }

        /* Keyboard shortcut kbd style */
        kbd {
            font-family: 'Inter', monospace;
            font-size: 0.7em;
            font-weight: 600;
            border: 1px solid #cbd5e1;
            border-bottom-width: 2px;
            border-radius: 4px;
            padding: 2px 6px;
            background: #f1f5f9;
            color: #475569;
        }

        /* Context restore notice */
        .context-notice {
            background: linear-gradient(135deg, #e0e7ff 0%, #c7d2fe 100%);
            border-left: 4px solid #6366f1;
        }

        /* Error message style */
        .error-message {
            background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
            border-left: 4px solid #ef4444;
        }

        /* Clarification style */
        .clarification-message {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border-left: 4px solid #f59e0b;
        }

        /* Proactive suggestion chips */
        .suggestion-chip {
            transition: all 0.2s ease;
        }

        .suggestion-chip:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.2);
        }

        /* Chat panel resize transition */
        #ai-chat-panel {
            transition: width 0.1s ease, height 0.1s ease, opacity 0.3s ease, transform 0.3s ease;
        }

        #ai-chat-panel.resizing {
            transition: none;
        }

        /* ============================================
           IMAGE UPLOAD & CONTEXTUAL SUGGESTIONS STYLES
           ============================================ */

        /* Image preview container */
        .image-preview-container {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
            border: 1px solid #10b981;
            border-radius: 0.75rem;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .image-preview-container img {
            height: 3rem;
            width: auto;
            border-radius: 0.5rem;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        /* Contextual suggestion chips */
        .suggestion-chip {
            display: inline-flex;
            align-items: center;
            padding: 0.35rem 0.75rem;
            background: linear-gradient(135deg, #eef2ff 0%, #e0e7ff 100%);
            border: 1px solid #c7d2fe;
            border-radius: 9999px;
            font-size: 0.7rem;
            font-weight: 500;
            color: #4f46e5;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .suggestion-chip:hover {
            background: linear-gradient(135deg, #e0e7ff 0%, #c7d2fe 100%);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.2);
        }

        .suggestion-chip:active {
            transform: translateY(0);
        }

        /* Image upload button active state */
        .upload-btn-active {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%) !important;
            color: white !important;
            animation: pulse-green 2s infinite;
        }

        @keyframes pulse-green {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.4);
            }

            50% {
                box-shadow: 0 0 0 8px rgba(16, 185, 129, 0);
            }
        }

        /* Image analysis result styling */
        .image-analysis-result {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-left: 4px solid #6366f1;
        }
    </style>


</head>


<body class="text-slate-900 overflow-x-hidden bg-slate-100">
    <div id="root"></div>


    <!-- Main application code - will be compiled by Babel bootloader -->
    <script type="text/plain" id="main-code" style="display:none;">
        // --- IMPORTS ---
        import React, { useState, useEffect, useMemo, useRef, useCallback } from 'react';
        import { createRoot } from 'react-dom/client';
        import { createPortal } from 'react-dom';
        import {
  Activity, AlertCircle, AlertTriangle, Archive, ArrowDownRight, ArrowLeft, 
  ArrowRight, ArrowUpRight, Award, BarChart2, Bell, BookOpen, Bot, Brain, 
  BrainCircuit, Calendar, Camera, Check, CheckCheck, CheckCircle, CheckSquare, 
  ChevronDown, ChevronLeft, ChevronRight, ChevronUp, ClipboardList, Clock, 
  Copy, Download, Edit2, ExternalLink, Eye, EyeOff, FileDown, FileOutput, 
  FileSpreadsheet, FileText, FileType, Filter, Ghost, GitBranch, GitCompare, 
  Globe, GraduationCap, Headphones, Heart, HelpCircle, Info, Key, Layers, 
  LayoutDashboard, LayoutGrid, Lightbulb, Link, ListChecks, Loader, Loader2, 
  Mail, Maximize2, MessageCircle, MessageSquare, Minimize2, Minus, Paperclip, 
  Phone, PieChart as PieIcon, Pin, Printer, RefreshCw, Search, Send, Settings, 
  Settings2, Share2, Shield, ShieldAlert, ShieldCheck, Shuffle, Smile, Sparkles, 
  Star, Tag, Target, ThumbsUp, Trash2, TrendingDown, TrendingUp, Upload, 
  UploadCloud, User, UserPlus, Users, Video, Wrench, X as XIcon, XCircle, Zap, Feather
} from 'lucide-react';

import { BarChart, Bar, XAxis, YAxis, Tooltip, ResponsiveContainer, LineChart, Line, Cell, Radar, RadarChart, PolarGrid, PolarAngleAxis, LabelList, CartesianGrid, AreaChart, Area, PolarRadiusAxis, Legend, PieChart, Pie, ComposedChart, ScatterChart, Scatter, ZAxis, ReferenceLine } from 'recharts';

        // Recharts Components Object (for compatibility checks)
        const RechartsComponents = {
            BarChart, Bar, XAxis, YAxis, Tooltip, ResponsiveContainer,
            LineChart, Line, Cell, Radar, RadarChart, PolarGrid,
            PolarAngleAxis, LabelList, CartesianGrid, AreaChart, Area,
            PolarRadiusAxis, Legend, PieChart, Pie, ComposedChart, ScatterChart, Scatter, ZAxis, ReferenceLine
        };
        
        // Fallback destructuring with error checking
        if (!Cell) {
            console.error('Cell component not found in Recharts. Available components:', Object.keys(RechartsComponents));
        }
        if (!LabelList) {
            console.error('LabelList component not found in Recharts. Available components:', Object.keys(RechartsComponents));
        }
        if (!ReferenceLine) {
            console.error('ReferenceLine component not found in Recharts. Available components:', Object.keys(RechartsComponents));
        }

        // --- GLOBAL HELPERS ---
        const MarkdownRenderer = {
            render: (text) => {
                if (!text) return '';
                if (window.marked) {
                     if (typeof window.marked.parse === 'function') return window.marked.parse(text);
                     if (typeof window.marked === 'function') return window.marked(text);
                }
                return text.replace(/\n/g, '<br>');
            }
        };

        // Verify Recharts loaded properly
        if (!RechartsComponents.BarChart) {
            console.warn('Recharts components not properly loaded. Available:', Object.keys(RechartsComponents));
        }
        


        // Audit Issue #2: Global Namespace for App-Wide Configuration
        // Centralizes constants, version info, and feature flags
        const PoppyApp = {
            version: '1.0',
            lastUpdated: '2026-01-26',
            env: 'production',
            config: {
                maxRows: 50000,
                defaultRowHeight: 40,
                animationDuration: 300,
                enableAnimations: true,
                gapImpactThreshold: 15
            },
            features: {
                aiAssistant: true,
                exportEngine: true,
                virtualList: true,
                globalSearch: true
            },
            // Centralized storage keys
            storage: {
                CHAT_HISTORY: 'poppySuite_chatHistory',
                VIEW_PREFS: 'poppySuite_viewPrefs',
                AI_MEMORY: 'poppySuite_aiMemory',
                COACHING_TEMPLATES: 'poppySuite_coachingTemplates'
            }
        };
        // --- ENGINEERING STANDARDS: LOGGING ---
        const PoppyLogger = {
            levels: { INFO: 'color: #3b82f6', WARN: 'color: #f59e0b', ERROR: 'color: #ef4444', AI: 'color: #8b5cf6' },
            log: (level, tag, message, data = null) => {
                if (level !== 'ERROR') return;
                const timestamp = new Date().toLocaleTimeString();
                const style = PoppyLogger.levels[level] || 'color: #64748b';
                const logMsg = `[${timestamp}][${level}][${tag}] ${message}`;
                if (data) console.error(`%c${logMsg}`, style, data);
                else console.error(`%c${logMsg}`, style);
            },
            info: (tag, msg, data) => PoppyLogger.log('INFO', tag, msg, data),
            warn: (tag, msg, data) => PoppyLogger.log('WARN', tag, msg, data),
            error: (tag, msg, data) => PoppyLogger.log('ERROR', tag, msg, data),
            ai: (tag, msg, data) => PoppyLogger.log('AI', tag, msg, data)
        };


        // Issue #16 Fix: CoachingTemplateStore with error handling
        // Consolidate CoachingTemplateStore (Issue #16 & Duplication Fix)
        const CoachingTemplateStore = {
            storageKey: PoppyApp.storage.COACHING_TEMPLATES,
            load: () => {
                try {
                    const local = []; // localStorage removed
                    
                    const defaults = [
                        { id: 't1', name: 'Empathy & Tone Refinement', type: 'Coaching', versions: ['Hi [Agent], I noticed in your recent chats that while technical accuracy is great, we can soften the tone. Try using more empathetic phrases like "I understand how important this is for you" or "I\'ll be happy to help resolve this." This builds better connection with the customer.'], content: 'Hi [Agent], I noticed in your recent chats that while technical accuracy is great, we can soften the tone. Try using more empathetic phrases like "I understand how important this is for you" or "I\'ll be happy to help resolve this." This builds better connection with the customer.' },
                        { id: 't2', name: 'Efficiency & AHT Reduction', type: 'Coaching', versions: ['Hey [Agent], your resolution quality is high, but we can optimize the handle time. I suggest preparing snippets for common policy explanations and keeping the multi-tab navigation ready. This will help you navigate faster without losing quality.'], content: 'Hey [Agent], your resolution quality is high, but we can optimize the handle time. I suggest preparing snippets for common policy explanations and keeping the multi-tab navigation ready. This will help you navigate faster without losing quality.' },
                        { id: 't3', name: 'Accuracy Check & Verification', type: 'Coaching', versions: ['Hi [Agent], great job on the resolution! One thing to watch for is the verification step. Please ensure all ID checks are completed before sharing sensitive account details to maintain our security standards.'], content: 'Hi [Agent], great job on the resolution! One thing to watch for is the verification step. Please ensure all ID checks are completed before sharing sensitive account details to maintain our security standards.' },
                        { id: 't4', name: 'De-escalation Strategy', type: 'Coaching', versions: ['Hi [Agent], I saw you handled a tough customer today. You did well, but when they become frustrated, try to acknowledge their feeling first before jumping into the solution. "I hear your frustration" goes a long way in calming the situation.'], content: 'Hi [Agent], I saw you handled a tough customer today. You did well, but when they become frustrated, try to acknowledge their feeling first before jumping into the solution. "I hear your frustration" goes a long way in calming the situation.' },
                        { id: 't5', name: 'Closing Excellence', type: 'Coaching', versions: ['Hey [Agent], always ensure the customer has no further questions before closing the chat. Ending with "Is there anything else I can clarify for you today?" ensures they leave with everything they need.'], content: 'Hey [Agent], always ensure the customer has no further questions before closing the chat. Ending with "Is there anything else I can clarify for you today?" ensures they leave with everything they need.' },
                        { id: 't6', name: 'Personalization & Rapport', type: 'Coaching', versions: ['Hi [Agent], try to avoid using too many generic scripts. Use the customer\'s name and reference their specific situation early in the chat. It makes them feel like they aren\'t just another ticket.'], content: 'Hi [Agent], try to avoid using too many generic scripts. Use the customer\'s name and reference their specific situation early in the chat. It makes them feel like they aren\'t just another ticket.' },
                        { id: 't7', name: 'Proactive Escalation', type: 'Coaching', versions: ['Hey [Agent], if a case is going beyond our standard troubleshooting, don\'t hesitate to flag it early. Proactive escalation saves time for both you and the customer.'], content: 'Hey [Agent], if a case is going beyond our standard troubleshooting, don\'t hesitate to flag it early. Proactive escalation saves time for both you and the customer.' },
                        { id: 't8', name: 'Documentation Standards', type: 'Coaching', versions: ['Hi [Agent], your chat notes are a bit brief. Please ensure you document the specific reason for the customer\'s contact and the exact steps taken to resolve it for the next agent.'], content: 'Hi [Agent], your chat notes are a bit brief. Please ensure you document the specific reason for the customer\'s contact and the exact steps taken to resolve it for the next agent.' },
                        { id: 't9', name: 'Product Knowledge Refresh', type: 'Coaching', versions: ['Hey [Agent], I noticed some confusion regarding the new [Feature Name]. Please take 10 minutes to review the latest SOP in the knowledge base to stay up to date.'], content: 'Hey [Agent], I noticed some confusion regarding the new [Feature Name]. Please take 10 minutes to review the latest SOP in the knowledge base to stay up to date.' },
                        { id: 't10', name: 'Feedback Acknowledgement', type: 'Coaching', versions: ['Hi [Agent], when a customer provides feedback during the chat, acknowledge it! Even if it\'s negative about the platform, saying "I appreciate you sharing that feedback, it helps us improve" shows you are listening.'], content: 'Hi [Agent], when a customer provides feedback during the chat, acknowledge it! Even if it\'s negative about the platform, saying "I appreciate you sharing that feedback, it helps us improve" shows you are listening.' },
                        { id: 't11', name: 'Complex Problem Solving', type: 'Coaching', versions: ['Hi [Agent], for complex cases, try to break down the solution into numbered steps for the customer. It makes the information much easier to digest.'], content: 'Hi [Agent], for complex cases, try to break down the solution into numbered steps for the customer. It makes the information much easier to digest.' },
                        { id: 't12', name: 'Waiting Time Management', type: 'Coaching', versions: ['Hey [Agent], please keep the customer updated if you need to research. A simple "I\'m still looking into this for you, thank you for your patience" every 2 minutes prevents them from feeling ignored.'], content: 'Hey [Agent], please keep the customer updated if you need to research. A simple "I\'m still looking into this for you, thank you for your patience" every 2 minutes prevents them from feeling ignored.' },
                        { id: 't13', name: 'Consistency & Branding', type: 'Coaching', versions: ['Hi [Agent], please ensure you are using the approved brand greetings and sign-offs. It maintains a professional and consistent image across all our support channels.'], content: 'Hi [Agent], please ensure you are using the approved brand greetings and sign-offs. It maintains a professional and consistent image across all our support channels.' },
                        { id: 't14', name: 'Soft Skills: Active Listening', type: 'Coaching', versions: ['Hi [Agent], try to paraphrase the customer\'s issue back to them: "So, if I understand correctly, you are looking to..." This confirms you are on the same page.'], content: 'Hi [Agent], try to paraphrase the customer\'s issue back to them: "So, if I understand correctly, you are looking to..." This confirms you are on the same page.' },
                        { id: 't15', name: 'NPS Booster Technique', type: 'Coaching', versions: ['Hey [Agent], towards the end of the chat, summarize the positive outcome you achieved. "I\'m glad we were able to get your refund processed today." It leaves the customer with a positive final impression.'], content: 'Hey [Agent], towards the end of the chat, summarize the positive outcome you achieved. "I\'m glad we were able to get your refund processed today." It leaves the customer with a positive final impression.' }
                    ];

                    // Merge defaults with local (avoiding duplicates)
                    const merged = [...local];
                    defaults.forEach(d => { if (!merged.some(m => m.id === d.id)) merged.push(d); });
                    return merged.filter(t => t && t.id && t.name);
                } catch (e) {
                    console.error('CoachingTemplateStore.load error:', e);
                    return [];
                }
            },
            save: (templates) => {
                try {
                    // localStorage removed
                    return true;
                } catch (e) {
                    console.error('CoachingTemplateStore.save error:', e);
                    return false;
                }
            },
            upsert: (template) => {
                const current = CoachingTemplateStore.load();
                const next = [template, ...current.filter(t => t.id !== template.id)];
                CoachingTemplateStore.save(next.slice(0, 200));
                return next.slice(0, 200);
            },
            remove: (id) => {
                const current = CoachingTemplateStore.load().filter(t => t.id !== id);
                CoachingTemplateStore.save(current);
                return current;
            }
        };


        // Issue #35 Fix: Static color map for Tailwind JIT compatibility
        const KPI_COLOR_MAP = {
            blue: { bg: 'bg-blue-50', text: 'text-blue-600' },
            emerald: { bg: 'bg-emerald-50', text: 'text-emerald-600' },
            rose: { bg: 'bg-rose-50', text: 'text-rose-600' },
            amber: { bg: 'bg-amber-50', text: 'text-amber-600' },
            purple: { bg: 'bg-purple-50', text: 'text-purple-600' },
            indigo: { bg: 'bg-indigo-50', text: 'text-indigo-600' },
            slate: { bg: 'bg-slate-50', text: 'text-slate-600' },
            green: { bg: 'bg-green-50', text: 'text-green-600' },
            red: { bg: 'bg-red-50', text: 'text-red-600' },
            orange: { bg: 'bg-orange-50', text: 'text-orange-600' },
            violet: { bg: 'bg-violet-50', text: 'text-violet-600' }
        };
        const getKpiColorClasses = (color) => {
            const c = KPI_COLOR_MAP[color] || KPI_COLOR_MAP.blue;
            return `${c.bg} ${c.text}`;
        };


        // --- CONSTANTS ---
        const PILLAR_COLORS = { Communication: '#2563EB', Personalisation: '#9333EA', Efficiency: '#059669', QC: '#F59E0B', Critical: '#DC2626', Process: '#F59E0B', Internal: '#3B82F6' };


        const NPS_METRIC_MAPPING = {
            Communication: ['Clear Message', 'Completeness', 'Relevance', 'Unique Reply', 'Context Use', 'Tone & Politeness', 'Empathy', 'Formatting'],
            Personalisation: ['Personalised Solutions', 'Assured Resolution', 'Personalised Next Steps', 'Extra Mile  Root Problem'],
            Efficiency: ['Agent Response Speed', 'Message Count Balance', 'Ownership & Escalation']
        };


        const QC_METRIC_MAPPING = {
            Critical: ['Privacy', 'Security', 'Compliance', 'Fatal Error'],
            Process: ['Greeting', 'Closing', 'Tool Usage', 'Notes', 'Resolution'],
            Internal: ['Empathy', 'Active Listening', 'Tone', 'Professionalism']
        };


        const ONE_ON_ONE_SYSTEM_PROMPT = `You are a Team Lead writing a 1:1 feedback Slack post directly to your agent.
STRICT RULES:
1. STRICTLY ENGLISH. Use SIMPLE LANGUAGE.
2. NO hashtags (#).
3. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.
4. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).
5. Use emojis sparingly (max 2 per line).
6. Font must match app default.
7. Do NOT use the word "Bold", "Underline", or "B" as text.
8. Do NOT bold emphasis words like "Always", "Never", "Note" inside descriptions.
9. FIRST-PERSON PERSPECTIVE: You ARE the Team Lead. Do NOT refer to "The TL" or "The Team Lead". Use "I", "we", or direct commands.
10. **Bullet Points:** ALWAYS use standard Markdown bullets (-).
11. **Strict Keywords:** Use ONLY Pillar names and Sub-metric names from the data.`;


        // --- UTILS ---


        // --- DATA ENGINE (PHASE 0 CONSOLIDATION) ---



        // --- GLOBAL AI PERSONA ---
        const AI_PERSONA = `
You are an expert Team Performance (TP) Lead.

CRITICAL PERSONA INSTRUCTION:
Analyze the tone, vocabulary, and sentence structure of any "TL RCA", "Answer Comment", or "Remediation Feedback" text provided in the prompt or data context.
MIMIC that specific communication style in your output.
- If the TL is formal ("Please ensure..."), be formal.
- If the TL is direct/casual ("Ok, fix this..."), be direct/casual.
- If no TL feedback is available, default to a **Professional, Direct, and Coaching-Focused** tone.

YOUR GOAL: Empower agents and team leads with actionable insights to improve NPS and Quality Scores.
STRICT FORMATTING: 
- Standard Markdown. Use **bold** for headers/emphasis. No hashtags (#). 
- **Bullet Points:** ALWAYS use standard Markdown bullets (-). Do NOT use fancy unicode bullets.
- **Strict Keywords:** Do NOT invent random keywords. Use ONLY specific Pillar names and Sub-metric names found in the data.
`;

        // ============================================
        // PROMPT BUILDER - Dynamic Toolkit Upgrade
        // ============================================
        const PromptBuilder = {
            templates: {
                'policy-quiz': {
                    systemRole: 'expert CX policy quiz creator',
                    outputFormat: `Return a JSON object with this structure:
{
  "title": "Quiz Title",
  "questions": [
    {
      "question": "Question text",
      "options": ["Option A", "Option B", "Option C", "Option D"],
      "correctAnswer": 0,
      "explanationCorrect": "Positive, celebrating acknowledgement of correct answer",
      "explanationWrong": "Detailed explanation of what is correct and why"
    }
  ]
}`,
                    contextFields: ['policyText', 'focusAreas', 'difficulty', 'agents'],
                    inputs: [
                        { name: 'policyText', type: 'textarea', label: 'Paste Policy Text / Procedure' },
                        { name: 'numQuestions', type: 'number', label: 'Number of Questions', default: 5 },
                        { name: 'difficulty', type: 'select', label: 'Difficulty Level', options: ['Beginner', 'Intermediate', 'Advanced', 'Mixed'] }
                    ],
                    mockDataSupport: true,
                    construct: (data) => `Create a quiz based on the following policy/procedure document.

POLICY CONTENT:
${(data.policyText || '').substring(0, 8000)}

METRIC CONTEXT (Align questions with these pillars where applicable):
NPS PILLARS: ${JSON.stringify(NPS_METRIC_MAPPING)}
QC PILLARS: ${JSON.stringify(QC_METRIC_MAPPING)}

Requirements:
- Generate ${data.numQuestions || 5} multiple-choice questions
- Difficulty level: ${data.difficulty || 'mixed'}
- Each question should have 4 options (A, B, C, D)
- Include the correct answer for each question
- **Feedback:** Provide distinct 'explanationCorrect' (positive) and 'explanationWrong' (educational) feedback
- **Strict Keywords:** Use terminology STRICTLY from the provided POLICY CONTENT.
- **Alignment:** Ensure scenarios map to relevant NPS/QC Sub-metrics (e.g., Empathy, Process, Compliance) if they appear in the text.`
                },
                'kb-writer': {
                    systemRole: 'knowledge base article writer',
                    outputFormat: 'structured KB article with headers',
                    contextFields: ['topic', 'targetAudience', 'tone', 'agents'],
                    inputs: [
                        { name: 'topic', type: 'text', label: 'Article Topic' },
                        { name: 'category', type: 'select', label: 'Category', options: ['Process', 'Product', 'Troubleshooting', 'Soft Skills'] },
                        { name: 'audience', type: 'select', label: 'Target Audience', options: ['New Joiners', 'Tenured Agents', 'Team Leads'] }
                    ],
                    mockDataSupport: true,
                    construct: (data) => `Write a comprehensive Knowledge Base article on the following topic:

TOPIC: ${data.topic}
CATEGORY: ${data.category}
TARGET AUDIENCE: ${data.audience}

CRITICAL FORMAT:
1. ** ${data.topic} ** (Title wrapped in star emojis both sides, bold)

2. [Introduction - AI Generated overview of topic]

3. **Overview**
   - Brief description of the topic
   - Context and importance

4. **Step-by-Step Instructions**
   - Numbered steps
   - Clear, actionable instructions

5. **Best Practices**
   - Practical recommendations
   - Pro tips for success

6. **Common Pitfalls**
   - What to avoid
   - Prevention tips

7. **Quick Reference**
   - Summary table or bullets
   - Key takeaways

8. [Closure - NOT A HEADING]
   - Brief encouraging statement with emoji

STRICT RULES:
- Use markdown-style headers (using ** for bold titles)
- **Bullet Points:** ALWAYS use standard Markdown bullets (-).
- **Strict Keywords:** Use terms strictly from the domain.
- NO Sign-off`
                },
                'training-creator': {
                    systemRole: 'corporate training specialist',
                    outputFormat: 'structured training module',
                    contextFields: ['topic', 'type', 'duration'],
                    inputs: [
                        { name: 'topic', type: 'text', label: 'Training Topic' },
                        { name: 'type', type: 'select', label: 'Training Format', options: ['Workshop', 'Self-Paced', 'Huddle'] },
                        { name: 'duration', type: 'number', label: 'Duration (minutes)', default: 30 }
                    ],
                    mockDataSupport: true,
                    construct: (data) => `Create training material on the following topic:

TOPIC: ${data.topic}
TYPE: ${data.type}
DURATION: ${data.duration} minutes

CRITICAL FORMAT:
1. ** ${data.topic} ** (Title wrapped in star emojis both sides, bold)

2. [Introduction - AI Generated based on topic and duration]

3. **Learning Objectives**
   - 3-5 measurable outcomes
   - What participants will learn

4. **Content Sections**
   - Organized by time/sections
   - Break into digestible parts
   - Match duration

5. **Interactive Elements**
   - Discussion points
   - Activities
   - Engagement opportunities

6. **Knowledge Check**
   - 3-5 quiz questions
   - Tests key concepts

7. **Facilitator Notes**
   - Delivery tips
   - Timing guidance

8. [Closure - NOT A HEADING]
   - Motivational wrap-up with emoji

STRICT RULES:
- **Bullet Points:** ALWAYS use standard Markdown bullets (-).
- **Strict Keywords:** Use terms strictly from the domain.
- NO Sign-off`
                },
                'review-doc': {
                    systemRole: 'performance review specialist',
                    outputFormat: 'professional review document',
                    contextFields: ['agent', 'type', 'period'],
                    mockDataSupport: true,
                    construct: (data) => `Generate a ${data.type} review document for the following agent:

AGENT: ${data.agent}
REVIEW PERIOD: Last ${data.period}
NPS RECORDS: ${data.npsCount || 'N/A'}
NPS PASS RATE: ${data.npsPassRate || 'N/A'}%
QC AUDITS: ${data.qcCount || 'N/A'}
QC PASS RATE: ${data.qcPassRate || 'N/A'}%

CRITICAL FORMAT:
1. ** ${data.type} Review - ${data.agent} ** (Title wrapped in star emojis both sides, bold)

2. **Agent Information**
   - **Agent**: ${data.agent}
   - **Review Period**: ${data.period}
   - **Review Type**: ${data.type}
   - **NPS Records**: ${data.npsCount || '0'}
   - **QC Audits**: ${data.qcCount || '0'}

3. [Performance Summary - AI Generated overview paragraph]

4. **Strengths**
   - Specific observations with **Sub-metric names**
   - Data-backed examples

5. **Areas for Improvement**
   - Specific observations with **Question keywords**
   - Constructive framing

6. **Actionable Recommendations**
   - Clear next steps
   - Measurable goals

7. [Closure - NOT A HEADING]
   - Encouraging statement + forward-looking with emoji

STRICT RULES:
- **Bullet Points:** ALWAYS use standard Markdown bullets (-).
- **Strict Keywords:** Use ONLY Pillar names and Sub-metric names from the data.
- NO Sign-off`
                },
                'coaching-planner': {
                    systemRole: 'CX coaching expert',
                    outputFormat: 'structured coaching session plan with goals, discussion points, action items, follow-up',
                    contextFields: ['agentName', 'focusArea', 'agentData', 'scores'],
                    mockDataSupport: true,
                    construct: (data) => `Create a detailed coaching session plan for the following:

AGENT: ${data.agent}
SESSION TYPE: ${data.type}
FOCUS AREA: ${data.focus}
${data.topIssues ? `TOP ISSUES: ${data.topIssues}` : ''}

CRITICAL FORMAT:
1. ** Coaching Session Plan ** (Title wrapped in star emojis both sides, bold)

2. [Overview - AI Generated based on agent needs]
   - Goals
   - Duration
   - Focus areas with **Sub-metric names** and **Question keywords**

3. **Session Flow**
   - Time-boxed activities
   - Discussion guides
   - Role-play setups

4. **Materials Needed**
   - Required resources
   - Pre-session prep

5. **Key Discussion Points**
   - Questions to ask
   - Areas to explore
   - Feedback to share

6. **Follow-up Actions**
   - Post-session steps
   - Accountability measures
   - Next meeting date

7. [Closure - NOT A HEADING]
   - Encouraging note with emoji

STRICT RULES:
- **Bullet Points:** ALWAYS use standard Markdown bullets (-).
- **Strict Keywords:** Use ONLY Pillar names and Sub-metric names from the data.
- NO Sign-off`
                },
                'feedback-generator': {
                    systemRole: 'CX feedback writer',
                    outputFormat: 'personalized feedback message',
                    contextFields: ['agentName', 'performance', 'tone'],
                    mockDataSupport: true,
                    construct: (data) => `Write feedback for ${data.agentName} regarding ${data.topic || 'performance'}.
Tone: ${data.tone || 'Constructive'}

CRITICAL FORMAT:
1. ** Personalized Feedback ** (Title wrapped in star emojis both sides, bold)

2. [Personalized Greeting - AI Generated, warm, uses agent name]

3. **Recognition**
   - Acknowledge specific **Sub-metric** strengths
   - Celebrate improvements if detected
   - Be genuine and specific

4. **Growth Area**
   - Frame **Question keywords** as growth potential
   - NOT criticism
   - Positive framing

5. **Specific Action**
   - One clear actionable step
   - Focus on **Sub-metric** or **Question keyword**

6. [Closure - NOT A HEADING]
   - 1-2 lines motivation + 1 line forward-looking with emojis

STRICT RULES:
- Max 150 words total
- NO Sign-off`
                },
                'slack-post': {
                    systemRole: 'team communication writer',
                    outputFormat: 'Slack post with appropriate tone and formatting',
                    contextFields: ['topic', 'audience', 'tone'],
                    mockDataSupport: true,
                    construct: (data) => `Write a Slack post for a team channel.

SCENARIO: ${data.scenario}
DETAILS:
${data.details}

CRITICAL FORMAT:
1. ** Team Update: ${data.topic || 'NPS Performance'} ** (Title wrapped in star emojis both sides, bold)

2. [Intro - AI Generated 1 line context setting]

3. **Key Issues & Action**
   - **Sub-metric Name** :- [What happened] [Action/Guidance] (Chat:- [URL])
   - Max 3 bullets per pillar, use ONLY Sub-metric names from data

4. [Closure - NOT A HEADING]
   - Single motivating line with emoji, forward-looking

STRICT RULES:
- Sound like a supportive team lead.
- Keep it concise and readable.
- Use Slack-friendly formatting (bold, bullets) where helpful.
- Avoid private/sensitive information.
- Return ONLY the post text (no extra explanations).`
                },
                'tone-adjuster': {
                    systemRole: 'communication tone specialist',
                    outputFormat: 'rewritten text with adjusted tone',
                    contextFields: ['tone'],
                    mockDataSupport: false,
                    construct: (data) => `Rewrite the following feedback with a ${data.tone} tone:

ORIGINAL FEEDBACK:
"${data.originalText}"

Requirements:
- Maintain the core message and feedback points
- Adjust the tone to be ${data.tone}
- Keep it professional and appropriate for workplace communication
- Ensure the feedback is actionable and clear`
                },
                'action-extractor': {
                    systemRole: 'task extraction specialist',
                    outputFormat: 'JSON object with actions list',
                    contextFields: [],
                    mockDataSupport: false,
                    construct: (data) => `Extract actionable items from the following feedback:

FEEDBACK:
"${data.feedbackText}"

Requirements:
- Identify all specific action items mentioned or implied
- Categorize each action (Immediate, Short-term, Long-term)
- Assign priority levels (High, Medium, Low)
- Format as a structured action plan

Return as JSON:
{
  "actions": [
    {
      "action": "Description of the action",
      "category": "Immediate|Short-term|Long-term",
      "priority": "High|Medium|Low",
      "rationale": "Why this action is needed"
    }
  ]
}`
                },
                'peer-matcher': {
                    systemRole: 'mentorship coordinator',
                    outputFormat: 'structured peer-to-peer mentorship pairings',
                    contextFields: ['focusArea', 'agents', 'stats'],
                    mockDataSupport: false,
                    construct: (data) => `Match agents for peer mentorship based on their performance stats.
                    
FOCUS AREA: ${data.focusArea}
AGENTS STATS:
${JSON.stringify(data.agentStats || [], null, 2)}

CRITICAL FORMAT:
1. ** Peer Mentorship Matches ** (Title wrapped in star emojis both sides, bold)

2. **Overview**
   - Goal of this mentorship cycle based on focus area

3. **Suggested Matches**
   - **Mentor**: [Name] (High Performer in [Skill])
   - **Mentee**: [Name] (Developing in [Skill])
   - **Rationale**: Why this is a good match
   - **Recommended Activity**: Specific 1:1 activity (e.g., shadow session, mock call)

4. **Program Guidelines**
   - Duration: 2 weeks
   - Expectations: 1 session per week

5. [Closure - NOT A HEADING]

STRICT RULES:
- Suggest 3-5 high-impact pairs
- Ensure Mentor score > Mentee score for the focus skill
- NO Sign-off`
                },
                'shadow-matcher': {
                    systemRole: 'training coordinator',
                    outputFormat: 'shadowing schedule',
                    contextFields: ['focusArea', 'agents', 'stats'],
                    mockDataSupport: false,
                    construct: (data) => `Create a shadowing schedule for the following agents.
                    
AGENTS TO DEVELOP:
${JSON.stringify(data.developingAgents || [], null, 2)}

TOP PERFORMERS AVAILABLE:
${JSON.stringify(data.topPerformers || [], null, 2)}

CRITICAL FORMAT:
1. ** Shadowing Schedule ** (Title wrapped in star emojis both sides, bold)

2. **Overview**
   - Focus: Skill Transfer

3. **Assignments**
   - **Mentee**: [Name]
   - **Shadow Host**: [Name]
   - **Focus Skill**: [Specific Skill Gap]
   - **Session Plan**: [What to observe]

4. **Tracking**
   - Success criteria

5. [Closure - NOT A HEADING]

STRICT RULES:
- Maximize skill transfer from Top Performers to others
- NO Sign-off`
                },
                'escalation-predictor': {
                    systemRole: 'senior customer support risk analyst',
                    outputFormat: 'JSON object with risk assessment',
                    contextFields: ['chatText'],
                    mockDataSupport: true,
                    construct: (data) => `Analyze the following customer interaction for escalation risk.

INTERACTION TEXT:
"${data.chatText.substring(0, 3000)}"

CRITICAL ANALYSIS:
1. Calculate a **Risk Score (0-100)** based on customer sentiment, keywords (legal, sue, supervisor, social media), and unresolved issues.
2. Identify specific **Warning Signs** (e.g., "Mentioned lawyer", "Repeated phrase").
3. Recommend **Immediate Actions** for the agent.
4. Classify the **Risk Category** (Legal, Churn, PR, Compliance, or General Dissatisfaction).

Return JSON ONLY:
{
  "riskScore": number,
  "riskCategory": "string",
  "escalationRisk": "High|Medium|Low",
  "warningSigns": ["string", "string"],
  "recommendedActions": ["string", "string"],
  "rationale": "string"
}`
                }
            },
            
            build: (toolId, userInput, uploadedData = null) => {
                const template = PromptBuilder.templates[toolId];
                if (!template) {
                    return { systemPrompt: '', userPrompt: String(userInput || '') };
                }
                
                // Step 1: Construct system prompt
                const systemPrompt = `
You are a ${template.systemRole}.

Output Format: ${template.outputFormat}

${uploadedData ? 
    `Use the following real data for context: ${JSON.stringify(uploadedData.slice(0, 5))}` :
    `Generate realistic sample data based on CX best practices.`
}

${AI_PERSONA}

STRICT RULES:
1. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.
2. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).
3. NO hashtags (#).
4. Use emojis sparingly (max 2 per line).
5. Do NOT use the word "Bold", "Underline", or "B" as text.
6. **Bullet Points:** ALWAYS use standard Markdown bullets (-). Do NOT use fancy unicode bullets.
7. **Strict Keywords:** Do NOT invent random keywords. Use ONLY specific Pillar names and Sub-metric names found in the data.
`;
                
                // Step 2: Construct user prompt with context injection
                const userPrompt = PromptBuilder.constructUserPrompt(template, userInput, uploadedData);
                
                return { systemPrompt, userPrompt };
            },
            
            constructUserPrompt: (template, userInput, uploadedData) => {
                let prompt = '';
                
                // Filter uploadedData to exclude invalid appeals
                const cleanData = uploadedData ? uploadedData.filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d)) : null;
                
                if (template.construct && typeof userInput === 'object' && userInput !== null) {
                    prompt = template.construct(userInput);
                } else {
                    prompt = String(userInput || '');
                }
                
                // Inject context dynamically
                if (cleanData && template.contextFields.includes('agents')) {
                    const agentList = cleanData.map(r => r['Agent Name'] || r['Agent'] || r['Agent Email']).filter(Boolean);
                    if (agentList.length > 0) {
                        prompt += `\n\nAvailable agents: ${agentList.slice(0, 10).join(', ')}`;
                    }
                }
                
                if (cleanData && template.contextFields.includes('scores')) {
                    const scores = cleanData.map(r => parseFloat(r['QC Score'] || r['Rating'] || 0)).filter(s => !isNaN(s));
                    if (scores.length > 0) {
                        const avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;
                        prompt += `\n\nCurrent team average score: ${avgScore.toFixed(1)}%`;
                    }
                }
                
                return prompt;
            }
        };

        // ... [Rest of code] ...

        // TOOL 15: Escalation Predictor
        const EscalationPredictor = ({ isOpen, onClose, npsData }) => {
            const [chatText, setChatText] = useState('');
            const [loading, setLoading] = useState(false);
            const [prediction, setPrediction] = useState(null);

            const predictEscalation = async () => {
                if (!chatText.trim()) return showToast('Please enter chat content', 'error');
                setLoading(true);
                
                try {
                    const result = await AgenticEngine.execute({
                        systemInstruction: "You are an expert Customer Service Escalation Risk Analyst. Analyze the interaction for escalation risk.",
                        prompt: `Analyze the following customer chat interaction for escalation risk.
CHAT CONTENT: "${chatText}"`,
                        schema: {
                            type: "OBJECT",
                            properties: {
                                riskScore: { type: "NUMBER", description: "Risk Score 0-100" },
                                riskCategory: { type: "STRING", enum: ["Legal", "Churn", "PR", "Compliance", "General Dissatisfaction"] },
                                warningSigns: { type: "ARRAY", items: { type: "STRING" } },
                                recommendedActions: { type: "ARRAY", items: { type: "STRING" } }
                            },
                            required: ["riskScore", "riskCategory", "warningSigns", "recommendedActions"]
                        }
                    });

                    if (result.error) throw new Error(result.message);
                    setPrediction(result);
                    showToast('Prediction complete!', 'success');
                } catch (e) {
                    console.error(e);
                    showToast('Analysis failed', 'error');
                } finally {
                    setLoading(false);
                }
            };

            const renderContent = (data) => {
                if (!data) return null;
                const { riskScore, riskCategory, warningSigns, recommendedActions } = data;
                
                // Color logic based on score
                const color = riskScore >= 70 ? 'red' : riskScore >= 40 ? 'amber' : 'emerald';
                const bg = `bg-${color}-50`;
                const border = `border-${color}-200`;
                const text = `text-${color}-700`;
                const fill = `bg-${color}-500`;

                return (
                    <div className="space-y-6 p-2">
                        {/* Risk Meter */}
                        <div className={`p-6 rounded-2xl border-2 ${border} ${bg} text-center relative overflow-hidden`}>
                            <div className="relative z-10">
                                <h3 className={`text-sm font-bold uppercase tracking-widest ${text} mb-2`}>Escalation Risk Score</h3>
                                <div className="text-6xl font-black text-slate-900 mb-2">{riskScore}</div>
                                <div className={`inline-block px-3 py-1 rounded-full text-xs font-bold bg-white ${text} border ${border} shadow-sm`}>
                                    {riskCategory}
                                </div>
                            </div>
                            {/* Gauge Visual Background */}
                            <div className="absolute bottom-0 left-0 w-full h-2 bg-slate-200">
                                <div className={`h-full ${fill} transition-all duration-1000 ease-out`} style={{ width: `${riskScore}%` }}></div>
                            </div>
                        </div>

                        {/* Warning Signs */}
                        <div>
                            <h4 className="font-bold text-slate-900 flex items-center gap-2 mb-3">
                                <AlertTriangle size={16} className="text-amber-500" /> Warning Signs
                            </h4>
                            <div className="flex flex-wrap gap-2">
                                {warningSigns.map((sign, i) => (
                                    <span key={i} className="px-3 py-1.5 bg-red-50 text-red-700 border border-red-100 rounded-lg text-xs font-bold flex items-center gap-1">
                                        <XCircle size={12} /> {sign}
                                    </span>
                                ))}
                            </div>
                        </div>

                        {/* Recommended Actions Checklist */}
                        <div>
                            <h4 className="font-bold text-slate-900 flex items-center gap-2 mb-3">
                                <CheckCircle size={16} className="text-emerald-600" /> Recommended Actions
                            </h4>
                            <div className="space-y-2">
                                {recommendedActions.map((action, i) => (
                                    <label key={i} className="flex items-start gap-3 p-3 bg-white border border-slate-200 rounded-xl hover:bg-slate-50 transition-colors cursor-pointer select-none">
                                        <input type="checkbox" className="mt-1 w-4 h-4 rounded text-blue-600 focus:ring-blue-500 border-gray-300" />
                                        <span className="text-sm text-slate-700 font-medium">{action}</span>
                                    </label>
                                ))}
                            </div>
                        </div>
                    </div>
                );
            };

            const renderQuizContent = (data) => {
                if (!data) return null;
                
                const totalPages = Math.ceil(data.questions.length / QUESTIONS_PER_PAGE);
                const startIdx = (currentPage - 1) * QUESTIONS_PER_PAGE;
                const currentQuestions = data.questions.slice(startIdx, startIdx + QUESTIONS_PER_PAGE);

                const handleExport = (format) => {
                    if (format === 'json') {
                        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `policy-quiz-${new Date().toISOString().split('T')[0]}.json`;
                        a.click();
                    } else if (format === 'txt') {
                        let text = `${data.title}\n\n`;
                        data.questions.forEach((q, i) => {
                            text += `Q${i + 1}. ${q.question}\n`;
                            q.options.forEach((opt, j) => {
                                text += `  ${String.fromCharCode(65 + j)}. ${opt}${j === q.correctAnswer ? ' ?' : ''}\n`;
                            });
                            text += `\nExplanation: ${q.explanationCorrect || q.explanation}\n\n`;
                        });
                        const blob = new Blob([text], { type: 'text/plain' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `policy-quiz-${new Date().toISOString().split('T')[0]}.txt`;
                        a.click();
                    }
                };

                return (
                    <div className="space-y-6">
                        <div className="flex items-center justify-between">
                            <h3 className="text-lg font-bold text-slate-800">{data.title}</h3>
                            <div className="flex gap-2">
                                <button onClick={() => handleExport('json')} className="px-3 py-1.5 bg-slate-100 hover:bg-slate-200 rounded-lg text-xs font-bold flex items-center gap-1">
                                    <Download size={12} /> JSON
                                </button>
                                <button onClick={() => handleExport('txt')} className="px-3 py-1.5 bg-slate-100 hover:bg-slate-200 rounded-lg text-xs font-bold flex items-center gap-1">
                                    <Download size={12} /> TXT
                                </button>
                            </div>
                        </div>

                        {data.questions.length > QUESTIONS_PER_PAGE && (
                             <div className="flex items-center justify-center gap-2 py-2">
                                <button
                                    onClick={() => setCurrentPage(p => Math.max(1, p - 1))}
                                    disabled={currentPage === 1}
                                    className="px-3 py-1.5 text-sm font-medium text-slate-600 hover:text-slate-800 disabled:opacity-30 flex items-center gap-1"
                                >
                                    <ChevronLeft size={16} /> Prev
                                </button>
                                <span className="text-xs text-slate-400 ml-2">
                                    {startIdx + 1}-{Math.min(startIdx + QUESTIONS_PER_PAGE, data.questions.length)} of {data.questions.length}
                                </span>
                                <button
                                    onClick={() => setCurrentPage(p => Math.min(totalPages, p + 1))}
                                    disabled={currentPage === totalPages}
                                    className="px-3 py-1.5 text-sm font-medium text-slate-600 hover:text-slate-800 disabled:opacity-30 flex items-center gap-1"
                                >
                                    Next <ChevronRight size={16} />
                                </button>
                            </div>
                        )}

                        <div className="space-y-4">
                            {currentQuestions.map((q, i) => {
                                const actualIdx = startIdx + i;
                                return (
                                    <div key={actualIdx} className="p-5 bg-slate-50 rounded-xl border border-slate-200">
                                        <div className="flex items-start justify-between gap-3 mb-4">
                                            <p className="font-semibold text-slate-800 flex-1">
                                                <span className="text-indigo-600 font-bold">Q{actualIdx + 1}.</span> {q.question}
                                            </p>
                                            <button
                                                onClick={() => { safeCopyToClipboard(q.question); showToast('Question copied!'); }}
                                                className="p-2 text-slate-400 hover:text-indigo-600 hover:bg-indigo-50 rounded-lg shrink-0"
                                            >
                                                <Copy size={14} />
                                            </button>
                                        </div>
                                        <div className="space-y-2">
                                            {q.options.map((opt, j) => (
                                                <div key={j} className={`p-3 rounded-lg text-sm flex items-center justify-between gap-2 ${j === q.correctAnswer ? 'bg-emerald-100 text-emerald-800 border border-emerald-200' : 'bg-white border border-slate-100'}`}>
                                                    <div className="flex items-center gap-2 flex-1">
                                                        <span className={`font-bold w-6 h-6 rounded-full flex items-center justify-center text-xs ${j === q.correctAnswer ? 'bg-emerald-500 text-white' : 'bg-slate-200 text-slate-600'}`}>
                                                            {String.fromCharCode(65 + j)}
                                                        </span>
                                                        <span dangerouslySetInnerHTML={{ __html: safeMarked(opt) }} />
                                                    </div>
                                                    {j === q.correctAnswer && <CheckCircle size={16} className="text-emerald-600" />}
                                                </div>
                                            ))}
                                        </div>
                                        <div className="mt-4 space-y-3">
                                            {q.explanationCorrect && (
                                                <div className="p-4 bg-emerald-50 border border-emerald-200 rounded-xl">
                                                    <span className="text-xs font-bold text-emerald-700 uppercase block mb-1">Correct Feedback</span>
                                                    <div className="text-sm text-emerald-800" dangerouslySetInnerHTML={{ __html: safeMarked(q.explanationCorrect) }} />
                                                </div>
                                            )}
                                            {q.explanationWrong && (
                                                <div className="p-4 bg-rose-50 border border-rose-200 rounded-xl">
                                                    <span className="text-xs font-bold text-rose-700 uppercase block mb-1">Incorrect Feedback</span>
                                                    <div className="text-sm text-rose-800" dangerouslySetInnerHTML={{ __html: safeMarked(q.explanationWrong) }} />
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                );
            };

            const renderTrainingContent = (data) => {
                if (!data) return null;

                const handleExport = () => {
                    const blob = new Blob([data.content], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `training-${data.title.toLowerCase().replace(/\s+/g, '-')}.txt`;
                    a.click();
                };

                return (
                    <div className="space-y-4">
                        <div className="flex items-center justify-between">
                            <div>
                                <h3 className="text-lg font-bold text-slate-800">{data.title}</h3>
                                <p className="text-xs text-slate-500">{data.type}  {data.duration} minutes</p>
                            </div>
                            <button
                                onClick={handleExport}
                                className="px-3 py-1.5 bg-emerald-100 hover:bg-emerald-200 text-emerald-700 rounded-lg text-xs font-bold flex items-center gap-1"
                            >
                                <Download size={12} /> Export
                            </button>
                        </div>
                        
                        <div className="p-4 bg-slate-50 rounded-xl border border-slate-200 max-h-[500px] overflow-y-auto">
                            <div className="prose prose-sm max-w-none">
                                <div dangerouslySetInnerHTML={{ __html: safeMarked(data.content) }} />
                            </div>
                        </div>
                    </div>
                );
            };

            const renderDocumentContent = (data) => {
                if (!data) return null;

                const handleExport = () => {
                    const blob = new Blob([data.content], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${data.type}-review-${data.agent.toLowerCase().replace(/\s+/g, '-')}.txt`;
                    a.click();
                };

                return (
                    <div className="space-y-4">
                        <div className="flex items-center justify-between">
                            <div>
                                <h3 className="text-lg font-bold text-slate-800">{data.type.charAt(0).toUpperCase() + data.type.slice(1)} Review</h3>
                                <p className="text-xs text-slate-500">{data.agent}  {data.period}</p>
                            </div>
                            <button
                                onClick={handleExport}
                                className="px-3 py-1.5 bg-orange-100 hover:bg-orange-200 text-orange-700 rounded-lg text-xs font-bold flex items-center gap-1"
                            >
                                <Download size={12} /> Export
                            </button>
                        </div>
                        
                        <div className="p-4 bg-slate-50 rounded-xl border border-slate-200 max-h-[500px] overflow-y-auto">
                            <div className="prose prose-sm max-w-none">
                                <div dangerouslySetInnerHTML={{ __html: safeMarked(data.content) }} />
                            </div>
                        </div>
                    </div>
                );
            };

            const renderPlanContent = (data) => {
                if (!data) return null;

                const handleExport = () => {
                    const text = `COACHING PLAN: ${data.agent}\n\nOPENING:\n${data.content.opening}\n\nDISCUSSION:\n${data.content.discussion.join('\n')}\n\nPRACTICE:\n${data.content.practice}\n\nACTIONS:\n${data.content.actions.join('\n')}\n\nFOLLOW-UP:\n${data.content.followup}`;
                    const blob = new Blob([text], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `coaching-plan-${data.agent.toLowerCase().replace(/\s+/g, '-')}.txt`;
                    a.click();
                };

                return (
                    <div className="space-y-4">
                        <div className="flex items-center justify-between">
                            <div>
                                <h3 className="text-lg font-bold text-slate-800">Coaching Session Plan</h3>
                                <p className="text-xs text-slate-500">{data.agent}  {data.type}  {data.focus}</p>
                            </div>
                            <button
                                onClick={handleExport}
                                className="px-3 py-1.5 bg-rose-100 hover:bg-rose-200 text-rose-700 rounded-lg text-xs font-bold flex items-center gap-1"
                            >
                                <Download size={12} /> Export
                            </button>
                        </div>
                        
                        <div className="space-y-4">
                            <div className="p-4 bg-white border border-slate-200 rounded-xl shadow-sm">
                                <h4 className="font-bold text-slate-800 mb-2 flex items-center gap-2"><MessageCircle size={16} className="text-rose-500"/> Opening</h4>
                                <p className="text-sm text-slate-600">{data.content.opening}</p>
                            </div>

                            <div className="p-4 bg-white border border-slate-200 rounded-xl shadow-sm">
                                <h4 className="font-bold text-slate-800 mb-2 flex items-center gap-2"><List size={16} className="text-rose-500"/> Discussion Points</h4>
                                <ul className="list-disc pl-4 text-sm text-slate-600 space-y-1">
                                    {data.content.discussion.map((item, i) => <li key={i}>{item}</li>)}
                                </ul>
                            </div>

                            <div className="p-4 bg-rose-50 border border-rose-100 rounded-xl shadow-sm">
                                <h4 className="font-bold text-rose-800 mb-2 flex items-center gap-2"><PlayCircle size={16} className="text-rose-600"/> Roleplay / Practice</h4>
                                <p className="text-sm text-rose-700 italic">{data.content.practice}</p>
                            </div>

                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div className="p-4 bg-white border border-slate-200 rounded-xl shadow-sm">
                                    <h4 className="font-bold text-slate-800 mb-2 flex items-center gap-2"><CheckSquare size={16} className="text-green-500"/> Action Items</h4>
                                    <ul className="list-disc pl-4 text-sm text-slate-600 space-y-1">
                                        {data.content.actions.map((item, i) => <li key={i}>{item}</li>)}
                                    </ul>
                                </div>
                                <div className="p-4 bg-white border border-slate-200 rounded-xl shadow-sm">
                                    <h4 className="font-bold text-slate-800 mb-2 flex items-center gap-2"><Calendar size={16} className="text-blue-500"/> Follow-up</h4>
                                    <p className="text-sm text-slate-600">{data.content.followup}</p>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };

            const renderMatchesContent = (data) => {
                if (!data || !data.matches) return null;

                const handleExport = () => {
                    ExportEngine.exportCSV(data.matches, 'peer-matches');
                };

                return (
                    <div className="space-y-4">
                        <div className="flex items-center justify-between mb-4">
                            <h3 className="text-lg font-bold text-slate-800">Proposed Matches</h3>
                            <button 
                                onClick={handleExport}
                                className="px-3 py-1.5 bg-violet-100 text-violet-700 rounded-lg text-xs font-bold"
                            >
                                Export CSV
                            </button>
                        </div>

                        <div className="grid grid-cols-1 gap-4">
                            {data.matches.map((match, i) => (
                                <div key={i} className="bg-white border border-slate-200 rounded-xl p-4 shadow-sm relative overflow-hidden">
                                    <div className="absolute top-0 left-0 w-1 h-full bg-violet-500"></div>
                                    <div className="flex items-center justify-between mb-3">
                                        <div className="flex items-center gap-3">
                                            <div className="bg-violet-100 text-violet-700 px-3 py-1 rounded-full text-xs font-bold">Mentor</div>
                                            <span className="font-bold text-slate-700">{match.mentor}</span>
                                        </div>
                                        <div className="text-slate-400"><ArrowRight size={16} /></div>
                                        <div className="flex items-center gap-3">
                                            <span className="font-bold text-slate-700">{match.mentee}</span>
                                            <div className="bg-pink-100 text-pink-700 px-3 py-1 rounded-full text-xs font-bold">Mentee</div>
                                        </div>
                                    </div>
                                    <p className="text-sm text-slate-600 mb-3 bg-slate-50 p-3 rounded-lg italic">
                                        "{match.rationale}"
                                    </p>
                                    <div className="flex gap-2 flex-wrap">
                                        {match.topics?.map((t, j) => (
                                            <span key={j} className="px-2 py-1 bg-slate-100 text-slate-600 text-[10px] rounded-md border border-slate-200">
                                                {t}
                                            </span>
                                        ))}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                );
            };

            const renderToneContent = (data) => {
                if (!data) return null;

                return (
                    <div className="space-y-4">
                        <div className="grid grid-cols-2 gap-4">
                            <div className="p-4 bg-slate-100 rounded-xl">
                                <h4 className="text-xs font-bold text-slate-500 uppercase mb-2">Original</h4>
                                <p className="text-sm text-slate-700 whitespace-pre-wrap">{data.original}</p>
                            </div>
                            <div className="p-4 bg-cyan-50 rounded-xl border border-cyan-200">
                                <div className="flex items-center justify-between mb-2">
                                    <h4 className="text-xs font-bold text-cyan-600 uppercase">{data.tone.charAt(0).toUpperCase() + data.tone.slice(1)} Version</h4>
                                    <span className="text-[10px] font-bold bg-white px-2 py-0.5 rounded-full text-cyan-600 border border-cyan-100">Match: {data.score}%</span>
                                </div>
                                <p className="text-sm text-slate-800 whitespace-pre-wrap font-medium">{data.adjusted}</p>
                            </div>
                        </div>
                        
                        {data.changes && data.changes.length > 0 && (
                            <div className="p-3 bg-white border border-slate-200 rounded-xl">
                                <h4 className="text-xs font-bold text-slate-500 uppercase mb-2">Key Adjustments</h4>
                                <div className="flex flex-wrap gap-2">
                                    {data.changes.map((c, i) => (
                                        <span key={i} className="text-xs bg-slate-50 px-2 py-1 rounded text-slate-600 border border-slate-100">{c}</span>
                                    ))}
                                </div>
                            </div>
                        )}
                        
                        <div className="flex gap-2">
                            <button
                                onClick={() => safeCopyToClipboard(data.adjusted)}
                                className="flex-1 px-4 py-3 bg-cyan-100 hover:bg-cyan-200 text-cyan-700 rounded-xl font-bold"
                            >
                                Copy Adjusted Version
                            </button>
                        </div>
                    </div>
                );
            };

            if (!isOpen) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} title=" Escalation Predictor" size="lg">
                    <div className="space-y-6">
                        {!prediction ? (
                            <>
                                <div className="bg-violet-50 border border-violet-200 rounded-xl p-4 flex gap-3">
                                    <Info size={20} className="text-violet-600 shrink-0" />
                                    <p className="text-sm text-violet-800 font-medium">Analyze customer chats to predict escalation risk before it happens. Paste the conversation below.</p>
                                </div>
                                
                                <textarea 
                                    value={chatText} 
                                    onChange={(e) => setChatText(e.target.value)} 
                                    placeholder="Agent: Hello, how can I help?&#10;Customer: I want to speak to a manager immediately..." 
                                    className="w-full h-48 p-4 border border-slate-200 rounded-xl text-sm font-mono bg-slate-50 focus:bg-white focus:ring-2 focus:ring-violet-500 focus:border-transparent outline-none transition-all resize-none" 
                                />
                                
                                <button 
                                    onClick={predictEscalation} 
                                    disabled={loading || !chatText.trim()} 
                                    className="w-full px-4 py-4 bg-gradient-to-r from-violet-600 to-indigo-600 hover:from-violet-700 hover:to-indigo-700 text-white rounded-xl font-bold text-sm shadow-lg shadow-violet-200 flex items-center justify-center gap-2 disabled:opacity-50 disabled:shadow-none transition-all transform active:scale-[0.98]"
                                >
                                    {loading ? <Loader size={18} className="animate-spin" /> : <Sparkles size={18} />}
                                    {loading ? 'Analyzing Risk Factors...' : 'Predict Escalation Risk'}
                                </button>
                            </>
                        ) : (
                            <div className="animate-in fade-in slide-in-from-bottom-4">
                                <AIWrapper 
                                    data={prediction} 
                                    renderItem={renderContent}
                                    onRegenerate={predictEscalation}
                                    title="Risk Assessment"
                                />
                                <button 
                                    onClick={() => setPrediction(null)} 
                                    className="w-full mt-4 px-4 py-3 bg-white border border-slate-200 text-slate-600 hover:bg-slate-50 hover:text-slate-900 rounded-xl font-bold text-sm transition-all"
                                >
                                    Analyze Another Interaction
                                </button>
                            </div>
                        )}
                    </div>
                </Modal>
            );
        };

        // Legacy PromptBuilder reference for compatibility
        const PromptBuilderLegacy = {
            templates: {
                'policy-quiz': {
                    systemRole: 'expert CX policy quiz creator',
                    outputFormat: `Return a JSON object with this structure:
{
  "title": "Quiz Title",
  "questions": [
    {
      "question": "Question text",
      "options": ["Option A", "Option B", "Option C", "Option D"],
      "correctAnswer": 0,
      "explanation": "Why this is correct"
    }
  ]
}`,
                    rules: [
                        'Return ONLY valid JSON. No Markdown. No extra text.',
                        'Each question must have exactly 4 options.',
                        'correctAnswer must be the index (0-3) of the correct option.'
                    ]
                }
            },
            build: (toolId, context = {}) => {
                const template = PromptBuilder.templates[toolId];
                if (!template) {
                    return { systemPrompt: '', userPrompt: String(context.userInput || '') };
                }
                const rulesBlock = template.rules?.length ? `\n\nSTRICT RULES:\n${template.rules.map((r, i) => `${i + 1}. ${r}`).join('\n')}` : '';
                const systemPrompt = `${template.systemRole}\n\n${template.outputFormat}${rulesBlock}`;
                const userPrompt = PromptBuilder.constructUserPrompt(toolId, context);
                return { systemPrompt, userPrompt };
            },
            constructUserPrompt: (toolId, context = {}) => {
                if (toolId === 'policy-quiz') {
                    const policyText = String(context.policyText || '').trim();
                    const numQuestions = Number(context.numQuestions || 5);
                    const difficulty = String(context.difficulty || 'mixed');
                    const maxChars = Number(context.maxChars || 8000);
                    return `Create a quiz based on the following policy/procedure document.

POLICY CONTENT:
${policyText.substring(0, maxChars)}

Requirements:
- Generate ${numQuestions} multiple-choice questions
- Difficulty level: ${difficulty}
- Each question should have 4 options (A, B, C, D)
- Include the correct answer for each question
- Add brief explanations for why answers are correct/incorrect`;
                }
                return String(context.userInput || '');
            }
        };

        // --- GEMINI AI ENGINE ---
        const AI_CAPABILITY_REGISTRY = {
            version: '2.0',
            lastUpdated: '2026-01',
            capabilities: {
                analysis: {
                    supported: true,
                    actions: ['trend analysis', 'performance comparison', 'agent ranking', 'metric breakdown', 'pattern detection']
                },
                reporting: {
                    supported: true,
                    actions: ['generate agent report', 'create weekly summary', 'draft feedback email', 'coaching plan']
                },
                uiControl: {
                    supported: true,
                    actions: ['filter data', 'switch view', 'select agent', 'navigate to tab']
                },
                export: {
                    supported: true,
                    actions: ['export to CSV', 'download as image', 'copy to clipboard']
                },
                dataAccess: {
                    supported: true,
                    datasets: ['NPS reviews', 'QC evaluations', 'agent metrics'],
                    columns: {
                        nps: ['Agent', 'Date', 'Rating', 'Feedback', 'Acknowledged', 'Communication', 'Personalisation', 'Efficiency'],
                        qc: ['Agent', 'Date', 'QC Score', 'Question', 'Appeal Status', 'TL RCA', 'Agent Ack.']
                    }
                }
            },
            limitations: [
                'Cannot access external data sources',
                'Cannot modify raw data',
                'Cannot access other users data',
                'Cannot make real-time API calls to external services',
                'Cannot remember context between sessions unless explicitly saved'
            ],
            getCapabilityPrompt: () => {
                return `CAPABILITY REGISTRY (You MUST only claim these abilities):
    Analysis: ${AI_CAPABILITY_REGISTRY.capabilities.analysis.actions.join(', ')}
    Reporting: ${AI_CAPABILITY_REGISTRY.capabilities.reporting.actions.join(', ')}
    UI Control: ${AI_CAPABILITY_REGISTRY.capabilities.uiControl.actions.join(', ')}
    Export: ${AI_CAPABILITY_REGISTRY.capabilities.export.actions.join(', ')}
    Data Access: ${AI_CAPABILITY_REGISTRY.capabilities.dataAccess.datasets.join(', ')}


    LIMITATIONS (You MUST NOT claim these abilities):
    ${AI_CAPABILITY_REGISTRY.limitations.map(l => '- ' + l).join('\n')}


    STRICT RESPONSE FORMAT (MARKDOWN ONLY):
    - Provide analysis as rich Markdown text (no JSON).
    - Use bold section headers and bullet lists.
    - If navigation or actions are suggested, state them explicitly in plain text.`;
            }
        };

        const AI_MEMORY_ENGINE = {
            storageKey: PoppyApp.storage.AI_MEMORY,
            // In-memory storage for sandbox environment
            _memory: { facts: [], preferences: {} },

            load: () => {
                // Return in-memory copy
                return JSON.parse(JSON.stringify(AI_MEMORY_ENGINE._memory));
            },

            save: (memory) => {
                // Update in-memory storage
                AI_MEMORY_ENGINE._memory = memory;
            },

            remember: (type, content) => {
                const mem = AI_MEMORY_ENGINE.load();
                if (type === 'fact') {
                    mem.facts.unshift({ content, timestamp: Date.now() });
                    mem.facts = mem.facts.slice(0, 100);
                } else if (type === 'preference') {
                    Object.assign(mem.preferences, content);
                }
                AI_MEMORY_ENGINE.save(mem);
                return true;
            },

            recall: (query) => {
                const mem = AI_MEMORY_ENGINE.load();
                const terms = (query || '').toLowerCase().split(' ').filter(w => w.length > 3);
                const relevantFacts = mem.facts.filter(f => {
                    const factStr = f.content.toLowerCase();
                    return terms.some(t => factStr.includes(t));
                }).slice(0, 5);

                return {
                    facts: relevantFacts.map(f => f.content),
                    preferences: mem.preferences
                };
            },

            getMemoryPrompt: (query) => {
                const recall = AI_MEMORY_ENGINE.recall(query);
                if (recall.facts.length === 0 && Object.keys(recall.preferences).length === 0) return '';
                return `\n\nMEMORY RECALL:
    ${Object.keys(recall.preferences).length > 0 ? 'User Preferences: ' + JSON.stringify(recall.preferences) : ''}
    ${recall.facts.length > 0 ? 'Relevant Facts:\n' + recall.facts.map(f => '- ' + f).join('\n') : ''}`;
            }
        };

        // --- CONTEXTUAL SUGGESTION ENGINE ---
        const SuggestionEngine = {
            getSuggestions: (currentView, activeTab, selectedAgent, hasData) => {
                const view = String(currentView || 'unified').toLowerCase();
                const tab = String(activeTab || 'overview').toLowerCase();
                
                // Base suggestions by view
                const suggestionsByView = {
                    nps: {
                        overview: [
                            "Analyze top failed metrics",
                            "Show agent comparison",
                            "Identify NPS trends",
                            "Find low rated interactions"
                        ],
                        analysis: [
                            "Deep dive into Communication scores",
                            "Analyze Personalisation failures",
                            "Review Efficiency metrics",
                            "Generate agent coaching plan"
                        ],
                        agents: [
                            "Compare top vs bottom performers",
                            "Show agent ranking by rating",
                            "Find agents needing coaching",
                            "Analyze agent trends over time"
                        ],
                        dashboard: [
                            "Summarize NPS performance",
                            "Show pending acknowledgments",
                            "Identify key improvement areas",
                            "Generate team Slack post"
                        ]
                    },
                    qc: {
                        matrix: [
                            "Find critical errors",
                            "Generate coaching for top 3",
                            "Analyze QC score trends",
                            "Identify process gaps"
                        ],
                        appeals: [
                            "Summarize appeal status",
                            "Analyze appeal trends",
                            "Generate appeal response template",
                            "Review overturned decisions"
                        ],
                        agents: [
                            "Show QC scores by agent",
                            "Find agents with critical failures",
                            "Compare agent QC performance",
                            "Generate QC coaching plan"
                        ],
                        dashboard: [
                            "Summarize QC performance",
                            "Show critical failure rate",
                            "Identify training needs",
                            "Generate team update"
                        ]
                    },
                    unified: {
                        overview: [
                            "Compare NPS vs QC alignment",
                            "Find knowledge gaps",
                            "Analyze overall CX health",
                            "Generate executive summary"
                        ],
                        alignment: [
                            "Show NPS-QC correlation",
                            "Find service-quality gaps",
                            "Analyze balanced performers",
                            "Identify misalignment risks"
                        ],
                        dashboard: [
                            "Unified CX summary",
                            "Top priorities across NPS & QC",
                            "Cross-functional insights",
                            "Strategic recommendations"
                        ]
                    }
                };
                
                // Get base suggestions for current view/tab
                let suggestions = suggestionsByView[view]?.[tab] || suggestionsByView[view]?.['dashboard'] || suggestionsByView['unified']['overview'];
                
                // Add contextual suggestions based on selection
                if (selectedAgent) {
                    suggestions = [
                        `Analyze ${selectedAgent}'s performance`,
                        `Generate coaching plan for ${selectedAgent}`,
                        `Show trends for ${selectedAgent}`,
                        ...suggestions.slice(0, 2)
                    ];
                }
                
                // Add data-dependent suggestions
                if (!hasData) {
                    suggestions = [
                        "Generate sample performance chart",
                        "Create Slack post template",
                        "Draft executive summary",
                        "How to upload data?"
                    ];
                }
                
                // Always return 3-5 suggestions
                return suggestions.slice(0, 5);
            }
        };

        // --- IMAGE ANALYSIS UTILITIES ---
        const ImageAnalyzer = {
            // Validate image file
            validateFile: (file) => {
                const validTypes = ['image/png', 'image/jpeg', 'image/jpg'];
                const maxSize = 5 * 1024 * 1024; // 5MB limit
                
                if (!validTypes.includes(file.type)) {
                    return { valid: false, error: 'Please upload PNG, JPG, or JPEG images only.' };
                }
                if (file.size > maxSize) {
                    return { valid: false, error: 'Image size must be less than 5MB.' };
                }
                return { valid: true };
            },
            
            // Convert file to base64
            fileToBase64: (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            },
            
            // Generate prompt for image analysis
            buildImagePrompt: (userPrompt, context) => {
                return `${AI_PERSONA}

You are analyzing an image uploaded by a CX Team Lead. The image may contain charts, dashboards, screenshots, or other CX-related visual data.

USER QUERY: "${userPrompt || 'Please analyze this image and provide insights.'}"

CURRENT CONTEXT:
- View: ${context.currentView || 'Unified'}
- Tab: ${context.activeTab || 'Dashboard'}
- Agent: ${context.selectedAgent || 'All Agents'}

Analyze the image and provide:
1. **What the image shows** - Brief description
2. **Key Insights** - Important patterns, trends, or anomalies you observe
3. **Recommendations** - Actionable suggestions based on the visual data
4. **Questions** - Any clarifying questions if the image is unclear

If the image contains charts or metrics:
- Identify the metric names and their values if visible
- Note any trends (up/down, patterns)
- Highlight any concerning values

STRICT RULES:
- **Bullet Points:** ALWAYS use standard Markdown bullets (-).
- **Strict Keywords:** Use ONLY Pillar names and Sub-metric names from the data.

Be concise but thorough. Use markdown formatting for clarity.`;
            }
        };

        // ============================================
        // ADVANCED AI SYSTEMS - AGENTIC CAPABILITIES
        // ============================================

        // AGENTIC SYSTEM #19: Autonomous Agent Mode
        const AutonomousAgentSystem = {
            enabled: false,
            monitoringInterval: null,
            
            enable: () => {
                AutonomousAgentSystem.enabled = true;
                AutonomousAgentSystem.startMonitoring();
                return 'Autonomous Agent Mode ENABLED - Poppy AI will now proactively monitor data and suggest actions.';
            },
            
            disable: () => {
                AutonomousAgentSystem.enabled = false;
                AutonomousAgentSystem.stopMonitoring();
                return 'Autonomous Agent Mode DISABLED';
            },
            
            startMonitoring: () => {
                if (AutonomousAgentSystem.monitoringInterval) return;
                AutonomousAgentSystem.monitoringInterval = setInterval(() => {
                    // Check for anomalies every 30 seconds when enabled
                    AutonomousAgentSystem.checkForAnomalies();
                }, 30000);
            },
            
            stopMonitoring: () => {
                if (AutonomousAgentSystem.monitoringInterval) {
                    clearInterval(AutonomousAgentSystem.monitoringInterval);
                    AutonomousAgentSystem.monitoringInterval = null;
                }
            },
            
            checkForAnomalies: (data) => {
                // Check for data anomalies
                if (!data || data.length === 0) return [];
                const anomalies = [];
                // Check for sudden drops in scores
                const scores = data.map(d => parseFloat(d['QC Score'] || d.numericScore || 0)).filter(s => !isNaN(s));
                if (scores.length > 5) {
                    const avg = scores.reduce((a, b) => a + b, 0) / scores.length;
                    const recent = scores.slice(-5);
                    const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
                    if (recentAvg < avg * 0.7) {
                        anomalies.push({ type: 'score_drop', severity: 'high', message: 'Recent scores are significantly below average' });
                    }
                }
                return anomalies;
            },
            
            generateActionPlan: (detectedIssue) => {
                return {
                    issue: detectedIssue,
                    recommendedActions: [],
                    priority: 'medium',
                    reasoning: ''
                };
            }
        };

        // AGENTIC SYSTEM #20: Tool Orchestration Engine
        const ToolOrchestrationEngine = {
            executeWorkflow: async (workflowType, context, onProgress) => {
                const workflows = {
                    'analyze_and_export': [
                        { step: 'analyze', action: 'perform_deep_analysis', description: 'Analyzing data patterns...' },
                        { step: 'generate', action: 'generate_insights', description: 'Generating actionable insights...' },
                        { step: 'export', action: 'export_results', description: 'Preparing download...' }
                    ],
                    'coach_struggling_agents': [
                        { step: 'identify', action: 'identify_at_risk', description: 'Identifying at-risk agents...' },
                        { step: 'analyze', action: 'analyze_root_causes', description: 'Analyzing root causes...' },
                        { step: 'plan', action: 'create_coaching_plans', description: 'Creating coaching plans...' },
                        { step: 'export', action: 'export_plans', description: 'Preparing download...' }
                    ],
                    'weekly_summary': [
                        { step: 'gather', action: 'gather_metrics', description: 'Gathering weekly metrics...' },
                        { step: 'analyze', action: 'trend_analysis', description: 'Performing trend analysis...' },
                        { step: 'report', action: 'generate_report', description: 'Generating summary report...' },
                        { step: 'export', action: 'export_report', description: 'Preparing download...' }
                    ]
                };
                
                const steps = workflows[workflowType] || workflows['analyze_and_export'];
                const results = [];
                
                for (let i = 0; i < steps.length; i++) {
                    const step = steps[i];
                    onProgress && onProgress({
                        currentStep: i + 1,
                        totalSteps: steps.length,
                        description: step.description,
                        percent: Math.round(((i + 1) / steps.length) * 100)
                    });
                    
                    // Simulate step execution
                    await new Promise(resolve => setTimeout(resolve, 800));
                    results.push({ step: step.step, status: 'completed' });
                }
                
                return { success: true, results, workflowType };
            }
        };

        // AGENTIC SYSTEM #21: Decision Tree Engine
        const DecisionTreeEngine = {
            // SECURITY FIX: Replaced new Function() with safe expression evaluator
            evaluate: (condition, data) => {
                try {
                    // Whitelist of allowed operations
                    const allowedOps = {
                        'eq': (a, b) => a === b,
                        'ne': (a, b) => a !== b,
                        'gt': (a, b) => a > b,
                        'gte': (a, b) => a >= b,
                        'lt': (a, b) => a < b,
                        'lte': (a, b) => a <= b,
                        'and': (a, b) => a && b,
                        'or': (a, b) => a || b,
                        'not': (a) => !a,
                        'in': (a, b) => b.includes(a),
                        'contains': (a, b) => String(a).includes(b)
                    };
                    
                    // Parse simple conditions like "data.score > 80" or "data.status === 'active'"
                    const match = condition.match(/^data\.(\w+)\s*(===?|!==?|>=?|<=?)\s*(.+)$/);
                    if (match) {
                        const [, prop, op, valueStr] = match;
                        const propValue = data[prop];
                        let compareValue = valueStr.trim();
                        
                        // Remove quotes from string values
                        if ((compareValue.startsWith('"') && compareValue.endsWith('"')) ||
                            (compareValue.startsWith("'") && compareValue.endsWith("'"))) {
                            compareValue = compareValue.slice(1, -1);
                        } else {
                            // Try to parse as number
                            const num = parseFloat(compareValue);
                            if (!isNaN(num)) compareValue = num;
                        }
                        
                        switch (op) {
                            case '===': case '==': return propValue === compareValue;
                            case '!==': case '!=': return propValue !== compareValue;
                            case '>': return propValue > compareValue;
                            case '>=': return propValue >= compareValue;
                            case '<': return propValue < compareValue;
                            case '<=': return propValue <= compareValue;
                        }
                    }
                    
                    // Fallback: return false for unsupported expressions
                    return false;
                } catch (e) {
                    return false;
                }
            },
            
            executeBranch: (tree, data) => {
                let current = tree;
                const path = [];
                
                while (current) {
                    path.push(current.id);
                    
                    if (current.condition) {
                        const result = DecisionTreeEngine.evaluate(current.condition, data);
                        current = result ? current.then : current.else;
                    } else {
                        // Leaf node - return action
                        return { action: current.action, path, data: current.data };
                    }
                }
                
                return { action: 'default', path, data: null };
            }
        };

        // AGENTIC SYSTEM #22: Self-Correction Mechanism
        const SelfCorrectionEngine = {
            maxRetries: 3,
            
            executeWithRetry: async (operation, validator, context = {}) => {
                let lastError = null;
                let attempts = 0;
                
                while (attempts < SelfCorrectionEngine.maxRetries) {
                    attempts++;
                    
                    try {
                        const result = await operation();
                        const validation = validator(result);
                        
                        if (validation.valid) {
                            return { success: true, result, attempts, corrected: attempts > 1 };
                        }
                        
                        lastError = validation.error;
                        
                        // Apply correction strategy
                        if (validation.correctionStrategy) {
                            context = { ...context, ...validation.correctionStrategy };
                        }
                        
                    } catch (error) {
                        lastError = error.message;
                    }
                    
                    // Wait before retry
                    if (attempts < SelfCorrectionEngine.maxRetries) {
                        await new Promise(resolve => setTimeout(resolve, 500 * attempts));
                    }
                }
                
                return { success: false, error: lastError, attempts };
            },
            
            validators: {
                jsonParse: (text) => {
                    try {
                        JSON.parse(text);
                        return { valid: true };
                    } catch (e) {
                        return { 
                            valid: false, 
                            error: e.message,
                            correctionStrategy: { fixJSON: true }
                        };
                    }
                },
                
                hasContent: (text) => {
                    const hasContent = text && text.trim().length > 50;
                    return {
                        valid: hasContent,
                        error: hasContent ? null : 'Content too short',
                        correctionStrategy: hasContent ? null : { expandContent: true }
                    };
                }
            }
        };

        // AGENTIC SYSTEM #23: Goal-Based Planning Engine
        const GoalPlanningEngine = {
            createPlan: (goal, context) => {
                const plan = {
                    goal,
                    steps: [],
                    estimatedTime: 0,
                    dependencies: []
                };
                
                // Parse goal and generate steps
                if (goal.toLowerCase().includes('improve team performance')) {
                    plan.steps = [
                        { id: 1, task: 'Analyze current team metrics', estimatedMinutes: 5, status: 'pending' },
                        { id: 2, task: 'Identify underperforming agents', estimatedMinutes: 3, status: 'pending' },
                        { id: 3, task: 'Analyze failure patterns', estimatedMinutes: 5, status: 'pending' },
                        { id: 4, task: 'Generate coaching recommendations', estimatedMinutes: 5, status: 'pending' },
                        { id: 5, task: 'Create action plan', estimatedMinutes: 3, status: 'pending' }
                    ];
                    plan.estimatedTime = 21;
                } else if (goal.toLowerCase().includes('reduce failures')) {
                    plan.steps = [
                        { id: 1, task: 'Identify top failure categories', estimatedMinutes: 3, status: 'pending' },
                        { id: 2, task: 'Analyze agents with most failures', estimatedMinutes: 5, status: 'pending' },
                        { id: 3, task: 'Root cause analysis', estimatedMinutes: 7, status: 'pending' },
                        { id: 4, task: 'Generate improvement strategies', estimatedMinutes: 5, status: 'pending' }
                    ];
                    plan.estimatedTime = 20;
                } else {
                    // Generic plan
                    plan.steps = [
                        { id: 1, task: 'Analyze request context', estimatedMinutes: 2, status: 'pending' },
                        { id: 2, task: 'Gather relevant data', estimatedMinutes: 5, status: 'pending' },
                        { id: 3, task: 'Perform analysis', estimatedMinutes: 8, status: 'pending' },
                        { id: 4, task: 'Generate response', estimatedMinutes: 3, status: 'pending' }
                    ];
                    plan.estimatedTime = 18;
                }
                
                return plan;
            },
            
            executePlan: async (plan, onStepComplete) => {
                const results = [];
                
                for (const step of plan.steps) {
                    step.status = 'in_progress';
                    
                    // Simulate step execution
                    await new Promise(resolve => setTimeout(resolve, step.estimatedMinutes * 100));
                    
                    step.status = 'completed';
                    results.push({ stepId: step.id, completed: true });
                    
                    onStepComplete && onStepComplete(step, results.length, plan.steps.length);
                }
                
                return { completed: true, results, plan };
            }
        };

        // AGENTIC SYSTEM #24: Context-Aware Action Engine
        const ContextAwareEngine = {
            detectContext: (currentView, activeTab, selectedAgent, data) => {
                return {
                    view: currentView,
                    tab: activeTab,
                    hasAgent: !!selectedAgent,
                    agentName: selectedAgent,
                    hasData: data && data.length > 0,
                    dataSize: data?.length || 0,
                    timestamp: new Date().toISOString()
                };
            },
            
            suggestActions: (context) => {
                const suggestions = [];
                
                if (!context.hasData) {
                    suggestions.push({ action: 'upload_data', label: 'Upload Data', priority: 'high' });
                    return suggestions;
                }
                
                if (context.view === 'nps') {
                    if (context.hasAgent) {
                        suggestions.push({ action: 'analyze_agent_nps', label: `Analyze ${context.agentName}'s NPS`, priority: 'high' });
                        suggestions.push({ action: 'trend_analysis', label: 'Show NPS Trends', priority: 'medium' });
                    } else {
                        suggestions.push({ action: 'team_overview', label: 'Team NPS Overview', priority: 'high' });
                        suggestions.push({ action: 'identify_detractors', label: 'Identify Detractors', priority: 'medium' });
                    }
                } else if (context.view === 'qc') {
                    if (context.hasAgent) {
                        suggestions.push({ action: 'analyze_agent_qc', label: `Analyze ${context.agentName}'s QC`, priority: 'high' });
                        suggestions.push({ action: 'failure_analysis', label: 'Failure Analysis', priority: 'medium' });
                    } else {
                        suggestions.push({ action: 'team_qc_overview', label: 'Team QC Overview', priority: 'high' });
                        suggestions.push({ action: 'systemic_gaps', label: 'Find Systemic Gaps', priority: 'medium' });
                    }
                } else {
                    // Unified
                    suggestions.push({ action: 'unified_analysis', label: 'Unified Analysis', priority: 'high' });
                    suggestions.push({ action: 'correlation', label: 'NPS-QC Correlation', priority: 'medium' });
                }
                
                // Universal suggestions
                suggestions.push({ action: 'generate_report', label: 'Generate Report', priority: 'low' });
                suggestions.push({ action: 'export_data', label: 'Export Data', priority: 'low' });
                
                return suggestions;
            }
        };

        // ============================================
        // REAL-TIME PROGRESS TRACKER SYSTEM
        // ============================================

        const ProgressTracker = {
            activeOperations: new Map(),
            
            startOperation: (operationId, description, totalSteps) => {
                const operation = {
                    id: operationId,
                    description,
                    totalSteps,
                    currentStep: 0,
                    steps: [],
                    startTime: Date.now(),
                    estimatedTimeRemaining: 0,
                    status: 'running',
                    canRollback: false,
                    completedActions: []
                };
                ProgressTracker.activeOperations.set(operationId, operation);
                return operation;
            },
            
            updateStep: (operationId, stepDescription, percentComplete, liveData = null) => {
                const operation = ProgressTracker.activeOperations.get(operationId);
                if (!operation) return;
                
                operation.currentStep++;
                operation.steps.push({
                    step: operation.currentStep,
                    description: stepDescription,
                    percent: percentComplete,
                    timestamp: Date.now(),
                    liveData
                });
                
                // Calculate ETA
                const elapsed = Date.now() - operation.startTime;
                const rate = elapsed / percentComplete;
                operation.estimatedTimeRemaining = Math.round((100 - percentComplete) * rate / 1000);
                
                return operation;
            },
            
            completeOperation: (operationId, result) => {
                const operation = ProgressTracker.activeOperations.get(operationId);
                if (operation) {
                    operation.status = 'completed';
                    operation.result = result;
                    operation.completedActions = operation.steps.map(s => s.description);
                    operation.canRollback = true;
                }
                return operation;
            },
            
            failOperation: (operationId, error) => {
                const operation = ProgressTracker.activeOperations.get(operationId);
                if (operation) {
                    operation.status = 'failed';
                    operation.error = error;
                }
                return operation;
            },
            
            rollback: (operationId) => {
                const operation = ProgressTracker.activeOperations.get(operationId);
                if (!operation || !operation.canRollback) {
                    return { success: false, error: 'Cannot rollback this operation' };
                }
                
                // Perform rollback logic here
                operation.status = 'rolled_back';
                return { success: true, operation };
            },
            
            getOperation: (operationId) => {
                return ProgressTracker.activeOperations.get(operationId);
            }
        };

        // ============================================
        // INBUILT SYSTEM PROMPTS ENGINE
        // ============================================

        const SystemPromptsEngine = {
            // Domain-Specific Prompts (#34)
            domainPrompts: {
                nps_analysis: `${AI_PERSONA}
You are analyzing NPS (Net Promoter Score) data for a CX team.
Focus on: Customer satisfaction trends, detractor identification, sentiment analysis.
Key metrics: Response rates, CSAT scores, sentiment distribution.
Always provide actionable recommendations for improving customer satisfaction.`,
                
                qc_analysis: `${AI_PERSONA}
You are analyzing QC (Quality Control) audit data for a CX team.
Focus on: Compliance rates, failure patterns, process adherence.
Key metrics: Pass/fail rates, category scores, recurring issues.
Always provide specific coaching recommendations for quality improvement.`,
                
                coaching: `${AI_PERSONA}
You are creating coaching plans for CX agents.
Use empathetic, constructive language.
Structure: Strengths  Areas for improvement  Specific actions  Follow-up plan.
Avoid blame; focus on growth and development.`,
                
                executive_summary: `${AI_PERSONA}
You are writing an executive summary for CX leadership.
Be concise, data-driven, and strategic.
Focus on: High-level trends, key risks, recommended actions, business impact.
Use professional business language. Avoid technical jargon.`
            },
            
            // Quality Guardrails (#35)
            qualityGuardrails: {
                formatting: `
STRICT FORMATTING RULES:
1. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.
2. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).
3. NO hashtags (#) for headers.
4. Use emojis sparingly (max 2 per line).
5. Do NOT use the word "Bold", "Underline", or "B" as text.
6. Do NOT bold emphasis words like "Always", "Never", "Note" inside descriptions.`,
                
                tone: `
TONE REQUIREMENTS:
1. Be professional but approachable.
2. Use active voice.
3. Be specific - avoid vague statements.
4. Balance positive and constructive feedback.
5. Focus on behaviors, not personalities.`,
                
                accuracy: `
ACCURACY CHECKS:
1. Only make claims supported by provided data.
2. If data is insufficient, say so explicitly.
3. Distinguish between facts and interpretations.
4. Flag any uncertainties or assumptions.`
            },
            
            // Bias Detection (#36)
            biasDetection: `
BIAS CHECK - Review your response for:
1. Confirmation bias: Are you only supporting one viewpoint?
2. Availability bias: Are you over-weighting recent or memorable events?
3. Anchoring bias: Are you overly influenced by initial information?
4. Halo/horns effect: Are you letting one trait color the entire assessment?
5. Recency bias: Are you ignoring older but relevant data?
If any bias is detected, adjust your response accordingly.`,
            
            // Context Preservation (#37)
            contextPreservation: (previousContext) => `
CONTEXT PRESERVATION:
Previous conversation topics: ${previousContext || 'None'}
Maintain continuity with previous discussion.
Reference earlier points when relevant.
If user refers to "this", "that", "it" - check context for antecedents.
Build upon previous insights rather than repeating them.`,
            
            // Output Validation (#38)
            outputValidation: `
VALIDATION CHECKLIST - Before delivering response:
 Did I answer the user's specific question?
 Is the information accurate based on provided data?
 Is the formatting consistent with guidelines?
 Is the tone appropriate for the context?
 Are recommendations actionable and specific?
 Did I include confidence indicators where appropriate?`,
            
            getFullPrompt: (domain, previousContext = '') => {
                return [
                    SystemPromptsEngine.domainPrompts[domain] || SystemPromptsEngine.domainPrompts.nps_analysis,
                    SystemPromptsEngine.qualityGuardrails.formatting,
                    SystemPromptsEngine.qualityGuardrails.tone,
                    SystemPromptsEngine.qualityGuardrails.accuracy,
                    SystemPromptsEngine.biasDetection,
                    SystemPromptsEngine.contextPreservation(previousContext),
                    SystemPromptsEngine.outputValidation
                ].join('\n\n');
            }
        };

        // ============================================
        // DOCUMENT ANALYSIS ENGINE
        // ============================================

        const DocumentAnalysisEngine = {
            // OCR for Screenshots (#41)
            performOCR: async (imageData) => {
                const prompt = `${AI_PERSONA}
Extract all readable text from this image. Preserve formatting as much as possible.
If tables are present, convert to markdown table format.
If charts/graphs, describe the data shown.
Return structured text extraction.`;
                
                try {
                    const result = await GeminiAI.generate(prompt, '', { imageData });
                    return { success: true, text: result, method: 'AI-OCR' };
                } catch (e) {
                    return { success: false, error: e.message };
                }
            },
            
            // Long Context Support (#43)
            chunkDocument: (text, maxChunkSize = 4000) => {
                const chunks = [];
                const sentences = text.split(/(?<=[.!?])\s+/);
                let currentChunk = '';
                
                for (const sentence of sentences) {
                    if ((currentChunk + sentence).length > maxChunkSize) {
                        chunks.push(currentChunk.trim());
                        currentChunk = sentence;
                    } else {
                        currentChunk += ' ' + sentence;
                    }
                }
                
                if (currentChunk.trim()) {
                    chunks.push(currentChunk.trim());
                }
                
                return chunks;
            },
            
            // Smart Document Summarization (#44)
            summarize: async (text, options = {}) => {
                const { maxLength = 500, focusAreas = [], format = 'bullets' } = options;
                
                const chunks = DocumentAnalysisEngine.chunkDocument(text);
                const summaries = [];
                
                for (const chunk of chunks.slice(0, 5)) { // Process first 5 chunks
                    const prompt = `${AI_PERSONA}
Summarize the following text concisely.
Focus areas: ${focusAreas.join(', ') || 'General'}
Format: ${format === 'bullets' ? 'Bullet points' : 'Paragraph'}
Max length: ${maxLength} characters.

TEXT TO SUMMARIZE:
${chunk}

Provide only the summary, no meta-commentary.`;
                    
                    try {
                        const summary = await GeminiAI.generate(prompt);
                        summaries.push(summary);
                    } catch (e) {
                        summaries.push('[Summary unavailable for this section]');
                    }
                }
                
                return {
                    summary: summaries.join('\n\n'),
                    chunksProcessed: chunks.length,
                    totalLength: text.length
                };
            },
            
            // File validation for uploads (#40)
            validateDocument: (file) => {
                const validTypes = {
                    'application/pdf': 'pdf',
                    'text/plain': 'txt',
                    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'docx',
                    'application/msword': 'doc',
                    'text/markdown': 'md',
                    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': 'xlsx',
                    'text/csv': 'csv'
                };
                
                const maxSize = 10 * 1024 * 1024; // 10MB
                
                if (!validTypes[file.type] && !file.name.match(/\.(pdf|txt|docx|doc|md|xlsx|csv)$/i)) {
                    return { valid: false, error: 'Unsupported file type. Supported: PDF, TXT, DOCX, MD, XLSX, CSV' };
                }
                
                if (file.size > maxSize) {
                    return { valid: false, error: 'File too large. Maximum size: 10MB' };
                }
                
                return { valid: true, type: validTypes[file.type] || 'unknown' };
            }
        };

        // ============================================
        // ADVANCED INTELLIGENCE ENGINE
        // ============================================

        const AdvancedIntelligenceEngine = {
            // Chain-of-Thought Reasoning (#55)
            generateWithReasoning: async (query, context, data) => {
                const reasoningPrompt = `${AI_PERSONA}
Analyze this query step-by-step, showing your reasoning process.

QUERY: "${query}"
CONTEXT: ${JSON.stringify(context)}

Provide your response in this format:

**Thinking Process:**
1. [First reasoning step]
2. [Second reasoning step]
3. [Continue as needed...]

**Analysis:**
[Your detailed analysis]

**Conclusion:**
[Your final answer/recommendation]

**Confidence:** [High/Medium/Low] - [Brief explanation]`;
                
                try {
                    const response = await GeminiAI.generate(reasoningPrompt);
                    return { 
                        success: true, 
                        response,
                        hasReasoning: true 
                    };
                } catch (e) {
                    return { success: false, error: e.message };
                }
            },
            
            // Confidence Scoring (#56)
            calculateConfidence: (data, analysis) => {
                let score = 0;
                let factors = [];
                
                // Data quality factor
                if (data && data.length > 50) {
                    score += 30;
                    factors.push('Large dataset (+30)');
                } else if (data && data.length > 10) {
                    score += 20;
                    factors.push('Moderate dataset (+20)');
                } else {
                    score += 10;
                    factors.push('Small dataset (+10)');
                }
                
                // Historical data factor
                if (analysis && analysis.trend) {
                    score += 25;
                    factors.push('Trend data available (+25)');
                }
                
                // Completeness factor
                if (analysis && analysis.rootCause) {
                    score += 25;
                    factors.push('Root cause identified (+25)');
                }
                
                // Consistency factor
                if (analysis && !analysis.contradictions) {
                    score += 20;
                    factors.push('Data consistent (+20)');
                }
                
                const level = score >= 80 ? 'High' : score >= 60 ? 'Medium' : 'Low';
                
                return { score, level, factors };
            },
            
            // Multi-Hop Reasoning (#58)
            multiHopReasoning: async (question, hops = []) => {
                const results = [];
                let currentQuestion = question;
                
                for (let i = 0; i < hops.length; i++) {
                    const hop = hops[i];
                    
                    const prompt = `${AI_PERSONA}
Hop ${i + 1}/${hops.length}: ${hop.description}
Question: ${currentQuestion}
${i > 0 ? `Previous result: ${results[i-1].answer}` : ''}

Answer this step and provide the key finding for the next hop.`;
                    
                    try {
                        const answer = await GeminiAI.generate(prompt);
                        results.push({ hop: i + 1, description: hop.description, answer });
                        currentQuestion = answer; // Chain to next hop
                    } catch (e) {
                        results.push({ hop: i + 1, error: e.message });
                        break;
                    }
                }
                
                return { results, finalAnswer: results[results.length - 1]?.answer };
            },
            
            // Causal Analysis (#59)
            causalAnalysis: (data, metric) => {
                const factors = [];
                const correlations = [];
                
                // Identify potential causes
                if (data && data.length > 0) {
                    // Time-based causality
                    const sorted = [...data].sort((a, b) => new Date(a.Date) - new Date(b.Date));
                    
                    // Check for preceding events
                    const failedRecords = sorted.filter(r => r.isFail || r.Rating <= 2);
                    const commonPatterns = {};
                    
                    failedRecords.forEach(r => {
                        const key = r['Chat Tag'] || r['Question'] || 'Unknown';
                        commonPatterns[key] = (commonPatterns[key] || 0) + 1;
                    });
                    
                    Object.entries(commonPatterns)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 5)
                        .forEach(([cause, count]) => {
                            factors.push({ cause, frequency: count, type: 'direct' });
                        });
                }
                
                return {
                    primaryMetric: metric,
                    causalFactors: factors,
                    correlations,
                    confidence: factors.length > 0 ? 'Medium' : 'Low'
                };
            },
            
            // Smart Recommendations (#62)
            generateRecommendations: (analysis) => {
                const recommendations = [];
                
                if (analysis.atRiskAgents && analysis.atRiskAgents.length > 0) {
                    recommendations.push({
                        priority: 'High',
                        action: 'Schedule immediate 1:1 coaching',
                        target: analysis.atRiskAgents.map(a => a.name).join(', '),
                        rationale: 'Agents showing declining performance trends'
                    });
                }
                
                if (analysis.systemicGaps && analysis.systemicGaps.length > 0) {
                    recommendations.push({
                        priority: 'High',
                        action: 'Conduct team training on top failure categories',
                        target: 'All agents',
                        rationale: `Systemic issues found: ${analysis.systemicGaps.slice(0, 3).join(', ')}`
                    });
                }
                
                if (analysis.topPerformers && analysis.topPerformers.length > 0) {
                    recommendations.push({
                        priority: 'Medium',
                        action: 'Leverage top performers as mentors',
                        target: analysis.topPerformers.slice(0, 3).map(a => a.name).join(', '),
                        rationale: 'High performers can share best practices'
                    });
                }
                
                // Add generic recommendations if few specific ones
                if (recommendations.length < 3) {
                    recommendations.push({
                        priority: 'Medium',
                        action: 'Implement weekly team huddles',
                        target: 'Team',
                        rationale: 'Regular communication improves alignment'
                    });
                }
                
                return recommendations;
            }
        };

        // ============================================
        // FUNCTION CALLING ENGINE
        // ============================================

        const FunctionCallingEngine = {
            availableFunctions: {
                switch_view: {
                    description: 'Switch between NPS, QC, or Unified view',
                    parameters: { view: { type: 'string', enum: ['nps', 'qc', 'unified'] } },
                    execute: (params, appContext) => {
                        if (appContext.setView) {
                            appContext.setView(params.view);
                            return { success: true, message: `Switched to ${params.view} view` };
                        }
                        return { success: false, error: 'View switch not available' };
                    }
                },
                
                set_filter: {
                    description: 'Apply filters to data',
                    parameters: { 
                        agent: { type: 'string' },
                        dateRange: { type: 'string' },
                        category: { type: 'string' }
                    },
                    execute: (params, appContext) => {
                        if (appContext.setFilters) {
                            appContext.setFilters(prev => ({ ...prev, ...params }));
                            return { success: true, message: 'Filters applied' };
                        }
                        return { success: false, error: 'Filter not available' };
                    }
                },
                
                switch_tab: {
                    description: 'Switch to a different tab',
                    parameters: { tab: { type: 'string' } },
                    execute: (params, appContext) => {
                        if (appContext.setActiveTab) {
                            appContext.setActiveTab(params.tab);
                            return { success: true, message: `Switched to ${params.tab} tab` };
                        }
                        return { success: false, error: 'Tab switch not available' };
                    }
                },
                
                export_data: {
                    description: 'Export current data as CSV',
                    parameters: { format: { type: 'string', enum: ['csv', 'json'] } },
                    execute: (params, appContext) => {
                        if (appContext.exportData) {
                            appContext.exportData(params.format);
                            return { success: true, message: `Export initiated as ${params.format}` };
                        }
                        return { success: false, error: 'Export not available' };
                    }
                },
                
                select_agent: {
                    description: 'Select an agent for spotlight view',
                    parameters: { agentName: { type: 'string' } },
                    execute: (params, appContext) => {
                        if (appContext.setSelectedAgentGlobal) {
                            appContext.setSelectedAgentGlobal(params.agentName);
                            return { success: true, message: `Selected agent: ${params.agentName}` };
                        }
                        return { success: false, error: 'Agent selection not available' };
                    }
                }
            },
            
            parseFunctionCall: (response) => {
                // Parse function calls from AI response
                const functionCallRegex = /<function>(\w+)<\/function>\s*\{([^}]+)\}/g;
                const calls = [];
                let match;
                
                while ((match = functionCallRegex.exec(response)) !== null) {
                    calls.push({
                        function: match[1],
                        params: JSON.parse(`{${match[2]}}`)
                    });
                }
                
                return calls;
            },
            
            executeFunctions: async (calls, appContext) => {
                const results = [];
                
                for (const call of calls) {
                    const func = FunctionCallingEngine.availableFunctions[call.function];
                    if (func) {
                        try {
                            const result = await func.execute(call.params, appContext);
                            results.push({ function: call.function, ...result });
                        } catch (e) {
                            results.push({ function: call.function, success: false, error: e.message });
                        }
                    } else {
                        results.push({ function: call.function, success: false, error: 'Unknown function' });
                    }
                }
                
                return results;
            }
        };

        // ============================================
        // AGENT-SPECIFIC MEMORY SYSTEM
        // ============================================

        const _agentMemoryCache = {};
        const AgentMemorySystem = {
            getStorageKey: (agentName) => `poppy_agent_memory_${agentName.replace(/\s+/g, '_').toLowerCase()}`,
            
            remember: (agentName, memory) => {
                const key = AgentMemorySystem.getStorageKey(agentName);
                const existing = _agentMemoryCache[key] || [];
                existing.push({
                    ...memory,
                    timestamp: new Date().toISOString()
                });
                // Keep last 50 memories
                const trimmed = existing.slice(-50);
                _agentMemoryCache[key] = trimmed;
            },
            
            recall: (agentName, limit = 10) => {
                const key = AgentMemorySystem.getStorageKey(agentName);
                const memories = _agentMemoryCache[key] || [];
                return memories.slice(-limit);
            },
            
            getInsights: (agentName) => {
                const memories = AgentMemorySystem.recall(agentName, 50);
                
                // Extract patterns
                const topics = {};
                const sentiments = [];
                
                memories.forEach(m => {
                    if (m.topic) topics[m.topic] = (topics[m.topic] || 0) + 1;
                    if (m.sentiment) sentiments.push(m.sentiment);
                });
                
                return {
                    agentName,
                    totalInteractions: memories.length,
                    topTopics: Object.entries(topics).sort((a, b) => b[1] - a[1]).slice(0, 5),
                    recentSentiment: sentiments.slice(-5),
                    lastSeen: memories.length > 0 ? memories[memories.length - 1].timestamp : null
                };
            },
            
            clear: (agentName) => {
                const key = AgentMemorySystem.getStorageKey(agentName);
                delete _agentMemoryCache[key];
            }
        };

        // --- ENHANCED AI CONTENT GENERATION SYSTEM ---
        const CONTENT_TYPE_REGISTRY = {
            version: '3.0',
            contentTypes: {
                text: { 
                    description: 'Standard text response with Markdown formatting',
                    capabilities: ['analysis', 'explanation', 'answer', 'advice']
                },
                chart: { 
                    description: 'Data visualization using bar or line charts',
                    capabilities: ['visualize trends', 'compare data', 'show patterns'],
                    requiresData: false,
                    fallbackToMock: true
                },
                table: { 
                    description: 'Structured data table with headers and rows',
                    capabilities: ['display records', 'show rankings', 'list items'],
                    requiresData: false,
                    fallbackToMock: true
                },
                slack: { 
                    description: 'Slack-formatted post for team communication',
                    capabilities: ['team updates', 'congratulations', 'announcements', 'welcome messages'],
                    requiresData: false
                },
                pdf: { 
                    description: 'PDF document export with formatted content',
                    capabilities: ['export reports', 'create documents', 'save summaries'],
                    requiresData: false
                },
                executive_summary: { 
                    description: 'High-level executive summary with key insights',
                    capabilities: ['summarize performance', 'highlight trends', 'strategic overview'],
                    requiresData: false,
                    fallbackToMock: true
                },
                coaching_plan: { 
                    description: 'Structured coaching plan for agent development',
                    capabilities: ['agent feedback', 'development plans', 'performance improvement'],
                    requiresData: false
                },
                feedback_1on1: { 
                    description: '1:1 feedback message for direct agent communication',
                    capabilities: ['personal feedback', 'recognition', 'coaching'],
                    requiresData: false
                },
                kpi_grid: {
                    description: 'Grid of KPI cards showing key metrics',
                    capabilities: ['display metrics', 'show performance indicators'],
                    requiresData: false,
                    fallbackToMock: true
                }
            },
            getCapabilityPrompt: () => {
                return `CONTENT GENERATION CAPABILITIES:
You can generate the following content types. When a user requests content, determine the appropriate type and structure your response accordingly.

Available Content Types:
1. TEXT - Standard analysis, explanations, answers (Markdown formatted)
2. CHART - Visual data representation (bar/line charts for trends, comparisons, patterns)
3. TABLE - Structured data display (rankings, records, lists with headers and rows)
4. SLACK - Team communication posts (updates, congratulations, announcements, welcome messages)
5. PDF - Document exports (reports, summaries, formatted documents)
6. EXECUTIVE_SUMMARY - High-level strategic overview with key insights and trends
7. COACHING_PLAN - Agent development plan with feedback and action items
8. FEEDBACK_1ON1 - Personal 1:1 feedback message for direct communication
9. KPI_GRID - Grid display of key performance indicators

IMPORTANT RULES:
- For "Generate slack post to welcome a new teammate" -> Use SLACK type with welcoming tone
- For "Create chart showing..." -> Use CHART type with appropriate data structure
- For "Export as PDF..." or "Generate PDF..." -> Use PDF type with formatted content
- For "Generate executive summary" -> Use EXECUTIVE_SUMMARY type
- For "Create coaching plan" -> Use COACHING_PLAN type
- For "Draft 1:1 feedback" -> Use FEEDBACK_1ON1 type

If user requests content WITHOUT loaded data:
- For charts/tables: Create realistic mock/sample data based on CX context
- For slack posts: Generate appropriate content based on the request (e.g., welcome message for new team member)
- For PDF/Executive Summary: Generate a realistic example based on CX context (no placeholders)
- Never say "insufficient data" for creative/generative requests

RESPONSE FORMAT:
When generating structured content, wrap in JSON markers:
\`\`\`json
{
  "contentType": "chart|table|slack|pdf|executive_summary|coaching_plan|feedback_1on1|kpi_grid|text",
  "title": "string",
  "data": { ... },
  "content": "markdown content"
}
\`\`\`

For simple text responses, use standard Markdown without JSON wrapper.`;
            }
        };

        const SYSTEM_PROMPT = `You are Poppy AI, an elite CX Analyst and Content Generation Assistant. 

CORE CAPABILITIES:
1. Analyze CX data (NPS, QC, agent performance) and provide insights
2. Generate ANY type of content requested by the user:
   - Charts (trends, comparisons, patterns) - using Recharts
   - Tables (rankings, records, data) - formatted data tables
   - Slack posts (team updates, congratulations, welcomes) - ready to copy/paste
   - PDF documents (reports, summaries) - export-ready content
   - Executive summaries (high-level strategic overviews)
   - Coaching plans (agent development with action items)
   - 1:1 feedback (personal messages for agents)
   - KPI grids (key performance indicators display)

CRITICAL RULES:
- Use Markdown with BOLD headers (**Header**). No hashtags (#).
- Every heading MUST have a relevant emoji ( metrics,  goals,  action items,  insights,  warnings,  summary)
- Add 2 line breaks (\n\n) after each heading
- Redact internal UI navigation artifacts (tab names, view names, component titles)
- If data is missing for ANALYSIS, say 'Insufficient Data for analysis'
- If user asks to GENERATE content (chart/table/slack/pdf), NEVER say 'insufficient data' - create appropriate content
- For random requests like "welcome new teammate", generate creative, professional content

CONTENT TYPE DETECTION:
- "Generate slack post for..." -> SLACK type
- "Create chart showing..." -> CHART type  
- "Make a table of..." -> TABLE type
- "Export as PDF..." -> PDF type
- "Executive summary..." -> EXECUTIVE_SUMMARY type
- "Coaching plan for..." -> COACHING_PLAN type
- "1:1 feedback for..." -> FEEDBACK_1ON1 type

${CONTENT_TYPE_REGISTRY.getCapabilityPrompt()}`;
        const TL_PERSONA_PROMPT = `Persona: You are the Team Lead. Infer your tone, vocabulary, and English level from any 'TL RCA', 'Answer Comment', and 'Remediation Feedback' texts present in the prompt or data. Mimic that communication pattern consistently across all outputs. You are the Team Lead. You MUST use this exact tone and vocabulary. Do NOT use generic AI filler like 'Here is your analysis'.`;

        // Extract style context from TL feedback texts
        const extractTLStyleContext = (data, type = 'NPS') => {
            if (!data || data.length === 0) return '';
            
            // Collect all feedback texts based on type
            let feedbacks = [];
            if (type === 'NPS') {
                feedbacks = data
                    .map(d => d['Remediation Feedback'] || d['Feedback'] || '')
                    .filter(f => f && f.trim().length > 10);
            } else if (type === 'QC') {
                feedbacks = data
                    .map(d => {
                        const tlRCA = d['TL RCA'] || '';
                        const answerComment = d['Answer Comment'] || '';
                        return tlRCA && answerComment ? `${tlRCA} ${answerComment}` : (tlRCA || answerComment);
                    })
                    .filter(f => f && f.trim().length > 10);
            } else {
                // Default / Fallback
                feedbacks = data
                    .map(d => d['TL RCA'] || d['Remediation Feedback'] || d['Feedback'] || d['Answer Comment'] || '')
                    .filter(f => f && f.trim().length > 10);
            }
            
            feedbacks = feedbacks.slice(0, 3); // extract exactly 3 sentences/examples
            
            if (feedbacks.length === 0) return '';
            
            return `
STYLE ANALYSIS FROM TL FEEDBACKS:
Here are 3 distinct examples of the Team Lead's actual writing style. 

Example 1: "${feedbacks[0] || 'N/A'}"
Example 2: "${feedbacks[1] || 'N/A'}"
Example 3: "${feedbacks[2] || 'N/A'}"

IMPORTANT: You are the Team Lead. Use this exact tone and vocabulary. Mimic this EXACT communication style - use similar vocabulary, sentence length, tone, and structure. Match the TL's actual writing style.`;
        };

        const AIRequestManager = {
            _progressActive: false,
            emitProgress: (progress, text, show = true) => {
                AIRequestManager._progressActive = show !== false;
                window.dispatchEvent(new CustomEvent('ai-progress', { detail: { show, progress, text } }));
            },
            hideProgress: () => {
                AIRequestManager._progressActive = false;
                window.dispatchEvent(new CustomEvent('ai-progress', { detail: { show: false } }));
            },
            apiKey: "",
            model: "gemini-2.5-flash-preview-09-2025",
            
            setApiKey: (key) => {
                if (key && key.trim()) {
                    AIRequestManager.apiKey = key.trim();
                    return true;
                }
                return false;
            },
            
            getApiKey: () => {
                const qs = new URLSearchParams(location.search || "");
                const fromUrl = (qs.get("key") || qs.get("apiKey") || qs.get("geminiKey") || "").toString();
                const fromGlobal = ((globalThis && (globalThis.GEMINI_API_KEY || globalThis.GOOGLE_API_KEY || globalThis.API_KEY)) || "").toString();
                return (AIRequestManager.apiKey || fromUrl || fromGlobal || "").trim();
            },

            generate: async (prompt, systemInstruction = "", options = {}) => {
                return GeminiAI.generate(prompt, systemInstruction, options);
            },

            generateJson: async (prompt, systemInstruction = "") => {
                return GeminiAI.generateJson(prompt, systemInstruction);
            }
        };

        // ============================================
        // ENHANCED SYSTEM PROMPT FOR SUPER AGENT
        // ============================================
        const SUPER_AGENT_SYSTEM_PROMPT = `
You are Poppy, the Super Agent  an advanced CX Intelligence AI with orchestration capabilities.

CORE CAPABILITIES:
1. Data Visualization: Generate charts (bar, line, pie) and tables directly in chat
2. Analysis Engine: Provide deep insights from uploaded data or mock samples
3. Content Creation: Draft reports, coaching plans, feedback, and Slack posts
4. Tool Orchestration: Execute multi-step workflows with progress tracking
5. Conversational Intelligence: Natural language understanding for all CX tasks

RESPONSE PRINCIPLES:
- When asked to "create a chart", generate JSON data and I will render it inline
- When asked to "analyze data", provide structured insights with headers
- When no data is uploaded, use realistic CX mock data (never say "insufficient data")
- For multi-step requests, break into workflow steps with progress updates
- Keep responses concise unless detailed analysis is requested

OUTPUT FORMATS:
- Charts: Wrap JSON in \`\`\`json ... \`\`\` with fields: name, value, (optional) target
- Tables: Wrap JSON in \`\`\`json ... \`\`\` with fields: headers[], rows[{...}]
- Analysis: Use markdown headers (## Key Insight, ## Patterns, ## Recommendations)
- Workflows: Use numbered steps with emojis for visual clarity

You never apologize for generating mock data - it's an expected feature for exploration.
`;

        const GeminiAI = {
            generate: async (prompt, systemInstruction = "", options = {}) => {
                const apiKey = AIRequestManager.getApiKey();
                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
                
                // Check if there's an image to analyze
                if (options.imageData) {
                    return GeminiAI.generateWithImage(prompt, options.imageData, systemInstruction);
                }
                const capabilityContext = AI_CAPABILITY_REGISTRY.getCapabilityPrompt();
                const finalSystem = (systemInstruction || SYSTEM_PROMPT) + " " + TL_PERSONA_PROMPT + " " + capabilityContext + " STRICT RULE: Use Markdown only. Do NOT return JSON. Use **bold** titles/headings (no #). Use - for bullet points. Be professional.";
                const memoryContext = options.useMemory ? AI_MEMORY_ENGINE.getMemoryPrompt(prompt) : "";
                const finalPrompt = memoryContext ? `${memoryContext}\n\n${prompt}` : prompt;
                const payload = { contents: [{ parts: [{ text: finalPrompt }] }], systemInstruction: { parts: [{ text: finalSystem }] } };
                const fetchWithRetry = async (retries = 3, delay = 800) => {
                    const shouldAutoProgress = !AIRequestManager._progressActive;
                    try {
                        if (shouldAutoProgress) AIRequestManager.emitProgress(35, 'Generating with AI...');
                        const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                        if (!response.ok) throw new Error(`API Error: ${response.status}`);
                        const data = await response.json();
                        if (shouldAutoProgress) AIRequestManager.emitProgress(90, 'Finalizing output...');
                        return data.candidates?.[0]?.content?.parts?.[0]?.text || "No insights generated.";
                    } catch (err) {
                        console.error("GeminiAI Generate Error:", err);
                        if (retries > 0) {
                            await new Promise(r => setTimeout(r, delay));
                            return fetchWithRetry(retries - 1, delay * 2);
                        }
                        return " AI Service currently unavailable. Please check API Key or Connection.";
                    } finally {
                        if (shouldAutoProgress) AIRequestManager.hideProgress();
                    }
                };
                return fetchWithRetry();
            },
            generateWithImage: async (prompt, imageDataUrl, systemInstruction = "") => {
                const apiKey = AIRequestManager.getApiKey();
                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

                const raw = String(imageDataUrl || '');
                const match = raw.match(/^data:(.*?);base64,(.*)$/);
                const mimeType = match?.[1] || 'image/png';
                const data = match?.[2] || raw.replace(/^data:.*?;base64,/, '');

                const capabilityContext = AI_CAPABILITY_REGISTRY.getCapabilityPrompt();
                const finalSystem = (systemInstruction || SYSTEM_PROMPT) + " " + TL_PERSONA_PROMPT + " " + capabilityContext + " STRICT RULE: Use Markdown only. Do NOT return JSON. Use **bold** titles/headings (no #). Use - for bullet points. Be professional.";

                const payload = {
                    contents: [{
                        parts: [
                            { text: prompt },
                            { inlineData: { mimeType, data } }
                        ]
                    }],
                    systemInstruction: { parts: [{ text: finalSystem }] }
                };

                const fetchWithRetry = async (retries = 3, delay = 800) => {
                    const shouldAutoProgress = !AIRequestManager._progressActive;
                    try {
                        if (shouldAutoProgress) AIRequestManager.emitProgress(35, 'Analyzing image with AI...');
                        const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                        if (!response.ok) throw new Error(`API Error: ${response.status}`);
                        const json = await response.json();
                        if (shouldAutoProgress) AIRequestManager.emitProgress(90, 'Finalizing output...');
                        return json.candidates?.[0]?.content?.parts?.[0]?.text || "No insights generated.";
                    } catch (err) {
                        console.error("GeminiAI Image Error:", err);
                        if (retries > 0) {
                            await new Promise(r => setTimeout(r, delay));
                            return fetchWithRetry(retries - 1, delay * 2);
                        }
                        return " AI Service currently unavailable. Please check API Key or Connection.";
                    } finally {
                        if (shouldAutoProgress) AIRequestManager.hideProgress();
                    }
                };
                return fetchWithRetry();
            },
            generateJson: async (prompt, schemaOrSystemInstruction = "") => {
                const apiKey = AIRequestManager.getApiKey();
                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
                const capabilityContext = AI_CAPABILITY_REGISTRY.getCapabilityPrompt();
                
                let systemInstruction = "Return ONLY valid JSON. No Markdown. No extra text.";
                let responseSchema = null;

                if (typeof schemaOrSystemInstruction === 'object') {
                    // It's a schema
                    systemInstruction = `Return valid JSON strictly following this schema: ${JSON.stringify(schemaOrSystemInstruction)}`;
                    // responseSchema = schemaOrSystemInstruction; // Not supported in this API version/config setup yet without more changes, so prompt injection is best.
                } else if (typeof schemaOrSystemInstruction === 'string' && schemaOrSystemInstruction.length > 0) {
                    systemInstruction = schemaOrSystemInstruction;
                }

                const finalSystem = `${systemInstruction} ${capabilityContext}`;
                const payload = { contents: [{ parts: [{ text: prompt }] }], systemInstruction: { parts: [{ text: finalSystem }] }, generationConfig: { responseMimeType: "application/json" } };
                const fetchWithRetry = async (retries = 3, delay = 800) => {
                    const shouldAutoProgress = !AIRequestManager._progressActive;
                    try {
                        if (shouldAutoProgress) AIRequestManager.emitProgress(35, 'Generating structured output...');
                        const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                        if (!response.ok) throw new Error(`API Error: ${response.status}`);
                        const data = await response.json();
                        if (shouldAutoProgress) AIRequestManager.emitProgress(90, 'Finalizing output...');
                        return data.candidates?.[0]?.content?.parts?.[0]?.text || "{}";
                    } catch (err) {
                        console.error("GeminiAI Json Error:", err);
                        if (retries > 0) {
                            await new Promise(r => setTimeout(r, delay));
                            return fetchWithRetry(retries - 1, delay * 2);
                        }
                        return "{}";
                    } finally {
                        if (shouldAutoProgress) AIRequestManager.hideProgress();
                    }
                };
                return fetchWithRetry();
            }
        };

        // --- ENHANCED AI CONTENT GENERATION ENGINE ---
        // ============================================
        // WORKFLOW ENGINE - Multi-Step & Bulk Operations
        // ============================================
        const WorkflowEngine = {
            // Define available workflow templates
            workflows: {
                coaching_plan: {
                    name: 'Coaching Planning',
                    description: 'Plan coaching for struggling agents',
                    steps: [
                        { id: 'identify', label: 'Identify struggling agents', action: 'identify_agents' },
                        { id: 'group', label: 'Group by failure themes', action: 'group_themes' },
                        { id: 'schedule', label: 'Suggest coaching schedule', action: 'suggest_schedule' },
                        { id: 'generate', label: 'Generate coaching plans', action: 'generate_plans' },
                        { id: 'summary', label: 'Present summary', action: 'present_summary' }
                    ]
                },
                weekly_meeting: {
                    name: 'Weekly Team Meeting',
                    description: 'Prepare for weekly team meeting',
                    steps: [
                        { id: 'agenda', label: 'Generate agenda', action: 'generate_agenda' },
                        { id: 'digest', label: 'Create weekly digest', action: 'create_digest' },
                        { id: 'talking', label: 'Prepare talking points', action: 'talking_points' },
                        { id: 'kudos', label: 'Identify team kudos', action: 'identify_kudos' }
                    ]
                },
                training_plan: {
                    name: 'Training Plan',
                    description: 'Create training plan for new hires',
                    steps: [
                        { id: 'analyze', label: 'Analyze common struggles', action: 'analyze_struggles' },
                        { id: 'curriculum', label: 'Build curriculum', action: 'build_curriculum' },
                        { id: 'materials', label: 'Suggest training materials', action: 'suggest_materials' },
                        { id: 'timeline', label: 'Create timeline', action: 'create_timeline' }
                    ]
                },
                monthly_analysis: {
                    name: 'Monthly Performance Analysis',
                    description: 'Analyze monthly performance',
                    steps: [
                        { id: 'trends', label: 'Identify trends', action: 'identify_trends' },
                        { id: 'anomalies', label: 'Detect anomalies', action: 'detect_anomalies' },
                        { id: 'recommend', label: 'Generate recommendations', action: 'generate_recommendations' },
                        { id: 'report', label: 'Compile report', action: 'compile_report' }
                    ]
                }
            },

            // Detect if query matches a workflow pattern
            detectWorkflow: (query) => {
                const lower = query.toLowerCase();
                
                // Coaching plan patterns
                if (/\b(plan coaching|coaching plan|struggling agents|agents need help)\b/.test(lower)) {
                    return 'coaching_plan';
                }
                // Weekly meeting patterns
                if (/\b(weekly meeting|team meeting|meeting prep|prepare for meeting|meeting agenda)\b/.test(lower)) {
                    return 'weekly_meeting';
                }
                // Training plan patterns
                if (/\b(training plan|new hire|onboarding|training curriculum)\b/.test(lower)) {
                    return 'training_plan';
                }
                // Monthly analysis patterns
                if (/\b(monthly analysis|this month's|performance analysis|month end|monthly report)\b/.test(lower)) {
                    return 'monthly_analysis';
                }
                
                return null;
            },

            // Detect bulk operation requests
            detectBulkOperation: (query) => {
                const lower = query.toLowerCase();
                const patterns = {
                    feedback: /\b(generate feedback|create feedback|feedback for)\b/,
                    coaching: /\b(create coaching|generate coaching|coaching for|coaching plans? for)\b/,
                    reminders: /\b(send reminders?|remind|pending acks?|acknowledgments?)\b/,
                    analyze: /\b(analyze all|analyze agents|review all|check all)\b/
                };
                
                for (const [type, pattern] of Object.entries(patterns)) {
                    if (pattern.test(lower)) return type;
                }
                return null;
            },

            // Parse agent selection from query
            parseAgentSelection: (query, allAgents, data) => {
                const lower = query.toLowerCase();
                const selection = {
                    type: 'none', // 'none', 'all', 'top', 'bottom', 'list', 'specific'
                    agents: [],
                    count: null,
                    criteria: null
                };

                // "all agents"
                if (/\b(all agents?|everyone|whole team|all team members?)\b/.test(lower)) {
                    selection.type = 'all';
                    selection.agents = allAgents;
                    return selection;
                }

                // "top N" or "bottom N"
                const topMatch = lower.match(/\btop\s+(\d+)\b/);
                const bottomMatch = lower.match(/\bbottom\s+(\d+)\b/);
                
                if (topMatch || bottomMatch) {
                    const count = parseInt(topMatch?.[1] || bottomMatch?.[1]);
                    const isTop = !!topMatch;
                    selection.type = isTop ? 'top' : 'bottom';
                    selection.count = count;
                    
                    // Determine criteria (struggling, performing, etc.)
                    if (/\bstruggling|failing|low|poor|bottom\b/.test(lower)) {
                        selection.criteria = 'struggling';
                    } else if (/\bperforming|high|best|top|excellent\b/.test(lower)) {
                        selection.criteria = 'performing';
                    } else {
                        selection.criteria = 'general';
                    }
                    
                    // Calculate agents based on criteria
                    selection.agents = WorkflowEngine.calculateTopAgents(data, count, isTop, selection.criteria);
                    return selection;
                }

                // Named agents (list)
                const namedAgents = allAgents.filter(agent => 
                    lower.includes(agent.toLowerCase())
                );
                if (namedAgents.length > 1) {
                    selection.type = 'list';
                    selection.agents = namedAgents;
                    return selection;
                }

                return selection;
            },

            // Calculate top/bottom agents based on criteria
            calculateTopAgents: (data, count, isTop, criteria) => {
                if (!data || data.length === 0) return [];
                
                const agentScores = {};
                data.forEach(record => {
                    const agent = record.Agent || record.agent;
                    if (!agent) return;
                    
                    const score = parseFloat(record['QC Score'] || record['Rating'] || record.score || 0);
                    if (!agentScores[agent]) {
                        agentScores[agent] = { total: 0, count: 0, scores: [] };
                    }
                    agentScores[agent].total += score;
                    agentScores[agent].count += 1;
                    agentScores[agent].scores.push(score);
                });

                // Calculate averages
                const agentList = Object.entries(agentScores).map(([agent, stats]) => ({
                    agent,
                    avg: stats.total / stats.count,
                    count: stats.count
                }));

                // Sort based on top/bottom
                agentList.sort((a, b) => isTop ? b.avg - a.avg : a.avg - b.avg);
                
                return agentList.slice(0, count).map(a => a.agent);
            },

            // Execute a workflow step
            executeStep: async (workflowType, stepIndex, context, data) => {
                const workflow = WorkflowEngine.workflows[workflowType];
                if (!workflow || stepIndex >= workflow.steps.length) return null;
                
                const step = workflow.steps[stepIndex];
                const { action } = step;
                
                // Simulate step execution with delay
                await new Promise(r => setTimeout(r, 800));
                
                // Generate step result based on action type
                switch (action) {
                    case 'identify_agents':
                        return WorkflowEngine.generateIdentifyAgentsResult(data, context);
                    case 'group_themes':
                        return WorkflowEngine.generateGroupThemesResult(data, context);
                    case 'suggest_schedule':
                        return WorkflowEngine.generateScheduleResult(data, context);
                    case 'generate_plans':
                        return WorkflowEngine.generatePlansResult(data, context);
                    case 'present_summary':
                        return WorkflowEngine.generateSummaryResult(data, context);
                    case 'generate_agenda':
                        return WorkflowEngine.generateAgendaResult(data, context);
                    case 'create_digest':
                        return WorkflowEngine.generateDigestResult(data, context);
                    case 'talking_points':
                        return WorkflowEngine.generateTalkingPointsResult(data, context);
                    case 'identify_kudos':
                        return WorkflowEngine.generateKudosResult(data, context);
                    case 'analyze_struggles':
                        return WorkflowEngine.generateStrugglesResult(data, context);
                    case 'build_curriculum':
                        return WorkflowEngine.generateCurriculumResult(data, context);
                    case 'identify_trends':
                        return WorkflowEngine.generateTrendsResult(data, context);
                    case 'detect_anomalies':
                        return WorkflowEngine.generateAnomaliesResult(data, context);
                    case 'generate_recommendations':
                        return WorkflowEngine.generateRecommendationsResult(data, context);
                    default:
                        return { type: 'text', content: `? ${step.label}` };
                }
            },

            // Generate result for identify agents step
            generateIdentifyAgentsResult: (data, context) => {
                const agents = context.selectedAgents || [];
                const strugglingCount = Math.min(agents.length, 5);
                return {
                    type: 'workflow_step',
                    step: 'identify',
                    content: `**Step 1: Identified ${strugglingCount} struggling agents**\n\n` +
                        `Agents with fail rate > 20%:\n` +
                        agents.slice(0, 5).map((a, i) => `${i + 1}. ${a}`).join('\n'),
                    data: { agents: agents.slice(0, 5) }
                };
            },

            // Generate result for group themes step
            generateGroupThemesResult: (data, context) => {
                const themes = [
                    { name: 'Documentation Issues', count: 3, agents: [] },
                    { name: 'Process Knowledge Gaps', count: 2, agents: [] },
                    { name: 'Communication Skills', count: 2, agents: [] }
                ];
                return {
                    type: 'workflow_step',
                    step: 'group',
                    content: `**Step 2: Grouped by Common Failure Themes**\n\n` +
                        themes.map(t => ` **${t.name}**: ${t.count} agents`).join('\n'),
                    data: { themes }
                };
            },

            // Generate result for schedule step
            generateScheduleResult: (data, context) => {
                return {
                    type: 'workflow_step',
                    step: 'schedule',
                    content: `**Step 3: Suggested Coaching Schedule**\n\n` +
                        ` **Week 1**: Documentation training (3 agents)\n` +
                        ` **Week 2**: Process workshops (2 agents)\n` +
                        ` **Week 3**: Communication skills (2 agents)`,
                    data: { schedule: [] }
                };
            },

            // Generate result for plans step
            generatePlansResult: (data, context) => {
                return {
                    type: 'workflow_step',
                    step: 'generate',
                    content: `**Step 4: Generated Coaching Plans**\n\n` +
                        `? Created 7 personalized coaching plans\n` +
                        `? Assigned mentors to each agent\n` +
                        `? Set milestone checkpoints`,
                    data: { plansGenerated: 7 }
                };
            },

            // Generate final summary
            generateSummaryResult: (data, context) => {
                return {
                    type: 'workflow_summary',
                    content: `##  Coaching Plan Summary\n\n` +
                        `**Total Agents**: 7 struggling agents identified\n` +
                        `**Group Sessions**: 3 themes identified\n` +
                        `**Timeline**: 3 weeks\n` +
                        `**Plans Generated**: 7 personalized plans\n\n` +
                        `**Action Items:**\n` +
                        ` Schedule Week 1 documentation training\n` +
                        ` Assign mentors by EOD\n` +
                        ` Set up progress tracking dashboard\n` +
                        ` Weekly check-ins scheduled`,
                    data: { completed: true }
                };
            },

            // Weekly meeting workflow steps
            generateAgendaResult: (data, context) => {
                return {
                    type: 'workflow_step',
                    step: 'agenda',
                    content: `**Step 1: Meeting Agenda Generated**\n\n` +
                        `1. Wins of the Week (5 min)\n` +
                        `2. Metrics Review (10 min)\n` +
                        `3. Process Updates (5 min)\n` +
                        `4. Team Challenges (10 min)\n` +
                        `5. Action Items (5 min)`,
                    data: {}
                };
            },

            generateDigestResult: (data, context) => {
                return {
                    type: 'workflow_step',
                    step: 'digest',
                    content: `**Step 2: Weekly Digest Created**\n\n` +
                        ` NPS improved by 3% this week\n` +
                        ` 2 agents achieved perfect scores\n` +
                        ` Average response time: 2.1 min\n` +
                        ` 15 tickets resolved above standard`,
                    data: {}
                };
            },

            generateTalkingPointsResult: (data, context) => {
                return {
                    type: 'workflow_step',
                    step: 'talking',
                    content: `**Step 3: Key Talking Points**\n\n` +
                        ` Celebrate the NPS improvement\n` +
                        ` Address the documentation gaps\n` +
                        ` Introduce new quality standards\n` +
                        ` Recognize top performers`,
                    data: {}
                };
            },

            generateKudosResult: (data, context) => {
                return {
                    type: 'workflow_step',
                    step: 'kudos',
                    content: `**Step 4: Team Kudos Identified**\n\n` +
                        ` Sarah - Handled escalated case excellently\n` +
                        ` Mike - Mentored 2 new team members\n` +
                        ` Team - Achieved highest weekly CSAT`,
                    data: {}
                };
            },

            // Training plan steps
            generateStrugglesResult: (data, context) => {
                return {
                    type: 'workflow_step',
                    step: 'analyze',
                    content: `**Step 1: Common Struggles Analyzed**\n\n` +
                        `Top 3 areas new hires struggle with:\n` +
                        `1. Ticket categorization (45% of errors)\n` +
                        `2. Response templates usage (30%)\n` +
                        `3. Escalation procedures (25%)`,
                    data: {}
                };
            },

            generateCurriculumResult: (data, context) => {
                return {
                    type: 'workflow_step',
                    step: 'curriculum',
                    content: `**Step 2: Training Curriculum Built**\n\n` +
                        `**Week 1**: Foundations\n` +
                        `**Week 2**: Hands-on Practice\n` +
                        `**Week 3**: Advanced Scenarios\n` +
                        `**Week 4**: Assessment & Certification`,
                    data: {}
                };
            },

            // Monthly analysis steps
            generateTrendsResult: (data, context) => {
                return {
                    type: 'workflow_step',
                    step: 'trends',
                    content: `**Step 1: Trends Identified**\n\n` +
                        ` Positive: NPS trending up (+5%)\n` +
                        ` Positive: First response time improved\n` +
                        ` Negative: Escalation rate increased slightly\n` +
                        ` Stable: QC scores maintained`,
                    data: {}
                };
            },

            generateAnomaliesResult: (data, context) => {
                return {
                    type: 'workflow_step',
                    step: 'anomalies',
                    content: `**Step 2: Anomalies Detected**\n\n` +
                        ` Unusual spike in refund requests (Week 3)\n` +
                        ` 2 agents with sudden score drops\n` +
                        ` Weekend ticket volume 20% above normal`,
                    data: {}
                };
            },

            generateRecommendationsResult: (data, context) => {
                return {
                    type: 'workflow_step',
                    step: 'recommend',
                    content: `**Step 3: Recommendations Generated**\n\n` +
                        `1. Investigate refund request patterns\n` +
                        `2. Schedule 1:1s with affected agents\n` +
                        `3. Review weekend staffing levels\n` +
                        `4. Update knowledge base articles`,
                    data: {}
                };
            },

            // Execute bulk operation
            executeBulkOperation: async (operationType, selection, data, onProgress) => {
                const results = [];
                const agents = selection.agents || [];
                const total = agents.length;
                
                for (let i = 0; i < agents.length; i++) {
                    const agent = agents[i];
                    const progress = Math.round(((i + 1) / total) * 100);
                    
                    if (onProgress) {
                        onProgress({
                            current: i + 1,
                            total,
                            agent,
                            percent: progress
                        });
                    }
                    
                    // Simulate operation
                    await new Promise(r => setTimeout(r, 600));
                    
                    let result;
                    switch (operationType) {
                        case 'feedback':
                            result = { agent, status: 'success', type: 'feedback', content: `Generated feedback for ${agent}` };
                            break;
                        case 'coaching':
                            result = { agent, status: 'success', type: 'coaching', content: `Created coaching plan for ${agent}` };
                            break;
                        case 'reminders':
                            result = { agent, status: 'success', type: 'reminder', content: `Sent reminder to ${agent}` };
                            break;
                        case 'analyze':
                            result = { agent, status: 'success', type: 'analysis', content: `Analyzed ${agent}'s performance` };
                            break;
                        default:
                            result = { agent, status: 'success', type: 'generic', content: `Processed ${agent}` };
                    }
                    
                    results.push(result);
                }
                
                return results;
            },

            // Generate bulk operation summary
            generateBulkSummary: (operationType, results) => {
                const successCount = results.filter(r => r.status === 'success').length;
                const failedCount = results.filter(r => r.status === 'failed').length;
                
                const titles = {
                    feedback: 'Feedback Generation',
                    coaching: 'Coaching Plan Creation',
                    reminders: 'Reminder Sending',
                    analyze: 'Performance Analysis'
                };
                
                return {
                    type: 'bulk_summary',
                    content: `##  ${titles[operationType] || 'Bulk Operation'} Complete\n\n` +
                        `**Total Processed**: ${results.length}\n` +
                        `**Successful**: ${successCount} ?\n` +
                        `**Failed**: ${failedCount} ${failedCount > 0 ? '?' : ''}\n\n` +
                        `**Processed Agents:**\n` +
                        results.map(r => ` ${r.agent} - ${r.status === 'success' ? '' : ''}`).join('\n'),
                    data: { successCount, failedCount, total: results.length }
                };
            }
        };

        // ============================================
        // SUPER AGENT SYSTEM - Enhanced Intent Detection
        // ============================================
        const SuperAgentSystem = {
            intentCache: new Map(),

            detectIntent_Legacy: (query, context = {}) => {
                const lowerQuery = query.toLowerCase();
                const tokens = lowerQuery.split(/\s+/);
                const { hasData, currentView, selectedAgent } = context;
                
                // Priority 1: Explicit Analysis Requests
                if (/analyze\s+(this|the)\s+(chart|table|data)/i.test(query)) {
                    return { type: 'meta_analysis', target: SuperAgentSystem.extractTargetFromContext(context) };
                }
                
                // Priority 2: Chart/Visualization Intent
                if (/(trend|pattern|visual|chart|graph)/i.test(lowerQuery)) {
                    if (hasData) {
                        return { type: 'chart', subtype: SuperAgentSystem.inferChartType(query) };
                    } else {
                        return { type: 'chart', fallbackToMock: true };
                    }
                }
                
                // Priority 3: Comparison Intent
                const compareMatch = lowerQuery.match(/compare\s+(.*)\s+(with|vs|versus|and)\s+(.*)/i);
                if (compareMatch) {
                    const agents = SuperAgentSystem.extractAgentNames(query, context.allAgents || []);
                    return { type: 'comparison_table', agents };
                }
                
                // Priority 4: Action/Coaching Intent
                if (/(coach|help|improve)/i.test(lowerQuery)) {
                    if (selectedAgent) {
                        return { type: 'coaching_plan', agent: selectedAgent, focus: SuperAgentSystem.extractFocus(query) };
                    } else {
                        return { type: 'coaching_plan', focus: 'general' };
                    }
                }
                
                // Priority 5: Summary/Report Intent
                if (/(summary|report|overview)/i.test(lowerQuery)) {
                    return { type: 'executive_summary', scope: SuperAgentSystem.determineScope(currentView, query) };
                }
                
                // Priority 6: Workflow Orchestration
                const workflowMatch = lowerQuery.match(/(create|make|generate)\s+a?\s+(.*)\s+workflow/i);
                if (workflowMatch) {
                    const workflowType = workflowMatch[2];
                    return { type: 'workflow', workflowType };
                }
                
                // Default: Conversational Response
                return { type: 'conversation' };
            },

            detectIntent: async (query, context = {}) => {
                const normalizedQuery = query.toLowerCase().trim();
                
                // Step 8: Cache
                if (SuperAgentSystem.intentCache.has(normalizedQuery)) {
                    const cached = SuperAgentSystem.intentCache.get(normalizedQuery);
                    if (Date.now() - cached.timestamp < 300000) { // 5 min
                        return cached.data;
                    }
                }

                const legacyResult = SuperAgentSystem.detectIntent_Legacy(query, context);

                try {
                    const prompt = `You are an intent classifier for a CX analytics platform. Given the user query and context, return ONLY a JSON object with: {type: string, confidence: number, entities: {metrics: [], agents: [], timeframe: string}, reasoning: string}.
                    
Allowed types: meta_analysis, chart, comparison_table, coaching_plan, executive_summary, workflow, conversation.

User query: "${query}"
Context: ${JSON.stringify({ hasData: context.hasData, currentView: context.currentView, selectedAgent: context.selectedAgent })}.

Respond with JSON only.`;

                    const systemInstruction = "You are a strict JSON classifier. Return only valid JSON with no markdown formatting.";
                    
                    // Step 5: Call GeminiAI.generateJson
                    let llmResultRaw = await GeminiAI.generateJson(prompt, systemInstruction);
                    let llmResult;
                    
                    try {
                        llmResult = typeof llmResultRaw === 'string' ? JSON.parse(llmResultRaw) : llmResultRaw;
                    } catch (e) {
                        console.warn("LLM Intent JSON Parse Failed", e);
                        return legacyResult;
                    }
                    
                    // Step 6: Validation
                    const allowedTypes = ['meta_analysis', 'chart', 'comparison_table', 'coaching_plan', 'executive_summary', 'workflow', 'conversation'];
                    if (!allowedTypes.includes(llmResult.type) || typeof llmResult.confidence !== 'number') {
                         return legacyResult;
                    }
                    
                    // Step 7: Confidence Threshold
                    if (llmResult.confidence < 70) {
                        if (legacyResult.type !== 'conversation' && legacyResult.type !== llmResult.type) {
                            return legacyResult;
                        }
                    }
                    
                    // Step 8: Cache
                    SuperAgentSystem.intentCache.set(normalizedQuery, { timestamp: Date.now(), data: llmResult });
                    
                    // Step 10: Telemetry
                    const telemetry = JSON.parse(sessionStorage.getItem('intent_telemetry') || '{"llm": 0, "legacy": 0}');
                    telemetry.llm++;
                    sessionStorage.setItem('intent_telemetry', JSON.stringify(telemetry));
                    
                    return llmResult;

                } catch (err) {
                    console.error("Intent Detection Failed", err);
                    // Step 10: Telemetry
                    const telemetry = JSON.parse(sessionStorage.getItem('intent_telemetry') || '{"llm": 0, "legacy": 0}');
                    telemetry.legacy++;
                    sessionStorage.setItem('intent_telemetry', JSON.stringify(telemetry));
                    return legacyResult;
                }
            },
            
            parseStructuredResponse: (aiResponse) => {
                let processedResponse = aiResponse;
                const sideEffects = [];

                // 1. JSON Charts extraction
                const jsonMatch = aiResponse.match(/```json\s*({[\s\S]*?})\s*```/);
                if (jsonMatch) {
                    try {
                        const data = JSON.parse(jsonMatch[1]);
                        if (data.contentType === 'chart') {
                             const id = `chat-chart-${Date.now()}-${Math.random().toString(36).slice(2)}`;
                             const placeholder = `<div id="${id}" class="w-full h-64 my-3 bg-slate-50 rounded-lg p-4"><div class="chart-placeholder flex items-center justify-center h-full text-slate-400">Loading Chart...</div></div>`;
                             processedResponse = processedResponse.replace(jsonMatch[0], placeholder);
                             
                             sideEffects.push(() => {
                                 setTimeout(() => {
                                     SuperAgentSystem.renderChartInContainer(data, id);
                                 }, 100);
                             });
                        }
                    } catch (e) {
                        console.error("Failed to parse chart JSON", e);
                    }
                }
                
                // 2. Markdown Tables
                const tableMatch = processedResponse.match(/\|(.+)\|\n\|([-:| ]+)\|\n((?:\|.*\|\n?)+)/);
                if (tableMatch) {
                    try {
                        const headers = tableMatch[1].split('|').map(h => h.trim()).filter(Boolean);
                        const rowsRaw = tableMatch[3].trim().split('\n');
                        const rows = rowsRaw.map(rowStr => {
                            const cells = rowStr.split('|').map(c => c.trim()).filter(c => c !== '');
                            const rowObj = {};
                            headers.forEach((h, i) => rowObj[h] = cells[i] || '');
                            return rowObj;
                        });
                        
                        const tableData = { headers, rows };
                        // Convert to HTML
                        const tableHTML = `
                            <div class="overflow-x-auto my-3 rounded-lg border border-slate-200">
                                <table class="w-full text-xs">
                                    <thead class="bg-slate-50">
                                        <tr>${headers.map(h => `<th class="px-3 py-2 text-left font-semibold text-slate-700">${h}</th>`).join('')}</tr>
                                    </thead>
                                    <tbody>
                                        ${rows.map(row => `
                                            <tr class="border-t border-slate-100 hover:bg-slate-50">
                                                ${headers.map(h => `<td class="px-3 py-2">${row[h] || '-'}</td>`).join('')}
                                            </tr>
                                        `).join('')}
                                    </tbody>
                                </table>
                            </div>
                        `;
                        
                        processedResponse = processedResponse.replace(tableMatch[0], tableHTML);
                    } catch (e) {
                        console.error("Failed to parse markdown table", e);
                    }
                }

                return { text: processedResponse, sideEffects };
            },
            
            renderChartInContainer: (chartData, containerId) => {
                const container = document.getElementById(containerId);
                if (!container) return;
                
                const chartType = chartData.chartType || 'bar';
                
                try {
                    // Use React to render chart
                    const chartElement = React.createElement(ResponsiveContainer, { width: '100%', height: '100%' },
                        chartType === 'bar' 
                            ? React.createElement(BarChart, { data: chartData.data },
                                React.createElement(CartesianGrid, { strokeDasharray: '3 3' }),
                                React.createElement(XAxis, { dataKey: 'name', tick: { fontSize: 11 } }),
                                React.createElement(YAxis, { tick: { fontSize: 11 } }),
                                React.createElement(Tooltip),
                                React.createElement(Bar, { dataKey: 'value', fill: '#3b82f6' })
                              )
                            : React.createElement(LineChart, { data: chartData.data },
                                React.createElement(CartesianGrid, { strokeDasharray: '3 3' }),
                                React.createElement(XAxis, { dataKey: 'name', tick: { fontSize: 11 } }),
                                React.createElement(YAxis, { tick: { fontSize: 11 } }),
                                React.createElement(Tooltip),
                                React.createElement(Line, { type: 'monotone', dataKey: 'value', stroke: '#8b5cf6', strokeWidth: 2 })
                              )
                    );
                    
                    if (window.ReactDOM && window.ReactDOM.render) {
                        window.ReactDOM.render(chartElement, container);
                    } else if (window.ReactDOM && window.ReactDOM.createRoot) {
                        const root = window.ReactDOM.createRoot(container);
                        root.render(chartElement);
                    }
                } catch (e) {
                    container.innerHTML = `<div class="text-red-500 text-xs p-2">Chart Error: ${e.message}</div>`;
                }
            },
            
            extractTargetFromContext: (context) => {
                if (context.activeElement) return context.activeElement;
                if (context.lastChart) return { type: 'chart', data: context.lastChart };
                if (context.lastTable) return { type: 'table', data: context.lastTable };
                return null;
            },
            
            inferChartType: (query) => {
                const lower = query.toLowerCase();
                if (/(trend|over time|history)/i.test(lower)) return 'line';
                if (/(compare|distribution|breakdown)/i.test(lower)) return 'bar';
                if (/(pie|percentage|share|proportion)/i.test(lower)) return 'pie';
                return 'bar';
            },
            
            extractAgentNames: (query, allAgents) => {
                const lower = query.toLowerCase();
                return allAgents.filter(agent => lower.includes(agent.toLowerCase()));
            },
            
            extractFocus: (query) => {
                const focuses = ['communication', 'efficiency', 'quality', 'soft skills', 'technical'];
                const lower = query.toLowerCase();
                return focuses.find(f => lower.includes(f)) || 'general';
            },
            
            determineScope: (currentView, query) => {
                if (/team|all|everyone/i.test(query)) return 'team';
                if (/agent|individual/i.test(query)) return 'agent';
                return currentView || 'unified';
            },
            
            // Render chart inside chat bubble
            renderChartInChat: (chartData, chatMessageId) => {
                const chartContainerId = `chat-chart-${Date.now()}-${Math.random().toString(36).slice(2)}`;
                const chartHTML = `
                    <div id="${chartContainerId}" class="w-full h-64 my-3 bg-slate-50 rounded-lg p-4">
                        <div class="chart-placeholder">Loading chart...</div>
                    </div>
                `;
                
                const messageElement = document.getElementById(chatMessageId);
                if (!messageElement) return;
                
                const contentDiv = messageElement.querySelector('.ai-response-content');
                if (!contentDiv) return;
                
                contentDiv.insertAdjacentHTML('beforeend', chartHTML);
                
                setTimeout(() => {
                    const container = document.getElementById(chartContainerId);
                    if (!container) return;
                    
                    const chartType = chartData.chartType || 'bar';
                    
                    // Use React to render chart
                    const chartElement = React.createElement(ResponsiveContainer, { width: '100%', height: '100%' },
                        chartType === 'bar' 
                            ? React.createElement(BarChart, { data: chartData.data },
                                React.createElement(CartesianGrid, { strokeDasharray: '3 3' }),
                                React.createElement(XAxis, { dataKey: 'name', tick: { fontSize: 11 } }),
                                React.createElement(YAxis, { tick: { fontSize: 11 } }),
                                React.createElement(Tooltip),
                                React.createElement(Bar, { dataKey: 'value', fill: '#3b82f6' })
                              )
                            : React.createElement(LineChart, { data: chartData.data },
                                React.createElement(CartesianGrid, { strokeDasharray: '3 3' }),
                                React.createElement(XAxis, { dataKey: 'name', tick: { fontSize: 11 } }),
                                React.createElement(YAxis, { tick: { fontSize: 11 } }),
                                React.createElement(Tooltip),
                                React.createElement(Line, { type: 'monotone', dataKey: 'value', stroke: '#8b5cf6', strokeWidth: 2 })
                              )
                    );
                    
                    if (window.ReactDOM && window.ReactDOM.render) {
                        window.ReactDOM.render(chartElement, container);
                    }
                }, 100);
                
                return chartContainerId;
            },
            
            // Render table inside chat bubble
            renderTableInChat: (tableData, chatMessageId) => {
                const { headers, rows } = tableData;
                
                const tableHTML = `
                    <div class="overflow-x-auto my-3 rounded-lg border border-slate-200">
                        <table class="w-full text-xs">
                            <thead class="bg-slate-50 sticky top-0">
                                <tr>
                                    ${headers.map(h => `<th class="px-3 py-2 text-left font-semibold text-slate-700">${h}</th>`).join('')}
                                </tr>
                            </thead>
                            <tbody>
                                ${rows.map(row => `
                                    <tr class="border-t border-slate-100 hover:bg-slate-50">
                                        ${headers.map(h => `<td class="px-3 py-2">${row[h] || '-'}</td>`).join('')}
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
                
                const messageElement = document.getElementById(chatMessageId);
                if (!messageElement) return;
                
                const contentDiv = messageElement.querySelector('.ai-response-content');
                if (!contentDiv) return;
                
                contentDiv.insertAdjacentHTML('beforeend', tableHTML);
            },
            
            // Generate analysis summary with insights
            generateAnalysisSummary: async (data, elementType, query) => {
                // Apply Global Filters
                const cleanData = data ? data.filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d)) : [];
                
                const context = {
                    dataPoints: cleanData.length,
                    elementType: elementType,
                    dataPreview: cleanData.slice(0, 10),
                    userQuery: query
                };
                
                const systemPrompt = `You are analyzing a ${elementType} with ${context.dataPoints} data points.
                
Your analysis should include:
1. KEY INSIGHT: One sentence summary of the most important finding
2. PATTERNS: 2-3 notable trends or patterns
3. ANOMALIES: Any outliers or unusual data points
4. RECOMMENDATIONS: 1-2 actionable next steps

Format your response in clear sections with headers.
Be concise but insightful.`;
                
                try {
                    const aiResponse = await GeminiAI.generate(
                        `Analyze this data: ${JSON.stringify(context.dataPreview)}. User asks: ${query}`,
                        systemPrompt
                    );
                    return aiResponse;
                } catch (e) {
                    return 'Unable to generate analysis at this time.';
                }
            }
        };

        // ============================================
        // CORE AGENT ENGINE (PHASE 6.5)
        // ============================================
        const AgenticEngine = {
            execute: async ({ systemInstruction, prompt, schema, rowData }) => {
                const schemaString = JSON.stringify(schema, null, 2);
                const enhancedSystemInstruction = `${systemInstruction}\n\nSTRICT JSON OUTPUT REQUIRED.\nYou must output ONLY valid JSON matching this schema:\n${schemaString}\n\nDo not include any Markdown formatting, code blocks, or explanatory text.`;
                const fullPrompt = `Context Data: ${JSON.stringify(rowData || {})}\n\n${prompt}`;
                
                try {
                    // Use GeminiAI.generateJson if available to leverage JSON mode
                    const responseText = await GeminiAI.generateJson(fullPrompt, enhancedSystemInstruction);
                    
                    let result;
                    try {
                        result = JSON.parse(responseText);
                    } catch (e) {
                        // Strip markdown if present and retry
                        const cleanText = responseText.replace(/```json/g, '').replace(/```/g, '').trim();
                        result = JSON.parse(cleanText);
                    }
                    
                    return result;
                } catch (e) {
                    console.error("AgenticEngine Execution Failed:", e);
                    return {
                        error: true,
                        message: e.message,
                        fallback: "Agentic execution failed."
                    };
                }
            }
        };

        // ============================================
        // ENHANCED AI CONTENT ENGINE
        // ============================================
        const AIContentEngine = {
            // Detect content type from user query
            detectContentType: (query) => {
                const lowerQuery = query.toLowerCase();
                
                // Check for workflow patterns first
                const workflowType = WorkflowEngine.detectWorkflow(query);
                if (workflowType) {
                    return `workflow:${workflowType}`;
                }
                
                // Check for bulk operation patterns
                const bulkType = WorkflowEngine.detectBulkOperation(query);
                if (bulkType) {
                    return `bulk:${bulkType}`;
                }
                
                // Content type patterns - Enhanced for table builder
                const patterns = {
                    slack: /\b(slack|post|message|announce|congratulate|welcome|team update)\b/,
                    chart: /\b(chart|graph|plot|visualization|trend|compare|bar chart|line chart)\b/,
                    table: /\b(table|list|ranking|rank|leaderboard|data table|create table|show table|compare.*table|top\s+\d+|bottom\s+\d+)\b/,
                    pdf: /\b(pdf|export|document|report|save as|download as)\b/,
                    executive_summary: /\b(executive summary|summary|overview|high.level|strategic)\b/,
                    coaching_plan: /\b(coaching plan|development plan|improvement plan|action plan)\b/,
                    snapshot: /\b(snapshot|capture|screenshot|dashboard image|capture dashboard|share view)\b/,
                    feedback_1on1: /\b(1:1|one.on.one|feedback|1-on-1|personal feedback)\b/,
                    kpi_grid: /\b(kpi|metrics|indicators|scorecard|dashboard)\b/,
                    prediction: /\b(predict|prediction|forecast|next week|future performance|at risk|risk agents?|trending down|will.*perform|expected.*score)\b/
                };
                
                for (const [type, pattern] of Object.entries(patterns)) {
                    if (pattern.test(lowerQuery)) return type;
                }
                return 'text';
            },
            
            // Parse AI response for structured content
            parseResponse: (response) => {
                // Try to extract JSON block
                const jsonMatch = response.match(/```json\s*([\s\S]*?)```/) || 
                                   response.match(/\{[\s\S]*"contentType"[\s\S]*\}/);
                
                if (jsonMatch) {
                    try {
                        const jsonStr = jsonMatch[1] || jsonMatch[0];
                        const parsed = JSON.parse(jsonStr.replace(/```json/g, '').replace(/```/g, '').trim());
                        return {
                            contentType: parsed.contentType || 'text',
                            title: parsed.title || 'Generated Content',
                            data: parsed.data || {},
                            content: parsed.content || response.replace(/```json[\s\S]*?```/g, '').trim()
                        };
                    } catch (e) {
                        console.warn('JSON parse failed, treating as text:', e);
                    }
                }
                
                // Return as text type if no JSON found
                return {
                    contentType: 'text',
                    title: 'Response',
                    data: {},
                    content: response
                };
            },
            
            // Generate mock data for charts/tables when no real data available
            generateMockData: (contentType, context = {}) => {
                const mockData = {
                    chart: [
                        { name: 'Week 1', value: 85, target: 80 },
                        { name: 'Week 2', value: 88, target: 80 },
                        { name: 'Week 3', value: 82, target: 80 },
                        { name: 'Week 4', value: 91, target: 80 },
                    ],
                    table: {
                        headers: ['Agent', 'Score', 'Trend', 'Status'],
                        rows: [
                            { Agent: 'Alex Johnson', Score: '92%', Trend: ' +5%', Status: 'Excellent' },
                            { Agent: 'Sarah Chen', Score: '88%', Trend: ' +3%', Status: 'Good' },
                            { Agent: 'Mike Ross', Score: '85%', Trend: ' 0%', Status: 'Good' },
                            { Agent: 'Emily Davis', Score: '79%', Trend: ' -2%', Status: 'Needs Improvement' },
                            { Agent: 'Chris Wilson', Score: '94%', Trend: ' +7%', Status: 'Excellent' },
                        ]
                    },
                    kpi_grid: [
                        { title: 'NPS Score', value: '87%', icon: 'star', color: 'green', trend: '+5%' },
                        { title: 'QC Score', value: '91%', icon: 'shield', color: 'blue', trend: '+2%' },
                        { title: 'Response Time', value: '2.3m', icon: 'clock', color: 'purple', trend: '-10%' },
                        { title: 'Satisfaction', value: '4.8/5', icon: 'heart', color: 'rose', trend: '+0.3' },
                    ]
                };
                
                return mockData[contentType] || null;
            },
            
            // Generate content based on type
            generate: async (contentType, query, data = {}, options = {}) => {
                const hasData = data && (Array.isArray(data) ? data.length > 0 : Object.keys(data).length > 0);
                
                switch (contentType) {
                    case 'slack':
                        return AIContentEngine.generateSlackPost(query, data, hasData);
                    case 'chart':
                        return AIContentEngine.generateChartData(query, data, hasData);
                    case 'table':
                        return AIContentEngine.generateTableData(query, data, hasData);
                    case 'pdf':
                        return AIContentEngine.generatePDFContent(query, data, hasData);
                    case 'executive_summary':
                        return AIContentEngine.generateExecutiveSummary(query, data, hasData);
                    case 'coaching_plan':
                        return AIContentEngine.generateCoachingPlan(query, data, hasData);
                    case 'feedback_1on1':
                        return AIContentEngine.generate1on1Feedback(query, data, hasData);
                    case 'kpi_grid':
                        return AIContentEngine.generateKPIGrid(query, data, hasData);
                    case 'snapshot':
                        return AIContentEngine.generateSnapshot(query, data, hasData);
                    case 'prediction':
                        return AIContentEngine.generatePrediction(query, data, hasData, options);
                    default:
                        return { contentType: 'text', content: null };
                }
            },
            
            // Generate Slack post
            generateSlackPost: async (query, data, hasData) => {
                const cleanData = hasData ? data.filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d)) : [];
                const lowerQuery = query.toLowerCase();
                let prompt = '';
                const basePrompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\n`;
                
                if (lowerQuery.includes('welcome') || lowerQuery.includes('new teammate') || lowerQuery.includes('joining')) {
                    prompt = basePrompt + `Write a warm, welcoming Slack post for a new team member joining the CX team.
                    
Context: ${query}

STRICT RULES:
1. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.
2. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).
3. NO hashtags (#).
4. Use emojis sparingly (max 2 per line).
5. Do NOT use the word "Bold", "Underline", or "B" as text.
6. Keep it 4-6 sentences
7. **Bullet Points:** ALWAYS use standard Markdown bullets (-).
8. **Strict Keywords:** Use ONLY Pillar names and Sub-metric names from the data.

Return ONLY the Slack post text, no explanations.`;
                } else if (lowerQuery.includes('congratulate') || lowerQuery.includes('celebrate')) {
                    prompt = basePrompt + `Write a congratulatory Slack post celebrating team achievements.

Context: ${query}
${hasData ? `Data: ${JSON.stringify(cleanData.slice(0, 5))}` : ''}

STRICT RULES:
1. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.
2. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).
3. NO hashtags (#).
4. Use emojis sparingly (max 2 per line).
5. Do NOT use the word "Bold", "Underline", or "B" as text.
6. Keep it 4-5 sentences
7. **Bullet Points:** ALWAYS use standard Markdown bullets (-).
8. **Strict Keywords:** Use ONLY Pillar names and Sub-metric names from the data.

Return ONLY the Slack post text, no explanations.`;
                } else {
                    prompt = basePrompt + `Write a professional Slack post for the team.

Context: ${query}
${hasData ? `Data: ${JSON.stringify(cleanData.slice(0, 5))}` : 'No specific data - create a general team update'}

STRICT RULES:
1. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.
2. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).
3. NO hashtags (#).
4. Use emojis sparingly (max 2 per line).
5. Do NOT use the word "Bold", "Underline", or "B" as text.
6. Keep it under 150 words
7. **Bullet Points:** ALWAYS use standard Markdown bullets (-).
8. **Strict Keywords:** Use ONLY Pillar names and Sub-metric names from the data.

Return ONLY the Slack post text, no explanations.`;
                }
                
                try {
                    const result = await AIRequestManager.generate(prompt);
                    return {
                        contentType: 'slack',
                        title: 'Slack Post',
                        content: formatSlackMessage(result, 'SlackPost'),
                        data: { text: result }
                    };
                } catch (e) {
                    return {
                        contentType: 'slack',
                        title: 'Slack Post',
                        content: ' **Slack Post**\n\nUnable to generate post. Please try again.',
                        data: { text: '' }
                    };
                }
            },
            
            // Generate chart data
            generateChartData: (query, data, hasData) => {
                const cleanData = hasData ? data.filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d)) : [];
                let chartData = [];
                let chartType = 'bar';
                let title = 'Chart';
                
                if (hasData && Array.isArray(cleanData) && cleanData.length > 0) {
                    // Use real data
                    const dataKey = query.toLowerCase().includes('qc') ? 'QC Score' : 
                                   query.toLowerCase().includes('rating') ? 'Rating' : 'value';
                    chartData = cleanData.slice(0, 15).map((d, i) => ({
                        name: d.Agent || d.Date || `Item ${i + 1}`,
                        value: parseFloat(d[dataKey] || d['QC Score'] || d['Rating'] || Math.floor(Math.random() * 30) + 70)
                    }));
                    title = dataKey === 'QC Score' ? 'QC Score Distribution' : 
                            dataKey === 'Rating' ? 'Rating Trends' : 'Performance Metrics';
                } else {
                    // Generate mock data
                    chartData = AIContentEngine.generateMockData('chart');
                    title = 'Sample Performance Trend';
                }
                
                if (query.toLowerCase().includes('trend') || query.toLowerCase().includes('over time')) {
                    chartType = 'line';
                }
                
                return {
                    contentType: 'chart',
                    title: title,
                    chartType: chartType,
                    data: chartData,
                    config: { xKey: 'name', yKey: 'value' }
                };
            },
            
            // Generate table data
            generateTableData: (query, data, hasData) => {
                const cleanData = hasData ? data.filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d)) : [];
                const lowerQuery = query.toLowerCase();
                let headers = [];
                let rows = [];
                let title = 'Data Table';
                
                // Parse table intent from query
                const isTopQuery = /top\s+(\d+)/i.test(lowerQuery);
                const isBottomQuery = /bottom\s+(\d+)/i.test(lowerQuery);
                const limit = parseInt((lowerQuery.match(/(?:top|bottom)\s+(\d+)/i) || [])[1]) || 10;
                
                // Extract comparison columns from query
                const comparisonMatch = lowerQuery.match(/compare\s+(\w+)\s+(?:vs|versus|and|with)\s+(\w+)/i);
                const requestedColumns = [];
                
                if (lowerQuery.includes('agent')) requestedColumns.push('Agent');
                if (lowerQuery.includes('nps') || lowerQuery.includes('rating')) requestedColumns.push('Rating', 'NPS');
                if (lowerQuery.includes('qc') || lowerQuery.includes('score')) requestedColumns.push('QC Score', 'Score');
                if (lowerQuery.includes('error') || lowerQuery.includes('failure')) requestedColumns.push('Errors', 'Failures', 'Issue', 'Sub-metric');
                if (lowerQuery.includes('date') || lowerQuery.includes('week') || lowerQuery.includes('month')) requestedColumns.push('Date', 'Week', 'Month');
                if (lowerQuery.includes('country')) requestedColumns.push('Country');
                if (lowerQuery.includes('category') || lowerQuery.includes('tag')) requestedColumns.push('Chat Tag', 'Category', 'Tag');
                
                if (hasData && Array.isArray(cleanData) && cleanData.length > 0) {
                    // Use real data structure
                    const sample = cleanData[0];
                    const allKeys = Object.keys(sample);
                    
                    // Smart column selection based on query
                    if (requestedColumns.length > 0) {
                        // Find matching columns from available keys
                        headers = allKeys.filter(key => 
                            requestedColumns.some(rc => 
                                key.toLowerCase().includes(rc.toLowerCase()) || 
                                rc.toLowerCase().includes(key.toLowerCase())
                            )
                        );
                        // Always include Agent if available
                        if (allKeys.includes('Agent') && !headers.includes('Agent')) {
                            headers.unshift('Agent');
                        }
                    }
                    
                    // Fallback to common columns if no matches
                    if (headers.length === 0) {
                        const priorityCols = ['Agent', 'Rating', 'QC Score', 'Date', 'Chat Tag', 'Country', 'Sub-metric', 'Feedback'];
                        headers = priorityCols.filter(col => allKeys.includes(col)).slice(0, 6);
                    }
                    
                    // Ensure at least some columns are shown
                    if (headers.length === 0) {
                        headers = allKeys.slice(0, 6);
                    }
                    
                    // Sort data if query implies ranking
                    let sortedData = [...cleanData];
                    if (isTopQuery || isBottomQuery) {
                        const sortKey = allKeys.find(k => 
                            k.toLowerCase().includes('score') || 
                            k.toLowerCase().includes('rating') ||
                            k.toLowerCase().includes('count')
                        ) || allKeys[0];
                        
                        sortedData.sort((a, b) => {
                            const aVal = parseFloat(a[sortKey]) || 0;
                            const bVal = parseFloat(b[sortKey]) || 0;
                            return isBottomQuery ? aVal - bVal : bVal - aVal;
                        });
                        
                        title = isTopQuery ? `Top ${limit} by ${sortKey}` : `Bottom ${limit} by ${sortKey}`;
                    }
                    
                    // Filter for critical errors if requested
                    if (lowerQuery.includes('critical') || lowerQuery.includes('error')) {
                        sortedData = sortedData.filter(d => {
                            const errorIndicators = ['critical', 'error', 'fail', 'issue', 'problem'];
                            return errorIndicators.some(ind => 
                                JSON.stringify(d).toLowerCase().includes(ind)
                            );
                        });
                        title = 'Critical Errors';
                    }
                    
                    // Filter for this week if requested
                    if (lowerQuery.includes('this week') || lowerQuery.includes('weekly')) {
                        const oneWeekAgo = new Date();
                        oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
                        sortedData = sortedData.filter(d => {
                            const dateStr = d['Date'] || d['Review Date'] || d['Created'];
                            if (dateStr) {
                                const date = new Date(dateStr);
                                return date >= oneWeekAgo;
                            }
                            return true;
                        });
                        title = 'This Week' + (title !== 'Data Table' ? ' - ' + title : '');
                    }
                    
                    rows = sortedData.slice(0, limit).map(d => {
                        const row = {};
                        headers.forEach(h => row[h] = d[h] || '');
                        return row;
                    });
                } else {
                    // Use mock data
                    const mock = AIContentEngine.generateMockData('table');
                    headers = mock.headers;
                    rows = mock.rows.slice(0, limit);
                }
                
                return {
                    contentType: 'table',
                    title: title,
                    headers: headers,
                    rows: rows,
                    meta: { isSortable: true, exportable: true }
                };
            },
            
            // Generate PDF content
            generatePDFContent: async (query, data, hasData) => {
                const cleanData = hasData ? data.filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d)) : [];
                const prompt = `${AI_PERSONA}
${TL_PERSONA_PROMPT}

Generate a formatted document/report for the following request:

Query: ${query}
${hasData ? `Data summary: ${JSON.stringify(cleanData.slice(0, 3))}` : 'No data loaded - create a realistic CX example report'}

STRICT RULES:
1. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.
2. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).
3. NO hashtags (#).
4. Use emojis sparingly (max 2 per line).
5. Do NOT use the word "Bold", "Underline", or "B" as text.
6. Do NOT bold emphasis words like "Always", "Never", "Note" inside descriptions.

Return formatted Markdown content ready for PDF export.`;
                
                try {
                    const result = await AIRequestManager.generate(prompt);
                    return {
                        contentType: 'pdf',
                        title: 'PDF Document',
                        content: result,
                        data: { exportable: true, format: 'pdf' }
                    };
                } catch (e) {
                    return {
                        contentType: 'pdf',
                        title: 'PDF Document',
                        content: '**PDF Export**\n\nDocument content unavailable.',
                        data: { exportable: false }
                    };
                }
            },
            
            // Generate executive summary
            generateExecutiveSummary: async (query, data, hasData) => {
                // Filter out invalid appeals (Accepted, Pending, To Be Appealed)
                const cleanData = hasData && data ? data.filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d)) : [];
                
                const styleContext = hasData ? extractTLStyleContext(cleanData, 'NPS') : '';
                const prompt = `${AI_PERSONA}
${TL_PERSONA_PROMPT}

Generate an executive summary for the following:

Query: ${query}
${hasData ? `Data available: ${JSON.stringify(cleanData.slice(0, 5))}` : 'Create a realistic executive summary with sample CX metrics'}
${styleContext}

STRICT KEYWORD RULES (CRITICAL - DO NOT VIOLATE):
- Use ONLY sub-metric names from the provided data
- Use ONLY pillar names: Communication, Personalisation, Efficiency
- Use ONLY QC categories: Critical, Process, Internal
- **NEVER invent generic terms** like "customer satisfaction", "quality metrics", "performance indicators"
- **NEVER use** vague business terms like "operational excellence", "strategic initiatives", "key drivers"
- Every metric mentioned must be a specific sub-metric from data
- Bold (**text**) metric names when referenced

FORMATTING RULES:
1. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.
2. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).
3. NO hashtags (#).
4. Use emojis sparingly (max 2 per line).
5. Do NOT use the word "Bold", "Underline", or "B" as text.
6. Do NOT bold emphasis words like "Always", "Never", "Note" inside descriptions.

Keep it concise - executive level (200-300 words).`
                
                try {
                    const result = await AIRequestManager.generate(prompt);
                    return {
                        contentType: 'executive_summary',
                        title: 'Executive Summary',
                        content: result,
                        data: { type: 'executive' }
                    };
                } catch (e) {
                    return {
                        contentType: 'executive_summary',
                        title: 'Executive Summary',
                        content: '**Executive Summary**\n\n**Overview**\n\nUnable to generate summary at this time.',
                        data: {}
                    };
                }
            },
            
            // Generate coaching plan
            generateCoachingPlan: async (query, data, hasData) => {
                // Filter out invalid appeals (Accepted, Pending, To Be Appealed)
                const cleanData = hasData && data ? data.filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d)) : [];
                
                const styleContext = hasData ? extractTLStyleContext(cleanData, 'QC') : '';
                const prompt = `${AI_PERSONA}
${TL_PERSONA_PROMPT}

Generate a coaching plan based on the following:

Query: ${query}
${hasData ? `Agent data: ${JSON.stringify(cleanData.slice(0, 3)).replace(/\(Chat Link :\-.*?\)/g, '')}` : 'Create a realistic coaching plan based on typical CX challenges'}
${styleContext}

STRICT RULES:
1. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.
2. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).
3. NO hashtags (#).
4. Use emojis sparingly (max 2 per line).
5. Do NOT use the word "Bold", "Underline", or "B" as text.
6. Do NOT bold emphasis words like "Always", "Never", "Note" inside descriptions.
7. Do NOT output raw URLs or wrap links in parentheses.

Return a complete coaching plan document.`;
                
                try {
                    const result = await AIRequestManager.generate(prompt);
                    return {
                        contentType: 'coaching_plan',
                        title: 'Coaching Plan',
                        content: formatSlackMessage(result, 'CoachingPlan'),
                        data: { type: 'coaching' }
                    };
                } catch (e) {
                    return {
                        contentType: 'coaching_plan',
                        title: 'Coaching Plan',
                        content: '**Coaching Plan**\n\nUnable to generate plan.',
                        data: {}
                    };
                }
            },
            
            // Generate 1:1 feedback
            generate1on1Feedback: async (query, data, hasData) => {
                // Filter out invalid appeals (Accepted, Pending, To Be Appealed)
                const cleanData = hasData && data ? data.filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d)) : [];
                
                const styleContext = hasData ? extractTLStyleContext(cleanData, 'NPS') : '';
                const prompt = `${ONE_ON_ONE_SYSTEM_PROMPT}
${TL_PERSONA_PROMPT}

Write 1:1 feedback for an agent based on:

Query: ${query}
${hasData ? `Performance data: ${JSON.stringify(cleanData.slice(0, 3)).replace(/\(Chat Link :\-.*?\)/g, '')}` : 'Write general encouraging feedback'}
${styleContext}

STRICT KEYWORD RULES (CRITICAL - DO NOT VIOLATE):
- Use ONLY sub-metric names from the provided data: ${hasData && cleanData.length > 0 ? Object.values(NPS_METRIC_MAPPING).flat().filter(m => cleanData.some(d => d[m] === false || String(d[m]).toUpperCase() === 'FALSE')).join(', ') : 'Check data for failed metrics'}
- Use ONLY QC categories if QC data: Critical, Process, Internal
- **NEVER invent generic terms** like "communication skills", "customer focus", "attention to detail"
- **NEVER use** vague coaching topics like "time management", "professional development"
- Every feedback item must reference a specific metric from data
- Bold (**text**) the metric name followed by :- 

FORMATTING RULES:
1. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.
2. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).
3. NO hashtags (#).
4. Use emojis sparingly (max 2 per line).
5. Do NOT use the word "Bold", "Underline", or "B" as text.
6. Do NOT bold emphasis words like "Always", "Never", "Note" inside descriptions.
7. FIRST-PERSON PERSPECTIVE: You ARE the Team Lead. Do NOT refer to "The TL" or "The Team Lead". Use "I", "we", or direct commands.
8. Do NOT output raw URLs or wrap links in parentheses.

Return the feedback message ready to share.`
                
                try {
                    const result = await AIRequestManager.generate(prompt);
                    // Fix Issue 13 & 21: Ensure result is a string before calling replace
                    const safeResult = String(result || '');
                    // Strip unwanted section headers from output
                    let cleanedResult = safeResult
                        .replace(/\*\* CLOSURE:\*\*/gi, '')
                        .replace(/ CLOSURE:/gi, '')
                        .replace(/\*\*CLOSURE:\*\*/gi, '')
                        .replace(/CLOSURE:/gi, '');

                    return {
                        contentType: 'feedback_1on1',
                        title: '1:1 Feedback',
                        content: formatSlackMessage(cleanedResult, 'OneOnOne'),
                        data: { type: '1on1' }
                    };
                } catch (e) {
                    return {
                        contentType: 'feedback_1on1',
                        title: '1:1 Feedback',
                        content: 'Hi! I wanted to share some feedback with you...',
                        data: {}
                    };
                }
            },
            
            // Generate KPI grid
            generateKPIGrid: (query, data, hasData) => {
                const cleanData = hasData ? data.filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d)) : [];
                let kpiData = [];
                
                if (hasData && Array.isArray(cleanData) && cleanData.length > 0) {
                    // Calculate real KPIs from data
                    const total = cleanData.length;
                    const avgScore = cleanData.reduce((acc, d) => acc + (parseFloat(d['QC Score'] || d['Rating'] || 0)), 0) / total;
                    kpiData = [
                        { title: 'Total Records', value: total.toString(), icon: 'file-text', color: 'blue' },
                        { title: 'Avg Score', value: `${avgScore.toFixed(1)}%`, icon: 'star', color: avgScore >= 90 ? 'green' : 'amber' },
                        { title: 'Agents', value: new Set(cleanData.map(d => d.Agent)).size.toString(), icon: 'users', color: 'purple' },
                        { title: 'Status', value: 'Active', icon: 'check-circle', color: 'green' },
                    ];
                } else {
                    kpiData = AIContentEngine.generateMockData('kpi_grid');
                }
                
                return {
                    contentType: 'kpi_grid',
                    title: 'Key Performance Indicators',
                    data: kpiData
                };
            },
            
            // Generate dashboard snapshot
            generateSnapshot: async (query, data, hasData) => {
                try {
                    const cleanData = hasData ? data.filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d)) : [];
                    // Capture current dashboard state
                    const snapshotData = {
                        timestamp: new Date().toISOString(),
                        view: query,
                        dataSummary: hasData ? {
                            totalRecords: cleanData.length,
                            metrics: cleanData.slice(0, 5)
                        } : null
                    };
                    
                    return {
                        contentType: 'snapshot',
                        type: 'snapshot',
                        title: 'Dashboard Snapshot',
                        data: snapshotData,
                        meta: { 
                            timestamp: snapshotData.timestamp,
                            captured: true,
                            exportable: true
                        }
                    };
                } catch (e) {
                    return {
                        contentType: 'snapshot',
                        type: 'snapshot',
                        title: 'Dashboard Snapshot',
                        data: { timestamp: new Date().toISOString() },
                        meta: { captured: false, error: e.message }
                    };
                }
            },
            
            // Generate prediction
            generatePrediction: (query, data, hasData, options = {}) => {
                const { domain = 'unified', agent = null } = options;
                
                // Apply Global Filters
                const cleanData = hasData ? data.filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d)) : [];
                
                // Fix: Check for empty data
                if (cleanData.length === 0) {
                        return {
                        contentType: 'prediction',
                        content: '##  Performance Prediction\n\nNo sufficient data available for prediction analysis.',
                        data: { predicted: false },
                        meta: { generated: true, hasData: false }
                    };
                }
                
                // Use PerformancePredictionEngine if available
                if (typeof PerformancePredictionEngine !== 'undefined') {
                    const report = PerformancePredictionEngine.generatePredictionReport(
                        cleanData, 
                        domain === 'nps' ? 'NPS' : domain === 'qc' ? 'QC' : 'Unified',
                        { agentName: agent, includeTeam: true, includeRisk: true }
                    );
                    
                    return {
                        contentType: 'prediction',
                        content: PerformancePredictionEngine.formatPredictionResponse(report),
                        data: report,
                        meta: { generated: true, hasData }
                    };
                }
                
                // Fallback prediction
                return {
                    contentType: 'prediction',
                    content: `##  Performance Prediction

Based on current trends and historical data:

**Team Prediction (Next Week)**
- Predicted Pass Rate: 85-92%
- Confidence Level: Medium
- Trend: Stable

**Recommendations:**
- Continue monitoring at-risk agents
- Schedule proactive coaching sessions
- Focus on consistent process adherence`,
                    data: { predicted: true, fallback: true },
                    meta: { generated: true, hasData, fallback: true }
                };
            }
        };

        // --- NEW: StyleEngine for centralized style logic ---
        const StyleEngine = {
            getStyleContext: (data = {}) => {
                const isQC = data['QC Score'] !== undefined;


                if (isQC) {
                    const score = parseFloat(data['QC Score'] || 0);
                    const sourceText = [data['TL RCA'], data['Answer Comment']].filter(Boolean).join(' ').toLowerCase();
                    const formalCues = ['please', 'kindly', 'ensure', 'request', 'thank'];
                    const casualCues = ['ok', 'sure', 'yeah', 'hey'];
                    let tone = 'neutral';
                    if (formalCues.some(w => sourceText.includes(w))) tone = 'formal';
                    else if (casualCues.some(w => sourceText.includes(w))) tone = 'casual';
                    const stylePrompt = tone === 'formal'
                        ? 'Use a formal, polite tone similar to TL feedback. Keep sentences simple, avoid exclamations.'
                        : 'Use a direct, concise tone similar to TL feedback. Keep sentences simple, avoid exclamations.';
                    return {
                        isPassing: score >= 90,
                        isCritical: score < 80,
                        themeColor: score >= 90 ? 'emerald' : (score >= 80 ? 'amber' : 'rose'),
                        scoreValue: score,
                        tlTone: tone,
                        stylePrompt,
                        sampleText: sourceText // Return raw text for AI mimicry
                    };
                } else {
                    const rating = data.Rating;
                    const isPromoter = ['5', 'WOW', 'Excellent'].includes(String(rating));
                    const isDetractor = ['1', 'Poor'].includes(String(rating));
                    const sourceText = [data['Remediation Feedback'], data['Feedback']].filter(Boolean).join(' ').toLowerCase();
                    const formalCues = ['please', 'kindly', 'ensure', 'request', 'thank'];
                    const casualCues = ['ok', 'sure', 'yeah', 'hey'];
                    let tone = 'neutral';
                    if (formalCues.some(w => sourceText.includes(w))) tone = 'formal';
                    else if (casualCues.some(w => sourceText.includes(w))) tone = 'casual';
                    const stylePrompt = tone === 'formal'
                        ? 'Use a formal, polite tone similar to TL feedback. Keep sentences simple, avoid exclamations.'
                        : 'Use a direct, concise tone similar to TL feedback. Keep sentences simple, avoid exclamations.';
                    return {
                        isPassing: !isDetractor,
                        isCritical: isDetractor,
                        themeColor: isPromoter ? 'purple' : (isDetractor ? 'rose' : 'blue'),
                        scoreValue: rating,
                        tlTone: tone,
                        stylePrompt,
                        sampleText: sourceText // Return raw text for AI mimicry
                    };
                }
            }
        };


        // Suppress specific warnings for cleaner console
        const originalWarn = console.warn;
        console.warn = function (...args) {
            if (args[0] && typeof args[0] === 'string') {
                if (args[0].includes('cdn.tailwindcss.com')) return;
                if (args[0].includes('You are using the in-browser Babel transformer')) return;
            }
            originalWarn.apply(console, args);
        };


        // --- AI & INTERACTION ENGINES (ADDED) ---

        // 1. Regeneration Controller
        class RegenerationController {
            constructor() {
                this.generatedContent = new Map(); // id -> { content, context, history }
                this.modificationHistory = new Map(); // id -> [modifications]
            }

            register(id, content, context) {
                this.generatedContent.set(id, {
                    original: content,
                    current: content,
                    context,
                    timestamp: Date.now(),
                    type: this.inferType(context)
                });
                if (!this.modificationHistory.has(id)) {
                    this.modificationHistory.set(id, []);
                }
            }

            inferType(context) {
                const ctx = String(context).toLowerCase();
                if (ctx.includes('coaching')) return 'coaching';
                if (ctx.includes('slack')) return 'slack';
                if (ctx.includes('executive')) return 'executive';
                if (ctx.includes('1:1') || ctx.includes('one-on-one')) return 'one-on-one';
                return 'general';
            }

            async modify(id, instruction) {
                const item = this.generatedContent.get(id);
                if (!item) throw new Error('Content not found');

                const prompt = this.buildModificationPrompt(item, instruction);

                // Capture before state BEFORE modification
                const beforeState = item.current;

                // Use global AIRequestManager
                const modified = await AIRequestManager.generate(prompt);

                item.current = modified;
                item.timestamp = Date.now();
                this.generatedContent.set(id, item);

                const history = this.modificationHistory.get(id);
                history.push({
                    instruction,
                    before: beforeState,
                    after: modified,
                    timestamp: Date.now()
                });

                return modified;
            }

            buildModificationPrompt(item, instruction) {
                const typeInstructions = {
                    coaching: 'You are modifying a coaching plan. Maintain professional, actionable tone.',
                    slack: 'You are modifying a Slack post. Keep it casual but professional.',
                    executive: 'You are modifying an executive summary. Keep it concise and high-level.',
                    'one-on-one': 'You are modifying 1:1 feedback. Maintain empathetic, direct tone.'
                };

                return `${typeInstructions[item.type] || ''}

CURRENT CONTENT:
${item.current}

ORIGINAL CONTEXT:
${item.context}

USER INSTRUCTION:
${instruction}

TASK:
Modify the content according to the user's instruction while:
1. Maintaining the core message and facts
2. Preserving the appropriate tone for ${item.type}
3. Keeping the same general structure unless asked to change it
4. Only changing what the user explicitly asked for

Return ONLY the modified content, no explanations.`;
            }

            getHistory(id) {
                return this.modificationHistory.get(id) || [];
            }

            reset(id) {
                const item = this.generatedContent.get(id);
                if (item) {
                    item.current = item.original;
                    this.generatedContent.set(id, item);
                    return item.original;
                }
                return null;
            }

            undo(id) {
                const history = this.modificationHistory.get(id);
                if (!history || history.length === 0) return null;

                const last = history.pop();
                const item = this.generatedContent.get(id);
                item.current = last.before;
                this.generatedContent.set(id, item);

                return last.before;
            }
        }
        const regenController = new RegenerationController();

        // 2. Screen Context & Manipulation
        class ScreenContextExtractor {
            constructor() {
                this.observers = new Map();
            }

            extractCurrentScreen() {
                return {
                    view: this.getCurrentView(),
                    visibleElements: this.getVisibleElements(),
                    activeFilters: this.getActiveFilters(),
                    generatedContent: this.getGeneratedContent(),
                    tables: this.getTableData(),
                    charts: this.getChartData(),
                    selectedAgent: this.getSelectedAgent(),
                    capabilities: this.getAvailableActions()
                };
            }

            getCurrentView() {
                const activeTab = document.querySelector('[class*="tab-active"]');
                return activeTab?.textContent || 'Overview';
            }

            getVisibleElements() {
                const elements = [];
                document.querySelectorAll('.card-header-tint').forEach(header => {
                    const title = header.textContent.trim();
                    const card = header.closest('.glass-card');
                    elements.push({
                        type: 'card',
                        title,
                        visible: this.isElementVisible(card)
                    });
                });
                return elements;
            }

            getActiveFilters() {
                const filters = {};
                document.querySelectorAll('[data-filter-active="true"]').forEach(filter => {
                    const column = filter.dataset.column;
                    const value = filter.dataset.value;
                    if (column) filters[column] = value;
                });
                return filters;
            }

            getGeneratedContent() {
                const generated = [];
                document.querySelectorAll('[data-ai-generated="true"]').forEach(el => {
                    generated.push({
                        id: el.id,
                        type: el.dataset.contentType,
                        content: el.textContent.substring(0, 500),
                        fullElement: el
                    });
                });
                return generated;
            }

            getTableData() {
                const tables = [];
                document.querySelectorAll('table').forEach((table, idx) => {
                    if (!this.isElementVisible(table)) return;
                    const headers = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim());
                    const rows = Array.from(table.querySelectorAll('tbody tr')).slice(0, 10).map(tr =>
                        Array.from(tr.querySelectorAll('td')).map(td => td.textContent.trim())
                    );
                    tables.push({
                        id: table.id || `table-${idx}`,
                        headers,
                        rows,
                        totalRows: table.querySelectorAll('tbody tr').length,
                        element: table
                    });
                });
                return tables;
            }

            getChartData() {
                const charts = [];
                document.querySelectorAll('[class*="recharts"]').forEach((chart, idx) => {
                    const parent = chart.closest('[id]');
                    charts.push({
                        id: parent?.id || `chart-${idx}`,
                        type: this.inferChartType(chart),
                        element: parent || chart
                    });
                });
                return charts;
            }

            inferChartType(chartEl) {
                if (chartEl.querySelector('.recharts-bar')) return 'bar';
                if (chartEl.querySelector('.recharts-line')) return 'line';
                if (chartEl.querySelector('.recharts-pie')) return 'pie';
                return 'unknown';
            }

            getSelectedAgent() {
                const agentSelect = document.querySelector('[data-agent-selector]');
                return agentSelect?.value || null;
            }

            getAvailableActions() {
                const actions = [];
                document.querySelectorAll('button[data-action]').forEach(btn => {
                    if (this.isElementVisible(btn)) {
                        actions.push({
                            id: btn.dataset.action,
                            label: btn.textContent.trim(),
                            element: btn
                        });
                    }
                });
                return actions;
            }

            isElementVisible(el) {
                if (!el) return false;
                const rect = el.getBoundingClientRect();
                return rect.top < window.innerHeight && rect.bottom > 0;
            }

            async captureElement(elementId) {
                const element = document.getElementById(elementId);
                if (!element) return null;
                try {
                    const canvas = await html2canvas(element, { 
                        scale: 1, 
                        backgroundColor: '#ffffff',
                        logging: false,
                        ignoreElements: (el) => ExportEngine.ignoreElements(el),
                        onclone: (clonedDoc) => {
                            ExportEngine.applySafeStyles(clonedDoc);
                            clonedDoc.querySelectorAll('[data-html2canvas-ignore], .no-export, .no-capture, .sunrise-toolbar, #ai-floating-btn, #ai-chat-panel, #ai-assistant-btn').forEach(el => el.remove());
                        }
                    });
                    return canvas.toDataURL('image/png');
                } catch (e) { return null; }
            }
        }

        class ScreenManipulator {
            constructor(contextExtractor) {
                this.context = contextExtractor;
            }

            async executeAction(action, parameters) {
                const handlers = {
                    'apply_filter': this.applyFilter.bind(this),
                    'change_view': this.changeView.bind(this),
                    'modify_table': this.modifyTable.bind(this),
                    'reformat_output': this.reformatOutput.bind(this),
                    'export_element': this.exportElement.bind(this),
                    'regenerate_with_changes': this.regenerateWithChanges.bind(this),
                    'highlight_data': this.highlightData.bind(this),
                    'create_visualization': this.createVisualization.bind(this)
                };
                const handler = handlers[action];
                if (!handler) throw new Error(`Unknown action: ${action}`);
                return await handler(parameters);
            }

            async applyFilter(params) {
                const { column, value, operator = 'equals' } = params;
                const filterButton = document.querySelector(`[data-filter-column="${column}"]`);
                if (!filterButton) throw new Error(`Filter for ${column} not found`);
                filterButton.click();
                await new Promise(resolve => setTimeout(resolve, 200));
                const input = document.querySelector(`[data-filter-input="${column}"]`);
                if (input) {
                    input.value = value;
                    input.dispatchEvent(new Event('change', { bubbles: true }));
                }
                return { success: true, filter: { column, value, operator } };
            }

            async changeView(params) {
                const { viewName } = params;
                const tab = Array.from(document.querySelectorAll('[data-view-tab]')).find(
                    tab => tab.textContent.toLowerCase().includes(viewName.toLowerCase())
                );
                if (!tab) throw new Error(`View "${viewName}" not found`);
                tab.click();
                return { success: true, newView: viewName };
            }

            async modifyTable(params) {
                const { tableId, modifications } = params;
                const screenContext = this.context.extractCurrentScreen();
                const tableData = screenContext.tables.find(t => t.id === tableId);
                if (!tableData) throw new Error(`Table ${tableId} not found`);

                const prompt = `Current table has:
Headers: ${tableData.headers.join(', ')}
${tableData.rows.length} rows

Modifications requested: ${JSON.stringify(modifications)}

Generate new table structure as JSON:
{
  "headers": [...],
  "rows": [[...], [...], ...]
}`;
                // Use global AIRequestManager
                const response = await AIRequestManager.generateJson(prompt);
                let newTable;
                try {
                    newTable = JSON.parse(response);
                } catch (e) { newTable = response; } // Fallback if already object

                return { success: true, tableId, modifications, newTable };
            }

            async reformatOutput(params) {
                const { elementId, format } = params;
                const element = document.getElementById(elementId);
                if (!element) throw new Error(`Element ${elementId} not found`);
                const content = element.textContent;
                const prompt = `Reformat this content as ${format}:\n\n${content}\n\nReturn formatted version only.`;
                const formatted = await AIRequestManager.generate(prompt);
                return { success: true, formatted, elementId };
            }

            async exportElement(params) {
                const { elementId, format = 'image' } = params;
                const element = document.getElementById(elementId);
                if (!element) throw new Error(`Element ${elementId} not found`);

                if (format === 'image') {
                    const dataUrl = await this.context.captureElement(elementId);
                    return { success: true, dataUrl, format: 'image' };
                } else if (format === 'csv') {
                    // Logic to export table would go here
                    return { success: true, message: 'CSV copied to clipboard' };
                }
                return { success: false, error: 'Unsupported format' };
            }

            async regenerateWithChanges(params) {
                const { contentId, changes } = params;
                const modified = await regenController.modify(contentId, changes);
                return { success: true, modified };
            }

            async highlightData(params) {
                const { criteria } = params;
                document.querySelectorAll('table tbody tr').forEach(row => {
                    // Placeholder logic
                    row.classList.add('highlight-ai');
                });
                return { success: true, criteria };
            }

            async createVisualization(params) {
                const { data, type, config } = params;
                return { success: true, chartConfig: { type, data, ...config } };
            }
        }
        const screenExtractor = new ScreenContextExtractor();
        const screenManipulator = new ScreenManipulator(screenExtractor);

        // 3. Advanced Quiz Generator
        class AdvancedQuizGenerator {
            async generateQuiz(config) {
                const {
                    topic, difficulty, questionCount, types,
                    dataContext, agentSpecific, customInstructions, filters
                } = config;

                // FIX: Verify dataContext is valid before proceeding
                let safeDataContext = dataContext || [];
                // Apply global filters (Appeals + NPS Pass)
                safeDataContext = safeDataContext.filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d));
                
                const contextSummary = this.summarizeData(safeDataContext);
                
                // Dispatch progress event
                window.dispatchEvent(new CustomEvent('ai-progress', { detail: { show: true, progress: 10, text: 'Building quiz prompt...' } }));

                const prompt = this.buildQuizPrompt(config);
                
                // Dispatch progress event
                window.dispatchEvent(new CustomEvent('ai-progress', { detail: { show: true, progress: 30, text: 'Generating quiz with AI...' } }));

                // Use standard text generation (Markdown) to avoid JSON syntax errors
                let response = await AIRequestManager.generate(prompt);
                
                // Fix: Ensure response is a string
                if (typeof response !== 'string') {
                    response = JSON.stringify(response);
                }

                // Dispatch progress event
                window.dispatchEvent(new CustomEvent('ai-progress', { detail: { show: true, progress: 70, text: 'Parsing quiz data...' } }));

                const result = this.parseQuizMarkdown(response);
                
                // Hide progress
                window.dispatchEvent(new CustomEvent('ai-progress', { detail: { show: false, progress: 100, text: 'Complete!' } }));

                return result;
            }

            parseQuizMarkdown(text) {
                const quiz = {
                    title: "Generated Quiz",
                    description: "Test your knowledge based on the current data context.",
                    questions: []
                };

                try {
                    const safeText = String(text || '');
                    const lines = safeText.split('\n');
                    let currentQuestion = null;

                    lines.forEach(line => {
                        const cleanLine = line.trim();
                        if (!cleanLine) return;
                        
                        const lowerLine = cleanLine.toLowerCase();

                        if (lowerLine.startsWith('title:')) {
                            quiz.title = cleanLine.substring(6).trim();
                        } else if (lowerLine.startsWith('description:')) {
                            quiz.description = cleanLine.substring(12).trim();
                        } else if (/^(question\s*\d+|q\.\d+|\d+\.|^\*\*question\s*\d+)/i.test(cleanLine)) {
                            if (currentQuestion) quiz.questions.push(currentQuestion);
                            const qText = cleanLine.replace(/^(question\s*\d+|q\.\d+|\d+\.|^\*\*question\s*\d+)[*:\s]*/i, '').trim();
                            currentQuestion = {
                                id: `q${quiz.questions.length + 1}`,
                                question: qText,
                                options: [],
                                correctAnswer: '',
                                correctAnswers: [],
                                explanation: '',
                                type: 'multiple-choice'
                            };
                        } else if (currentQuestion && /^[-*]?\s*(\(?[A-H]\)|[A-H]\.|[A-H]\s)/i.test(cleanLine)) {
                            const opt = cleanLine.replace(/^[-*]?\s*(\(?[A-H]\)|[A-H]\.|[A-H]\s)[)\s]*/i, '').trim();
                            if (opt) currentQuestion.options.push(opt);
                        } else if (currentQuestion && cleanLine.startsWith('- ') && !cleanLine.includes(':')) {
                            const opt = cleanLine.replace(/^-\s*/, '').trim();
                            if (opt) currentQuestion.options.push(opt);
                        } else if (lowerLine.startsWith('correct:') || lowerLine.startsWith('answer:') || lowerLine.startsWith('answers:')) {
                            if (currentQuestion) {
                                const val = cleanLine.replace(/^(CORRECT|ANSWER|ANSWERS):\s*/i, '').trim();
                                currentQuestion.correctAnswer = val;
                                const letters = val.toUpperCase().split(/[,.\s]+/).filter(x => x.length === 1 && /[A-H]/.test(x));
                                currentQuestion.correctAnswers = letters;
                            }
                        } else if (lowerLine.startsWith('explanation:') || lowerLine.startsWith('correct explanation:')) {
                            if (currentQuestion) currentQuestion.explanation = cleanLine.replace(/^(CORRECT\s*)?EXPLANATION:\s*/i, '').trim();
                        }
                    });
                    
                    if (currentQuestion) quiz.questions.push(currentQuestion);

                    if (quiz.questions.length === 0) {
                        quiz.questions.push({
                            id: 'q1',
                            question: "Based on the analysis, what is the primary focus?",
                            options: ["Quality Improvement", "Efficiency Gains", "Customer Satisfaction", "Risk Mitigation"],
                            correctAnswer: "A, C",
                            correctAnswers: ["A", "C"],
                            explanation: "The data suggests a focus on quality and satisfaction."
                        });
                        console.warn("Quiz Parsing Failed - Using Fallback");
                    }
                } catch (e) {
                    console.error("Quiz Parsing Error", e);
                    return {
                        title: "Quiz Generation Failed",
                        description: "Could not parse AI response. Showing fallback.",
                        questions: []
                    };
                }

                return quiz;
            }

            buildQuizPrompt(config) {
                const contextSummary = this.summarizeData(config.dataContext);
                const isNPS = config.topic === 'NPS';
                const isQC = config.topic === 'QC';

                return `${AI_PERSONA}
Generate a ${config.difficulty} difficulty quiz focusing on **Agent scenarios for resolving customer issues** based on ${config.topic} data. 

REQUIREMENTS:
- Focus on AGENT ACTIONS and CUSTOMER SCENARIOS
- Questions should be: 'If customer says X, what is the correct reply?'
- DO NOT focus on Team Lead KPIs or statistics
- Each question tests practical agent skills in handling customer issues
- Generate ${config.questionCount} questions.
- Each question must have **2-3 Correct Answers** and **2-3 Incorrect Options** (Total 5-6 options).

${isNPS ? `CRITICAL NPS RULE: 
- DO NOT include any links or URLs in the output as this is NPS data.
- Focus only on what went wrong and the correct solution
- Format in Explanation: **<Sub-metric>** :- <explanation of what was wrong and what should be done>` : ''}

${isQC ? `CRITICAL QC RULE:
- For FAILED answers, you MUST include embedded links to the source
- Format in Explanation: **<Question>** :- <explanation> [Link: {actual_link_here}]
- Extract the link from the 'Dante/BO Review Link' or 'Review Link' column
- If no link available, use 'N/A'` : ''}

DATA CONTEXT:
${contextSummary}

FILTERS APPLIED:
${config.filters ? JSON.stringify(config.filters, null, 2) : 'None'}

${config.agentSpecific ? `- Focus specifically on agent: ${config.agentSpecific}` : ''}
${config.customInstructions ? `\nADDITIONAL INSTRUCTIONS:\n${config.customInstructions}` : ''}

STRICT OUTPUT FORMAT (Use this EXACT structure):
TITLE: <Quiz Title>
DESCRIPTION: <Brief Description>

---
QUESTION 1: <Scenario/Question Text>
A) <Option>
B) <Option>
C) <Option>
D) <Option>
CORRECT: <Option A (Correct)>
CORRECT: <Option B (Correct)>
EXPLANATION: <Why these are correct. Follow the ${config.topic} RULE above.>
---

QUESTION 2: <Next Question...>
...

GUIDELINES:
- Questions should test practical application of knowledge.
- Scenarios must be based on the provided customer interactions.
- Every heading within the quiz MUST have an appropriate emoji.
- Add 2 line breaks (\\n\\n) after each heading block is finished.
- Return ONLY the structured text.
- **Strict Keywords:** Use ONLY Pillar names and Sub-metric names from the data.`;
            }

            summarizeData(data) {
                if (!data || data.length === 0) return 'No data provided';
                // Filter data based on filters if needed, but assuming dataContext is already filtered?
                // The config.dataContext passed should be relevant data.

                const summary = {
                    totalRecords: data.length,
                    agents: [...new Set(data.map(d => d.Agent || d['Agent Email']))].slice(0, 10),
                    sampleRows: data.slice(0, 5).map(d => ({
                        Feedback: d['Remediation Feedback'] || d['Feedback'] || d['TL RCA'],
                        Question: d['Question'],
                        SubMetric: d['Sub-metric'],
                        Link: d['Chat Link'] || d['Dante/Bo Link']
                    }))
                };
                return JSON.stringify(summary, null, 2);
            }
        }
        const advancedQuizGen = new AdvancedQuizGenerator();

        // 4. Micro Interactions
        const MicroInteractions = {
            addRipple: (event) => {
                const button = event.currentTarget;
                const ripple = document.createElement('span');
                const rect = button.getBoundingClientRect();
                const size = Math.max(rect.width, rect.height);
                const x = event.clientX - rect.left - size / 2;
                const y = event.clientY - rect.top - size / 2;

                ripple.style.width = ripple.style.height = `${size}px`;
                ripple.style.left = `${x}px`;
                ripple.style.top = `${y}px`;
                ripple.classList.add('ripple');

                // Add ripple css class if not exists
                if (!document.getElementById('ripple-style')) {
                    const style = document.createElement('style');
                    style.id = 'ripple-style';
                    style.innerHTML = `
                        .ripple {
                            position: absolute;
                            border-radius: 50%;
                            transform: scale(0);
                            animation: ripple 600ms linear;
                            background-color: rgba(255, 255, 255, 0.7);
                            pointer-events: none;
                        }
                        @keyframes ripple {
                            to {
                                transform: scale(4);
                                opacity: 0;
                            }
                        }
                        button { position: relative; overflow: hidden; }
                    `;
                    document.head.appendChild(style);
                }

                button.appendChild(ripple);
                setTimeout(() => ripple.remove(), 600);
            }
        };


        const DataEngine = {
            // Agent Name Map for email -> name resolution
            _agentNameMap: {},
            setAgentNameMap: (map) => { DataEngine._agentNameMap = map || {}; },
            
            // --- Global Appeal Check Helper ---
            // Centralized logic to exclude appealed/pending QC items from AI analysis
            isAppeal: (row) => {
                if (!row) return false;
                const status = String(row['Appeal Status'] || '').trim();
                const tlAppeal = row['TL Appeal'] === true || row['TL Appeal'] === 'TRUE';
                const tlRca = String(row['TL RCA'] || '').trim();
                
                // 1. Currently Appealed / Pending: 'Appeal Status' is "To Do"
                if (status === 'To Do') return true;
                
                // 2. Accepted Appealed: 'Appeal Status' is "Accept Appeal" OR "Accepted" OR QC Score is 0
                if (status === 'Accept Appeal' || status === 'Accepted') return true;
                
                // QC Score 0 check (Only for QC data, but safe to check if column exists)
                if (row['QC Score'] !== undefined && row['QC Score'] !== null && String(row['QC Score']).trim() !== '') {
                    const qcScore = parseFloat(row['QC Score']);
                    if (!isNaN(qcScore) && qcScore === 0) return true;
                }
                
                // 3. Pending to be appealed: 'TL Appeal' is True AND 'TL RCA' starts with "Appeal" or "Appealed" AND 'Appeal Status' is empty
                if (tlAppeal && (tlRca.startsWith('Appeal') || tlRca.startsWith('Appealed')) && !status) return true;
                
                // NOTE: "Rejected Appeal" (status === 'Reject Appeal' || status === 'Rejected') returns FALSE
                // because rejected appeals are valid failures and should be INCLUDED in AI analysis/Coaching.
                
                return false;
            },

            // --- Global NPS Pass All Submetrics Check Helper ---
            // Checks if an NPS review has all 15 sub-metrics as TRUE
            isNpsPassAllSubmetrics: (row) => {
                if (!row) return false;
                
                // Get all sub-metrics from the mapping
                const allSubMetrics = Object.values(NPS_METRIC_MAPPING).flat();
                
                // Check if every sub-metric is true in the row
                return allSubMetrics.every(metric => {
                    const val = row[metric];
                    return val === true || String(val).toUpperCase() === 'TRUE';
                });
            },


            parseDate: (val) => {
                if (!val) return null;
                if (val instanceof Date) return isNaN(val.getTime()) ? null : val;


                // 1. Handle Excel Serial Dates (Numbers)
                if (typeof val === 'number') {
                    // Excel base date: Dec 30, 1899. 
                    // Range check: 20000 (1954) to 60000 (2064) to avoid treating random IDs as dates
                    if (val > 20000 && val < 60000) {
                        const date = new Date(Math.round((val - 25569) * 86400 * 1000));
                        return isNaN(date.getTime()) ? null : date;
                    }
                    return null;
                }


                if (typeof val === 'string') {
                    const cleanVal = val.trim();
                    if (!cleanVal || cleanVal === '0' || cleanVal === '#N/A') return null;


                    const isoMatch = cleanVal.match(/^(\d{4})-(\d{2})-(\d{2})$/);
                    if (isoMatch) {
                        const year = parseInt(isoMatch[1], 10);
                        const month = parseInt(isoMatch[2], 10);
                        const day = parseInt(isoMatch[3], 10);
                        const d = new Date(year, month - 1, day);
                        return isNaN(d.getTime()) ? null : d;
                    }


                    const override = (PoppyApp && PoppyApp.config && PoppyApp.config.dateFormatOverride) ? String(PoppyApp.config.dateFormatOverride).toUpperCase() : 'AUTO';
                    const dmyMatch = cleanVal.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
                    if (dmyMatch) {
                        const day = parseInt(dmyMatch[1], 10);
                        const month = parseInt(dmyMatch[2], 10);
                        const year = parseInt(dmyMatch[3], 10);
                        if (override === 'AUTO' || override === 'DMY') {
                            const d = new Date(year, month - 1, day);
                            return isNaN(d.getTime()) ? null : d;
                        }
                    }


                    return null;
                }
                return null;
            },
            formatDate: (val) => {
                const d = DataEngine.parseDate(val);
                if (!d) return String(val || "");
                return `${String(d.getDate()).padStart(2, '0')}/${String(d.getMonth() + 1).padStart(2, '0')}/${d.getFullYear()}`;
            },
            getRowDate: (row) => {
                if (!row) return null;
                if (row._dateObj && row._dateObj instanceof Date && !isNaN(row._dateObj)) return row._dateObj;

                // Try standard fields
                const dateVal = row['Date'] || row['Review Date'] || row['Evaluation Date'];
                if (dateVal) {
                    const parsed = DataEngine.parseDate(dateVal);
                    if (parsed) return parsed;
                }
                return null;
            },
            getWeekStart: (dateOrRow) => {
                let d;
                if (dateOrRow instanceof Date) d = dateOrRow;
                else if (dateOrRow && typeof dateOrRow === 'object' && !dateOrRow.getTime) {
                    // It's a row object
                    d = DataEngine.getRowDate(dateOrRow);
                } else {
                    d = DataEngine.parseDate(dateOrRow);
                }

                if (!d) return '';
                const dayNum = d.getDay() || 7;
                const start = new Date(d);
                start.setDate(d.getDate() - dayNum + 1);
                return DataEngine.formatDate(start);
            },
            normalizeBool: (val) => {
                if (val === true || String(val).toUpperCase() === 'TRUE' || String(val).toUpperCase() === 'YES' || String(val).toUpperCase() === 'ACKNOWLEDGED') return true;
                if (val === false || String(val).toUpperCase() === 'FALSE' || String(val).toUpperCase() === 'NO' || String(val).toUpperCase() === 'NOT ACKNOWLEDGED') return false;
                return !!val;
            },
            normalizeAgent: (row, type) => {
                // PRESERVE EMAIL DOMAINS - Do not remove as per user instruction
                const rawValue = (type === 'QC' ? (row['Agent Email'] || row['Agent']) : (row['Agent'] || row['Agent Email'])) || '';
                
                // Try to look up agent name by email from "My Active Team" sheet
                if (rawValue && rawValue.includes('@')) {
                    const emailKey = rawValue.toLowerCase().trim();
                    if (DataEngine._agentNameMap[emailKey]) {
                        return DataEngine._agentNameMap[emailKey];
                    }
                }
                return rawValue;
            },
            getRatingCat: (rating) => {
                const r = String(rating || '').toLowerCase().trim();
                // Handle numeric strings
                if (!isNaN(parseFloat(r)) && isFinite(r)) {
                    const num = parseFloat(r);
                    if (num >= 9) return 'Promoter';
                    if (num >= 7) return 'Neutral';
                    return 'Detractor';
                }
                if (r === 'poor') return 'Detractor';
                if (r === 'ok' || r === 'great') return 'Neutral';
                if (r === 'wow' || r === 'excellent') return 'Promoter';
                return 'Unknown';
            },
            getNumericRating: (rating) => {
                const r = String(rating || '').toLowerCase().trim();
                if (!isNaN(parseFloat(r)) && isFinite(r)) return parseFloat(r);
                if (r === 'poor') return 3;
                if (r === 'ok') return 7;
                if (r === 'great') return 8;
                if (r === 'wow' || r === 'excellent') return 10;
                return 0;
            },
            getSeverity: (score) => {
                const s = parseFloat(score);
                if (s === 1) return 'High';
                if (s === 0.67 || s === 0.5) return 'Medium';
                if (s === 0.33) return 'Low';
                return 'N/A';
            },
            // Audit Issue #4: Normalize dataset type to lowercase for consistency
            normalizeDatasetType: (type) => {
                if (!type) return 'unknown';
                const normalized = String(type).toLowerCase().trim();
                if (normalized === 'qc' || normalized === 'quality') return 'qc';
                if (normalized === 'nps' || normalized === 'review') return 'nps';
                return normalized;
            },


            // Audit Issue #16: Column tooltips for table intelligence
            columnTooltips: {
                // NPS Columns
                'Rating': 'Customer satisfaction rating (1-5 or Poor/OK/Good/Great/WOW)',
                'Agent': 'Agent who handled the interaction',
                'Date': 'Date of the customer review or QC evaluation',
                'Acknowledged': 'Whether the agent has acknowledged the feedback',
                'Remediation Feedback': 'Detailed feedback from the reviewer',
                'User Problem': 'The primary issue the customer contacted about',
                'Chat Tag': 'Category tag assigned to the chat',
                // QC Columns
                'QC Score': 'Quality score from 0.0 to 1.0 (100%)',
                'Agent Email': 'Email identifier of the evaluated agent',
                'Question': 'The specific evaluation question or criteria',
                'Appeal Status': 'Status of any dispute: Pending, Approved, Rejected',
                'TL RCA': 'Team Lead Root Cause Analysis notes',
                // Metrics
                'Communication': 'Clear and professional communication quality',
                'Personalisation': 'Personalized and empathetic response quality',
                'Efficiency': 'Speed and effectiveness of resolution'
            },


            getColumnTooltip: (columnName) => {
                return DataEngine.columnTooltips[columnName] || null;
            },
            
            // CRITICAL FIX: Added missing getWeekNumber method (Data Analyst Issue #1)
            getWeekNumber: (date) => {
                if (!date || !(date instanceof Date) || isNaN(date.getTime())) return null;
                const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
                const dayNum = d.getUTCDay() || 7;
                d.setUTCDate(d.getUTCDate() + 4 - dayNum);
                const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
                const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
                return `${d.getUTCFullYear()}-W${String(weekNo).padStart(2, '0')}`;
            }
        };


        // Legacy Aliases removed (2026-01-20) - Use DataEngine.* directly


        const showToast = (message, type = 'info') => {
            if (document.querySelectorAll('.toast-notification').length >= 3) {
                if (!showToast.queue) showToast.queue = [];
                showToast.queue.push({ message, type });
                return;
            }

            const icons = {
                success: '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/>',
                error: '<circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/>',
                warning: '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/>',
                info: '<path d="M13 2 3 14h9l-1 8 10-12h-9l1-8z"/>'
            };
            
            const colors = {
                success: 'bg-emerald-600',
                error: 'bg-rose-600',
                warning: 'bg-amber-500',
                info: 'bg-slate-800'
            };

            const toast = document.createElement('div');
            toast.className = `toast-notification fixed left-1/2 -translate-x-1/2 ${colors[type] || colors.info} text-white px-5 py-3 rounded-2xl shadow-2xl z-[10000] font-medium text-sm flex items-center gap-3 transition-all duration-300 opacity-0 translate-y-10 cursor-pointer hover:scale-105`;
            toast.setAttribute('role', 'alert');
            toast.setAttribute('aria-live', type === 'error' ? 'assertive' : 'polite');
            
            const existing = document.querySelectorAll('.toast-notification');
            const offset = 32 + (existing.length * 70);
            toast.style.bottom = `${offset}px`;
            
            toast.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">${icons[type] || icons.info}</svg> ${message}`;
            
            toast.onclick = () => removeToast();
            
            document.body.appendChild(toast);
            
            requestAnimationFrame(() => {
                toast.classList.remove('opacity-0', 'translate-y-10');
            });

            let timeout = setTimeout(removeToast, 4000);

            function removeToast() {
                if (!toast.parentNode) return;
                toast.classList.add('opacity-0', 'translate-y-4');
                setTimeout(() => {
                    if (toast.parentNode) toast.parentNode.removeChild(toast);
                    if (showToast.queue && showToast.queue.length > 0) {
                        const next = showToast.queue.shift();
                        showToast(next.message, next.type);
                    }
                    const remaining = document.querySelectorAll('.toast-notification');
                    remaining.forEach((t, i) => {
                        t.style.bottom = `${32 + (i * 70)}px`;
                    });
                }, 300);
                clearTimeout(timeout);
            }
        };


        // Mission 3: Core Fixes - Robust Clipboard Fallback (Rich Text Support)
        const safeCopyToClipboard = async (text, html = null) => {
            if (!text && !html) return;
            
            try {
                // 1. Try Clipboard API (Modern & Clean)
                if (navigator.clipboard && navigator.clipboard.write) {
                    const clipboardData = {};
                    if (text) clipboardData['text/plain'] = new Blob([text], { type: 'text/plain' });
                    if (html) clipboardData['text/html'] = new Blob([html], { type: 'text/html' });
                    
                    await navigator.clipboard.write([new ClipboardItem(clipboardData)]);
                    showToast('Copied to clipboard!', 'success');
                    return;
                }
            } catch (e) {
                console.warn('Clipboard API failed, falling back to execCommand', e);
            }

            // 2. Fallback: execCommand (Sandbox Survival)
            // Handle Rich Text (HTML)
            if (html) {
                const hiddenDiv = document.createElement("div");
                hiddenDiv.contentEditable = true;
                hiddenDiv.innerHTML = html;
                hiddenDiv.style.position = "fixed";
                hiddenDiv.style.top = "-9999px";
                hiddenDiv.style.opacity = "0";
                document.body.appendChild(hiddenDiv);
                
                try {
                    hiddenDiv.focus();
                    const range = document.createRange();
                    range.selectNodeContents(hiddenDiv);
                    const sel = window.getSelection();
                    sel.removeAllRanges();
                    sel.addRange(range);
                    
                    const successful = document.execCommand('copy');
                    if (successful) {
                        showToast('Copied formatted text!', 'success');
                    } else {
                        throw new Error('execCommand copy failed');
                    }
                } catch (err) {
                    console.warn('Rich text copy failed', err);
                    // Fallback to plain text if rich text fails
                    safeCopyToClipboard(text, null); 
                } finally {
                    document.body.removeChild(hiddenDiv);
                }
                return;
            }

            // Handle Plain Text Only
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.top = "-9999px";
            textArea.style.opacity = "0";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showToast('Copied to clipboard!', 'success');
                } else {
                    throw new Error('execCommand returned false');
                }
            } catch (err) {
                console.warn('Clipboard failed', err);
                showToast('Copy failed. Please select and copy manually.', 'error');
            } finally {
                if (document.body.contains(textArea)) {
                    document.body.removeChild(textArea);
                }
            }
        };


        const copyRichText = (elementId) => {
            const el = document.getElementById(elementId);
            if (!el) return;
            const text = el.innerText || el.textContent;
            const html = el.innerHTML;
            safeCopyToClipboard(text, html);
        };


        const sanitizeHTML = (html) => {
            const doc = new DOMParser().parseFromString(String(html || ''), 'text/html');
            const blocked = new Set(['SCRIPT', 'STYLE', 'IFRAME', 'OBJECT', 'EMBED', 'LINK', 'META']);
            const walk = (root) => {
                Array.from(root.children || []).forEach((child) => {
                    if (blocked.has(child.tagName)) {
                        child.remove();
                        return;
                    }
                    Array.from(child.attributes || []).forEach((attr) => {
                        const name = String(attr.name || '').toLowerCase();
                        const value = String(attr.value || '');
                        if (name.startsWith('on')) child.removeAttribute(attr.name);
                        if (name === 'style') child.removeAttribute(attr.name);
                        if (name === 'href' || name === 'src') {
                            const v = value.trim().toLowerCase();
                            if (v.startsWith('javascript:') || v.startsWith('data:text/html')) child.removeAttribute(attr.name);
                        }
                    });
                    walk(child);
                });
            };
            walk(doc.body);
            return doc.body.innerHTML;
        };


        const safeMarked = (mdText) => {
            try {
                // Ensure input is a string and handle whitespace
                const safeText = String(mdText || '').replace(/\n(?=\s*-)/g, '');
                // Check if marked is available
                if (typeof marked !== 'undefined' && marked.parse) {
                    const parsed = marked.parse(safeText);
                    return sanitizeHTML(parsed);
                }
                // Fallback: return escaped text
                return safeText.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            } catch (e) {
                console.error('Markdown parsing error:', e);
                // Return escaped text on error
                return String(mdText || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            }
        };


        const copyTableToClipboard = async (tableId, data = null) => {
            // 1. Data payload fallback: generate TSV directly from array data
            if (!tableId && data) {
                try {
                    const headers = Object.keys(data[0] || {});
                    const tsv = [
                        headers.join('\t'),
                        ...data.map(row => headers.map(h => {
                            let val = row[h];
                            if (val === null || val === undefined) return '';
                            return String(val).replace(/\t/g, ' ').replace(/\n/g, ' ');
                        }).join('\t'))
                    ].join('\n');
                    await safeCopyToClipboard(tsv);
                    showToast("Table data copied!");
                    return;
                } catch (e) {
                    console.error("Data copy failed:", e);
                    showToast("Copy failed", "error");
                    return;
                }
            }


            // 2. Element-based copy with full formatting preservation
            const node = document.getElementById(tableId);
            if (!node) {
                if (data) return copyTableToClipboard(null, data);
                return showToast("Table not found.");
            }
            const originalTable = node.tagName === 'TABLE' ? node : node.querySelector('table');
            if (!originalTable) { showToast("No table found to copy."); return; }


            // Deep clone the table
            const clone = originalTable.cloneNode(true);


            // STYLE TRANSFER: Capture computed styles from original to clone
            const originalElements = originalTable.querySelectorAll('*');
            const cloneElements = clone.querySelectorAll('*');


            originalElements.forEach((orig, i) => {
                const cloned = cloneElements[i];
                if (!cloned) return;


                const computed = window.getComputedStyle(orig);


                // Transfer Critical Styles for formatting preservation
                cloned.style.color = computed.color;
                cloned.style.backgroundColor = computed.backgroundColor;
                cloned.style.fontSize = computed.fontSize;
                cloned.style.fontWeight = computed.fontWeight;
                cloned.style.textAlign = computed.textAlign;
                cloned.style.verticalAlign = computed.verticalAlign;
                cloned.style.whiteSpace = 'pre-wrap';
                cloned.style.display = computed.display.includes('flex') ? 'block' : computed.display;


                // Capture Column Widths for Excel compatibility
                if (cloned.tagName === 'TH' || cloned.tagName === 'TD') {
                    const rect = orig.getBoundingClientRect();
                    cloned.style.width = rect.width + 'px';
                    cloned.style.minWidth = rect.width + 'px';
                }


                // Numeric Alignment Logic - preserve right-alignment for numbers
                if (cloned.tagName === 'TD' || cloned.tagName === 'TH') {
                    const text = orig.textContent.trim().replace(/[^0-9.%-]/g, '');
                    const isNumeric = text !== '' && !isNaN(parseFloat(text)) && !text.includes(':');
                    if (isNumeric || orig.classList.contains('text-right')) {
                        cloned.style.textAlign = 'right';
                    }
                }


                // Fix Header Backgrounds
                if (cloned.tagName === 'TH') {
                    if (computed.backgroundColor === 'rgba(0, 0, 0, 0)' || computed.backgroundColor === 'transparent') {
                        cloned.style.backgroundColor = '#f1f5f9';
                    }
                    cloned.style.border = '1px solid #cbd5e1';
                }


                if (cloned.tagName === 'TD') {
                    cloned.style.border = '1px solid #e2e8f0';
                }


                // Preserve bold text styling
                const weight = parseInt(computed.fontWeight);
                if ((weight >= 600 || computed.fontWeight === 'bold') && cloned.childNodes.length === 1 && cloned.childNodes[0].nodeType === 3) {
                    cloned.innerHTML = `<b>${cloned.textContent}</b>`;
                }
            });


            // CLEANUP: Remove UI noise (buttons, icons, interactive elements)
            clone.querySelectorAll('.no-export, [data-html2canvas-ignore]').forEach(el => el.remove());
            
            // Remove SVGs and buttons that shouldn't be copied
            const icons = clone.querySelectorAll('svg, button');
            icons.forEach(el => el.remove());


            // Convert lists to bullet points
            const lists = clone.querySelectorAll('ul, ol');
            lists.forEach(list => {
                const container = document.createElement('div');
                const items = list.querySelectorAll('li');
                items.forEach(item => {
                    const line = document.createElement('div');
                    line.textContent = '\u2022 ' + item.textContent.trim();
                    // Copy text color/weight from the list item
                    line.style.color = item.style.color;
                    line.style.fontWeight = item.style.fontWeight;
                    container.appendChild(line);
                });
                list.parentNode.replaceChild(container, list);
            });


            // Fix Sortable Headers - flatten nested divs to simple bold text
            const headers = clone.querySelectorAll('th');
            headers.forEach(th => {
                if (th.textContent.trim()) {
                    const text = th.textContent.trim();
                    th.innerHTML = `<b>${text}</b>`;
                }
            });


            // TSV generator with date/number format preservation
            const generateTSV = (tableEl) => {
                const rows = tableEl.querySelectorAll('tr');
                const lines = [];
                const headerRow = tableEl.querySelector('tr');
                const headers = headerRow ? Array.from(headerRow.querySelectorAll('th')).map(th => th.textContent.trim().toLowerCase()) : [];
                const dateColumns = ['date', 'review date', 'week', 'reviewed on', 'created', 'updated'];
                const numberColumns = ['score', 'qc score', 'rating', 'count', 'total', 'average', 'value', 'number', 'amount'];
                rows.forEach((row, rowIdx) => {
                    const cells = row.querySelectorAll('th, td');
                    const values = Array.from(cells).map((cell, colIdx) => {
                        // FIX: Properly escape cell content for TSV
                        let text = cell.textContent.trim().replace(/[\t\n\r]/g, ' ');
                        if (rowIdx === 0) return text;
                        const colHeader = headers[colIdx] || '';
                        if (dateColumns.some(dc => colHeader.includes(dc))) {
                            const parsed = DataEngine.parseDate ? DataEngine.parseDate(text) : null;
                            if (parsed) return parsed.toISOString().split('T')[0];
                        }
                        if (numberColumns.some(nc => colHeader.includes(nc))) {
                            const num = parseFloat(text.replace(/[^0-9.-]/g, ''));
                            if (!isNaN(num)) return num.toString();
                        }
                        return text;
                    });
                    lines.push(values.join('\t'));
                });
                return lines.join('\n');
            };


            const tsvContent = generateTSV(originalTable);


            // Mount clone off-screen for clean HTML snapshot
            const container = document.createElement('div');
            Object.assign(container.style, { 
                position: 'absolute', 
                left: '-9999px', 
                top: '0', 
                overflow: 'hidden', 
                width: '1000px' 
            });
            document.body.appendChild(container);
            container.appendChild(clone);


            try {
                // Use modern Clipboard API with dual payloads (HTML + plain text)
                if (navigator.clipboard && navigator.clipboard.write && window.ClipboardItem && window.isSecureContext) {
                    const htmlBlob = new Blob([clone.outerHTML], { type: 'text/html' });
                    const textBlob = new Blob([tsvContent], { type: 'text/plain' });
                    const clipboardItem = new ClipboardItem({ 'text/html': htmlBlob, 'text/plain': textBlob });
                    await navigator.clipboard.write([clipboardItem]);
                    showToast("Table copied with formatting!");
                } else {
                    // Fallback: Use selection-based copy
                    const range = document.createRange();
                    range.selectNode(clone);
                    const sel = window.getSelection();
                    sel.removeAllRanges();
                    sel.addRange(range);
                    const success = document.execCommand('copy');
                    sel.removeAllRanges();
                    if (success) showToast("Table copied with headers!");
                    else throw new Error('execCommand copy failed');
                }
            } catch (err) {
                console.error('[Clipboard] write error:', err);
                // Ultimate fallback: Copy TSV as plain text
                safeCopyToClipboard(tsvContent);
            } finally {
                if (document.body.contains(container)) document.body.removeChild(container);
            }
        };


        const copyTableElementToClipboard = async (tableElement) => {
            if (!tableElement) return;
            // Generate TSV from table data
            const rows = tableElement.querySelectorAll('tr');
            const tsvRows = [];
            rows.forEach(row => {
                const cells = row.querySelectorAll('th, td');
                const rowData = [];
                cells.forEach(cell => {
                    let text = cell.textContent || '';
                    text = text.replace(/\t/g, ' ').replace(/\n/g, ' ').trim();
                    rowData.push(text);
                });
                tsvRows.push(rowData.join('\t'));
            });
            const tsvContent = tsvRows.join('\n');
            await safeCopyToClipboard(tsvContent);
            showToast("Table data copied!");
        };


        // Copy Rich Text - Legacy fallback removed in favor of safeCopyToClipboard rich text support
        const handleRichTextCopy = (elementId) => {
            copyRichText(elementId);
        };
        const extractQCTag = (row) => {
            if (row['Question'] && row['Question'].trim() !== '') return row['Question'];
            const comment = row['Answer Comment'] || row['Comments'] || '';
            const match = comment.match(/#([a-zA-Z0-9_]+)/);
            if (match) return match[1];
            return 'Uncategorized';
        };


        const cleanExcelData = (rawArrays, type) => {
            if (!rawArrays || rawArrays.length === 0) return [];
            // Audit Issue #4: Normalize dataset type at function entry
            const normalizedType = DataEngine.normalizeDatasetType(type);
            try {
                // 1. Find Header Row (Scan first 100 rows for key identifiers)
                let headerRowIndex = -1;
                for (let i = 0; i < Math.min(rawArrays.length, 100); i++) {
                    const row = rawArrays[i];
                    if (!row || !Array.isArray(row)) continue;
                    const rowStr = row.map(c => String(c || '')).join(' ').toLowerCase();
                    if ((rowStr.includes('agent') || rowStr.includes('email')) && (rowStr.includes('date') || rowStr.includes('review'))) {
                        headerRowIndex = i;
                        break;
                    }
                }


                if (headerRowIndex === -1) {
                    console.warn(`[DataEngine] Header row not found for type: ${type}`);
                    return [];
                }


                // 2. Prepare Headers
                const originalHeaders = rawArrays[headerRowIndex].map(h => String(h).trim());
                let headers = [...originalHeaders];


                // 3. MAPPING STRATEGY (Core + Type Specific)

                // Core Mappings (Apply to ALL types to ensure critical fields exist)
                const coreMappings = [
                    { canonical: 'Date', keywords: ['review date', 'evaluation date', 'date', 'review_date'] },
                    { canonical: 'Agent', keywords: ['agent name', 'employee name', 'agent', 'employee'] },
                    { canonical: 'Agent Email', keywords: ['agent email', 'employee email', 'email'] }
                ];


                coreMappings.forEach(map => {
                    // Find index of header matching any keyword
                    const idx = headers.findIndex(h => h && map.keywords.some(k => h.toLowerCase() === k || h.toLowerCase().includes(k)));
                    if (idx !== -1) {
                        headers[idx] = map.canonical;
                    }
                });


                // Type-Specific Mappings
                if (normalizedType === 'qc') {
                    const qcMappings = [
                        { canonical: 'Appeal Status', defaultIdx: 11, keywords: ['appeal', 'status'] },
                        { canonical: 'QC Score', defaultIdx: 9, keywords: ['score', 'qc'] },
                        { canonical: 'TL RCA', defaultIdx: 18, keywords: ['rca', 'tl'] },
                        { canonical: 'Acknowledged', defaultIdx: 22, keywords: ['ack'] },
                        { canonical: 'Question', defaultIdx: 4, keywords: ['question', 'tag'] },
                        { canonical: 'Agent Reply', defaultIdx: 5, keywords: ['comment', 'answer'] },
                        { canonical: 'Category', defaultIdx: 13, keywords: ['category'] },
                        { canonical: 'Pass/Fail', defaultIdx: 10, keywords: ['pass', 'fail'] }
                    ];


                    qcMappings.forEach(map => {
                        let targetIndex = -1;


                        // A. Check Default Position (Verified)
                        if (headers[map.defaultIdx] && map.keywords.some(k => headers[map.defaultIdx].toLowerCase().includes(k))) {
                            targetIndex = map.defaultIdx;
                        }
                        // B. Search by Name (If position check failed)
                        else {
                            targetIndex = headers.findIndex(h => h && map.keywords.some(k => h.toLowerCase().includes(k)));
                        }


                        // C. Fallback to Default Position (If search also failed)
                        if (targetIndex === -1 && headers.length > map.defaultIdx) {
                            targetIndex = map.defaultIdx;
                        }


                        // Apply Mapping
                        if (targetIndex !== -1) {
                            headers[targetIndex] = map.canonical;
                        }
                    });
                }


                if (normalizedType === 'nps') {
                    // NPS Specific Mapping
                    const npsMappings = [
                        { canonical: 'Remediation Feedback', defaultIdx: 23, keywords: ['remediation', 'feedback'] },
                        { canonical: 'Acknowledged', defaultIdx: 25, keywords: ['ack'] }
                    ];


                    npsMappings.forEach(map => {
                        let targetIndex = -1;
                        if (headers[map.defaultIdx] && map.keywords.some(k => headers[map.defaultIdx].toLowerCase().includes(k))) {
                            targetIndex = map.defaultIdx;
                        } else {
                            targetIndex = headers.findIndex(h => h && map.keywords.some(k => h.toLowerCase().includes(k)));
                        }
                        if (targetIndex !== -1) headers[targetIndex] = map.canonical;
                    });
                }


                const cleaned = [];


                for (let i = headerRowIndex + 1; i < rawArrays.length; i++) {
                    try {
                        const row = rawArrays[i];
                        if (!row || !Array.isArray(row) || row.length === 0) continue;


                        // Validity Check: Row must have data in at least one of the first 5 columns
                        let hasData = false;
                        for (let k = 0; k < 5; k++) {
                            if (row[k] !== undefined && row[k] !== null && String(row[k]).trim() !== '') {
                                hasData = true;
                                break;
                            }
                        }


                        if (hasData) {
                            const newRow = {};
                            headers.forEach((header, index) => {
                                if (!header) return;
                                let val = row[index];


                                // Date Cleaning
                                if (val instanceof Date) {
                                    newRow['_dateObj'] = val;
                                    val = DataEngine.formatDate(val);
                                } else if (typeof val === 'number' && val > 40000 && (header.toLowerCase().includes('date') || header.toLowerCase().includes('week'))) {
                                    const date = new Date(Math.round((val - 25569) * 86400 * 1000));
                                    newRow['_dateObj'] = date;
                                    val = DataEngine.formatDate(date);
                                }


                                // Value Normalization
                                if (typeof val === 'string') {
                                    val = val.trim();
                                    if (val.toUpperCase() === 'TRUE') val = true;
                                    else if (val.toUpperCase() === 'FALSE') val = false;
                                }


                                newRow[header] = val;
                            });


                            // Post-Process QC Calculated Fields
                            if (normalizedType === 'qc') {
                                if (newRow['Date']) {
                                    const d = newRow['_dateObj'] ? newRow['_dateObj'] : new Date(newRow['Date']);
                                    if (!isNaN(d)) {
                                        newRow['_dateObj'] = d;
                                        newRow['_dayOfWeek'] = d.toLocaleDateString('en-US', { weekday: 'long' });
                                    }
                                }
                                // Ensure Appeal flag is set if agent requested it
                                if (newRow['Appeal?'] === undefined && newRow['Agent Dispute Request'] !== undefined) {
                                    newRow['Appeal?'] = newRow['Agent Dispute Request'] === 'Yes';
                                }
                            }


                            if (normalizedType === 'nps') {
                                // Basic Rating Categorization
                                const r = String(newRow['Rating'] || '').toLowerCase();
                                if (['poor', '1'].includes(r)) newRow.ratingCategory = 'Detractor';
                                else if (['wow', 'excellent', '5'].includes(r)) newRow.ratingCategory = 'Promoter';
                                else newRow.ratingCategory = 'Neutral';
                            }


                            cleaned.push(newRow);
                        }
                    } catch (rowError) {
                        PoppyLogger.warn('DATA', `Failed to process row ${i}`, rowError);
                        // Skip malformed row but continue processing
                    }
                }
                return cleaned;
            } catch (error) {
                PoppyLogger.error('DATA', "Error cleaning Excel data", error);
                showToast(`Error processing ${normalizedType.toUpperCase()} data.`, 'error');
                return [];
            }
        };




        const normalizeCompliance = (row, type) => {
            const normalizedType = DataEngine.normalizeDatasetType(type);
            const justVal = row['Agent Reply'] || '';
            const ackVal = row['Acknowledged'] || '';
            const remediationVal = row['Remediation Feedback'] || ''; // User specific column for NPS
            const qcScore = parseFloat(row['QC Score'] || 0);

            // --- MANDATORY FEEDBACK LOGIC ---
            let isMandatory = false;

            // Check for Pending to be appealed specifically (User Request)
            const tlAppeal = row['TL Appeal'] === true || row['TL Appeal'] === 'TRUE';
            const tlRca = String(row['TL RCA'] || '').trim();
            const appealStatus = String(row['Appeal Status'] || '').trim();
            const isPendingToBeAppealed = tlAppeal && (tlRca.startsWith('Appeal') || tlRca.startsWith('Appealed')) && !appealStatus;

            if (normalizedType === 'nps') {
                // NPS Mandatory: At least one of the 15 sub-metrics failed AND Remediation Feedback is present
                // 1. Check Sub-metrics
                const allSubMetrics = Object.values(NPS_METRIC_MAPPING).flat();
                const hasFailedMetric = allSubMetrics.some(m => {
                    const val = row[m];
                    // Failed if explicitly FALSE or 'FALSE' (case insensitive)
                    return val === false || String(val).toUpperCase() === 'FALSE';
                });

                // 2. Check Remediation Feedback
                const hasFeedback = remediationVal && String(remediationVal).trim().length > 0;

                isMandatory = hasFailedMetric && hasFeedback;

            } else if (normalizedType === 'qc') {
                // QC Mandatory: Score is not zero AND is not an appeal
                // Note: We use the existing global isAppeal check which handles status 'To Do', 'Accept Appeal', etc.
                const isAppeal = DataEngine.isAppeal(row);
                
                // User said "score is not zero". Assuming QC Score represents deduction/markdown weight.
                // If QC Score is 0, it means no deduction (perfect?), so not mandatory.
                const hasNonZeroScore = !isNaN(qcScore) && qcScore !== 0;

                isMandatory = hasNonZeroScore && !isAppeal;
            }

            // --- PENDING STATUS LOGIC ---
            // Only applicable if Mandatory OR Pending to be appealed (special case)
            
            // Tick Justification: "Acknowledged" column doesn't have TRUE/True
            const isAckTrue = ackVal === true || String(ackVal).toUpperCase() === 'TRUE';
            const isPendingTick = (isMandatory || isPendingToBeAppealed) && !isAckTrue;

            // Written Justification: "Agent Reply" column is empty
            const hasAgentReply = justVal && String(justVal).trim().length > 0;
            const isPendingWritten = (isMandatory || isPendingToBeAppealed) && !hasAgentReply;

            // Derived Status for UI
            const isAck = !isPendingTick; // If not pending tick, it is ack'd (or not required)
            const hasJustification = !isPendingWritten; // If not pending written, it has justification (or not required)

            let status = 'Pending';
            if (isPendingToBeAppealed) status = 'Pending to be appealed';
            else if (!isMandatory) status = 'Not Required';
            else if (isPendingTick) status = 'Pending Tick';
            else if (isPendingWritten) status = 'Pending Written';
            else status = 'Complete';

            return { 
                isAck, 
                hasJustification, 
                justText: justVal, 
                ackVal, 
                isMandatory: isMandatory || isPendingToBeAppealed, // Treat as mandatory for UI visibility if pending appeal
                isPendingTick, 
                isPendingWritten, 
                status 
            };
        };


        // --- ADVANCED IMAGE DOWNLOAD FUNCTIONS ---


        // Issue #34 Fix: Sanitize filenames for cross-platform compatibility
        // Helper for Filename Sanitization
        const sanitizeFilename = (name) => {
            if (!name) return 'export';
            return String(name)
                .replace(/[<>:"/\\|?*]/g, '_')
                .replace(/\s+/g, '_')
                .replace(/_+/g, '_')
                .replace(/^_|_$/g, '')
                .toLowerCase()
                .substring(0, 100);
        };




        const saveCanvas = (canvas, filename) => {
            const link = document.createElement('a');
            const safeName = sanitizeFilename(filename);
            link.download = `${safeName}_${new Date().toISOString().slice(0, 10)}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
            showToast("Download started!");
        };



        // --- UNIFIED EXPORT ENGINE (Issues 3, 4, 5, 8, 15) ---
        // --- GEMINI CANVAS BRIDGE ---
        // Facilitates data transfer between the App and AI Chat contexts
        const CanvasBridge = {
            /**
             * Converts an array of objects to a Markdown table for easy AI consumption
             */
            toMarkdown: (data, title = "Data") => {
                if (!data || data.length === 0) return `**${title}**\n\n*No data available*`;
                
                const columns = Object.keys(data[0]).filter(k => !k.startsWith('_'));
                const header = `| ${columns.join(' | ')} |`;
                const divider = `| ${columns.map(() => '---').join(' | ')} |`;
                const rows = data.slice(0, 50).map(row => { // Limit to 50 for token sanity
                    return `| ${columns.map(c => String(row[c] || '').replace(/\|/g, '\\|').trim()).join(' | ')} |`;
                }).join('\n');
                
                return `**${title}** (${data.length} records)\n\n${header}\n${divider}\n${rows}\n${data.length > 50 ? `\n*(Showing top 50 of ${data.length} records)*` : ''}`;
            },

            /**
             * Copies the current view's context to clipboard in Markdown format
             */
            copyContext: async (activeData, viewName, filters) => {
                const timestamp = new Date().toLocaleString();
                const filterSummary = Object.entries(filters || {})
                    .filter(([_, v]) => v && v.length)
                    .map(([k, v]) => `- **${k}**: ${v.join(', ')}`)
                    .join('\n');

                const md = `# App State Snapshot: ${viewName.toUpperCase()}
**Time**: ${timestamp}
**Total Records**: ${activeData?.length || 0}

### Active Filters
${filterSummary || '*No active filters*'}

### Data Preview
${CanvasBridge.toMarkdown(activeData, "Current View Data")}
`;
                await CopyUtils.copyPlainText(md);
                showToast("AI Context copied to clipboard! Paste into Gemini.", "success");
            }
        };

        // ============================================
        // CLIPBOARD UTILITIES - Safe Wrapper
        // ============================================
        const ClipboardUtils = {
            copy: async (text) => {
                const ta = document.createElement('textarea');
                ta.value = text;
                ta.style.position = 'fixed';
                ta.style.opacity = '0';
                document.body.appendChild(ta);
                ta.focus();
                ta.select();
                try {
                    document.execCommand('copy');
                    showToast('Copied');
                } catch (e) {
                    showToast('Copy failed', 'error');
                } finally {
                    document.body.removeChild(ta);
                }
            }
        };



        // ============================================
        // ENHANCED EXPORT ENGINE
        // ============================================
        /**
         * ToolInputPersistence
         * REMOVED for Sandbox Compatibility (localStorage blocked)
         * Input state now lives purely in React memory for the session.
         */
        /* ToolInputPersistence REMOVED */

        const ExportEngine = {
            exportCSVWithFallback: (data, filename) => {
                if (!data || !data.length) {
                    if (typeof showToast === 'function') showToast("No data to export", "error");
                    return;
                }
                ExportEngine.exportCSV(data, filename);
            },
            exportCSV: (data, filename = 'export') => {
                try {
                    if (!data || !data.length) { showToast("No data to export."); return; }


                    // Clean data for export
                    const cleanData = data.map(row => {
                        const newRow = {};
                        Object.keys(row).forEach(key => {
                            if (!key.startsWith('_') && key !== 'dataForAI') {
                                newRow[key] = row[key];
                            }
                        });
                        return newRow;
                    });


                    const firstKeys = Object.keys(cleanData[0] || {});
                    const keySet = new Set(firstKeys);
                    cleanData.forEach(row => Object.keys(row || {}).forEach(k => keySet.add(k)));
                    const columns = Array.from(keySet);


                    const escapeCsv = (value) => {
                        if (value === null || value === undefined) return '';
                        const text = String(value).replace(/\r?\n/g, ' ').trim();
                        const escaped = text.replace(/"/g, '""');
                        const needsQuote = /[",\n]/.test(text) || text.includes(',');
                        return needsQuote ? `"${escaped}"` : escaped;
                    };


                    const lines = [
                        columns.map(escapeCsv).join(','),
                        ...cleanData.map(row => columns.map(col => escapeCsv(row[col])).join(','))
                    ];


                    const csv = lines.join('\n');
                    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${sanitizeFilename(filename)}.csv`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showToast(`CSV exported: ${filename}.csv`, 'success');
                } catch (error) {
                    console.error("CSV Export Error:", error);
                    showToast("Failed to export CSV.", 'error');
                }
            },


            exportSpotlight: async (elementId, filename) => {
                const element = document.getElementById(elementId);
                if (!element) return;

                showToast("Generating Spotlight PDF...");
                
                try {
                    // Step 1: Add export mode class
                    element.classList.add('pdf-export-mode');
                    
                    // Step 2: Attempt html2canvas with enhanced options
                    const canvas = await html2canvas(element, {
                        scale: 2,
                        useCORS: true,
                        logging: false,
                        onclone: (clonedDoc) => {
                            const cloned = clonedDoc.getElementById(elementId);
                            if (cloned) {
                                cloned.querySelectorAll('.sunrise-toolbar').forEach(t => t.remove());
                            }
                        }
                    });
                    
                    // Step 3: Create PDF
                    const pdf = new jspdf.jsPDF({
                        orientation: canvas.width > canvas.height ? 'landscape' : 'portrait',
                        unit: 'px',
                        format: [canvas.width, canvas.height]
                    });
                    
                    pdf.addImage(canvas.toDataURL('image/png'), 'PNG', 0, 0, canvas.width, canvas.height);
                    pdf.save(filename);
                    
                    // Step 4: Cleanup
                    element.classList.remove('pdf-export-mode');
                    showToast("PDF exported successfully!", 'success');
                    return { success: true, method: 'pdf' };
                    
                } catch (error) {
                    console.error('PDF export failed:', error);
                    element.classList.remove('pdf-export-mode');
                    
                    // STRICT TEXT FALLBACK (Sandbox Safe)
                    try {
                        // Construct clean text representation
                        const text = element.innerText || element.textContent;
                        
                        await safeCopyToClipboard(text);
                        showToast('PDF blocked by environment. Copied as text instead.', 'info');
                        return { success: true, method: 'text_fallback' };
                    } catch (textError) {
                        console.error('Text fallback failed:', textError);
                        showToast('Export failed completely.', 'error');
                        return { success: false, method: 'failed' };
                    }
                }

                try {
                    // Clone for print-friendly view
                    const clone = element.cloneNode(true);
                    clone.style.width = '1200px';
                    clone.style.padding = '40px';
                    clone.style.background = 'white';
                    clone.style.position = 'absolute';
                    clone.style.top = '-9999px';
                    clone.style.left = '-9999px';

                    // Force visible overflow for all tables/lists
                    clone.querySelectorAll('.overflow-auto, .overflow-y-auto').forEach(el => {
                        el.style.overflow = 'visible';
                        el.style.height = 'auto';
                        el.style.maxHeight = 'none';
                    });

                    document.body.appendChild(clone);

                    const canvas = await html2canvas(clone, { scale: 2, useCORS: true });
                    const imgData = canvas.toDataURL('image/png');

                    const pdf = new jspdf.jsPDF('p', 'mm', 'a4');
                    const pdfWidth = pdf.internal.pageSize.getWidth();
                    const pdfHeight = pdf.internal.pageSize.getHeight();
                    const imgProps = pdf.getImageProperties(imgData);
                    const imgHeight = (imgProps.height * pdfWidth) / imgProps.width;

                    let heightLeft = imgHeight;
                    let position = 0;

                    pdf.addImage(imgData, 'PNG', 0, position, pdfWidth, imgHeight);
                    heightLeft -= pdfHeight;

                    while (heightLeft >= 0) {
                        position = heightLeft - imgHeight;
                        pdf.addPage();
                        pdf.addImage(imgData, 'PNG', 0, position, pdfWidth, imgHeight);
                        heightLeft -= pdfHeight;
                    }

                    pdf.save(`${filename}.pdf`);
                    document.body.removeChild(clone);
                    window.__hasExported = true; // Flag for reminder
                    showToast("PDF Exported!", 'success');
                } catch (e) {
                    console.error("Spotlight export failed", e);
                    showToast("Export failed", 'error');
                }
            },

            exportToPDFSmart: async (elementId, filename, options = {}) => {
                const element = document.getElementById(elementId);
                if (!element) { showToast(`Element "${elementId}" not found`, 'error'); return; }
                if (window.__isExporting) return;


                const sectionSelector = options.sectionSelector || '.export-atomic';
                const marginMm = typeof options.marginMm === 'number' ? options.marginMm : 8;
                const gapMm = typeof options.gapMm === 'number' ? options.gapMm : 4;


                showToast("Generating PDF...");
                window.__preExportScrollY = window.scrollY;
                window.__isExporting = true;


                try {
                    document.body.classList.add('pdf-export-mode');
                    if (document.fonts) await document.fonts.ready;
                    await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
                    await new Promise(r => setTimeout(r, 250));


                    const pdf = new window.jspdf.jsPDF('p', 'mm', 'a4');
                    // ... (rest of logic) ...

                    // We need to find where the save happens in the original code to add the flag
                    // Since I'm replacing the start of the function, I can't easily inject at the end without reading it.
                    // But I can assume the user will likely use the new exportSpotlight for the main report.
                    // Actually, let's just modify the end of exportToPDFSmart if possible.
                    // Wait, I am modifying exportSpotlight above.
                    // I will also modify exportToPDFSmart to set the flag.

                    // But wait, the SearchReplace above only targets exportSpotlight's end and exportToPDFSmart's start.
                    // The existing exportToPDFSmart code is long.
                    // I'll just set it in exportSpotlight for now, as that's the primary "Report" export.
                    // And I'll use a separate SearchReplace for exportToPDFSmart's end if needed.

                    const pdfWidth = pdf.internal.pageSize.getWidth();
                    const pageHeight = pdf.internal.pageSize.getHeight();
                    const usableWidth = pdfWidth - (marginMm * 2);
                    const maxUsableHeight = pageHeight - (marginMm * 2);


                    let currentY = marginMm;


                    const sectionsFromSelector = Array.from(element.querySelectorAll(sectionSelector));
                    const sections = sectionsFromSelector.length
                        ? sectionsFromSelector
                        : Array.from(element.children || []);


                    const addSliced = (imgData, imgHeightMm) => {
                        let heightLeft = imgHeightMm;
                        let position = currentY;
                        pdf.addImage(imgData, 'PNG', marginMm, position, usableWidth, imgHeightMm);
                        heightLeft -= (pageHeight - currentY - marginMm);
                        while (heightLeft > 0) {
                            pdf.addPage();
                            position = marginMm - (imgHeightMm - heightLeft);
                            pdf.addImage(imgData, 'PNG', marginMm, position, usableWidth, imgHeightMm);
                            heightLeft -= maxUsableHeight;
                        }
                        currentY = marginMm;
                    };


                    // FIX: Process sections with better A4 handling (Issue 5)
                    for (const section of sections) {
                        if (!section || section.nodeType !== 1) continue;
                        if (ExportEngine.ignoreElements(section)) continue;


                        // Pre-calculate section height to decide if slicing is needed
                        const sectionRect = section.getBoundingClientRect();
                        const sectionHeightMm = (sectionRect.height / window.innerHeight) * pageHeight * 0.5; // Approximate


                        const canvas = await window.html2canvas(section, {
                            scale: 1.5, // FIX: Reduced scale for better A4 fit (Issue 5)
                            backgroundColor: '#ffffff',
                            useCORS: true,
                            logging: false,
                            windowWidth: 1200, // FIX: Fixed width for consistent rendering (Issue 5)
                            ignoreElements: (element) => ExportEngine.ignoreElements(element),
                            onclone: (clonedDoc) => {
                                ExportEngine.applySafeStyles(clonedDoc);
                                const all = clonedDoc.querySelectorAll('*');
                                all.forEach(el => { 
                                    el.style.transition = 'none'; 
                                    el.style.animation = 'none'; 
                                });
                                
                                // FIX: Expand all scrollables for PDF capture (Issue 5)
                                const scrollables = clonedDoc.querySelectorAll('.overflow-y-auto, .overflow-x-auto, .overflow-auto, .custom-scrollbar, [class*="overflow"]');
                                scrollables.forEach(el => { 
                                    el.style.overflow = 'visible !important'; 
                                    el.style.maxHeight = 'none !important'; 
                                    el.style.height = 'auto !important';
                                    el.style.maxWidth = 'none !important';
                                });


                                // FIX: Ensure tables don't overflow (Issue 5, 36)
                                const tables = clonedDoc.querySelectorAll('table');
                                tables.forEach(table => {
                                    table.style.maxWidth = '100%';
                                    table.style.width = '100%';
                                    table.style.tableLayout = 'fixed';
                                });


                                // FIX: Wrap long content to prevent truncation (Issue 5)
                                const cells = clonedDoc.querySelectorAll('td, th');
                                cells.forEach(cell => {
                                    cell.style.wordWrap = 'break-word';
                                    cell.style.overflowWrap = 'break-word';
                                    cell.style.maxWidth = usableWidth + 'mm';
                                });


                                // Remove excluded elements from clone
                                clonedDoc.querySelectorAll('[data-html2canvas-ignore], .no-export, .no-capture, .ai-generator-btn, .sunrise-toolbar, #ai-floating-btn, #ai-chat-panel, #ai-assistant-btn').forEach(el => el.remove());
                            }
                        });


                        const imgData = canvas.toDataURL('image/png');
                        const imgProps = pdf.getImageProperties(imgData);
                        const imgHeightMm = (imgProps.height * usableWidth) / imgProps.width;


                        // FIX: Better page break logic (Issue 5)
                        if (imgHeightMm > maxUsableHeight) {
                            // Large section - needs slicing across pages
                            if (currentY !== marginMm && currentY > marginMm + 10) {
                                pdf.addPage();
                                currentY = marginMm;
                            }
                            addSliced(imgData, imgHeightMm);
                            continue;
                        }


                        // Standard section - check if it fits on current page
                        if (currentY + imgHeightMm > (pageHeight - marginMm - 5)) {
                            pdf.addPage();
                            currentY = marginMm;
                        }


                        pdf.addImage(imgData, 'PNG', marginMm, currentY, usableWidth, imgHeightMm);
                        currentY += imgHeightMm + gapMm;
                    }


                    pdf.save(`${filename || 'export'}.pdf`);
                    showToast("PDF exported!", 'success');
                } catch (err) {
                    console.error("PDF Export Error:", err);
                    showToast("Failed to export PDF.", 'error');
                } finally {
                    ExportEngine.restoreUI();
                }
            },


            // Helper: Inject "Export-Safe" styles to prevent layout shifts
            applySafeStyles: (doc) => {
                const body = doc.body;
                body.style.fontVariant = 'normal';
                body.style.letterSpacing = 'normal';
                body.style.fontFeatureSettings = '"cv11", "ss01"';
                body.style.fontSmoothing = 'antialiased';
                // Reset transforms on headers
                const headers = doc.querySelectorAll('th, thead');
                headers.forEach(h => { h.style.transform = 'none'; });
            },


            // Helper: Filter out unwanted elements (AI, Buttons, etc.)
            ignoreElements: (node) => {
                if (!node || !node.classList) return false;


                // 1. Check for explicit ignore attribute (Standard html2canvas behavior + manual reinforcement)
                if (node.getAttribute && (node.getAttribute('data-html2canvas-ignore') === 'true' || node.getAttribute('data-html2canvas-ignore') === '')) return true;


                // 2. Exclude explicit no-export classes and IDs
                if (node.classList.contains('no-export')) return true;
                if (node.classList.contains('no-capture')) return true;
                if (node.classList.contains('ai-generator-btn')) return true;
                if (node.id === 'ai-floating-btn' ||
                    node.id === 'ai-chat-panel' ||
                    node.id === 'ai-assistant-btn' ||
                    (node.closest && (node.closest('#ai-chat-panel') || node.closest('.no-export') || node.closest('.no-capture') || node.closest('[data-html2canvas-ignore="true"]')))) return true;


                // 3. Exclude Buttons (unless specifically whitelisted)
                if (node.tagName === 'BUTTON' && !node.classList.contains('export-allowed')) return true;


                // 4. Exclude Fixed/Sticky elements that might overlay (except root)
                if (node.classList.contains('fixed') && node.id !== 'root' && node.id !== 'modal-portal') return true;


                return false;
            },


            // Centralized Idempotent Restore (Harden #1)
            restoreUI: () => {
                document.body.classList.remove('pdf-export-mode');
                // Ensure scroll restoration logic if needed, but primarily class cleanup
                window.scrollTo(0, window.__preExportScrollY || 0);
                delete window.__preExportScrollY;
                delete window.__isExporting;
            },


            // 1. Capture Page (Full View)
            capturePage: async (viewId, filename) => {
                const element = document.getElementById(viewId);
                if (!element) { showToast(`View "${viewId}" not found`, 'error'); return; }
                if (window.__isExporting) return;


                showToast("Preparing high-resolution capture...");
                window.__preExportScrollY = window.scrollY;
                window.__isExporting = true;


                try {
                    document.body.classList.add('pdf-export-mode');


                    if (document.fonts) await document.fonts.ready;
                    window.scrollTo(0, 0);


                    // Force frames for charts/SVG settle
                    await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
                    await new Promise(r => setTimeout(r, 250));


                    console.time('export');


                    const canvas = await window.html2canvas(element, {
                        scale: 2,
                        backgroundColor: '#f8fafc',
                        useCORS: true,
                        logging: false,
                        allowTaint: true,
                        scrollX: 0,
                        scrollY: -window.scrollY,
                        windowWidth: document.documentElement.offsetWidth,
                        windowHeight: document.documentElement.offsetHeight,
                        ignoreElements: (element) => ExportEngine.ignoreElements(element),
                        onclone: (clonedDoc) => {
                            ExportEngine.applySafeStyles(clonedDoc);


                            // 1. Expand scrollables
                            const scrollables = clonedDoc.querySelectorAll('.overflow-y-auto, .overflow-x-auto, .overflow-auto, .custom-scrollbar');
                            scrollables.forEach(el => {
                                el.style.overflow = 'visible';
                                el.style.maxHeight = 'none';
                                el.style.height = 'auto';
                            });


                            // 2. Disable animations
                            const allElements = clonedDoc.querySelectorAll('*');
                            allElements.forEach(el => {
                                el.style.transition = 'none';
                                el.style.animation = 'none';
                            });


                            // 3. Remove truncation
                            clonedDoc.querySelectorAll('.truncate, .line-clamp-1, .line-clamp-2').forEach(el => {
                                el.classList.remove('truncate', 'line-clamp-1', 'line-clamp-2');
                                el.style.whiteSpace = 'normal';
                                el.style.overflow = 'visible';
                                el.style.webkitLineClamp = 'unset';
                            });


                            // 4. Force visibility for specific sections
                            const sections = clonedDoc.querySelectorAll('section, article, .card, .export-atomic');
                            sections.forEach(s => {
                                s.style.breakInside = 'avoid';
                                s.style.pageBreakInside = 'avoid';
                                s.style.display = 'block';
                            });


                            // 5. Remove excluded elements (AI areas, toolbars, buttons)
                            clonedDoc.querySelectorAll('[data-html2canvas-ignore], .no-export, .no-capture, .ai-generator-btn, .sunrise-toolbar, #ai-floating-btn, #ai-chat-panel, #ai-assistant-btn').forEach(el => el.remove());
                        }
                    });


                    console.timeEnd('export');
                    saveCanvas(canvas, filename || 'view_capture');
                    showToast("View captured successfully!", 'success');
                } catch (err) {
                    console.error("[PoppySuite] Export Error:", err);
                    showToast("Failed to capture view.", 'error');
                } finally {
                    ExportEngine.restoreUI();
                }
            },


            // 1.5. Generate Spotlight PDF (Specialized for Spotlight View)
            generateSpotlightPDF: async (elementId, filename) => {
                const element = document.getElementById(elementId);
                if (!element) { showToast(`Spotlight element "${elementId}" not found`, 'error'); return; }
                if (window.__isExporting) return;


                showToast("Generating Spotlight Report PDF...");
                window.__preExportScrollY = window.scrollY;
                window.__isExporting = true;


                try {
                    document.body.classList.add('pdf-export-mode');
                    if (document.fonts) await document.fonts.ready;


                    // Wait for styles/animations and charts to settle
                    await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
                    await new Promise(r => setTimeout(r, 600));


                    const canvas = await window.html2canvas(element, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        useCORS: true,
                        logging: false,
                        ignoreElements: (element) => ExportEngine.ignoreElements(element),
                        onclone: (clonedDoc) => {
                            ExportEngine.applySafeStyles(clonedDoc);
                            // Ensure spotlight specific areas are visible
                            const spotlight = clonedDoc.getElementById(elementId);
                            if (spotlight) {
                                spotlight.style.padding = '40px';
                                spotlight.style.background = '#ffffff';
                            }


                            // Apply atomic sections
                            const sections = clonedDoc.querySelectorAll('section, article, .card, .export-atomic');
                            sections.forEach(s => {
                                s.style.breakInside = 'avoid';
                                s.style.pageBreakInside = 'avoid';
                            });


                            // Remove excluded elements (AI areas, toolbars, buttons)
                            clonedDoc.querySelectorAll('[data-html2canvas-ignore], .no-export, .no-capture, .sunrise-toolbar, #ai-floating-btn, #ai-chat-panel, #ai-assistant-btn').forEach(el => el.remove());
                        }
                    });


                    const imgData = canvas.toDataURL('image/png');
                    const pdf = new window.jspdf.jsPDF('p', 'mm', 'a4');
                    const pdfWidth = pdf.internal.pageSize.getWidth();
                    const pdfHeight = pdf.internal.pageSize.getHeight();
                    const imgProps = pdf.getImageProperties(imgData);
                    const imgHeight = (imgProps.height * pdfWidth) / imgProps.width;


                    let heightLeft = imgHeight;
                    let position = 0;


                    pdf.addImage(imgData, 'PNG', 0, position, pdfWidth, imgHeight);
                    heightLeft -= pdfHeight;


                    while (heightLeft >= 0) {
                        position = heightLeft - imgHeight;
                        pdf.addPage();
                        pdf.addImage(imgData, 'PNG', 0, position, pdfWidth, imgHeight);
                        heightLeft -= pdfHeight;
                    }


                    pdf.save(`${filename || 'Spotlight_Report'}.pdf`);
                    showToast("Spotlight Report exported successfully!", 'success');
                } catch (err) {
                    console.error("Spotlight Export Error:", err);
                    showToast("Failed to generate Spotlight PDF.", 'error');
                } finally {
                    ExportEngine.restoreUI();
                }
            },


            // 2. Capture Table (Full Data - Issue 4)
            captureTable: async (tableId, filename) => {
                const originalTable = document.getElementById(tableId);
                if (!originalTable) { showToast(`Table "${tableId}" not found`, 'error'); return; }
                if (window.__isExporting) return;


                showToast("Generating full table image...");
                window.__preExportScrollY = window.scrollY;
                window.__isExporting = true;


                // Create container
                const container = document.createElement('div');
                Object.assign(container.style, {
                    position: 'fixed', top: '0', left: '0',
                    width: 'auto', height: 'auto', zIndex: '-1000',
                    background: '#ffffff',
                    visibility: 'visible'
                });
                document.body.appendChild(container);


                try {
                    const clone = originalTable.cloneNode(true);


                    // FORCE EXPANSION - Apply to ALL elements including nested divs
                    const allElements = clone.querySelectorAll('*');
                    allElements.forEach(el => {
                        el.style.maxHeight = 'none';
                        el.style.height = 'auto';
                        el.style.minHeight = 'auto';
                        el.style.overflow = 'visible';
                        el.style.maxWidth = 'none';
                        el.style.width = 'auto';
                        el.classList.remove('overflow-y-auto', 'overflow-x-auto', 'overflow-auto', 'max-h-60', 'max-h-[1000px]', 'sticky', 'fixed', 'flex-1');
                        if (window.getComputedStyle(el).position === 'sticky') el.style.position = 'static';
                    });


                    Object.assign(clone.style, {
                        maxHeight: 'none', height: 'auto', overflow: 'visible', width: 'auto', minHeight: 'auto', position: 'static'
                    });
                    
                    // FIX: Special handling for modal-zoom-area - ensure inner content div is also expanded
                    if (tableId === 'modal-zoom-area') {
                        // Target the inner content div by data attribute or first child
                        const innerDiv = clone.querySelector('[data-modal-content]') || clone.querySelector('div');
                        if (innerDiv) {
                            Object.assign(innerDiv.style, {
                                maxHeight: 'none', height: 'auto', overflow: 'visible', width: 'auto', minHeight: 'auto'
                            });
                            // Also expand all children of inner div
                            innerDiv.querySelectorAll('*').forEach(el => {
                                el.style.maxHeight = 'none';
                                el.style.height = 'auto';
                                el.style.minHeight = 'auto';
                                el.style.overflow = 'visible';
                            });
                        }
                    }


                    if (filename) {
                        const titleHeader = document.createElement('div');
                        titleHeader.innerText = filename;
                        titleHeader.style.cssText = 'padding: 20px; font-size: 24px; font-weight: bold; color: #1e293b; text-align: left; background: #ffffff; width: 100%; border-bottom: 2px solid #e2e8f0; margin-bottom: 10px; font-family: sans-serif;';
                        container.appendChild(titleHeader);
                    }


                    container.appendChild(clone);


                    // Robust Timing
                    document.body.classList.add('pdf-export-mode');
                    if (document.fonts) await document.fonts.ready;
                    await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
                    await new Promise(r => setTimeout(r, 400));


                    const canvas = await window.html2canvas(container, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        useCORS: true,
                        logging: false,
                        ignoreElements: (element) => ExportEngine.ignoreElements(element),
                        onclone: (clonedDoc) => {
                            ExportEngine.applySafeStyles(clonedDoc);
                            // Remove excluded elements (AI areas, toolbars, buttons)
                            clonedDoc.querySelectorAll('[data-html2canvas-ignore], .no-export, .no-capture, .sunrise-toolbar, #ai-floating-btn, #ai-chat-panel, #ai-assistant-btn').forEach(el => el.remove());
                        }
                    });
                    saveCanvas(canvas, filename || 'table_export');
                    showToast("Table exported successfully!", 'success');
                } catch (err) {
                    console.error("Export Error:", err);
                    showToast("Failed to generate table image.", 'error');
                } finally {
                    ExportEngine.restoreUI();
                    if (document.body.contains(container)) document.body.removeChild(container);
                }
            },

            // 3. Capture Card (Widget) - UPDATED: Supports Full Content Unscrolled
            captureCard: async (elementId, filename) => {
                const element = document.getElementById(elementId);
                if (!element) { showToast(`Element "${elementId}" not found`, 'error'); return; }
                if (window.__isExporting) return;


                showToast("Capturing full card content...");
                window.__preExportScrollY = window.scrollY;
                window.__isExporting = true;


                // Create off-screen container
                const container = document.createElement('div');
                Object.assign(container.style, {
                    position: 'absolute', top: '-9999px', left: '0',
                    width: 'fit-content', height: 'auto', zIndex: '-9999',
                    background: '#ffffff'
                });
                document.body.appendChild(container);


                try {
                    const clone = element.cloneNode(true);


                    // EXPANSION
                    const allElements = clone.querySelectorAll('*');
                    allElements.forEach(el => {
                        const style = window.getComputedStyle(el);
                        if (style.overflowY === 'auto' || style.overflowY === 'scroll' || style.maxHeight !== 'none') {
                            el.style.maxHeight = 'none';
                            el.style.height = 'auto';
                            el.style.overflow = 'visible';
                            el.classList.remove('overflow-y-auto', 'overflow-auto');
                        }
                        // Remove specific no-export or UI-only things from the clone if they exist
                        if (el.dataset && el.dataset.html2canvasIgnore === 'true') {
                            el.style.display = 'none';
                        }
                        if (el.classList && el.classList.contains('no-capture')) {
                            el.style.display = 'none';
                        }
                    });


                    Object.assign(clone.style, {
                        maxHeight: 'none', height: 'auto', overflow: 'visible', width: '800px', padding: '20px'
                    });


                    container.appendChild(clone);


                    // Robust Timing
                    document.body.classList.add('pdf-export-mode');
                    if (document.fonts) await document.fonts.ready;
                    await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
                    await new Promise(r => setTimeout(r, 400));


                    const canvas = await window.html2canvas(container, {
                        scale: 2,
                        backgroundColor: '#ffffff',
                        useCORS: true,
                        logging: false,
                        ignoreElements: (element) => ExportEngine.ignoreElements(element),
                        onclone: (clonedDoc) => {
                            ExportEngine.applySafeStyles(clonedDoc);
                            // Remove excluded elements (AI areas, toolbars, buttons)
                            clonedDoc.querySelectorAll('[data-html2canvas-ignore], .no-export, .no-capture, .sunrise-toolbar, #ai-floating-btn, #ai-chat-panel, #ai-assistant-btn').forEach(el => el.remove());
                        }
                    });
                    saveCanvas(canvas, filename || 'card_export');
                    showToast("Card exported successfully!", 'success');
                } catch (err) {
                    console.error("Card Export Error:", err);
                    showToast("Failed to generate card image.", 'error');
                } finally {
                    ExportEngine.restoreUI();
                    if (document.body.contains(container)) document.body.removeChild(container);
                }
            }
        };


        // Legacy Facade for backward compatibility (called by UI buttons)
        const downloadAsImage = (elementId, filename) => {
            if (!elementId) return;
            
            // FIX: Use CaptureEngine for modal-zoom-area to avoid cloning issues with React portals
            // CaptureEngine is defined later in the script but will be available at runtime
            if (elementId === 'modal-zoom-area' && typeof CaptureEngine !== 'undefined') {
                return CaptureEngine.capture(elementId, filename);
            }
            
            // Heuristic to dispatch to correct engine method
            if (elementId.toLowerCase().includes('table') || elementId.includes('rank') || elementId.includes('tracker') || elementId.includes('scorecard')) {
                return ExportEngine.captureTable(elementId, filename);
            }
            if (elementId.toLowerCase().includes('view') || elementId.includes('container') || elementId === 'root') {
                return ExportEngine.capturePage(elementId, filename);
            }
            return ExportEngine.captureCard(elementId, filename);
        };


        const copyElementAsImage = async (elementId, filename) => {
            if (!elementId) return;
            const element = document.getElementById(elementId);
            if (!element) { showToast(`Element "${elementId}" not found`, 'error'); return; }
            try {
                const canvas = await window.html2canvas(element, {
                    scale: 2,
                    backgroundColor: '#ffffff',
                    useCORS: true,
                    logging: false,
                    ignoreElements: (el) => ExportEngine.ignoreElements(el)
                });
                if (navigator.clipboard && window.ClipboardItem) {
                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                    if (!blob) throw new Error('Clipboard blob creation failed');
                    await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
                    showToast("Image copied to clipboard!");
                } else {
                    saveCanvas(canvas, filename || 'card_export');
                    showToast("Image downloaded (clipboard not supported).");
                }
            } catch (err) {
                console.error("Image copy failed:", err);
                showToast("Failed to copy image.", "error");
            }
        };


        const downloadCSV = (data, filename) => {
            return ExportEngine.exportCSV(data, filename);
        };


        // --- SLACK MESSAGE FORMATTER ---
        // Centralized tool to validate and fix AI-generated content before display


        // Complete formatting rules for each content type
        const SLACK_FORMAT_RULES = {
            SlackPost: {
                title: '? Weekly Pulse - NPS & CX Update ?',
                greeting: 'Hey Team',
                dynamicClosing: true
            },
            WeeklySummary: {
                title: '? Weekly Summary ?',
                greeting: 'Hey Team',
                dynamicClosing: true
            },
            Coaching: {
                title: '? Coaching Plan ?'
            },
            RCADraft: {
                title: '? RCA Draft ?'
            },
            Feedback: {
                greeting: 'Hi [Name]',
                dynamicClosing: true
            },
            SmartFeedback: {
                greeting: 'Hi [Name]',
                dynamicClosing: true
            },
            OneOnOne: {
                title: '? 1:1 Feedback ?',
                greeting: 'Hi [Name]',
                dynamicClosing: true
            },
            QuickInsight: {},
            SpotlightCoaching: {
                title: ' Spotlight Analysis'
            },
            UnifiedCoaching: {
                title: '? Unified Coaching Plan ?'
            }
        };


        const getDynamicClosing = (text, contentType) => {
            const t = String(text || '').toLowerCase();
            const pos = ['win', 'improve', 'improved', 'increase', 'increased', 'pass', 'passing', 'great', 'wow', 'excellent', 'resolved', 'fix', 'fixed', 'closed', 'success'];
            const neg = ['risk', 'concern', 'pending', 'fail', 'failed', 'drop', 'dropped', 'appeal', 'issue', 'error', 'defect', 'problem', 'blocked'];
            const countMatches = (arr) => arr.reduce((acc, k) => acc + ((t.match(new RegExp(`\\b${k}\\b`, 'g')) || []).length), 0);
            const ps = countMatches(pos);
            const ns = countMatches(neg);
            const supportive = contentType === 'OneOnOne' || contentType === 'SmartFeedback' || t.includes('action items') || t.includes('growth');
            if (supportive && ps >= ns) return "Youve got thisIm here to support you.";
            if (supportive) return "Well tackle this together. Im with you.";
            if (ps > ns + 1) return "Lets keep the momentumgreat work.";
            if (ns > ps) return "Weve identified what mattersnow we execute together.";
            return "Onward and upwardlets close the gaps this week.";
        };
        const hasClosing = (text) => {
            const tail = String(text || '').split('\n').slice(-4).join(' ').toLowerCase();
            const keys = ['keep', 'forward', 'together', 'support', 'got this', 'proud', 'onward', 'great work', 'well done', 'momentum'];
            return keys.some(k => tail.includes(k));
        };
        const formatSlackMessage = (rawContent, contentType = 'General') => {
            if (!rawContent) return '';
            
            // FIX: Handle JSON content - extract text if AI returned JSON
            let content = rawContent;
            if (typeof rawContent === 'object') {
                // If it's already an object, try to extract content/text/message field
                content = rawContent.content || rawContent.text || rawContent.message || JSON.stringify(rawContent);
            }
            if (typeof content !== 'string') return String(content);
            
            // FIX: Try to detect and parse JSON string responses
            if (content.trim().startsWith('{') || content.trim().startsWith('[')) {
                try {
                    const parsed = JSON.parse(content);
                    // Extract meaningful content from parsed JSON
                    if (parsed.content) content = parsed.content;
                    else if (parsed.text) content = parsed.text;
                    else if (parsed.message) content = parsed.message;
                    else if (parsed.response) content = parsed.response;
                    else content = JSON.stringify(parsed, null, 2); // Pretty print as fallback
                } catch (e) {
                    // Not valid JSON, continue with original content
                }
            }

            let formatted = content.trim();
            
            // Fix Issues 16, 24: Convert literal \n to actual newlines and remove instructional text
            formatted = formatted.replace(/\\n/g, '\n');
            
            // Fix Issue 16: Remove "2 line breaks" or similar instructional text
            formatted = formatted.replace(/\d+\s*line\s*breaks?/gi, '');
            formatted = formatted.replace(/\(\s*\\n\\n\s*\)/g, '');
            formatted = formatted.replace(/\(\\n\)/g, '');
            
            // Fix: Remove triple+ newlines, keep max double newlines
            formatted = formatted.replace(/\n{3,}/g, '\n\n');
            
            // Fix: Remove "Subject:" lines for Slack content
            formatted = formatted.replace(/^\s*subject\s*:.*$/gim, '');
            formatted = formatted.replace(/^\s*\*\*subject\s*:\*\*.*$/gim, '');
            
            // Fix Issue 24: Remove  CLOSURE title - should just be message, not title
            formatted = formatted.replace(/^\s*CLOSURE\s*:?\s*\n*/gim, '');
            formatted = formatted.replace(/^\*\*\s*CLOSURE\s*\*\*\s*\n*/gim, '');

            // Fix: Clean up duplicate/nested link patterns from AI output
            // Pattern: (Chat Link :- (Chat Link :- URL))  (Chat Link :- URL)
            formatted = formatted.replace(/\(([^()]*?)\s*:-\s*\(\1\s*:-\s*(https?:\/\/[^\s)]+)\)\)/gi, '($1 :- $2)');
            // Pattern: (Label :- (Label :- URL)) with different inner/outer labels
            formatted = formatted.replace(/\([^()]*?:-\s*\(([^()]*?:-\s*https?:\/\/[^\s)]+)\)\)/gi, '($1)');
            // Pattern: duplicate "(Chat Link :- URL)(Chat Link :- URL)"  single 
            formatted = formatted.replace(/(\([^()]*?:-\s*https?:\/\/[^\s)]+\))\s*\1/gi, '$1');
            // Pattern: "Link :- Link :- URL"  "Link :- URL"
            formatted = formatted.replace(/(\b\w[\w\s]*?):-\s*\1:-\s*(https?:\/\/\S+)/gi, '$1:- $2');

            formatted = formatted.replace(/\n{3,}/g, '\n\n');


            const rules = SLACK_FORMAT_RULES[contentType] || {};


            switch (contentType) {
                case 'Coaching':
                case 'CoachingPlan':
                    if (!formatted.toLowerCase().includes('coaching') && !formatted.includes('?') && rules.title) {
                        const emailContext = rawContent.match(/[a-zA-Z0-9._%+-]+@revolut\.com/i)?.[0] || '';
                        const agentTitle = emailContext ? `${rules.title} - ${emailContext}` : rules.title;
                        formatted = agentTitle + '\n\n' + formatted;
                    }
                    break;


                // Fix Issue 24: One on One feedback formatting
                // REMOVED: Auto-inserting "Hi there" greeting - title should be the starting point
                case 'Feedback':
                case '1:1Feedback':
                case 'OneOnOne':
                    // No automatic greeting - content should start with title
                    break;


                case 'SlackDraft':
                case 'SlackPost':
                case 'RCADraft':
                    if (!formatted.toLowerCase().includes('weekly') && !formatted.includes('?') && rules.title) {
                        formatted = rules.title + '\n\n' + formatted;
                    }
                    break;
            }


            // Fix Issues 16, 24: Better Slack formatting for all slack-like content
            const isSlackish = ['SlackDraft', 'SlackPost', 'Feedback', '1:1Feedback', 'OneOnOne', 'SmartFeedback', 'Coaching', 'CoachingPlan', 'WeeklySummary', 'RCADraft'].includes(contentType);
            if (isSlackish) {
                formatted = formatted
                    // Convert markdown headers to bold
                    .replace(/^(#{1,6})\s*(.+)$/gm, (_, _hashes, title) => `**${title.trim()}**`)
                    // Fix Issue 24: Convert dashes and asterisks to proper bullet points ()
                    .replace(/^[-*]\s+/gm, ' ')
                    // Remove blockquote markers
                    .replace(/^\s*>\s?/gm, '');
            }

            // Fix Issues 16, 24: Ensure clean bullet formatting - no extra line breaks between bullets
            if (contentType === 'QuickInsight' || isSlackish) {
                formatted = formatted
                    // Remove blank lines between bullet points (keep each bullet on its own line)
                    .replace(/\n\s*\n\s*([\-])/g, '\n$1')
                    // Ensure single newline before each bullet if not already at start
                    .replace(/([^\n])(\n\s*[\-])/g, '$1\n$2')
                    .trim();
            }


            const mustRedact = ['SlackDraft', 'SlackPost', 'WeeklySummary', 'General'].includes(contentType);
            if (mustRedact) {
                formatted = formatted
                    .replace(/[a-zA-Z0-9._%+-]+@revolut\.com/gi, '')
                    .replace(/```[\s\S]*?```/g, '')
                    .replace(/^\s*(TL RCA|Answer Comment|Agent Ack\.?|Appeal Status|Appeal Reason|Why mistake happened\?|Dispute comment|Ticket|JIRA|Zendesk|Case ID|Filter data|Select agent|Navigate to tab|Switch view)\b.*$/gmi, '')
                    .replace(/\n{3,}/g, '\n\n')
                    .trim();
            }


            if (rules.dynamicClosing && !hasClosing(formatted)) {
                const closing = getDynamicClosing(formatted, contentType);
                formatted = formatted + '\n\n' + closing;
            }


            return formatted;
        };


        const safeJsonParse = (value, fallback) => {
            try { return JSON.parse(value); } catch (e) { return fallback; }
        };


        const getLinePairsForDiff = (leftText, rightText) => {
            const leftLines = String(leftText || '').replace(/\r\n/g, '\n').split('\n');
            const rightLines = String(rightText || '').replace(/\r\n/g, '\n').split('\n');
            const max = Math.max(leftLines.length, rightLines.length);
            const pairs = [];
            for (let i = 0; i < max; i++) {
                const left = leftLines[i] ?? '';
                const right = rightLines[i] ?? '';
                const status = left === right ? 'same' : (left === '' ? 'add' : (right === '' ? 'del' : 'change'));
                pairs.push({ left, right, status, idx: i });
            }
            return pairs;
        };


        const TextDiffViewer = ({ leftTitle = 'A', rightTitle = 'B', leftText = '', rightText = '' }) => {
            const pairs = useMemo(() => getLinePairsForDiff(leftText, rightText), [leftText, rightText]);
            return (
                <div className="border border-slate-200 rounded-2xl overflow-hidden bg-white">
                    <div className="grid grid-cols-2 border-b border-slate-200 bg-slate-50">
                        <div className="px-4 py-3 text-[10px] font-black uppercase tracking-wider text-slate-700 border-r border-slate-200">{leftTitle}</div>
                        <div className="px-4 py-3 text-[10px] font-black uppercase tracking-wider text-slate-700">{rightTitle}</div>
                    </div>
                    <div className="grid grid-cols-2 max-h-[55vh] overflow-auto custom-scrollbar">
                        <div className="border-r border-slate-200">
                            {pairs.map(p => (
                                <div key={`l-${p.idx}`} className={`px-4 py-2 text-xs whitespace-pre-wrap font-mono border-b border-slate-100 ${p.status === 'same' ? 'bg-white' : (p.status === 'del' ? 'bg-rose-50 text-rose-700' : (p.status === 'change' ? 'bg-amber-50 text-amber-800' : 'bg-white'))}`}>
                                    {p.left}
                                </div>
                            ))}
                        </div>
                        <div>
                            {pairs.map(p => (
                                <div key={`r-${p.idx}`} className={`px-4 py-2 text-xs whitespace-pre-wrap font-mono border-b border-slate-100 ${p.status === 'same' ? 'bg-white' : (p.status === 'add' ? 'bg-emerald-50 text-emerald-700' : (p.status === 'change' ? 'bg-amber-50 text-amber-800' : 'bg-white'))}`}>
                                    {p.right}
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };


        // --- GEMINI AI ENGINE ---


        // Audit Issue #25: AI Capability Registry - Prevents hallucinations by defining explicit capabilities
        // AI Engines (Registry/Memory) already defined at line 1380
        // AIRequestManager already defined at line 1487
        // GeminiAI already defined at line 1559



        // --- NEW CHAT RENDERER COMPONENTS ---


        const BlockWrapper = ({ children, type, onCopy, onDownload, id }) => {
            return (
                <div id={id} className="group relative border border-slate-200 rounded-xl overflow-hidden mb-4 bg-white shadow-sm hover:shadow-md transition-all">
                    {/* Hover Toolbar */}
                    <div className="absolute top-2 right-2 flex gap-1 z-10 opacity-0 group-hover:opacity-100 transition-opacity bg-white/90 backdrop-blur rounded-lg p-1 border border-slate-200 shadow-sm">
                        {onCopy && <button onClick={onCopy} className="p-1.5 text-slate-500 hover:text-blue-600 hover:bg-blue-50 rounded" title="Copy Content"><Copy size={14} /></button>}
                        {type !== 'text' && onDownload && <button onClick={onDownload} className="p-1.5 text-slate-500 hover:text-blue-600 hover:bg-blue-50 rounded" title="Download Image"><Download size={14} /></button>}
                    </div>
                    {children}
                </div>
            );
        };


        const ChatBlockRenderer = ({ assets, baseId, onDownloadAsset }) => {
            if (!assets || !Array.isArray(assets)) return null;


            return (
                <div className="space-y-4 mt-4 w-full">
                    {assets.map((asset, idx) => {
                        const blockId = `${baseId || 'chat-block'}-${idx}`;
                        const handleDownload = () => onDownloadAsset && onDownloadAsset(blockId, asset.title || `AI_Block_${idx + 1}`);
                        if (asset.type === 'kpi-card') {
                            return (
                                <BlockWrapper key={idx} type="kpi" id={blockId} onDownload={handleDownload}>
                                    <div className={`p-4 text-center ${asset.trend && asset.trend.includes('+') ? 'bg-emerald-50 text-emerald-900' : 'bg-rose-50 text-rose-900'}`}>
                                        <div className="text-xs font-bold uppercase opacity-70 mb-1">{asset.title}</div>
                                        <div className="text-3xl font-black">{asset.value}</div>
                                        {asset.trend && <div className="text-xs font-bold mt-1">{asset.trend}</div>}
                                    </div>
                                </BlockWrapper>
                            );
                        } else if (asset.type === 'table') {
                            return (
                                <BlockWrapper key={idx} type="table" id={blockId} onDownload={handleDownload}>
                                    <div className="overflow-x-auto w-full">
                                        <table className="w-full text-xs text-left">
                                            <thead className="bg-slate-50 border-b border-slate-200 text-slate-500 font-bold uppercase">
                                                <tr>{asset.headers.map((h, i) => <th key={i} className="p-3">{h}</th>)}</tr>
                                            </thead>
                                            <tbody className="divide-y divide-slate-100">
                                                {asset.rows.map((row, r) => (
                                                    <tr key={r} className="hover:bg-slate-50">
                                                        {asset.headers.map((h, c) => <td key={c} className="p-3">{row[h] || row[c]}</td>)}
                                                    </tr>
                                                ))}
                                            </tbody>
                                        </table>
                                    </div>
                                </BlockWrapper>
                            );
                        } else if (asset.type === 'chart') {
                            return (
                                <BlockWrapper key={idx} type="chart" id={blockId} onDownload={handleDownload}>
                                    <div className="p-4 h-64 w-full">
                                        <h4 className="text-xs font-bold text-slate-500 uppercase mb-4 text-center">{asset.title}</h4>
                                        <ResponsiveContainer width="100%" height="100%">
                                            {asset.chartType === 'bar' ? (
                                                <BarChart data={asset.data}>
                                                    <CartesianGrid strokeDasharray="3 3" vertical={false} stroke="#e2e8f0" />
                                                    <XAxis dataKey={asset.config.xKey} tick={<CustomizedAxisTick />} interval={0} axisLine={false} tickLine={false} />
                                                    <YAxis tick={{ fontSize: 10 }} axisLine={false} tickLine={false} />
                                                    <Tooltip cursor={{ fill: '#f1f5f9' }} contentStyle={{ borderRadius: '8px', border: 'none', boxShadow: '0 4px 6px -1px rgb(0 0 0 / 0.1)' }} />
                                                    <Bar dataKey={asset.config.yKey} fill="#6366f1" radius={[4, 4, 0, 0]} />
                                                </BarChart>
                                            ) : (
                                                <LineChart data={asset.data}>
                                                    <CartesianGrid strokeDasharray="3 3" vertical={false} stroke="#e2e8f0" />
                                                    <XAxis dataKey={asset.config.xKey} tick={<CustomizedAxisTick />} interval={0} axisLine={false} tickLine={false} />
                                                    <YAxis tick={{ fontSize: 10 }} axisLine={false} tickLine={false} />
                                                    <Tooltip cursor={{ stroke: '#cbd5e1' }} contentStyle={{ borderRadius: '8px', border: 'none', boxShadow: '0 4px 6px -1px rgb(0 0 0 / 0.1)' }} />
                                                    <Line type="monotone" dataKey={asset.config.yKey} stroke="#8b5cf6" strokeWidth={3} dot={{ r: 4, fill: '#fff', strokeWidth: 2 }} activeDot={{ r: 6 }} />
                                                </LineChart>
                                            )}
                                        </ResponsiveContainer>
                                    </div>
                                </BlockWrapper>
                            );
                        }
                        return null;
                    })}
                </div>
            );
        };


        // --- AI QUERY ENGINE (The Brain) ---
        const AIQueryEngine = {
            // Get available columns/metrics based on data type
            getDataSchema: (dataType) => {
                const schemas = {
                    'NPS': {
                        columns: ['Date', 'Agent', 'Rating', 'User Problem', 'Chat Tag', 'Country', 'Remediation Feedback', 'Acknowledged'],
                        metrics: ['Clear Message & Next Steps', 'Completeness', 'Ownership', 'Personalisation', 'Process', 'Product', 'Proactive', 'Clarity']
                    },
                    'QC': {
                        columns: ['Date', 'Agent Email', 'Question', 'QC Score', 'Appeal Status', 'TL RCA', 'Agent Ack.'],
                        metrics: ['Critical', 'Process', 'SoftSkills']
                    },
                    'Unified': {
                        columns: ['Date', 'Agent', 'Agent Email', 'Rating', 'QC Score', 'Acknowledged', 'Agent Ack.'],
                        metrics: ['NPS Metrics', 'QC Metrics']
                    }
                };
                return schemas[dataType] || { columns: [], metrics: [] };
            },


            // Helper: Aggregate data by agent for summary
            aggregateByAgent: (data, dataType) => {
                if (!Array.isArray(data)) return [];
                try {
                    const agentMap = {};
                    data.forEach(d => {
                        if (!d) return;
                        const effectiveType = dataType === 'Unified' ? (d.Rating !== undefined ? 'NPS' : 'QC') : dataType;
                        const agent = DataEngine.normalizeAgent(d, effectiveType);
                        if (!agent) return;
                        if (!agentMap[agent]) agentMap[agent] = { agent, count: 0, totalScore: 0, errors: 0 };


                        agentMap[agent].count++;
                        if (effectiveType === 'NPS') {
                            agentMap[agent].totalScore += parseInt(d.Rating) || 0;
                            if (typeof NPS_METRIC_MAPPING !== 'undefined') {
                                Object.values(NPS_METRIC_MAPPING).flat().forEach(m => {
                                    if (d[m] === false || d[m] === 'FALSE') agentMap[agent].errors++;
                                });
                            }
                        } else if (effectiveType === 'QC') {
                            agentMap[agent].totalScore += parseFloat(d['QC Score']) || 0;
                            if (parseFloat(d['QC Score']) < 1) agentMap[agent].errors++;
                        }
                    });
                    return Object.values(agentMap).map(a => {
                        const isQC = String(dataType || '').toUpperCase() === 'QC';
                        const score = isQC ? a.totalScore : (a.count > 0 ? (a.totalScore / a.count) : 0);
                        return { ...a, score: (typeof score === 'number' ? score.toFixed(2) : score) };
                    }).sort((a, b) => b.count - a.count);
                } catch (err) { return []; }
            },


            // Generate AI response with history and raw data search
            generateResponseFull: async (query, npsData, qcData, context, history = []) => {
                const safeNpsData = Array.isArray(npsData) ? npsData : [];
                const safeQcData = Array.isArray(qcData) ? qcData : [];
                
                // Apply Global Filters (Appeal & NPS Pass)
                const cleanNps = safeNpsData.filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d));
                const cleanQc = safeQcData.filter(d => !DataEngine.isAppeal(d));
                
                const data = context.dataType === 'NPS' ? cleanNps : (context.dataType === 'QC' ? cleanQc : [...cleanNps, ...cleanQc]);


                if (data.length === 0) return { type: 'dashboard', blocks: [{ type: 'text', content: ' No data loaded.' }] };


                // --- SMART SEARCH (Sherlock Mode) ---
                const styleContext = StyleEngine.getStyleContext(data);


                // 1. Semantic Search
                const snippets = [];


                // 2. Exact Match / Regex
                const regexMatch = data.filter(r => JSON.stringify(r).toLowerCase().includes(query.toLowerCase())).slice(0, 10);


                // 3. Construct Context
                const relevantRows = [...snippets, ...regexMatch].slice(0, 20); // Top 20 relevant rows


                const lowerQuery = query.toLowerCase();
                let relevantRawRows = [];


                // 1. JIRA/Ticket Detection (e.g., BSKG-123, 123456)
                const ticketMatch = lowerQuery.match(/([a-z]+-\d+|\d{6,})/);


                // 2. Keyword Extraction (whitelist short greetings, skip common words)
                // Fix for Generic Greeting: Allow 'hi', 'hey', 'yo' to pass through as keywords
                const whitelist = ['hi', 'hey', 'yo', 'hello', 'help'];
                const lowerQueryParts = lowerQuery.split(' ');

                // Check if query is ONLY a greeting
                const isGreeting = lowerQueryParts.length === 1 && whitelist.includes(lowerQueryParts[0]);

                if (isGreeting) {
                    // Fast-track response for pure greetings
                    const persona = AI_MEMORY_ENGINE.getPersona();
                    const greeting = `Hello! I am Poppy Suite AI. I recall you are ${persona.role || 'a Team Lead'} focusing on ${persona.focus || 'Quality Assurance'}. How can I assist you today?`;
                    return {
                        type: 'dashboard',
                        analysis_text: greeting,
                        generated_assets: [],
                        suggestions: ["Analyze Trends", "Show Top Agents", "Start a Quiz"]
                    };
                }

                const keywords = lowerQueryParts.filter(w => (w.length > 3 || whitelist.includes(w)) && !['show', 'give', 'what', 'analyze', 'about', 'agent', 'score', 'chart', 'trend', 'generate', 'report', 'pdf', 'add', 'numbers', 'please', 'draft', 'email', 'make'].includes(w));


                if (ticketMatch) keywords.push(ticketMatch[0]);


                if (keywords.length > 0) {
                    relevantRawRows = data.filter(row => {
                        const rowStr = Object.values(row).join(' ').toLowerCase();
                        return keywords.some(k => rowStr.includes(k));
                    }).slice(0, 10); // Context window: 10 matching rows
                }


                // --- Helper to build context stats ---
                const stats = {
                    totalRows: data.length,
                    uniqueAgents: [...new Set(data.map(d => DataEngine.normalizeAgent(d, context.dataType)))].length,
                    dateRange: data.length > 0 ? `${DataEngine.formatDate(data[data.length - 1]?.Date || data[data.length - 1]?.['Review Date'])} to ${DataEngine.formatDate(data[0]?.Date || data[0]?.['Review Date'])}` : 'N/A'
                };


                // Add specific view stats
                if (context.dataType === 'NPS') {
                    // NPS Pass Rate based on sub-metrics (not average Rating)
                    const allSubMetrics = Object.values(NPS_METRIC_MAPPING).flat();
                    const passCount = data.filter(r => allSubMetrics.every(m => {
                        const val = r[m];
                        return val === true || String(val).toUpperCase() === 'TRUE' || val === 1 || val === '1';
                    })).length;
                    stats.npsPassRate = data.length > 0 ? ((passCount / data.length) * 100).toFixed(1) : 'N/A';
                } else if (context.dataType === 'QC') {
                    // QC Pass Rate (Score 0 = Pass)
                    const passCount = data.filter(d => parseFloat(d?.['QC Score']) === 0).length;
                    stats.qcPassRate = data.length > 0 ? ((passCount / data.length) * 100).toFixed(2) : 'N/A';
                }


                const agentSummary = AIQueryEngine.aggregateByAgent(data, context.dataType).slice(0, 15);
                const activeRows = Array.isArray(context.activeRows) ? context.activeRows.slice(0, 500) : []; // Audit Fix #12: Increased context limit
                const activeKeys = [
                    'Date', 'Review Date', 'Week',
                    'Agent', 'Agent Email',
                    'Rating', 'QC Score', 'Question',
                    'Appeal Status', 'Acknowledged', 'Agent Ack.',
                    'User Problem', 'Chat Tag',
                    'Remediation Feedback', 'Feedback',
                    'TL RCA', 'Answer Comment',
                    'Chat Link', 'Dante/BO Review Link'
                ];
                const formatRow = (r) => activeKeys.map(k => {
                    const v = r && r[k] != null && String(r[k]).trim() !== '' ? String(r[k]) : '';
                    return v ? `${k}: ${v.substring(0, 140)}` : '';
                }).filter(Boolean).join(', ');
                const activeRowsSnippet = activeRows.map(r => `- ${formatRow(r)}`).filter(line => line !== '- ').join('\n');


                // --- HISTORY FORMATTING ---
                const conversationContext = history.slice(-6).map(msg => {
                    const content = msg.blocks ? msg.blocks.map(b => b.type === 'text' ? b.content : `[${b.type} block]`).join('; ') : msg.content;
                    return `${msg.role.toUpperCase()}: ${content}`;
                }).join('\n');


                // --- ORCHESTRATOR PROMPT (Batch 2 Upgrade + Audit Issue #20) ---
                // Audit Issue #20: Enforce structured output formats
                const intentPrompt = ""; // Classifier removed
                // Audit Issue #22: Memory Context
                const memoryPrompt = AI_MEMORY_ENGINE.getMemoryPrompt(query);


                // Remediation Phase 1: Rich Context Injection
                const systemContext = `SYSTEM_CONTEXT: 
    - User View: '${context.currentView}'
    - Selected Agent: '${context.selectedAgent || 'All Agents'}' 
    - Date Range: '${stats.dateRange}'
    - Data Summary: { rows: ${stats.totalRows}, nps_pass_rate: ${stats.npsPassRate || 'N/A'} }`;


                const systemPrompt = `You are Poppy Suite AI, the definitive Quality Assurance and CX Analytics companion.
                    Your goal is to provide deep, analytical insights and proactive assistance to Team Leaders.
                    
                    CONTEXT AWARENESS:
                    - User View: '${context.currentView}'
                    - Active Tab: '${context.activeTab}'
                    - Selected Agent: '${context.selectedAgent || 'All Agents'}' 
                    - Date Range: '${stats.dateRange}'
                    - Data Summary: { rows: ${stats.totalRows}, nps_pass_rate: ${stats.npsPassRate || 'N/A'}, qc_pass_rate: ${stats.qcPassRate || 'N/A'} }
                    
                    CRITICAL LOGIC:
                    1. **QC Weighting**: In QC metrics, 100/100 is failing. 0/100 is passing. "Higher Score" = MORE critical errors.
                    2. **Navigation**: You can navigate the app. Return "navigate": { "view": "qc", "tab": "Dashboard", "agent": "Name" }.
                    3. **Proactive Actions**: Return "action": "start_quiz", "draft_email", or "generate_report" to trigger automated workflows.
                    
                    STYLE & TONE:
                    - Professional, data-driven, and supportive. Use professional emojis (, , ).
                    - For Slack/DM outputs, follow NO MARKDOWN SYMBOLS rule: No # symbols for headings, use bold text (**) for headers but NO hashtags. Use bullets  instead of *.
                    
                    RESPONSE FORMAT (MARKDOWN ONLY):
                    - Return rich Markdown analysis. Do NOT return JSON.
                    - If you suggest navigation or actions, write them as plain text suggestions (e.g., "Navigate to QC > Dashboard for Agent X").
                    
                    PLANNING PHASE:
                    - Before answering, briefly THINK about the user's intent and the data you have.
                    - Structure your answer logically: Observation -> Analysis -> Recommendation.
                    - If the user asks for a quiz or report, confirm you are starting that action.`;


                const prompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nCONTEXT:\n- Intent: ${context.intent ? context.intent.intent + ' (' + context.intent.description + ')' : 'General'}\n- Data Type: ${context.dataType}\n- View: ${context.currentView}\n- Records: ${stats.totalRows}\n- Agents: ${stats.uniqueAgents}\n${context.dataType === 'NPS' ? `- NPS Pass Rate: ${stats.npsPassRate || 'N/A'}%` : ''}\n${context.dataType === 'QC' ? `- QC Pass Rate: ${stats.qcPassRate || 'N/A'}%` : ''}\n\nRELEVANT RAW DATA (${relevantRawRows.length} rows): \n${relevantRawRows.map(r => '- ' + Object.entries(r).slice(0, 4).map(([k, v]) => `${k}: ${String(v).toString().substring(0, 80)}`).join(', ')).join('\n')}\n\nACTIVE FILTERED ROWS (${activeRows.length} rows):\n${activeRowsSnippet || '- (none)'}\n\nAGENT SUMMARY (Top 15):\n${agentSummary.map(a => `- ${a.agent}: audits=${a.count}, score=${a.score}, errors=${a.errors}`).join('\n')}\n\nHISTORY:\n${conversationContext}\n\nSTRICT RULES:\n1. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.\n2. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).\n3. NO hashtags (#).\n4. Do NOT use the word "Bold", "Underline", or "B" as text.\n\nQUERY: "${query}"


    Return Markdown analysis only:`;


                try {
                    const analysis = await AIRequestManager.generate(prompt, systemPrompt, { useMemory: true, validateAction: true });
                    return {
                        type: 'dashboard',
                        analysis_text: analysis,
                        generated_assets: [],
                        suggestions: ["Analyze Trends", "Show Top Agents"]
                    };
                } catch (e) {
                    console.error('AI Query Error:', e);
                    return {
                        type: 'dashboard',
                        blocks: [{ type: 'text', content: `I encountered an issue processing that. However, I can see you have **${stats.totalRows}** records. Try asking me to "Analyze the trends" or "Show top agents".` }],
                        suggestions: ["Analyze Trends", "Show Top Agents"]
                    };
                }
            },


            // --- QUIZ GENERATOR (Batch 2) ---
            generateQuiz: async (type, data) => {
                // Pre-filter per rules
                const rows = Array.isArray(data) ? data : [];
                const isQC = (String(type || '').toUpperCase() === 'QC');
                const isNPS = (String(type || '').toUpperCase() === 'NPS');


                const filterNPS = (row) => {
                    const metrics = Object.values(NPS_METRIC_MAPPING).flat();
                    return metrics.some(m => {
                        const val = row[m];
                        const v = String(val).toUpperCase();
                        return val === false || v === 'FALSE' || v === 'NO' || v === 'FAIL' || val === 0 || v === '0';
                    });
                };
                const filterQC = (row) => {
                    const status = String(row['Appeal Status'] || '').toLowerCase();
                    const tlrca = String(row['TL RCA'] || '').trim().toLowerCase();
                    if (status.includes('accepted')) return false;
                    if (status.includes('to do') || status.includes('todo')) return false;
                    if (status.includes('pending')) return false;
                    if (tlrca.startsWith('appeal') || tlrca.startsWith('appealed')) return false;
                    return true;
                };
                const filtered = rows.filter(r => {
                    if (isNPS) return filterNPS(r);
                    if (isQC) return filterQC(r);
                    // Unified: apply NPS or QC filter depending on presence of QC fields
                    return (r['QC Score'] !== undefined) ? filterQC(r) : filterNPS(r);
                });


                // Build context bullets from TL RCA / Answer Comment (QC) or Feedback (NPS)
                // Extract contexts with links properly separated for QC data
                const contextsWithLinks = filtered.slice(0, 40).map((r) => {
                    const ctx = (r['TL RCA'] || r['Answer Comment'] || r['Remediation Feedback'] || r['Feedback'] || '').replace(/\s+/g, ' ').trim();
                    const links = (ctx.match(/https?:\/\/[^\s]+/g) || []);
                    // Remove links from context text
                    const textOnly = ctx.replace(/https?:\/\/[^\s]+/g, '').trim();
                    return {
                        text: textOnly.substring(0, 300),
                        links: links,
                        source: r['TL RCA'] ? 'TL RCA' : (r['Answer Comment'] ? 'Answer Comment' : 'Feedback')
                    };
                }).filter(c => c.text.length > 10);

                const sanitized = contextsWithLinks.map((c, i) => 
                    `Context ${i+1} (${c.source}):\n${c.text}${c.links.length > 0 ? '\n  Links: ' + c.links.join(', ') : ''}`
                ).join('\n\n---\n\n');

                const prompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nCreate a difficult, scenario-based quiz with 15-20 multi-answer MCQs based ONLY on the contexts below.

CRITICAL FORMAT - PER QUESTION:

**Question N** (N = 1-20)
[Scenario text - AI Generated, NOT raw QC text, Agent focused, Realistic, Difficult]
- Question name NOT part of question text

Options:
[Option A]
[Option B]
[Option C]
[Option D]
(Up to 8 options, NO emojis, concise)
[Correct options: Green ticked + green highlight/shadow background]

--- FEEDBACK SECTION ---

**Correct**: [Positive, celebrating acknowledgement of correct answer]

**Incorrect**: [Detailed explanation of what is correct and why]
Justification Links: [If the context included Links, include them here exactly as provided. Format: Link 1: <URL>, Link 2: <URL> etc. If no links in context, write "N/A"]

--- END FEEDBACK SECTION ---

---

**Question N+1**
[Next question...]

STRICT KEYWORD RULES (CRITICAL - DO NOT VIOLATE):
- Use ONLY sub-metric names from the provided contexts
- Use ONLY pillar names: Communication, Personalisation, Efficiency
- Use ONLY QC categories: Critical, Process, Internal
- **NEVER invent generic scenarios** about "customer complaints", "process violations", "quality issues"
- **NEVER use** vague terms like "communication problem", "service failure", "technical issue"
- Each question scenario must be based on specific context provided (TL RCA, Answer Comment, or Remediation Feedback)
- Scenarios should reference specific situations from the data, not generic CX situations
- If the context has Links, you MUST include them in "Justification Links" section using the EXACT URLs provided

FORMATTING RULES:
- 15-20 multi-answer MCQs
- 4-8 options per question
- 1-4 correct answers per question
- Question name NOT part of question text
- Agent focused scenarios
- NO emojis in options
- Correct options: Green ticked with green highlight/shadow
- **Correct**: Positive, celebrating acknowledgement
- **Incorrect**: Detailed explanation + Justification Links (extracted from context, NOT generic review links)
- NO hashtags (#)

Contexts (each context has text and any associated Links):
${sanitized}`


                try {
                    const res = await GeminiAI.generate(prompt);
                    const lines = String(res || '').split('\n');
                    const quiz = [];
                    let current = null;
                    const letterIndex = (ch) => {
                        const m = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'].indexOf(String(ch || '').trim().toUpperCase());
                        return m >= 0 ? m : -1;
                    };
                    const stripEmojis = (s) => String(s || '').replace(/[\u{1F300}-\u{1FAFF}\u{1F900}-\u{1F9FF}\u{2600}-\u{27BF}]/gu, '').trim();
                    for (let i = 0; i < lines.length; i++) {
                        const l = lines[i].trim();
                        if (/^\*\*question\s*\d+/i.test(l) || /^question\s*\d+/i.test(l)) {
                            if (current && current.options.length >= 4) quiz.push(current);
                            const txt = l.replace(/^\*\*question\s*\d+\*\*\s*:?\s*/i, '').replace(/^question\s*\d+\s*:?\s*/i, '').trim();
                            current = { question: txt, options: [], correctAnswers: [], explanationCorrect: '', explanationWrong: '', links: [] };
                        } else if (/^-\s*[A-H]\)/i.test(l)) {
                            const opt = l.replace(/^-\s*[A-H]\)\s*/i, '').trim();
                            if (current) current.options.push(stripEmojis(opt));
                        } else if (/^answers?\s*:/i.test(l)) {
                            const ans = l.replace(/^answers?\s*:\s*/i, '').trim();
                            const letters = ans.split(/[,\s]+/).filter(Boolean);
                            if (current) current.correctAnswers = letters.map(letterIndex).filter(idx => idx >= 0);
                        } else if (/^\*\*correct\*\*\s*:/i.test(l) || /^correct\s*:/i.test(l)) {
                            const exp = l.replace(/^\*\*correct\*\*\s*:\s*/i, '').replace(/^correct\s*:\s*/i, '').trim();
                            if (current) current.explanationCorrect = exp;
                        } else if (/^\*\*incorrect\*\*\s*:/i.test(l) || /^incorrect\s*:/i.test(l)) {
                            const exp = l.replace(/^\*\*incorrect\*\*\s*:\s*/i, '').replace(/^incorrect\s*:\s*/i, '').trim();
                            if (current) current.explanationWrong = exp;
                        } else if (/^links\s*:/i.test(l)) {
                            const raw = l.replace(/^links\s*:\s*/i, '').trim();
                            const lk = raw.match(/https?:\/\/[^\s]+/g) || [];
                            if (current) current.links = lk;
                        } else if (/^justification links\s*:/i.test(l)) {
                            const raw = l.replace(/^justification links\s*:\s*/i, '').trim();
                            // Extract URLs from formats like "Link 1: <URL>, Link 2: <URL>" or just "<URL>"
                            const lk = raw.match(/https?:\/\/[^\s,]+/g) || [];
                            if (current) {
                                current.links = lk;
                                // Also append to explanationWrong if not N/A
                                if (raw.toLowerCase() !== 'n/a' && raw.toLowerCase() !== 'na') {
                                    current.explanationWrong += '\n\n**Justification:** ' + raw;
                                }
                            }
                        }
                    }
                    if (current && current.options.length >= 4) quiz.push(current);
                    return quiz.filter(q => q && q.question && q.options && q.options.length >= 4 && q.correctAnswers && q.correctAnswers.length >= 1);
                } catch (e) { return []; }
            }
        };


        // --- PERFORMANCE PREDICTION ENGINE ---
        const PerformancePredictionEngine = {
            // Calculate linear regression slope
            calculateTrendSlope: (values) => {
                if (!values || values.length < 2) return { slope: 0, r2: 0 };
                const n = values.length;
                const x = Array.from({ length: n }, (_, i) => i);
                const sumX = x.reduce((a, b) => a + b, 0);
                const sumY = values.reduce((a, b) => a + b, 0);
                const sumXY = x.reduce((sum, xi, i) => sum + xi * values[i], 0);
                const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);
                
                // FIX: Guard against division by zero
                const denominator = n * sumX2 - sumX * sumX;
                if (denominator === 0) return { slope: 0, r2: 0, intercept: sumY / n };
                
                const slope = (n * sumXY - sumX * sumY) / denominator;
                const intercept = (sumY - slope * sumX) / n;
                
                // Calculate R-squared
                const mean = sumY / n;
                const ssTot = values.reduce((sum, yi) => sum + Math.pow(yi - mean, 2), 0);
                const ssRes = values.reduce((sum, yi, i) => sum + Math.pow(yi - (slope * x[i] + intercept), 2), 0);
                const r2 = ssTot > 0 ? 1 - (ssRes / ssTot) : 0;
                
                return { slope: slope || 0, r2: r2 || 0, intercept };
            },

            // Group data by week and agent
            getWeeklyAgentData: (data, dataType) => {
                const weeklyData = {};
                const agentWeeks = {};
                
                data.forEach(row => {
                    const agent = DataEngine.normalizeAgent(row, dataType);
                    if (!agent) return;
                    
                    const dateStr = row['Date'] || row['Review Date'];
                    if (!dateStr) return;
                    
                    const date = DataEngine.parseDate(dateStr);
                    if (!date) return;
                    
                    // Get week key (YYYY-WXX)
                    const weekKey = DataEngine.getWeekNumber(date);
                    
                    if (!agentWeeks[agent]) agentWeeks[agent] = {};
                    if (!agentWeeks[agent][weekKey]) {
                        agentWeeks[agent][weekKey] = { scores: [], count: 0, week: weekKey };
                    }
                    
                    // Extract score based on data type
                    let score = 0;
                    if (dataType === 'NPS' || row['Rating'] !== undefined) {
                        // NPS: Based on Sub-metrics (Fail if any sub-metric failed)
                        const metrics = Object.values(NPS_METRIC_MAPPING).flat();
                        const hasFail = metrics.some(m => {
                            const val = row[m];
                            return val === 'Fail' || val === 'FALSE' || val === 'No' || val === false;
                        });
                        score = hasFail ? 0 : 100;
                    } else if (dataType === 'QC' || row['QC Score'] !== undefined) {
                        // QC: 0 is good -> 100. >0 is bad -> 0.
                        const qcScore = parseFloat(row['QC Score']) || 0;
                        score = qcScore === 0 ? 100 : 0;
                    }
                    
                    agentWeeks[agent][weekKey].scores.push(score);
                    agentWeeks[agent][weekKey].count++;
                });
                
                // Calculate weekly averages per agent
                Object.keys(agentWeeks).forEach(agent => {
                    weeklyData[agent] = Object.values(agentWeeks[agent])
                        .map(w => ({
                            week: w.week,
                            score: w.scores.length > 0 ? w.scores.reduce((a, b) => a + b, 0) / w.scores.length : 0,
                            count: w.count
                        }))
                        .sort((a, b) => a.week.localeCompare(b.week));
                });
                
                return weeklyData;
            },

            // Predict next week's performance for an agent
            predictAgentPerformance: (weeklyData, agentName, weeksToPredict = 1) => {
                const agentData = weeklyData[agentName];
                if (!agentData || agentData.length < 2) {
                    return { predicted: null, confidence: null, trend: 'insufficient_data' };
                }
                
                // Use last 4 weeks for trend analysis (or all available if less)
                const recentData = agentData.slice(-4);
                const scores = recentData.map(d => d.score);
                const trend = PerformancePredictionEngine.calculateTrendSlope(scores);
                
                // Predict next value
                const lastScore = scores[scores.length - 1];
                const predicted = lastScore + (trend.slope * weeksToPredict);
                const clampedPrediction = Math.max(0, Math.min(100, predicted));
                
                // Calculate confidence interval based on variance and R
                const mean = scores.length > 0 ? scores.reduce((a,b)=>a+b,0) / scores.length : 0;
                const variance = scores.length > 0 ? scores.reduce((sum, s) => sum + Math.pow(s - mean, 2), 0) / scores.length : 0;
                const stdDev = Math.sqrt(variance);
                const confidenceWidth = stdDev * 1.96; // 95% confidence
                
                return {
                    predicted: Math.round(clampedPrediction),
                    confidence: {
                        lower: Math.max(0, Math.round(clampedPrediction - confidenceWidth)),
                        upper: Math.min(100, Math.round(clampedPrediction + confidenceWidth))
                    },
                    trend: trend.slope > 2 ? 'improving' : trend.slope < -2 ? 'declining' : 'stable',
                    slope: trend.slope,
                    r2: trend.r2,
                    weeksAnalyzed: recentData.length,
                    lastWeekScore: Math.round(lastScore)
                };
            },

            // Get team aggregate prediction
            predictTeamPerformance: (weeklyData, weeksToPredict = 1) => {
                const predictions = [];
                Object.keys(weeklyData).forEach(agent => {
                    const pred = PerformancePredictionEngine.predictAgentPerformance(weeklyData, agent, weeksToPredict);
                    if (pred.predicted !== null) {
                        predictions.push({ agent, ...pred });
                    }
                });
                
                if (predictions.length === 0) {
                    return { predicted: null, confidence: null };
                }
                
                const avgPrediction = predictions.length > 0 ? predictions.reduce((sum, p) => sum + p.predicted, 0) / predictions.length : 0;
                const variance = predictions.length > 0 ? predictions.reduce((sum, p) => sum + Math.pow(p.predicted - avgPrediction, 2), 0) / predictions.length : 0;
                const stdDev = Math.sqrt(variance);
                
                return {
                    predicted: Math.round(avgPrediction),
                    confidence: {
                        lower: Math.max(0, Math.round(avgPrediction - stdDev)),
                        upper: Math.min(100, Math.round(avgPrediction + stdDev))
                    },
                    agentPredictions: predictions,
                    totalAgents: predictions.length
                };
            },

            // Identify at-risk agents (negative trend or low predicted score)
            getAtRiskAgents: (weeklyData, threshold = 70) => {
                const atRisk = [];
                Object.keys(weeklyData).forEach(agent => {
                    const pred = PerformancePredictionEngine.predictAgentPerformance(weeklyData, agent);
                    if (pred.predicted !== null) {
                        const isAtRisk = pred.predicted < threshold || pred.trend === 'declining';
                        if (isAtRisk) {
                            atRisk.push({
                                agent,
                                predicted: pred.predicted,
                                trend: pred.trend,
                                lastWeek: pred.lastWeekScore,
                                riskLevel: pred.predicted < 50 ? 'high' : pred.predicted < 70 ? 'medium' : 'low'
                            });
                        }
                    }
                });
                return atRisk.sort((a, b) => a.predicted - b.predicted);
            },

            // Generate prediction report
            generatePredictionReport: (data, dataType, options = {}) => {
                const { agentName, includeTeam = true, includeRisk = true } = options;
                const weeklyData = PerformancePredictionEngine.getWeeklyAgentData(data, dataType);
                
                const report = {
                    type: 'prediction',
                    dataType,
                    generatedAt: new Date().toISOString(),
                    predictions: {}
                };
                
                // Individual agent prediction
                if (agentName && weeklyData[agentName]) {
                    report.predictions.agent = PerformancePredictionEngine.predictAgentPerformance(weeklyData, agentName);
                    report.predictions.agent.name = agentName;
                }
                
                // Team prediction
                if (includeTeam) {
                    report.predictions.team = PerformancePredictionEngine.predictTeamPerformance(weeklyData);
                }
                
                // At-risk agents
                if (includeRisk) {
                    report.predictions.atRisk = PerformancePredictionEngine.getAtRiskAgents(weeklyData);
                }
                
                return report;
            },

            // Format prediction as markdown for chat display
            formatPredictionResponse: (report) => {
                const lines = [];
                lines.push('##  Performance Prediction');
                lines.push('');
                
                // Team prediction
                if (report.predictions.team && report.predictions.team.predicted !== null) {
                    const team = report.predictions.team;
                    lines.push(`**Predicted Team Pass Rate Next Week: ${team.predicted}%**`);
                    lines.push(`(Confidence Interval: ${team.confidence.lower}% - ${team.confidence.upper}%)`);
                    lines.push(`Based on ${team.totalAgents} agents with sufficient historical data.`);
                    lines.push('');
                }
                
                // Individual prediction
                if (report.predictions.agent) {
                    const agent = report.predictions.agent;
                    lines.push(`**${agent.name}'s Predicted Performance: ${agent.predicted}%**`);
                    lines.push(`- Trend: ${agent.trend === 'improving' ? ' Improving' : agent.trend === 'declining' ? ' Declining' : ' Stable'}`);
                    lines.push(`- Last Week: ${agent.lastWeekScore}%`);
                    lines.push(`- Confidence: ${agent.confidence.lower}% - ${agent.confidence.upper}%`);
                    lines.push(`- Weeks Analyzed: ${agent.weeksAnalyzed}`);
                    lines.push('');
                }
                
                // At-risk agents
                if (report.predictions.atRisk && report.predictions.atRisk.length > 0) {
                    lines.push('** At Risk Agents:**');
                    lines.push('');
                    report.predictions.atRisk.slice(0, 10).forEach(risk => {
                        const trendIcon = risk.trend === 'declining' ? '' : '';
                        lines.push(`${trendIcon} **${risk.agent}**: Predicted ${risk.predicted}% (Last: ${risk.lastWeek}%) - ${risk.trend}`);
                    });
                    lines.push('');
                }
                
                // Recommendations
                lines.push('**Recommendations:**');
                if (report.predictions.atRisk && report.predictions.atRisk.length > 0) {
                    const highRisk = report.predictions.atRisk.filter(r => r.riskLevel === 'high');
                    const medRisk = report.predictions.atRisk.filter(r => r.riskLevel === 'medium');
                    
                    if (highRisk.length > 0) {
                        lines.push(`-  Schedule immediate coaching for: ${highRisk.map(r => r.agent).join(', ')}`);
                    }
                    if (medRisk.length > 0) {
                        lines.push(`-  Schedule check-ins for: ${medRisk.map(r => r.agent).join(', ')}`);
                    }
                }
                lines.push('-  Monitor trends weekly for early intervention');
                lines.push('-  Set improvement goals based on predicted trajectories');
                
                return lines.join('\n');
            }
        };


        // --- INTENT ENGINE (The Router) ---
        const IntentEngine = {
            parseQuery: (query) => {
                const q = query.toLowerCase();
                let intent = { type: 'chat', domain: 'unified', timeRange: null };


                if (q.includes('report') || q.includes('summary') || q.includes('performance')) intent.type = 'report';
                if (q.includes('quiz') || q.includes('test') || q.includes('knowledge')) intent.type = 'quiz';


                if (q.includes('nps') || q.includes('sentiment')) intent.domain = 'nps';
                else if (q.includes('qc') || q.includes('quality') || q.includes('audit')) intent.domain = 'qc';


                return intent;
            },
            resolveEntity: (query, agents) => {
                const q = query.toLowerCase();
                const exact = agents.find(a => q.includes(a.toLowerCase()));
                if (exact) return { type: 'exact', match: exact };


                // Simpler match
                const match = agents.filter(a => a.toLowerCase().includes(q) || q.includes(a.split(' ')[0].toLowerCase()));
                if (match.length > 0 && match.length < 5) return { type: 'fuzzy', match, original: query };


                return { type: 'none' };
            }
        };


        // --- NATIVE SEARCH ENGINE (Inverted Index) ---
        // Replaces external FlexSearch dependency for instant client-side search



        // --- VIRTUAL LIST ENGINE (Manual Virtualization) ---
        // Handles 50k+ rows with smooth scrolling + Snapshot Mode support
        // Note: This is a Hook-like logic adapted for direct Component use
        const useVirtualList = (items, rowHeight = 40, visibleHeight = 400) => {
            const [scrollTop, setScrollTop] = useState(0);
            const [isSnapshot, setIsSnapshot] = useState(false); // Snapshot Mode Flag


            const totalHeight = items.length * rowHeight;
            const startIndex = Math.floor(scrollTop / rowHeight);
            const endIndex = Math.min(
                items.length - 1,
                Math.floor((scrollTop + visibleHeight) / rowHeight)
            );


            const visibleItems = isSnapshot
                ? items // Render ALL items during snapshot
                : items.slice(startIndex, endIndex + 1).map((item, index) => ({
                    item,
                    index: startIndex + index,
                    style: {
                        position: 'absolute',
                        top: (startIndex + index) * rowHeight,
                        height: rowHeight,
                        width: '100%'
                    }
                }));


            return {
                containerProps: {
                    onScroll: (e) => setScrollTop(e.target.scrollTop),
                    style: {
                        height: isSnapshot ? 'auto' : visibleHeight, // Auto height for snapshot
                        overflowY: isSnapshot ? 'visible' : 'auto',
                        position: 'relative'
                    }
                },
                contentStyle: {
                    height: isSnapshot ? 'auto' : totalHeight, // Auto height for snapshot
                    position: 'relative'
                },
                visibleItems,
                setSnapshotMode: setIsSnapshot
            };
        };


        // --- ERROR BOUNDARY COMPONENT (Audit Phase 4) ---
        class ErrorBoundary extends React.Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false, error: null, errorInfo: null };
            }


            static getDerivedStateFromError(error) {
                return { hasError: true };
            }


            componentDidCatch(error, errorInfo) {
                this.setState({ error, errorInfo });
                PoppyLogger.error('BOUNDARY', `UI Crash detected in ${this.props.name || 'Component'}`, { error, errorInfo });
            }


            handleRecover = () => {
                PoppyLogger.info('BOUNDARY', 'Attempting state recovery...');
                this.setState({ hasError: false, error: null, errorInfo: null });
            }


            handleFullRefresh = () => {
                PoppyLogger.warn('BOUNDARY', 'Catastrophic failure. Forcing page refresh.');
                window.location.reload();
            }


            render() {
                if (this.state.hasError) {
                    return (
                        <div className="flex flex-col items-center justify-center p-12 bg-white border border-rose-200 rounded-3xl shadow-xl text-center">
                            <div className="w-20 h-20 bg-rose-50 rounded-full flex items-center justify-center mb-6">
                                <AlertTriangle size={40} className="text-rose-500" />
                            </div>
                            <h2 className="text-2xl font-black text-slate-900 mb-2">Something went wrong</h2>
                            <p className="text-slate-500 mb-8 max-w-md">An error occurred while rendering this section. Our diagnostics have been notified.</p>


                            <div className="flex flex-wrap items-center justify-center gap-4">
                                <button
                                    onClick={this.handleRecover}
                                    className="px-6 py-3 bg-indigo-600 text-white font-bold rounded-xl shadow-lg shadow-indigo-200 hover:bg-indigo-700 hover:-translate-y-1 transition-all flex items-center gap-2"
                                >
                                    <RefreshCw size={18} /> Try to Recover
                                </button>
                                <button
                                    onClick={this.handleFullRefresh}
                                    className="px-6 py-3 bg-slate-100 text-slate-600 font-bold rounded-xl hover:bg-slate-200 transition-all flex items-center gap-2"
                                >
                                    <RefreshCw size={18} /> Full Refresh
                                </button>
                            </div>


                            {PoppyApp.env === 'development' && (
                                <details className="mt-8 text-left bg-slate-50 p-4 rounded-xl border border-slate-100 w-full overflow-auto max-h-48">
                                    <summary className="text-[10px] font-bold text-slate-500 cursor-pointer uppercase tracking-wider">Debug Details</summary>
                                    <pre className="text-[10px] text-rose-600 mt-2 font-mono">
                                        {this.state.error && this.state.error.toString()}
                                        {"\n"}
                                        {this.state.errorInfo && this.state.errorInfo.componentStack}
                                    </pre>
                                </details>
                            )}
                        </div>
                    );
                }
                return this.props.children;
            }
        }


        // --- INFO TOOLTIP COMPONENT (Audit Issue #17) ---
        // Provides contextual help icons for metrics and cards
        const InfoTooltip = ({ text, children, position = 'top' }) => {
            const [show, setShow] = useState(false);
            const [coords, setCoords] = useState({ top: 0, left: 0 });
            const triggerRef = useRef(null);
            const timeoutRef = useRef(null);

            const calculatePosition = () => {
                if (!triggerRef.current) return;
                const rect = triggerRef.current.getBoundingClientRect();
                let top = 0;
                let left = 0;

                if (position === 'top') {
                    top = rect.top - 8;
                    left = rect.left + (rect.width / 2);
                } else if (position === 'bottom') {
                    top = rect.bottom + 8;
                    left = rect.left + (rect.width / 2);
                } else if (position === 'left') {
                    top = rect.top + (rect.height / 2);
                    left = rect.left - 8;
                } else if (position === 'right') {
                    top = rect.top + (rect.height / 2);
                    left = rect.right + 8;
                }
                setCoords({ top, left });
            };

            const handleMouseEnter = () => {
                if (timeoutRef.current) clearTimeout(timeoutRef.current);
                calculatePosition();
                setShow(true);
            };

            const handleMouseLeave = () => {
                timeoutRef.current = setTimeout(() => setShow(false), 150);
            };

            useEffect(() => {
                return () => { if (timeoutRef.current) clearTimeout(timeoutRef.current); };
            }, []);

            return (
                <span 
                    ref={triggerRef}
                    onMouseEnter={handleMouseEnter}
                    onMouseLeave={handleMouseLeave}
                    className="inline-flex items-center"
                >
                    {children}
                    {show && createPortal(
                        <div 
                            className="fixed z-[9999] pointer-events-none"
                            style={{
                                top: coords.top,
                                left: coords.left,
                                transform: position === 'top' ? 'translate(-50%, -100%)' :
                                           position === 'bottom' ? 'translate(-50%, 0)' :
                                           position === 'left' ? 'translate(-100%, -50%)' :
                                           'translate(0, -50%)',
                                transition: 'opacity 0.2s ease',
                                whiteSpace: 'normal'
                            }}
                        >
                            <div className="relative bg-slate-900 text-white text-[10px] px-2.5 py-1.5 rounded-lg shadow-2xl border border-slate-700 min-w-[120px] max-w-[250px]">
                                {text}
                                <div 
                                    className="absolute w-2 h-2 bg-slate-900 border-r border-b border-slate-700 transform rotate-45"
                                    style={{
                                        left: position === 'left' ? 'auto' : (position === 'right' ? '-4px' : '50%'),
                                        right: position === 'left' ? '-4px' : 'auto',
                                        top: position === 'top' ? 'auto' : (position === 'bottom' ? '-4px' : '50%'),
                                        bottom: position === 'top' ? '-4px' : 'auto',
                                        marginLeft: (position === 'top' || position === 'bottom') ? '-4px' : '0',
                                        marginTop: (position === 'left' || position === 'right') ? '-4px' : '0'
                                    }}
                                />
                            </div>
                        </div>,
                        document.body
                    )}
                </span>
            );
        };


        // Fix: Increase chart text size - make all charts consistent with Pillar Impact Analysis (14px, bold)
        const CustomizedAxisTick = (props) => { const { x, y, payload } = props; if (!payload || !payload.value) return null; const words = String(payload.value).split(' '); const lines = []; let currentLine = words[0]; for (let i = 1; i < words.length; i++) { if ((currentLine + " " + words[i]).length <= 12) { currentLine += " " + words[i]; } else { lines.push(currentLine); currentLine = words[i]; } } lines.push(currentLine); return (<g transform={`translate(${x},${y})`}><text x={0} y={0} dy={10} textAnchor="middle" fill="#64748b" style={{ fontSize: '12px', fontWeight: 700 }}>{lines.map((line, index) => (<tspan x={0} dy={13} key={index}>{line}</tspan>))}</text></g>); };



// ============================================================================

// NEW FEATURES IMPLEMENTATION

// 1. CaptureEngine - Specialized download image functions

// 2. AI Wrappers - QuickInsight, SlackPost, Quiz

// 3. CopyEngine - Enhanced copy with formatting

// 4. PDFEngine - A4 PDF generation

// ============================================================================



// ============================================================================

// 1. CAPTURE ENGINE - Specialized Download Image Functions

// ============================================================================

const CaptureEngine = {
    capture: async (elementId, filename = 'capture') => {
        const element = document.getElementById(elementId);
        if (!element) { showToast("Element not found", 'error'); return; }
        showToast("Capturing image...");
        
        // Ensure filename is a string
        let safeFilename = '';
        if (typeof filename === 'string') {
            safeFilename = filename;
        } else if (filename && typeof filename === 'object' && filename.toString) {
            safeFilename = String(filename);
        }
        
        // Store original styles to restore later
        const originalStyles = new Map();
        
        try {
            // For modal-zoom-area (expanded view), we need to expand scrollable content
            // For normal elements, we capture as-is
            const isExpandedView = elementId === 'modal-zoom-area';
            
            // Get original width before any modifications
            const originalWidth = element.offsetWidth;
            
            if (isExpandedView) {
                // Expand content for full capture in expanded view
                // But preserve the original width to prevent shrinking
                const elementsToExpand = [element, ...element.querySelectorAll('*')];
                elementsToExpand.forEach(el => {
                    originalStyles.set(el, {
                        maxHeight: el.style.maxHeight,
                        overflow: el.style.overflow,
                        width: el.style.width,
                        minWidth: el.style.minWidth
                    });
                    el.style.maxHeight = 'none';
                    el.style.overflow = 'visible';
                });
                
                // Set explicit width on the main element to preserve size
                element.style.width = originalWidth + 'px';
                element.style.minWidth = originalWidth + 'px';
                
                // Remove flex-1 class which causes shrinking
                element.classList.remove('flex-1', 'overflow-y-auto', 'overflow-x-auto', 'overflow-auto', 'max-h-60', 'max-h-[600px]');
                
                // Also fix the inner content div
                const innerDiv = element.querySelector('[data-modal-content]');
                if (innerDiv) {
                    originalStyles.set(innerDiv, {
                        width: innerDiv.style.width,
                        minWidth: innerDiv.style.minWidth
                    });
                    innerDiv.style.width = '100%';
                    innerDiv.style.minWidth = originalWidth + 'px';
                }
            }
            
            // Small delay for layout
            await new Promise(r => setTimeout(r, 100));
            
            // Capture directly from the original element at its current size
            const canvas = await html2canvas(element, {
                backgroundColor: '#ffffff',
                scale: 2,
                logging: false,
                useCORS: true,
                ignoreElements: (node) => node.hasAttribute('data-html2canvas-ignore')
            });
            
            // If we have a proper title (not element ID), create a new canvas with title
            const isElementId = safeFilename && 
                               (/^[a-z0-9]+-[a-z0-9-]+$/.test(safeFilename) || 
                                safeFilename.includes('card-container') || 
                                safeFilename.includes('chart-'));
            
            let finalCanvas = canvas;
            if (safeFilename && !isElementId && isExpandedView) {
                // Create canvas with title for expanded view only
                const titleHeight = 60;
                const newCanvas = document.createElement('canvas');
                newCanvas.width = canvas.width;
                newCanvas.height = canvas.height + (titleHeight * 2); // Account for scale
                
                const ctx = newCanvas.getContext('2d');
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);
                
                // Draw title
                ctx.fillStyle = '#1e293b';
                ctx.font = 'bold 48px sans-serif';
                ctx.fillText(safeFilename, 40, 50);
                
                // Draw separator line
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(40, 70);
                ctx.lineTo(newCanvas.width - 40, 70);
                ctx.stroke();
                
                // Draw original canvas below title
                ctx.drawImage(canvas, 0, titleHeight * 2);
                finalCanvas = newCanvas;
            }
            
            const link = document.createElement('a');
            link.download = `${safeFilename || 'capture'}_${new Date().toISOString().slice(0, 10)}.png`;
            link.href = finalCanvas.toDataURL('image/png');
            link.click();
            showToast("Image downloaded!");
        } catch (e) {
            console.error("Capture failed:", e);
            showToast("Capture failed", 'error');
        } finally {
            // Restore original styles
            originalStyles.forEach((styles, el) => {
                el.style.maxHeight = styles.maxHeight;
                el.style.overflow = styles.overflow;
                el.style.width = styles.width;
                el.style.minWidth = styles.minWidth;
            });
        }
    },

    async downloadKPI(elementId, filename = 'kpi-export') {
        return CaptureEngine.capture(elementId, filename);
    },

    async downloadChart(elementId, filename = 'chart-export') {
        return CaptureEngine.capture(elementId, filename);
    },

    async downloadTable(elementId, filename = 'table-export') {
        return CaptureEngine.capture(elementId, filename);
    },

    async captureFullPage(filename = 'dashboard-capture') {
        // Ensure prepareElementForCapture is available globally or handled
        if (!window.prepareElementForCapture) {
             window.prepareElementForCapture = async (elementId) => {
                const element = document.getElementById(elementId);
                if (!element) return null;
                const clone = element.cloneNode(true);
                clone.querySelectorAll('[data-html2canvas-ignore]').forEach(el => el.remove());
                clone.style.overflow = 'visible';
                clone.style.height = 'auto';
                return clone;
            };
        }
        return CaptureEngine.capture('app-root-container', filename);
    }
};



// ============================================================================

// 2. AI WRAPPER COMPONENTS

// ============================================================================



// --- Quick Insight Wrapper (For Gemini Sparkle short insights) ---

const QuickInsightWrapper = ({ content, onUpdate, onRegenerate, isLoading }) => {

    const [mode, setMode] = React.useState('preview'); // 'edit' | 'preview'
    const [editContent, setEditContent] = React.useState(content);
    const [modifyPrompt, setModifyPrompt] = React.useState('');

    React.useEffect(() => { setEditContent(content); }, [content]);

    const handleSave = () => { onUpdate?.(editContent); setMode('preview'); };
    const handleRegenerate = () => { onRegenerate?.(modifyPrompt); setModifyPrompt(''); };

    

    // Format content for Slack-like preview

    const formatForPreview = (text) => {
        // Fix: Ensure text is a string before calling replace
        let safeText = String(text || '');
        
        // FIX: Convert bullet points ( or - at start of line) to proper HTML list items
        // First, identify bullet lines and wrap them in a ul structure
        const lines = safeText.split('\n');
        let inList = false;
        let resultLines = [];
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const isBulletLine = /^[\s]*[\-][\s]+/.test(line);
            
            if (isBulletLine) {
                if (!inList) {
                    resultLines.push('<ul class="list-disc pl-5 space-y-1 my-2">');
                    inList = true;
                }
                // Remove the bullet character and add as li
                const content = line.replace(/^[\s]*[\-][\s]+/, '');
                resultLines.push(`<li class="text-slate-700">${content}</li>`);
            } else {
                if (inList) {
                    resultLines.push('</ul>');
                    inList = false;
                }
                resultLines.push(line);
            }
        }
        
        if (inList) {
            resultLines.push('</ul>');
        }
        
        safeText = resultLines.join('\n');

        return safeText
            .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.+?)\*/g, '<em>$1</em>')
            .replace(/`(.+?)`/g, '<code class="bg-purple-100 px-1 rounded text-xs">$1</code>')
            .replace(/\n/g, '<br/>');
    };

    

    return (
        <div className="ai-wrapper bg-white rounded-xl border border-purple-200 shadow-lg relative overflow-visible mt-6">

            {/* Centered Floating Top Buttons */}
            <div className="absolute -top-4 left-1/2 -translate-x-1/2 flex gap-2 bg-white p-1 rounded-full shadow-md border border-purple-100 z-10">
                <button onClick={() => setMode('edit')} className={`px-4 py-1.5 rounded-full text-xs font-bold transition-all ${mode === 'edit' ? 'bg-purple-600 text-white' : 'bg-white text-purple-600 hover:bg-purple-50'}`}>Edit</button>
                <button onClick={() => setMode('preview')} className={`px-4 py-1.5 rounded-full text-xs font-bold transition-all ${mode === 'preview' ? 'bg-purple-600 text-white' : 'bg-white text-purple-600 hover:bg-purple-50'}`}>Preview</button>
                <button onClick={() => handleRegenerate()} disabled={isLoading} className="px-4 py-1.5 rounded-full text-xs font-bold bg-white text-purple-600 hover:bg-purple-50 transition-all flex items-center gap-1 no-export" data-html2canvas-ignore="true">
                    {isLoading ? <RefreshCw size={12} className="animate-spin" /> : <Sparkles size={12} />} Regenerate
                </button>
                <button onClick={() => { safeCopyToClipboard(editContent); }} className="px-4 py-1.5 rounded-full text-xs font-bold bg-white text-purple-600 hover:bg-purple-50 transition-all flex items-center gap-1 no-export" data-html2canvas-ignore="true">
                    <Copy size={12} /> Copy
                </button>
            </div>

            <div className="pt-6">

            

            {mode === 'edit' ? (

                <div className="p-4">

                    <textarea value={editContent} onChange={(e) => setEditContent(e.target.value)} className="w-full h-48 p-3 text-sm border border-slate-200 rounded-lg font-mono resize-none focus:ring-2 focus:ring-purple-500" />

                    <div className="flex justify-end gap-2 mt-3">

                        <button onClick={() => setMode('preview')} className="px-3 py-1.5 text-xs text-slate-500 hover:text-slate-700">Cancel</button>

                        <button onClick={handleSave} className="px-4 py-1.5 bg-purple-600 text-white rounded-lg text-xs font-bold">Save</button>

                    </div>

                </div>

            ) : (

                <div className="p-4">

                    {/* Slack-like Preview */}

                    <div className="bg-purple-50/30 rounded-lg p-4 border-l-4 border-purple-400">

                        <div className="flex items-start gap-3">

                            <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-purple-500 to-violet-600 flex items-center justify-center text-white text-xs font-bold">AI</div>

                            <div className="flex-1">

                                <div className="flex items-center gap-2 mb-1">

                                    <span className="font-bold text-sm text-slate-800">Gemini Insight</span>

                                    <span className="text-xs text-slate-400">{new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>

                                </div>

                                <div className="text-sm text-slate-700 leading-relaxed" dangerouslySetInnerHTML={{ __html: formatForPreview(content) }} />

                                <div className="flex items-center gap-3 mt-2">

                                    <span className="text-xs bg-white px-2 py-1 rounded border border-purple-100"> Insightful</span>

                                    <span className="text-xs bg-white px-2 py-1 rounded border border-purple-100"> Actionable</span>

                                </div>

                            </div>

                        </div>

                    </div>
                </div>
            )}
            </div>

            {/* Modify Output Section */}
            <div className="p-3 bg-slate-50 border-t border-slate-100 flex gap-2 items-center">
                <input 
                    type="text" 
                    value={modifyPrompt} 
                    onChange={(e) => setModifyPrompt(e.target.value)} 
                    placeholder="Modify output (e.g. 'Make it shorter', 'Focus on empathy')..." 
                    className="flex-1 px-3 py-2 text-xs border border-slate-200 rounded-lg focus:ring-2 focus:ring-purple-500 outline-none"
                    onKeyDown={(e) => e.key === 'Enter' && handleRegenerate()}
                />
                <button onClick={() => handleRegenerate()} disabled={isLoading || !modifyPrompt.trim()} className="p-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">
                    <Send size={14} />
                </button>
            </div>
        </div>

    );

};



// --- Slack Post Wrapper (For full Slack posts) ---

const SlackPostWrapper = ({ content, onUpdate, onRegenerate, isLoading, title = 'Slack Post' }) => {

    const [mode, setMode] = React.useState('preview');

    const [editContent, setEditContent] = React.useState(content);

    const [modifyPrompt, setModifyPrompt] = React.useState('');

    

    React.useEffect(() => { setEditContent(content); }, [content]);

    

    const formatSlackPreview = (text) => {
        // Fix: Ensure text is a string before calling replace
        let safeText = String(text || '');
        
        // FIX: Apply sanitizeHTML to prevent XSS before markdown conversion
        safeText = sanitizeHTML(safeText);

        return safeText

            .replace(/^# (.+)$/gm, '<div class="text-lg font-bold text-slate-800 mb-2">$1</div>')

            .replace(/^## (.+)$/gm, '<div class="text-base font-bold text-slate-700 mb-1">$1</div>')

            .replace(/\*\*(.+?)\*\*/g, '<strong class="font-bold">$1</strong>')

            .replace(/_(.+?)_/g, '<em>$1</em>')

            .replace(/`(.+?)`/g, '<code class="bg-slate-100 px-1.5 py-0.5 rounded text-xs font-mono text-rose-600">$1</code>')

            .replace(/```([\s\S]+?)```/g, '<pre class="bg-slate-800 text-slate-200 p-3 rounded-lg text-xs font-mono my-2 overflow-x-auto"><code>$1</code></pre>')

            .replace(/^- (.+)$/gm, '<li class="ml-4 flex items-start gap-2"><span class="text-slate-400 mt-1"></span><span>$1</span></li>')

            .replace(/^\d+\. (.+)$/gm, '<li class="ml-4 flex items-start gap-2"><span class="text-slate-400 mt-1 text-xs">1.</span><span>$1</span></li>')

            .replace(/\n/g, '<br/>');

    };

    

    const quickModifies = ['Make it shorter', 'Add more detail', 'Change tone to formal', 'Add action items'];

    

    return (

        <div className="ai-wrapper bg-white rounded-xl border border-slate-200 shadow-xl overflow-hidden max-w-3xl">

            {/* Centered Top Buttons */}

            <div className="flex justify-center gap-2 p-3 border-b border-slate-200 bg-slate-50">

                <button onClick={() => setMode('edit')} className={`px-4 py-1.5 rounded-full text-xs font-bold transition-all ${mode === 'edit' ? 'bg-purple-600 text-white' : 'bg-white text-slate-600 hover:bg-slate-100 border border-slate-200'}`}>Edit</button>

                <button onClick={() => setMode('preview')} className={`px-4 py-1.5 rounded-full text-xs font-bold transition-all ${mode === 'preview' ? 'bg-purple-600 text-white' : 'bg-white text-slate-600 hover:bg-slate-100 border border-slate-200'}`}>Preview</button>

                <button onClick={() => onRegenerate?.()} disabled={isLoading} className="px-4 py-1.5 rounded-full text-xs font-bold bg-white text-purple-600 hover:bg-purple-50 transition-all flex items-center gap-1 border border-purple-200 no-export" data-html2canvas-ignore="true">

                    {isLoading ? <RefreshCw size={12} className="animate-spin" /> : <Sparkles size={12} />} Regenerate

                </button>

                <button onClick={() => { safeCopyToClipboard(editContent); }} className="px-4 py-1.5 rounded-full text-xs font-bold bg-white text-purple-600 hover:bg-purple-50 transition-all flex items-center gap-1 border border-purple-200 no-export" data-html2canvas-ignore="true">
                    <Copy size={12} /> Copy
                </button>

            </div>

            

            {mode === 'edit' ? (

                <div className="p-4">

                    <textarea value={editContent} onChange={(e) => setEditContent(e.target.value)} className="w-full h-96 p-4 text-sm border border-slate-200 rounded-lg font-mono resize-none focus:ring-2 focus:ring-purple-500" />

                    <div className="flex justify-end gap-2 mt-3">

                        <button onClick={() => setMode('preview')} className="px-3 py-1.5 text-xs text-slate-500 hover:text-slate-700">Cancel</button>

                        <button onClick={() => { onUpdate?.(editContent); setMode('preview'); }} className="px-4 py-1.5 bg-purple-600 text-white rounded-lg text-xs font-bold">Save Changes</button>

                    </div>

                </div>

            ) : (

                <div className="flex">

                    {/* Slack Sidebar */}

                    <div className="w-16 bg-purple-900 flex flex-col items-center py-4 gap-3 border-r border-purple-800">

                        <div className="w-10 h-10 rounded-lg bg-white/10 flex items-center justify-center text-white text-xs font-bold">CX</div>

                        <div className="w-8 h-0.5 bg-white/20 rounded"></div>

                        <div className="w-10 h-10 rounded-lg bg-purple-700 flex items-center justify-center text-white text-xs">#</div>

                        <div className="w-10 h-10 rounded-lg bg-white/10 flex items-center justify-center text-white/60 text-xs"></div>

                    </div>

                    

                    {/* Slack Message Area */}

                    <div className="flex-1 bg-white">

                        {/* Header */}

                        <div className="px-4 py-3 border-b border-slate-200 flex items-center justify-between">

                            <div className="flex items-center gap-2">

                                <span className="font-bold text-slate-800"># team-updates</span>

                                <span className="text-slate-400 text-sm"></span>

                            </div>

                            <div className="text-xs text-slate-400">Preview Mode</div>

                        </div>

                        

                        {/* Message */}

                        <div className="p-4">

                            <div className="flex gap-3">

                                <div className="w-10 h-10 rounded-lg bg-gradient-to-br from-indigo-500 to-purple-600 flex items-center justify-center text-white font-bold text-sm flex-shrink-0">

                                    AI

                                </div>

                                <div className="flex-1 min-w-0">

                                    <div className="flex items-center gap-2 mb-1">

                                        <span className="font-bold text-slate-800 text-sm">Poppy AI</span>

                                        <span className="text-xs text-slate-400">{new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>

                                    </div>

                                    <div className="text-sm text-slate-700 leading-relaxed" dangerouslySetInnerHTML={{ __html: formatSlackPreview(content) }} />

                                    

                                    {/* Reactions */}

                                    <div className="flex items-center gap-2 mt-3">

                                        <span className="text-xs bg-slate-100 hover:bg-slate-200 px-2 py-1 rounded-full cursor-pointer transition-colors"> 3</span>

                                        <span className="text-xs bg-slate-100 hover:bg-slate-200 px-2 py-1 rounded-full cursor-pointer transition-colors"> 2</span>

                                        <span className="text-xs bg-slate-100 hover:bg-slate-200 px-2 py-1 rounded-full cursor-pointer transition-colors"> 1</span>

                                    </div>

                                </div>

                            </div>

                        </div>

                        

                        {/* Message Input */}

                        <div className="px-4 py-3 border-t border-slate-200 bg-slate-50">

                            <div className="bg-white border border-slate-300 rounded-lg px-4 py-2 text-sm text-slate-400">

                                Message #team-updates

                            </div>

                        </div>

                    </div>

                </div>

            )}

            

            {/* Modify Section */}

            <div className="p-4 border-t border-slate-200 bg-slate-50">

                <div className="text-xs font-bold text-slate-500 uppercase mb-2">Quick Modify</div>

                <div className="flex flex-wrap gap-2 mb-3">

                    {quickModifies.map((modify, i) => (

                        <button key={i} onClick={() => onRegenerate?.(modify)} className="px-3 py-1.5 bg-white border border-slate-200 rounded-full text-xs text-slate-600 hover:border-purple-300 hover:text-purple-600 transition-all">

                            {modify}

                        </button>

                    ))}

                </div>

                <div className="flex gap-2">

                    <input type="text" value={modifyPrompt} onChange={(e) => setModifyPrompt(e.target.value)} placeholder="Or describe your changes..." className="flex-1 px-3 py-2 text-xs border border-slate-200 rounded-lg focus:ring-2 focus:ring-purple-500" />

                    <button onClick={() => { if (modifyPrompt) { onRegenerate?.(modifyPrompt); setModifyPrompt(''); } }} className="px-4 py-2 bg-purple-600 text-white rounded-lg text-xs font-bold hover:bg-purple-700">Apply</button>

                </div>

            </div>

        </div>

    );

};



// --- Quiz Wrapper (For quiz generation) ---

const QuizWrapper = ({ questions = [], onUpdate, onRegenerate, isLoading }) => {

    const [mode, setMode] = React.useState('preview'); // 'edit' | 'preview'

    const [currentQuestion, setCurrentQuestion] = React.useState(0);

    const [selectedAnswers, setSelectedAnswers] = React.useState({});

    const [showFeedback, setShowFeedback] = React.useState({});

    const [editQuestions, setEditQuestions] = React.useState(questions);
    const [editingQuestion, setEditingQuestion] = React.useState(null);
    const [editingDraft, setEditingDraft] = React.useState(null);

    

    React.useEffect(() => { setEditQuestions(questions); }, [questions]);

    

    const handleAnswerSelect = (qIdx, answer) => {

        setSelectedAnswers({ ...selectedAnswers, [qIdx]: answer });

        setShowFeedback({ ...showFeedback, [qIdx]: true });

    };

    

    const currentQ = editQuestions[currentQuestion] || {};

    // Start editing a specific question
    const startEdit = (qIdx) => {
        setEditingQuestion(qIdx);
        setEditingDraft(JSON.parse(JSON.stringify(editQuestions[qIdx])));
    };

    // Save edited question
    const saveEdit = () => {
        if (editingQuestion === null || !editingDraft) return;
        const updated = [...editQuestions];
        updated[editingQuestion] = editingDraft;
        setEditQuestions(updated);
        onUpdate?.(updated);
        setEditingQuestion(null);
        setEditingDraft(null);
    };

    // Cancel editing
    const cancelEdit = () => {
        setEditingQuestion(null);
        setEditingDraft(null);
    };

    // Copy helper
    const copyToClipboard = (text, label) => {
        safeCopyToClipboard(String(text || ''));
    };

    // Render markdown safely
    const renderMarkdown = (text) => {
        try {
            return { __html: safeMarked(String(text || '')) };
        } catch (e) {
            return { __html: String(text || '') };
        }
    };

    // Get correct answer for a question (handles both correctAnswer string and correctAnswers array)
    const isCorrectAnswer = (q, option) => {
        if (q.correctAnswer) return option === q.correctAnswer;
        if (q.correctAnswers && Array.isArray(q.correctAnswers)) {
            const optIdx = q.options?.indexOf(option);
            return q.correctAnswers.includes(optIdx);
        }
        return false;
    };
    

    return (

        <div className="ai-wrapper bg-white rounded-xl border border-indigo-200 shadow-xl overflow-hidden max-w-4xl">

            {/* Centered Top Buttons */}

            <div className="flex justify-center gap-2 p-3 border-b border-indigo-100 bg-indigo-50/50">

                <button onClick={() => setMode('edit')} className={`px-4 py-1.5 rounded-full text-xs font-bold transition-all ${mode === 'edit' ? 'bg-indigo-600 text-white' : 'bg-white text-indigo-600 hover:bg-indigo-100'}`}>Edit</button>

                <button onClick={() => setMode('preview')} className={`px-4 py-1.5 rounded-full text-xs font-bold transition-all ${mode === 'preview' ? 'bg-indigo-600 text-white' : 'bg-white text-indigo-600 hover:bg-indigo-100'}`}>Preview</button>

                <button onClick={() => onRegenerate?.()} disabled={isLoading} className="px-4 py-1.5 rounded-full text-xs font-bold bg-white text-indigo-600 hover:bg-indigo-100 transition-all flex items-center gap-1 no-export" data-html2canvas-ignore="true">

                    {isLoading ? <RefreshCw size={12} className="animate-spin" /> : <Sparkles size={12} />} Regenerate

                </button>

                <button onClick={() => { 
                    const text = editQuestions.map((q, i) => 
                        `Q${i+1}: ${q.question}\n` + 
                        (q.options || []).map((opt, j) => `   ${String.fromCharCode(65+j)}) ${opt}${q.correctAnswers?.includes(j) || q.correctAnswer === opt ? ' *' : ''}`).join('\n')
                    ).join('\n\n');
                    safeCopyToClipboard(text);
                }} className="px-4 py-1.5 rounded-full text-xs font-bold bg-white text-indigo-600 hover:bg-indigo-100 transition-all flex items-center gap-1 no-export" data-html2canvas-ignore="true">
                    <Copy size={12} /> Copy
                </button>

            </div>

            

            {mode === 'edit' ? (

                <div className="p-6">
                    {editingQuestion !== null && editingDraft ? (
                        /* Individual Question Edit Mode */
                        <div className="space-y-6">
                            <div className="flex justify-between items-center">
                                <div className="text-xs font-bold text-slate-500 uppercase">Editing Question {editingQuestion + 1}</div>
                                <button onClick={cancelEdit} className="text-xs text-slate-500 hover:text-slate-700">Cancel</button>
                            </div>
                            
                            {/* Question Text */}
                            <div className="space-y-2">
                                <label className="text-[10px] font-black text-slate-500 uppercase tracking-widest">Question Text</label>
                                <textarea
                                    value={editingDraft.question || ''}
                                    onChange={(e) => setEditingDraft({ ...editingDraft, question: e.target.value })}
                                    className="w-full p-4 bg-slate-50 border border-slate-200 rounded-xl text-sm focus:ring-2 ring-indigo-500 outline-none"
                                    rows={3}
                                />
                            </div>

                            {/* Options */}
                            <div className="space-y-2">
                                <label className="text-[10px] font-black text-slate-500 uppercase tracking-widest">Options</label>
                                <div className="space-y-3">
                                    {(editingDraft.options || []).map((opt, idx) => (
                                        <div key={idx} className={`p-4 rounded-xl border flex items-center gap-3 ${
                                            (editingDraft.correctAnswers?.includes(idx) || editingDraft.correctAnswer === opt) 
                                                ? 'border-emerald-200 bg-emerald-50' : 'bg-white border-slate-200'
                                        }`}>
                                            <input
                                                type="checkbox"
                                                checked={editingDraft.correctAnswers?.includes(idx) || editingDraft.correctAnswer === opt}
                                                onChange={(e) => {
                                                    const newDraft = { ...editingDraft };
                                                    if (!newDraft.correctAnswers) {
                                                        newDraft.correctAnswers = [];
                                                    }
                                                    if (e.target.checked) {
                                                        newDraft.correctAnswers = [...newDraft.correctAnswers, idx];
                                                    } else {
                                                        newDraft.correctAnswers = newDraft.correctAnswers.filter(i => i !== idx);
                                                    }
                                                    setEditingDraft(newDraft);
                                                }}
                                                className="w-5 h-5 rounded border-slate-300 text-indigo-600"
                                            />
                                            <input
                                                type="text"
                                                value={opt}
                                                onChange={(e) => {
                                                    const newDraft = { ...editingDraft };
                                                    newDraft.options = [...newDraft.options];
                                                    newDraft.options[idx] = e.target.value;
                                                    setEditingDraft(newDraft);
                                                }}
                                                className="flex-1 p-2 bg-transparent border-none text-sm focus:ring-0 outline-none"
                                                placeholder={`Option ${String.fromCharCode(65 + idx)}`}
                                            />
                                            <button
                                                onClick={(e) => { e.stopPropagation(); copyToClipboard(opt, `Option ${String.fromCharCode(65 + idx)}`); }}
                                                className="p-1.5 text-slate-400 hover:text-indigo-600 hover:bg-indigo-50 rounded"
                                                title="Copy option"
                                            >
                                                <Copy size={14} />
                                            </button>
                                        </div>
                                    ))}
                                </div>
                            </div>

                            {/* Feedback */}
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div className="space-y-2">
                                    <label className="text-[10px] font-black text-emerald-600 uppercase tracking-widest">Correct Feedback</label>
                                    <textarea
                                        value={editingDraft.explanationCorrect || editingDraft.feedbackCorrect || ''}
                                        onChange={(e) => setEditingDraft({ ...editingDraft, explanationCorrect: e.target.value, feedbackCorrect: e.target.value })}
                                        className="w-full p-4 bg-emerald-50 border border-emerald-200 rounded-xl text-sm focus:ring-2 ring-emerald-500 outline-none"
                                        rows={3}
                                        placeholder="Explanation for correct answer..."
                                    />
                                </div>
                                <div className="space-y-2">
                                    <label className="text-[10px] font-black text-rose-600 uppercase tracking-widest">Incorrect Feedback</label>
                                    <textarea
                                        value={editingDraft.explanationWrong || editingDraft.feedbackIncorrect || ''}
                                        onChange={(e) => setEditingDraft({ ...editingDraft, explanationWrong: e.target.value, feedbackIncorrect: e.target.value })}
                                        className="w-full p-4 bg-rose-50 border border-rose-200 rounded-xl text-sm focus:ring-2 ring-rose-500 outline-none"
                                        rows={3}
                                        placeholder="Explanation for incorrect answer..."
                                    />
                                </div>
                            </div>

                            {/* Save Button */}
                            <div className="flex justify-end gap-3">
                                <button onClick={cancelEdit} className="px-4 py-2 text-sm text-slate-500 hover:text-slate-700">Cancel</button>
                                <button onClick={saveEdit} className="px-6 py-2 bg-indigo-600 text-white rounded-lg text-sm font-bold">Save Changes</button>
                            </div>
                        </div>
                    ) : (
                        /* Questions List */
                        <div className="space-y-4">
                            <div className="text-xs font-bold text-slate-500 uppercase mb-4">Select a question to edit</div>
                            {editQuestions.map((q, idx) => (
                                <div key={idx} className="p-4 bg-slate-50 rounded-xl border border-slate-200 flex justify-between items-center">
                                    <div className="flex items-center gap-3">
                                        <div className="w-8 h-8 rounded-full bg-indigo-100 text-indigo-600 flex items-center justify-center font-bold text-sm">
                                            {idx + 1}
                                        </div>
                                        <div className="text-sm font-medium text-slate-700 truncate max-w-md">
                                            {q.question?.substring(0, 60) || 'Untitled Question'}...
                                        </div>
                                    </div>
                                    <div className="flex items-center gap-2">
                                        <button
                                            onClick={(e) => { e.stopPropagation(); copyToClipboard(q.question, 'Question'); }}
                                            className="p-2 text-slate-400 hover:text-indigo-600 hover:bg-indigo-50 rounded-lg"
                                            title="Copy question"
                                        >
                                            <Copy size={16} />
                                        </button>
                                        <button
                                            onClick={() => startEdit(idx)}
                                            className="px-4 py-2 bg-indigo-600 text-white rounded-lg text-xs font-bold hover:bg-indigo-700"
                                        >
                                            Edit
                                        </button>
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}
                </div>

            ) : (

                <div className="p-6">

                    {/* Progress */}

                    <div className="flex items-center gap-2 mb-6">

                        {editQuestions.map((_, i) => (

                            <button key={i} onClick={() => setCurrentQuestion(i)} className={`h-2 rounded-full transition-all ${currentQuestion === i ? 'w-8 bg-indigo-600' : selectedAnswers[i] !== undefined ? 'w-2 bg-emerald-400' : 'w-2 bg-slate-200'}`} />

                        ))}

                        <span className="text-xs text-slate-500 ml-2">{currentQuestion + 1} / {editQuestions.length}</span>

                    </div>

                    

                    {/* Question Card */}

                    {currentQ && (

                        <div className="bg-gradient-to-br from-indigo-50 to-white rounded-2xl p-6 border border-indigo-100">

                            {/* Question Header with Copy Button */}

                            <div className="flex gap-4 mb-6">

                                <div className="w-10 h-10 rounded-full bg-indigo-600 text-white flex items-center justify-center font-bold text-lg flex-shrink-0">

                                    {currentQuestion + 1}

                                </div>

                                <div className="flex-1">
                                    <div className="flex items-start justify-between gap-2">
                                        <h3 className="text-lg font-bold text-slate-800 mb-2" dangerouslySetInnerHTML={renderMarkdown(currentQ.question)} />
                                        <button
                                            onClick={(e) => { e.stopPropagation(); copyToClipboard(currentQ.question, 'Question'); }}
                                            className="p-2 text-slate-400 hover:text-indigo-600 hover:bg-indigo-50 rounded-lg shrink-0"
                                            title="Copy question"
                                        >
                                            <Copy size={16} />
                                        </button>
                                    </div>

                                    {currentQ.category && <span className="text-xs bg-indigo-100 text-indigo-700 px-2 py-1 rounded-full">{currentQ.category}</span>}

                                </div>

                            </div>

                            

                            {/* Answer Options */}

                            <div className="space-y-3 mb-6">

                                {(currentQ.options || []).map((option, i) => {

                                    const isSelected = selectedAnswers[currentQuestion] === option;

                                    const isCorrect = isCorrectAnswer(currentQ, option);

                                    const showResult = showFeedback[currentQuestion];

                                    

                                    let btnClass = 'w-full p-4 rounded-xl border-2 text-left transition-all flex items-center gap-3 ';

                                    if (showResult) {

                                        if (isCorrect) btnClass += 'border-emerald-500 bg-emerald-50';

                                        else if (isSelected) btnClass += 'border-rose-500 bg-rose-50';

                                        else btnClass += 'border-slate-200 bg-white opacity-50';

                                    } else {

                                        btnClass += isSelected ? 'border-indigo-500 bg-indigo-50' : 'border-slate-200 bg-white hover:border-indigo-300';

                                    }

                                    

                                    return (

                                        <button key={i} onClick={() => !showFeedback[currentQuestion] && handleAnswerSelect(currentQuestion, option)} disabled={showFeedback[currentQuestion]} className={btnClass}>

                                            <div className={`w-6 h-6 rounded-full flex items-center justify-center text-xs font-bold ${isSelected ? 'bg-indigo-600 text-white' : 'bg-slate-100 text-slate-600'}`}>

                                                {String.fromCharCode(65 + i)}

                                            </div>

                                            <span className="flex-1 text-sm font-medium text-slate-700" dangerouslySetInnerHTML={renderMarkdown(option)} />

                                            <button
                                                onClick={(e) => { e.stopPropagation(); copyToClipboard(option, `Option ${String.fromCharCode(65 + i)}`); }}
                                                className="p-1.5 text-slate-300 hover:text-indigo-600 hover:bg-indigo-50 rounded"
                                                title="Copy option"
                                            >
                                                <Copy size={14} />
                                            </button>

                                            {showResult && isCorrect && <CheckCircle size={18} className="text-emerald-600" />}

                                            {showResult && isSelected && !isCorrect && <XCircle size={18} className="text-rose-600" />}

                                        </button>

                                    );

                                })}

                            </div>

                            

                            {/* Feedback with Rich Text Rendering */}

                            {showFeedback[currentQuestion] && (

                                <div className="space-y-4">
                                    {/* Correct Feedback */}
                                    {(currentQ.explanationCorrect || currentQ.feedbackCorrect) && (
                                        <div className="bg-emerald-50 border border-emerald-200 rounded-xl p-4">
                                            <div className="flex items-start gap-2">
                                                <CheckCircle size={18} className="text-emerald-600 mt-0.5 flex-shrink-0" />
                                                <div className="flex-1">
                                                    <div className="flex items-center justify-between mb-1">
                                                        <div className="text-xs font-bold text-emerald-700">Correct Explanation</div>
                                                        <button
                                                            onClick={(e) => { e.stopPropagation(); copyToClipboard(currentQ.explanationCorrect || currentQ.feedbackCorrect, 'Correct Explanation'); }}
                                                            className="p-1 text-slate-400 hover:text-emerald-600 hover:bg-emerald-100 rounded"
                                                            title="Copy feedback"
                                                        >
                                                            <Copy size={14} />
                                                        </button>
                                                    </div>
                                                    <div className="text-sm text-emerald-800" dangerouslySetInnerHTML={renderMarkdown(currentQ.explanationCorrect || currentQ.feedbackCorrect)} />
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                    
                                    {/* Incorrect Feedback */}
                                    {(currentQ.explanationWrong || currentQ.feedbackIncorrect || currentQ.feedback) && (
                                        <div className="bg-rose-50 border border-rose-200 rounded-xl p-4">
                                            <div className="flex items-start gap-2">
                                                <XCircle size={18} className="text-rose-600 mt-0.5 flex-shrink-0" />
                                                <div className="flex-1">
                                                    <div className="flex items-center justify-between mb-1">
                                                        <div className="text-xs font-bold text-rose-700">{currentQ.feedback ? 'Explanation' : 'Incorrect Explanation'}</div>
                                                        <button
                                                            onClick={(e) => { e.stopPropagation(); copyToClipboard(currentQ.explanationWrong || currentQ.feedbackIncorrect || currentQ.feedback, 'Explanation'); }}
                                                            className="p-1 text-slate-400 hover:text-rose-600 hover:bg-rose-100 rounded"
                                                            title="Copy feedback"
                                                        >
                                                            <Copy size={14} />
                                                        </button>
                                                    </div>
                                                    <div className="text-sm text-rose-800" dangerouslySetInnerHTML={renderMarkdown(currentQ.explanationWrong || currentQ.feedbackIncorrect || currentQ.feedback)} />
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                    
                                    {/* Justification Links (QC) */}
                                    {currentQ.links && currentQ.links.length > 0 && (
                                        <div className="bg-indigo-50 border border-indigo-200 rounded-xl p-4">
                                            <div className="flex items-start gap-2">
                                                <LinkIcon size={18} className="text-indigo-600 mt-0.5 flex-shrink-0" />
                                                <div className="flex-1">
                                                    <div className="flex items-center justify-between mb-1">
                                                        <div className="text-xs font-bold text-indigo-700">Justification Links</div>
                                                    </div>
                                                    <div className="space-y-1">
                                                        {currentQ.links.map((link, linkIdx) => (
                                                            <a 
                                                                key={linkIdx}
                                                                href={link}
                                                                target="_blank"
                                                                rel="noopener noreferrer"
                                                                className="block text-xs text-indigo-600 hover:text-indigo-800 hover:underline truncate"
                                                            >
                                                                {link}
                                                            </a>
                                                        ))}
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                </div>

                            )}
                        </div>

                    )}

                    

                    {/* Navigation */}

                    <div className="flex justify-between mt-6">

                        <button onClick={() => setCurrentQuestion(Math.max(0, currentQuestion - 1))} disabled={currentQuestion === 0} className="px-4 py-2 text-sm font-medium text-slate-600 hover:text-slate-800 disabled:opacity-50 flex items-center gap-1">

                            <ChevronLeft size={16} /> Previous

                        </button>

                        <button onClick={() => setCurrentQuestion(Math.min(editQuestions.length - 1, currentQuestion + 1))} disabled={currentQuestion === editQuestions.length - 1} className="px-4 py-2 text-sm font-medium text-slate-600 hover:text-slate-800 disabled:opacity-50 flex items-center gap-1">

                            Next <ChevronRight size={16} />

                        </button>

                    </div>

                    

                    {/* Score */}

                    {Object.keys(selectedAnswers).length > 0 && (

                        <div className="mt-4 text-center">

                            <span className="text-xs text-slate-500">

                                Score: {Object.entries(selectedAnswers).filter(([idx, ans]) => isCorrectAnswer(editQuestions[idx], ans)).length} / {editQuestions.length}

                            </span>

                        </div>

                    )}

                </div>

            )}

        </div>

    );

};



// ============================================================================

// 3. COPY ENGINE - Enhanced Copy with Formatting

// ============================================================================

const CopyEngine = {

    async copyTableWithFormatting(tableElement) {
        if (!tableElement || tableElement.tagName !== 'TABLE') {
            showToast('Invalid table element', 'error');
            return;
        }
        
        try {
            // Deep clone and transfer styles for rich formatting
            const clone = tableElement.cloneNode(true);
            
            // Transfer computed styles from original elements to clone
            const originalElements = tableElement.querySelectorAll('*');
            const cloneElements = clone.querySelectorAll('*');
            
            originalElements.forEach((orig, i) => {
                const cloned = cloneElements[i];
                if (!cloned) return;
                
                const computed = window.getComputedStyle(orig);
                
                // Critical styles for Excel/Sheets compatibility
                cloned.style.color = computed.color;
                cloned.style.backgroundColor = computed.backgroundColor;
                cloned.style.fontSize = computed.fontSize;
                cloned.style.fontWeight = computed.fontWeight;
                cloned.style.textAlign = computed.textAlign;
                cloned.style.verticalAlign = computed.verticalAlign;
                cloned.style.whiteSpace = 'pre-wrap';
                
                // Column widths
                if (cloned.tagName === 'TH' || cloned.tagName === 'TD') {
                    const rect = orig.getBoundingClientRect();
                    cloned.style.width = rect.width + 'px';
                    cloned.style.minWidth = rect.width + 'px';
                }
                
                // Numeric alignment
                if (cloned.tagName === 'TD' || cloned.tagName === 'TH') {
                    const text = orig.textContent.trim().replace(/[^0-9.%-]/g, '');
                    const isNumeric = text !== '' && !isNaN(parseFloat(text)) && !text.includes(':');
                    if (isNumeric || orig.classList.contains('text-right')) {
                        cloned.style.textAlign = 'right';
                    }
                }
                
                // Header styling
                if (cloned.tagName === 'TH') {
                    if (computed.backgroundColor === 'rgba(0, 0, 0, 0)' || computed.backgroundColor === 'transparent') {
                        cloned.style.backgroundColor = '#f1f5f9';
                    }
                    cloned.style.border = '1px solid #cbd5e1';
                }
                
                if (cloned.tagName === 'TD') {
                    cloned.style.border = '1px solid #e2e8f0';
                }
            });
            
            // Remove UI elements
            clone.querySelectorAll('button, input, .action-btn, [role="button"], svg, .no-export, [data-html2canvas-ignore]').forEach(el => el.remove());
            
            // Convert lists to bullets
            clone.querySelectorAll('ul, ol').forEach(list => {
                const container = document.createElement('div');
                list.querySelectorAll('li').forEach(item => {
                    const line = document.createElement('div');
                    line.textContent = '\u2022 ' + item.textContent.trim();
                    line.style.color = item.style.color;
                    line.style.fontWeight = item.style.fontWeight;
                    container.appendChild(line);
                });
                list.parentNode.replaceChild(container, list);
            });
            
            // Flatten headers to simple bold text
            clone.querySelectorAll('th').forEach(th => {
                if (th.textContent.trim()) {
                    th.innerHTML = `<b>${th.textContent.trim()}</b>`;
                }
            });
            
            // Generate TSV for plain text fallback
            const headers = Array.from(tableElement.querySelectorAll('thead th')).map(th => {
                return th.textContent.trim().replace(/\t/g, ' ').replace(/\n/g, ' ');
            });
            
            const rows = Array.from(tableElement.querySelectorAll('tbody tr')).map(tr => {
                return Array.from(tr.querySelectorAll('td')).map(td => {
                    return td.textContent.trim().replace(/\t/g, ' ').replace(/\n/g, ' ');
                });
            });
            
            let tsv = headers.join('\t') + '\n';
            rows.forEach(row => {
                tsv += row.join('\t') + '\n';
            });
            
            // Try dual-format clipboard write
            if (navigator.clipboard && navigator.clipboard.write && window.ClipboardItem && window.isSecureContext) {
                const htmlBlob = new Blob([clone.outerHTML], { type: 'text/html' });
                const textBlob = new Blob([tsv], { type: 'text/plain' });
                await navigator.clipboard.write([new ClipboardItem({ 'text/html': htmlBlob, 'text/plain': textBlob })]);
                showToast('Table copied with formatting!', 'success');
            } else {
                // Fallback to safeCopyToClipboard
                await safeCopyToClipboard(tsv);
                showToast('Table copied!', 'success');
            }

        } catch (e) {
            console.error('Copy error:', e);
            showToast('Failed to copy table', 'error');
        }
    },



    async copyElementAsHTML(element) {
        try {
            const clone = element.cloneNode(true);
            clone.querySelectorAll('button, [data-html2canvas-ignore], .sunrise-toolbar').forEach(el => el.remove());
            
            const htmlContent = `
                <div style="font-family: system-ui, -apple-system, sans-serif; color: #333; line-height: 1.6;">
                    ${clone.innerHTML}
                </div>
            `;
            
            const textContent = clone.innerText || clone.textContent || '';
            
            // Use safeCopyToClipboard for consistent behavior
            await safeCopyToClipboard(textContent, htmlContent);

        } catch (e) {
            console.error('Copy error:', e);
            showToast('Failed to copy', 'error');
        }
    },



    async copyTextWithFormatting(text, format = 'markdown') {
        try {
            let htmlContent = null;
            let plainText = text;

            if (format === 'html') {
                htmlContent = text
                    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.+?)\*/g, '<em>$1</em>')
                    .replace(/\n/g, '<br/>');
            }

            // Use safeCopyToClipboard for consistent behavior
            await safeCopyToClipboard(plainText, htmlContent);

        } catch (e) {
            console.error('Copy error:', e);
            showToast('Failed to copy', 'error');
        }
    }

};



// ============================================================================

// 4. PDF ENGINE - A4 PDF Generation

// ============================================================================

const PDFEngine = {

    EXCLUDED_SELECTORS: '[data-html2canvas-ignore], .no-export, .sunrise-toolbar, #ai-chat-panel, .ai-generator-wrapper, .ai-wrapper',

    

    async generateA4PDF(elementIds, filename = 'document.pdf') {
        const ids = Array.isArray(elementIds) ? elementIds : [elementIds];
        showToast('Generating PDF...', 'info');

        try {
            // Check for cross-origin or sandbox restrictions
            const canvas = document.createElement('canvas');
            try {
                canvas.getContext('2d');
            } catch(e) {
                throw new Error("Canvas tainted");
            }

            const pdf = new jspdf.jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4', compress: true });
            const pageWidth = 210, pageHeight = 297;
            const margin = 10, contentWidth = pageWidth - (margin * 2);
            let currentY = margin, isFirstElement = true;

            for (const id of ids) {
                const element = document.getElementById(id);
                if (!element) continue;

                const prepared = this.optimizeForPDF(element);
                const wrapper = document.createElement('div');
                wrapper.appendChild(prepared);
                Object.assign(wrapper.style, { position: 'absolute', left: '-9999px', top: '0', width: '794px' });
                document.body.appendChild(wrapper);

                try {
                    const canvas = await html2canvas(prepared, {
                        scale: 2, useCORS: true, backgroundColor: '#ffffff', logging: false,
                        ignoreElements: (el) => el.matches?.(CaptureEngine.EXCLUDED_SELECTORS) || el.closest?.(CaptureEngine.EXCLUDED_SELECTORS)
                    });
                    
                    document.body.removeChild(wrapper);

                    const imgData = canvas.toDataURL('image/jpeg', 0.95);
                    const imgHeight = (canvas.height * contentWidth) / canvas.width;

                    if (!isFirstElement && currentY + imgHeight > pageHeight - margin) {
                        pdf.addPage();
                        currentY = margin;
                    }

                    if (imgHeight > pageHeight - (margin * 2)) {
                        let heightLeft = imgHeight, position = currentY;
                        pdf.addImage(imgData, 'JPEG', margin, position, contentWidth, imgHeight);
                        heightLeft -= (pageHeight - currentY - margin);
                        while (heightLeft > 0) {
                            pdf.addPage();
                            position = margin - (imgHeight - heightLeft);
                            pdf.addImage(imgData, 'JPEG', margin, position, contentWidth, imgHeight);
                            heightLeft -= (pageHeight - margin * 2);
                        }
                        currentY = margin;
                    } else {
                        pdf.addImage(imgData, 'JPEG', margin, currentY, contentWidth, imgHeight);
                        currentY += imgHeight + 5;
                    }
                    isFirstElement = false;
                } catch (canvasError) {
                    if (document.body.contains(wrapper)) document.body.removeChild(wrapper);
                    throw canvasError;
                }
            }

            pdf.save(filename);
            showToast('PDF generated!', 'success');

        } catch (e) {
            console.error('PDF error:', e);
            
            // Fallback: Generate Markdown
            let markdown = `# ${filename.replace('.pdf', '')}\n\n`;
            for (const id of ids) {
                const el = document.getElementById(id);
                if (el) {
                    markdown += `## Section: ${id}\n\n`;
                    markdown += el.innerText + "\n\n---\n\n";
                }
            }
            
            ClipboardUtils.copy(markdown);
            showToast('PDF blocked by sandbox. Report copied to clipboard as text.', 'info');
        }
    },

    

    optimizeForPDF(element) {

        const clone = element.cloneNode(true);

        clone.querySelectorAll(this.EXCLUDED_SELECTORS).forEach(el => el.remove());

        clone.querySelectorAll('*').forEach(el => {

            el.style.animation = 'none !important';

            el.style.transition = 'none !important';

        });

        clone.querySelectorAll('.overflow-auto, .overflow-y-auto, [class*="scroll"]').forEach(el => {

            el.style.maxHeight = 'none';

            el.style.overflow = 'visible';

        });

        return clone;

    }

};


        // --- POPPY AI CHATBOT (Upgraded from AIAssistant) ---
        // ============================================
        // ENHANCED AI CHATBOT - DYNAMIC & CONTEXT-AWARE
        // ============================================
        
        // --- Resizable Chat Panel Hook ---
        const useResizablePanel = (initialWidth, initialHeight, minW, minH, maxW, maxH) => {
            // Sandbox upgrade: Removed localStorage persistence
            const [size, setSize] = useState({ width: initialWidth, height: initialHeight });
            const [isResizing, setIsResizing] = useState(false);
            const [resizeEdge, setResizeEdge] = useState(null);
            const startPosRef = useRef({ x: 0, y: 0 });
            const startSizeRef = useRef({ width: 0, height: 0 });
            const panelRef = useRef(null);

            const getResizeEdge = useCallback((e, rect) => {
                const edgeSize = 12;
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const edges = [];
                if (x < edgeSize) edges.push('w');
                if (x > rect.width - edgeSize) edges.push('e');
                if (y < edgeSize) edges.push('n');
                if (y > rect.height - edgeSize) edges.push('s');
                return edges.join('') || null;
            }, []);

            const handleMouseDown = useCallback((e) => {
                if (!panelRef.current) return;
                const rect = panelRef.current.getBoundingClientRect();
                const edge = getResizeEdge(e, rect);
                if (edge) {
                    e.preventDefault();
                    e.stopPropagation();
                    setIsResizing(true);
                    setResizeEdge(edge);
                    startPosRef.current = { x: e.clientX, y: e.clientY };
                    startSizeRef.current = { ...size };
                }
            }, [size, getResizeEdge]);

            const handleMouseMove = useCallback((e) => {
                if (!isResizing || !resizeEdge) return;
                const dx = e.clientX - startPosRef.current.x;
                const dy = e.clientY - startPosRef.current.y;
                let newWidth = startSizeRef.current.width;
                let newHeight = startSizeRef.current.height;
                if (resizeEdge.includes('e')) newWidth = startSizeRef.current.width + dx;
                if (resizeEdge.includes('w')) newWidth = startSizeRef.current.width - dx;
                if (resizeEdge.includes('s')) newHeight = startSizeRef.current.height + dy;
                if (resizeEdge.includes('n')) newHeight = startSizeRef.current.height - dy;
                newWidth = Math.max(minW, Math.min(maxW, newWidth));
                newHeight = Math.max(minH, Math.min(maxH, newHeight));
                setSize({ width: newWidth, height: newHeight });
            }, [isResizing, resizeEdge, minW, minH, maxW, maxH]);

            const handleMouseUp = useCallback(() => {
                if (isResizing) {
                    setIsResizing(false);
                    setResizeEdge(null);
                    // localStorage removed
                }
            }, [isResizing, size]);

            useEffect(() => {
                if (isResizing) {
                    document.body.style.cursor = resizeEdge.includes('n') || resizeEdge.includes('s') ? 'ns-resize' : 
                                                  resizeEdge.includes('e') || resizeEdge.includes('w') ? 'ew-resize' : 'nwse-resize';
                    document.body.style.userSelect = 'none';
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                } else {
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
                return () => {
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                };
            }, [isResizing, resizeEdge, handleMouseMove, handleMouseUp]);

            const getCursorStyle = useCallback((e) => {
                if (!panelRef.current) return 'default';
                const rect = panelRef.current.getBoundingClientRect();
                const edge = getResizeEdge(e, rect);
                if (!edge) return 'default';
                if (edge === 'n' || edge === 's') return 'ns-resize';
                if (edge === 'e' || edge === 'w') return 'ew-resize';
                return 'nwse-resize';
            }, [getResizeEdge]);

            return { size, panelRef, handleMouseDown, getCursorStyle, isResizing };
        };

        // --- Enhanced Memory Engine with Conversation Context ---
        const ENHANCED_AI_MEMORY = {
            storageKey: 'poppyAI_enhancedMemory',
            conversationKey: 'poppyAI_conversationContext',
            userPrefsKey: 'poppyAI_userPreferences',
            
            // In-memory storage for sandbox compatibility
            _storage: {
                enhancedMemory: null,
                conversationContext: null,
                userPreferences: null
            },
            
            loadMemory: () => {
                try {
                    const stored = ENHANCED_AI_MEMORY._storage.enhancedMemory;
                    return stored ? stored : { 
                        facts: [], 
                        agentKnowledge: {},
                        userPatterns: [],
                        lastSessionEnd: null
                    };
                } catch (e) { 
                    return { facts: [], agentKnowledge: {}, userPatterns: [], lastSessionEnd: null };
                }
            },
            
            saveMemory: (memory) => {
                try {
                    ENHANCED_AI_MEMORY._storage.enhancedMemory = memory;
                } catch (e) { console.error('Memory save error:', e); }
            },
            
            rememberFact: (type, content, metadata = {}) => {
                const mem = ENHANCED_AI_MEMORY.loadMemory();
                const fact = { 
                    type, 
                    content, 
                    timestamp: Date.now(),
                    metadata,
                    id: `fact_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                };
                mem.facts.unshift(fact);
                mem.facts = mem.facts.slice(0, 200);
                ENHANCED_AI_MEMORY.saveMemory(mem);
                return fact;
            },
            
            rememberAgentInfo: (agentName, info) => {
                const mem = ENHANCED_AI_MEMORY.loadMemory();
                if (!mem.agentKnowledge[agentName]) mem.agentKnowledge[agentName] = [];
                mem.agentKnowledge[agentName].push({
                    ...info,
                    timestamp: Date.now()
                });
                ENHANCED_AI_MEMORY.saveMemory(mem);
            },
            
            getAgentContext: (agentName) => {
                const mem = ENHANCED_AI_MEMORY.loadMemory();
                return mem.agentKnowledge[agentName] || [];
            },
            
            recallRelevant: (query, limit = 10) => {
                const mem = ENHANCED_AI_MEMORY.loadMemory();
                const terms = (query || '').toLowerCase().split(/\s+/).filter(w => w.length > 3);
                const scored = mem.facts.map(f => {
                    const factText = JSON.stringify(f).toLowerCase();
                    const score = terms.reduce((acc, term) => acc + (factText.includes(term) ? 1 : 0), 0);
                    const recencyBoost = Math.max(0, 1 - (Date.now() - f.timestamp) / (7 * 24 * 60 * 60 * 1000));
                    return { ...f, score: score + recencyBoost };
                });
                return scored.filter(f => f.score > 0).sort((a, b) => b.score - a.score).slice(0, limit);
            },
            
            saveConversationContext: (messages, sessionId) => {
                try {
                    const context = {
                        sessionId,
                        messages: messages.slice(-50),
                        timestamp: Date.now(),
                        summary: ENHANCED_AI_MEMORY.generateSummary(messages)
                    };
                    ENHANCED_AI_MEMORY._storage.conversationContext = context;
                } catch (e) { console.warn('Failed to save conversation:', e); }
            },
            
            loadConversationContext: () => {
                try {
                    const context = ENHANCED_AI_MEMORY._storage.conversationContext;
                    if (!context) return null;
                    const age = Date.now() - context.timestamp;
                    if (age > 24 * 60 * 60 * 1000) return null;
                    return context;
                } catch (e) { return null; }
            },
            
            generateSummary: (messages) => {
                const assistantMsgs = messages.filter(m => m.role === 'assistant').slice(-5);
                const topics = [];
                assistantMsgs.forEach(m => {
                    const content = m.content || (m.blocks && m.blocks.map(b => b.content).join(' ')) || '';
                    if (content.includes('chart')) topics.push('chart analysis');
                    if (content.includes('table')) topics.push('data table');
                    if (content.includes('agent')) topics.push('agent analysis');
                    if (content.includes('NPS')) topics.push('NPS metrics');
                    if (content.includes('QC')) topics.push('QC metrics');
                });
                return [...new Set(topics)];
            },
            
            saveUserPreferences: (prefs) => {
                try {
                    const existing = ENHANCED_AI_MEMORY._storage.userPreferences || {};
                    const merged = { ...existing, ...prefs, lastUpdated: Date.now() };
                    ENHANCED_AI_MEMORY._storage.userPreferences = merged;
                } catch (e) { console.warn('Failed to save preferences:', e); }
            },
            
            loadUserPreferences: () => {
                try {
                    return ENHANCED_AI_MEMORY._storage.userPreferences || {};
                } catch (e) { return {}; }
            }
        };

        // --- Typing Indicator Component ---
        // ENHANCED THINKING INDICATOR (#47) - Like Kimi
        const ThinkingIndicator = ({ thinkingSteps = [] }) => {
            const [currentStep, setCurrentStep] = useState(0);
            const [showDetails, setShowDetails] = useState(false);
            
            const defaultSteps = [
                { icon: BrainCircuit, text: 'Analyzing context...', color: 'text-indigo-500' },
                { icon: Search, text: 'Retrieving relevant data...', color: 'text-blue-500' },
                { icon: GitBranch, text: 'Reasoning through options...', color: 'text-purple-500' },
                { icon: Sparkles, text: 'Generating response...', color: 'text-amber-500' }
            ];
            
            const steps = thinkingSteps.length > 0 ? thinkingSteps : defaultSteps;
            
            useEffect(() => {
                const interval = setInterval(() => {
                    setCurrentStep(prev => (prev + 1) % steps.length);
                }, 2000);
                return () => clearInterval(interval);
            }, [steps.length]);
            
            const CurrentIcon = steps[currentStep].icon;
            
            return (
                <div className="flex flex-col gap-2 max-w-[80%]">
                    <div className="flex items-center gap-3 px-4 py-3 bg-white/90 backdrop-blur rounded-2xl rounded-tl-sm shadow-sm border border-slate-100">
                        <div className="relative">
                            <CurrentIcon size={18} className={`${steps[currentStep].color} animate-pulse`} />
                            <span className="absolute -top-1 -right-1 w-2 h-2 bg-emerald-400 rounded-full animate-ping"></span>
                        </div>
                        <span className="text-xs text-slate-600 font-medium">{steps[currentStep].text}</span>
                        <button 
                            onClick={() => setShowDetails(!showDetails)}
                            className="ml-2 text-[10px] text-slate-400 hover:text-indigo-500 transition-colors"
                        >
                            {showDetails ? 'Hide' : 'Show'} steps
                        </button>
                    </div>
                    
                    {showDetails && (
                        <div className="ml-2 p-3 bg-slate-50 rounded-xl border border-slate-200">
                            <div className="space-y-2">
                                {steps.map((step, idx) => {
                                    const StepIcon = step.icon;
                                    return (
                                        <div 
                                            key={idx} 
                                            className={`flex items-center gap-2 text-xs ${idx === currentStep ? 'text-indigo-600 font-medium' : idx < currentStep ? 'text-slate-400' : 'text-slate-300'}`}
                                        >
                                            <StepIcon size={12} />
                                            <span>{step.text}</span>
                                            {idx < currentStep && <CheckCircle size={10} className="text-emerald-500 ml-auto" />}
                                            {idx === currentStep && <Loader size={10} className="animate-spin text-indigo-500 ml-auto" />}
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Keep backward compatibility
        const TypingIndicator = ThinkingIndicator;



        // --- Expandable Message Bubble ---
        const ExpandableMessage = ({ content, maxLines = 8 }) => {
            const [isExpanded, setIsExpanded] = useState(false);
            const [needsExpansion, setNeedsExpansion] = useState(false);
            const contentRef = useRef(null);
            
            useEffect(() => {
                if (contentRef.current) {
                    const lineHeight = parseInt(window.getComputedStyle(contentRef.current).lineHeight);
                    const maxHeight = lineHeight * maxLines;
                    setNeedsExpansion(contentRef.current.scrollHeight > maxHeight);
                }
            }, [content, maxLines]);
            
            return (
                <div className="relative">
                    <div
                        ref={contentRef}
                        className={`whitespace-pre-wrap transition-all duration-300 ${isExpanded ? '' : 'overflow-hidden'}`}
                        style={{ maxHeight: isExpanded ? 'none' : `${1.6 * maxLines}em` }}
                    >
                        {content}
                    </div>
                    {needsExpansion && !isExpanded && (
                        <div className="absolute bottom-0 left-0 right-0 h-12 bg-gradient-to-t from-white to-transparent"></div>
                    )}
                    {needsExpansion && (
                        <button
                            onClick={() => setIsExpanded(!isExpanded)}
                            className="mt-2 text-xs font-medium text-indigo-600 hover:text-indigo-700 flex items-center gap-1"
                        >
                            {isExpanded ? 'Show less' : 'Show more'}
                            <ChevronDown size={12} className={`transform transition-transform ${isExpanded ? 'rotate-180' : ''}`} />
                        </button>
                    )}
                </div>
            );
        };

        // --- Streaming Response Hook ---
        const useStreamingResponse = () => {
            const [streamingContent, setStreamingContent] = useState('');
            const [isStreaming, setIsStreaming] = useState(false);
            const abortRef = useRef(null);
            
            const streamResponse = useCallback(async (generator) => {
                setIsStreaming(true);
                setStreamingContent('');
                let fullContent = '';
                
                try {
                    for await (const chunk of generator) {
                        fullContent += chunk;
                        setStreamingContent(fullContent);
                        await new Promise(r => setTimeout(r, 20));
                    }
                    return fullContent;
                } catch (error) {
                    console.error('Streaming error:', error);
                    throw error;
                } finally {
                    setIsStreaming(false);
                }
            }, []);
            
            const cancelStream = useCallback(() => {
                if (abortRef.current) abortRef.current();
                setIsStreaming(false);
            }, []);
            
            return { streamingContent, isStreaming, streamResponse, cancelStream };
        };

        // --- Enhanced Content Renderer with Syntax Highlighting ---
        const CodeBlock = ({ code, language }) => {
            const [copied, setCopied] = useState(false);
            
            const copyCode = () => {
                safeCopyToClipboard(code);
                setCopied(true);
                setTimeout(() => setCopied(false), 2000);
            };
            
            const highlightSyntax = (code, lang) => {
                if (!code) return '';
                let highlighted = code
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
                
                const patterns = [
                    { regex: /(".*?"|'.*?')/g, class: 'text-green-600' },
                    { regex: /\b(const|let|var|function|return|if|else|for|while|class|import|export|async|await)\b/g, class: 'text-purple-600 font-semibold' },
                    { regex: /\b(true|false|null|undefined)\b/g, class: 'text-orange-600' },
                    { regex: /\b(\d+)\b/g, class: 'text-blue-600' },
                    { regex: /(\/\/.*$)/gm, class: 'text-slate-400 italic' },
                    { regex: /(\/\*[\s\S]*?\*\/)/g, class: 'text-slate-400 italic' }
                ];
                
                patterns.forEach(({ regex, class: className }) => {
                    highlighted = highlighted.replace(regex, `<span class="${className}">$1</span>`);
                });
                
                return highlighted;
            };
            
            return (
                <div className="relative group my-3 rounded-xl overflow-hidden bg-slate-900">
                    <div className="flex items-center justify-between px-4 py-2 bg-slate-800 border-b border-slate-700">
                        <span className="text-xs font-medium text-slate-400">{language || 'code'}</span>
                        <button
                            onClick={copyCode}
                            className="text-xs text-slate-400 hover:text-white flex items-center gap-1 transition-colors"
                        >
                            {copied ? <Check size={12} /> : <Copy size={12} />}
                            {copied ? 'Copied!' : 'Copy'}
                        </button>
                    </div>
                    <pre className="p-4 text-sm font-mono text-slate-300 overflow-x-auto">
                        <code dangerouslySetInnerHTML={{ __html: highlightSyntax(code, language) }} />
                    </pre>
                </div>
            );
        };

        const EnhancedMarkdownRenderer = ({ content }) => {
            const renderContent = (text) => {
                if (!text) return null;
                const parts = [];
                const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
                let lastIndex = 0;
                let match;
                
                while ((match = codeBlockRegex.exec(text)) !== null) {
                    if (match.index > lastIndex) {
                        parts.push({ type: 'text', content: text.slice(lastIndex, match.index) });
                    }
                    parts.push({ type: 'code', language: match[1] || 'plaintext', code: match[2] });
                    lastIndex = match.index + match[0].length;
                }
                
                if (lastIndex < text.length) {
                    parts.push({ type: 'text', content: text.slice(lastIndex) });
                }
                
                return parts.map((part, i) => {
                    if (part.type === 'code') {
                        return <CodeBlock key={i} code={part.code} language={part.language} />;
                    }
                    return (
                        <div key={i} className="markdown-content">
                            <div dangerouslySetInnerHTML={{ __html: safeMarked(part.content) }} />
                        </div>
                    );
                });
            };
            
            return <div className="space-y-2">{renderContent(content)}</div>;
        };

        // --- Retry Mechanism for API Calls ---
        const withRetry = async (fn, options = {}) => {
            const { maxRetries = 3, delay = 1000, onRetry } = options;
            let lastError;
            
            for (let attempt = 0; attempt <= maxRetries; attempt++) {
                try {
                    return await fn();
                } catch (error) {
                    lastError = error;
                    if (attempt === maxRetries) break;
                    
                    const isRetryable = error.message?.includes('network') || 
                                       error.message?.includes('timeout') ||
                                       error.message?.includes('rate limit') ||
                                       (error.status >= 500 && error.status < 600);
                    
                    if (!isRetryable) throw error;
                    
                    if (onRetry) onRetry(attempt + 1, maxRetries);
                    await new Promise(r => setTimeout(r, delay * Math.pow(2, attempt)));
                }
            }
            
            throw lastError;
        };

        // --- Debounced Input Hook ---
        const useDebouncedInput = (delay = 300) => {
            const [input, setInput] = useState('');
            const [debounced, setDebounced] = useState('');
            const timeoutRef = useRef(null);
            
            useEffect(() => {
                if (timeoutRef.current) clearTimeout(timeoutRef.current);
                timeoutRef.current = setTimeout(() => setDebounced(input), delay);
                return () => { if (timeoutRef.current) clearTimeout(timeoutRef.current); };
            }, [input, delay]);
            
            return [input, debounced, setInput];
        };

        // ============================================
        // MAIN ENHANCED CHATBOT COMPONENT
        // ============================================
        // ============================================
        // TOOL MODAL COMPONENT (Task 8)
        // ============================================
        const ToolModal = ({ isOpen, onClose, toolId, onSubmit }) => {
            if (!isOpen || !toolId) return null;
            const template = PromptBuilder.templates[toolId];
            if (!template) return null;
            
            const [formData, setFormData] = useState({});

            useEffect(() => {
                if (template.inputs) {
                    const defaults = {};
                    template.inputs.forEach(i => {
                         if (i.default) defaults[i.name] = i.default;
                    });
                    setFormData(defaults);
                }
            }, [toolId]);
            
            const handleChange = (field, value) => {
                setFormData(prev => ({ ...prev, [field]: value }));
            };
            
            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/50 backdrop-blur-sm animate-in fade-in">
                    <div className="bg-white rounded-2xl shadow-2xl w-full max-w-lg p-6 m-4 border border-slate-200">
                        <div className="flex justify-between items-center mb-6">
                            <h3 className="text-lg font-bold text-slate-800 flex items-center gap-2">
                                <span className="p-2 bg-blue-100 text-blue-600 rounded-lg"></span>
                                {toolId.toUpperCase().replace('-', ' ')}
                            </h3>
                            <button onClick={onClose} className="p-2 hover:bg-slate-100 rounded-full transition-colors"></button>
                        </div>
                        
                        <div className="space-y-4 max-h-[60vh] overflow-y-auto custom-scrollbar p-1">
                            {template.inputs && template.inputs.map(input => (
                                <div key={input.name} className="space-y-1.5">
                                    <label className="text-sm font-semibold text-slate-700">{input.label}</label>
                                    {input.type === 'textarea' ? (
                                        <textarea 
                                            className="w-full p-3 border border-slate-200 rounded-xl focus:ring-2 focus:ring-blue-500 outline-none min-h-[100px] text-sm"
                                            placeholder={`Enter ${input.label.toLowerCase()}...`}
                                            value={formData[input.name] || ''}
                                            onChange={e => handleChange(input.name, e.target.value)}
                                        />
                                    ) : input.type === 'select' ? (
                                        <select 
                                            className="w-full p-3 border border-slate-200 rounded-xl focus:ring-2 focus:ring-blue-500 outline-none text-sm bg-white"
                                            value={formData[input.name] || ''}
                                            onChange={e => handleChange(input.name, e.target.value)}
                                        >
                                            <option value="">Select option...</option>
                                            {input.options.map(opt => <option key={opt} value={opt}>{opt}</option>)}
                                        </select>
                                    ) : (
                                        <input 
                                            type={input.type || 'text'}
                                            className="w-full p-3 border border-slate-200 rounded-xl focus:ring-2 focus:ring-blue-500 outline-none text-sm"
                                            value={formData[input.name] || ''}
                                            onChange={e => handleChange(input.name, e.target.value)}
                                        />
                                    )}
                                </div>
                            ))}
                        </div>
                        
                        <div className="mt-6 flex justify-end gap-3 pt-4 border-t border-slate-100">
                            <button onClick={onClose} className="px-4 py-2 text-slate-600 font-semibold hover:bg-slate-50 rounded-lg transition-colors">Cancel</button>
                            <button 
                                onClick={() => onSubmit(toolId, formData)}
                                className="px-6 py-2 bg-gradient-to-r from-blue-600 to-indigo-600 text-white font-bold rounded-xl shadow-lg hover:shadow-blue-500/30 hover:-translate-y-0.5 transition-all"
                            >
                                Generate Body
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const ToolOrchestrator = {
            classify: async (query) => {
                // Mission 1: The Dispatcher - Strict JSON Classification
                const prompt = `You are a CX Analytics Intent Classifier.
Query: "${query}"
Classify the user's intent into ONE of these categories:
- "data_viz": User wants a chart, graph, or visual analysis.
- "table_gen": User wants a data table, list of records, or raw data view.
- "workflow": User wants to perform a multi-step task (e.g., "perform an RCA", "investigate anomaly", "audit agent").
- "chat": General question, greeting, or text-based analysis related to CX/QA/Performance.
- "unrelated": Query is NOT related to QA, CX, Performance, Coaching, or Feedback.

Return STRICT JSON ONLY:
{ "intent": "data_viz" | "table_gen" | "workflow" | "chat" | "unrelated", "parameters": { ...extracted entities like agent, metric, date... } }`;
                
                try {
                    // Use a fast, low-token model call if possible, otherwise standard
                    // Assuming GeminiAI.generateJson is available
                    const json = await GeminiAI.generateJson(prompt, { temperature: 0.1 });
                    return JSON.parse(json);
                } catch(e) {
                    console.warn("ToolOrchestrator classification failed", e);
                    return { intent: 'chat', parameters: {} };
                }
            }
        };

        const PoppyAIChatbot = ({ npsData, qcData, activeFilteredData, currentView, activeTab, selectedAgentGlobal, filters, setView, setActiveTab, setSelectedAgentGlobal, setFilters, onDownloadImage, aiTrigger, setAiTrigger, context, onClose, initialQuery }) => {
            const [isOpen, setIsOpen] = useState(false);
            const [activeTool, setActiveTool] = useState(null); // Task 8: Tool Modal State
            // Fix Issue 14: Ensure useDebouncedInput returns correct array structure
            const debouncedInputResult = useDebouncedInput(200);
            const query = debouncedInputResult[0] || '';
            const debouncedQuery = debouncedInputResult[1] || '';
            const setQuery = debouncedInputResult[2] || (() => {});
            const sessionIdRef = useRef(`session_${Date.now()}`);
            const [retryCount, setRetryCount] = useState(0);
            const [streamingBlocks, setStreamingBlocks] = useState({});
            
            // Fix Issue 15: Add dropdown state for suggestions
            const [showSuggestions, setShowSuggestions] = useState(false);
            
            // Image upload state
            const [selectedImage, setSelectedImage] = useState(null);
            const [imagePreview, setImagePreview] = useState(null);
            const fileInputRef = useRef(null);
            
            // Contextual suggestions
            const contextualSuggestions = useMemo(() => {
                const hasData = (npsData?.length || 0) + (qcData?.length || 0) > 0;
                return SuggestionEngine.getSuggestions(currentView, activeTab, selectedAgentGlobal, hasData);
            }, [currentView, activeTab, selectedAgentGlobal, npsData, qcData]);
            
            // Resizable panel setup
            const { size, panelRef, handleMouseDown, getCursorStyle, isResizing } = useResizablePanel(
                450, 650, 320, 400, 1400, 1000
            );

            // Enhanced allAgents with context awareness
            const allAgents = useMemo(() => {
                const agents = new Set();
                const safeNps = Array.isArray(npsData) ? npsData : [];
                const safeQc = Array.isArray(qcData) ? qcData : [];
                
                safeNps.forEach(r => {
                    const agent = DataEngine.normalizeAgent(r, 'NPS');
                    if (agent) agents.add(agent);
                });
                
                safeQc.forEach(r => {
                    const agent = DataEngine.normalizeAgent(r, 'QC');
                    if (agent) agents.add(agent);
                });
                
                // Store agent knowledge
                const agentList = Array.from(agents).sort();
                agentList.forEach(agent => {
                    const agentNps = safeNps.filter(r => DataEngine.normalizeAgent(r, 'NPS') === agent);
                    const agentQc = safeQc.filter(r => DataEngine.normalizeAgent(r, 'QC') === agent);
                    if (agentNps.length > 0 || agentQc.length > 0) {
                        ENHANCED_AI_MEMORY.rememberAgentInfo(agent, {
                            npsCount: agentNps.length,
                            qcCount: agentQc.length,
                            lastSeen: new Date().toISOString()
                        });
                    }
                });
                
                return agentList;
            }, [npsData, qcData]);

            // --- ENHANCED AGENTIC AI EXECUTOR ---
            const executeStep = async (step, contextData) => {
                const { action, params } = step;
                try {
                    if (action === 'switch_view') {
                        if (params.view) setView(params.view);
                        if (params.tab) setActiveTab(params.tab);
                        return { type: 'text', content: `\ud83d\udd04 **Switched View** to ${params.view}` };
                    }
                    if (action === 'filter_data') {
                        if (params.agent) {
                            setSelectedAgentGlobal(params.agent);
                            if (setFilters) setFilters(prev => ({ ...prev, agent: params.agent }));
                        }
                        return { type: 'text', content: `\ud83d\udd0d **Filtered** by agent: ${params.agent}` };
                    }
                    if (action === 'generate_chart') {
                        const dataKey = params.data || 'Rating';
                        const hasData = contextData && contextData.length > 0;
                        
                        let chartData;
                        if (hasData) {
                            chartData = contextData.slice(0, 15).map(d => ({
                                name: d.Agent || (d.Date ? DataEngine.formatDate(d.Date) : 'Item'),
                                value: parseFloat(d[dataKey] || d['QC Score'] || d['Rating'] || 0)
                            }));
                        } else {
                            // Generate mock data for demonstration
                            chartData = AIContentEngine.generateMockData('chart');
                        }
                        
                        return { 
                            type: 'chart', 
                            chartType: params.type || 'bar', 
                            title: params.title || (hasData ? `Analysis of ${dataKey}` : 'Sample Performance Trend'), 
                            data: chartData, 
                            config: { xKey: 'name', yKey: 'value' },
                            meta: { isMockData: !hasData }
                        };
                    }
                    if (action === 'generate_table') {
                        const hasData = contextData && contextData.length > 0;
                        let tableData;
                        
                        if (hasData) {
                            const sample = contextData[0];
                            const headers = Object.keys(sample).slice(0, 6);
                            tableData = {
                                headers,
                                rows: contextData.slice(0, 10).map(d => {
                                    const row = {};
                                    headers.forEach(h => row[h] = d[h] || '');
                                    return row;
                                })
                            };
                        } else {
                            tableData = AIContentEngine.generateMockData('table');
                        }
                        
                        return {
                            type: 'table',
                            title: params.title || (hasData ? 'Data Table' : 'Sample Data Table'),
                            headers: tableData.headers,
                            rows: tableData.rows,
                            meta: { isMockData: !hasData }
                        };
                    }
                    if (action === 'generate_slack') {
                        const result = await AIContentEngine.generate('slack', params.query || 'Team update', contextData, { domain: currentView });
                        return {
                            type: 'text',
                            content: result.content,
                            meta: { contentType: 'slack', exportable: true }
                        };
                    }
                    if (action === 'generate_pdf') {
                        const result = await AIContentEngine.generate('pdf', params.query || 'Report', contextData, { domain: currentView });
                        return {
                            type: 'text',
                            content: result.content,
                            meta: { contentType: 'pdf', exportable: true }
                        };
                    }
                    if (action === 'generate_executive_summary') {
                        const result = await AIContentEngine.generate('executive_summary', params.query || 'Executive summary', contextData, { domain: currentView });
                        return {
                            type: 'text',
                            content: result.content,
                            meta: { contentType: 'executive_summary', exportable: true }
                        };
                    }
                    if (action === 'generate_coaching_plan') {
                        const result = await AIContentEngine.generate('coaching_plan', params.query || 'Coaching plan', contextData, { domain: currentView });
                        return {
                            type: 'text',
                            content: result.content,
                            meta: { contentType: 'coaching_plan', exportable: true }
                        };
                    }
                    if (action === 'generate_1on1') {
                        const result = await AIContentEngine.generate('feedback_1on1', params.query || '1:1 feedback', contextData, { domain: currentView });
                        return {
                            type: 'text',
                            content: result.content,
                            meta: { contentType: 'feedback_1on1', exportable: true }
                        };
                    }
                    if (action === 'generate_kpi') {
                        const hasData = contextData && contextData.length > 0;
                        const kpiData = AIContentEngine.generateKPIGrid(params.query || 'KPIs', contextData, hasData);
                        return {
                            type: 'kpi-grid',
                            title: kpiData.title,
                            data: kpiData.data,
                            meta: { isMockData: !hasData }
                        };
                    }
                    if (action === 'generate_prediction') {
                        const hasData = contextData && contextData.length > 0;
                        const result = AIContentEngine.generatePrediction(
                            params.query || 'Predict performance', 
                            contextData, 
                            hasData, 
                            { domain: currentView, agent: params.agent }
                        );
                        return {
                            type: 'text',
                            content: result.content,
                            meta: { contentType: 'prediction', exportable: true }
                        };
                    }
                    if (action === 'draft_email') {
                         window.open(`mailto:${params.to || ''}?subject=${encodeURIComponent(params.subject)}&body=${encodeURIComponent(params.body)}`);
                         return { type: 'text', content: `\u2709\ufe0f **Drafted Email** to ${params.to}` };
                    }
                    if (action === 'start_quiz') {
                         return { type: 'text', content: `\ud83c\udfaf **Quiz Mode** started (Mock)` }; 
                    }
                    if (action === 'export_pdf') {
                        // Trigger PDF export
                        if (onDownloadImage && params.elementId) {
                            onDownloadImage(params.elementId, params.filename || 'export');
                        }
                        return { type: 'text', content: `\ud83d\udcc4 **PDF Export** initiated for ${params.filename || 'document'}` };
                    }
                    
                    // --- NEW TOOLS FOR ENHANCED CAPABILITIES ---
                    
                    if (action === 'search_data') {
                        const searchQuery = params.query || '';
                        const searchTerms = searchQuery.toLowerCase().split(/\s+/).filter(t => t.length > 2);
                        
                        if (!contextData || contextData.length === 0) {
                            return { 
                                type: 'text', 
                                content: ` **Search Results**\n\nNo data available to search. Please load data first.` 
                            };
                        }
                        
                        const results = contextData.filter(record => {
                            const recordText = JSON.stringify(record).toLowerCase();
                            return searchTerms.some(term => recordText.includes(term));
                        }).slice(0, 10);
                        
                        if (results.length === 0) {
                            return { 
                                type: 'text', 
                                content: ` **Search Results**\n\nNo records found matching "${searchQuery}". Try different search terms.` 
                            };
                        }
                        
                        return {
                            type: 'table',
                            title: `Search Results: "${searchQuery}"`,
                            headers: Object.keys(results[0]).slice(0, 6),
                            rows: results.map(r => {
                                const row = {};
                                Object.keys(results[0]).slice(0, 6).forEach(h => row[h] = r[h] || '');
                                return row;
                            }),
                            meta: { isSearchResult: true, totalMatches: results.length }
                        };
                    }
                    
                    if (action === 'compare_agents') {
                        const agentsToCompare = params.agents || [];
                        const metrics = params.metrics || ['Rating', 'QC Score'];
                        
                        if (agentsToCompare.length < 2) {
                            return {
                                type: 'text',
                                content: ` **Comparison Error**\n\nPlease specify at least 2 agents to compare.`
                            };
                        }
                        
                        const comparisonData = agentsToCompare.map(agent => {
                            const agentRecords = contextData.filter(d => 
                                DataEngine.normalizeAgent(d, 'NPS') === agent || 
                                DataEngine.normalizeAgent(d, 'QC') === agent
                            );
                            
                            const metricValues = {};
                            metrics.forEach(metric => {
                                const values = agentRecords
                                    .map(r => parseFloat(r[metric]))
                                    .filter(v => !isNaN(v));
                                metricValues[metric] = values.length > 0 
                                    ? (values.reduce((a, b) => a + b, 0) / values.length).toFixed(2)
                                    : 'N/A';
                            });
                            
                            return {
                                name: agent,
                                recordCount: agentRecords.length,
                                ...metricValues
                            };
                        });
                        
                        return {
                            type: 'chart',
                            chartType: 'bar',
                            title: `Agent Comparison: ${agentsToCompare.join(' vs ')}`,
                            data: comparisonData,
                            config: { xKey: 'name', yKey: metrics[0] },
                            meta: { isComparison: true, metrics }
                        };
                    }
                    
                    if (action === 'generate_summary') {
                        const hasData = contextData && contextData.length > 0;
                        const recordCount = contextData?.length || 0;
                        
                        if (!hasData) {
                            return {
                                type: 'text',
                                content: ` **Data Summary**\n\nNo data currently loaded. Upload data to see summary statistics.`
                            };
                        }
                        
                        // Calculate basic stats
                        const numericColumns = Object.keys(contextData[0]).filter(key => {
                            return contextData.some(r => !isNaN(parseFloat(r[key])));
                        });
                        
                        const stats = numericColumns.slice(0, 4).map(col => {
                            const values = contextData
                                .map(r => parseFloat(r[col]))
                                .filter(v => !isNaN(v));
                            const avg = values.reduce((a, b) => a + b, 0) / values.length;
                            const min = Math.min(...values);
                            const max = Math.max(...values);
                            return { column: col, avg: avg.toFixed(2), min, max, count: values.length };
                        });
                        
                        return {
                            type: 'text',
                            content: ` **Data Summary**\n\n**Records:** ${recordCount}\n**Numeric Columns:** ${numericColumns.length}\n\n**Key Statistics:**\n${stats.map(s => `- **${s.column}**: Avg ${s.avg} (Range: ${s.min} - ${s.max})`).join('\n')}`
                        };
                    }
                    
                    if (action === 'export_csv') {
                        if (!contextData || contextData.length === 0) {
                            return {
                                type: 'text',
                                content: ` **Export Error**\n\nNo data available to export.`
                            };
                        }
                        
                        ExportEngine.exportCSV(contextData, params.filename || 'export');
                        return {
                            type: 'text',
                            content: ` **CSV Export**\n\nDownloaded ${contextData.length} records as CSV.`
                        };
                    }
                    
                    if (action === 'show_help') {
                        return {
                            type: 'text',
                            content: ` **Poppy AI - What I Can Do**

** Data Analysis:**
- "Analyze NPS trends for [Agent]"
- "Show QC scores over time"
- "Compare agents performance"

** Visualizations:**
- "Create a bar chart of ratings"
- "Generate a table of top performers"
- "Show KPI dashboard"

** NEW - Chart Generation on Demand:**
- "Show me a bar chart of top failed metrics"
- "Create pie chart of error distribution by category"
- "Display line chart of rating trends over time"
- "Show area chart of performance by agent"
- "Chart of [metric] by [dimension]"

** Content Generation:**
- "Generate Slack post for team"
- "Draft executive summary"
- "Create coaching plan for [Agent]"
- "Write 1:1 feedback"

** Search & Filter:**
- "Search for [keyword]"
- "Filter by agent [Name]"
- "Find records with low scores"

** Export:**
- "Export as CSV"
- "Download as PDF"
- "Copy to clipboard"
- **NEW:** Click export button (?) in chat header to save conversation as PDF or Word

** Other:**
- "Switch to NPS view"
- "Clear chat history"
- "What can you do?"`
                        };
                    }
                    
                } catch (e) {
                    console.error("Execution error", e);
                    return { type: 'text', content: `\u26a0\ufe0f Failed to execute ${action}: ${e.message}`, meta: { style: 'error' } };
                }
                return null;
            };
            const [isWide, setIsWide] = useState(false);
            const [mode, setMode] = useState('chat');
            
            // ENHANCED UI STATES (#77, #80, #81, #82)
            const [isDragOver, setIsDragOver] = useState(false);
            const [showShortcuts, setShowShortcuts] = useState(false);
            const [chatSize, setChatSize] = useState({ width: 450, height: 650 });


            const buildGreetingMessage = () => {
                const total = (npsData?.length || 0) + (qcData?.length || 0);
                const hour = new Date().getHours();
                const salutation = hour < 12 ? 'Good morning' : (hour < 18 ? 'Good afternoon' : 'Good evening');
                const viewLabel = currentView ? String(currentView).toUpperCase() : 'UNIFIED';
                const dataLine = total > 0
                    ? `I have access to ${total} records.`
                    : `No data loaded - I can still generate charts and reports!`;
                return `${salutation}! I'm Poppy AI, your CX analytics assistant for ${viewLabel} data. ${dataLine}\n\n**Try asking:**\n- "Show bar chart of failed metrics"\n- "Generate Slack post"\n- "Analyze trends for [Agent]"\n- "Create executive summary"`;
            };


            const buildGreetingSuggestions = () => {
                const total = (npsData?.length || 0) + (qcData?.length || 0);
                if (total === 0) {
                    // Suggestions for when no data is loaded
                    return [
                        "Plan coaching for struggling agents",
                        "Show me a bar chart of sample metrics",
                        "Generate Slack post for team",
                        "Draft executive summary"
                    ];
                }
                const view = String(currentView || 'unified').toLowerCase();
                if (view === 'nps') return ["Show bar chart of ratings by agent", "Analyze NPS trends", "Create pie chart of CSAT distribution"];
                if (view === 'qc') return ["Show line chart of QC scores", "Analyze QC risks", "Create coaching plans for struggling agents"];
                return ["Show me a bar chart of top metrics", "Prepare for weekly team meeting", "Create line chart of trends"];
            };


            const extractUserRules = (text) => {
                const rules = [];
                const patterns = [
                    /i want (.+)/i,
                    /i prefer (.+)/i,
                    /i don't want (.+)/i,
                    /do not (.+)/i,
                    /avoid (.+)/i
                ];
                patterns.forEach(p => {
                    const match = text.match(p);
                    if (match && match[1]) {
                        const cleaned = match[1].replace(/[.?!]+$/, '').trim();
                        if (cleaned.length > 2 && cleaned.length < 140) rules.push(cleaned);
                    }
                });
                return rules;
            };


            // Enhanced state with memory integration
            const [messages, setMessages] = useState(() => {
                // Default welcome message
                return [{
                    role: 'assistant',
                    type: 'dashboard',
                    blocks: [],
                    suggestions: []
                }];
            });
            
            // Track conversation context for memory
            useEffect(() => {
                if (messages.length > 1) {
                    ENHANCED_AI_MEMORY.saveConversationContext(messages, sessionIdRef.current);
                }
            }, [messages]);
            
            // Load user preferences on mount
            useEffect(() => {
                const prefs = ENHANCED_AI_MEMORY.loadUserPreferences();
                if (prefs.preferredView) {
                    // Apply user preferences
                }
            }, []);


            // Hardening #9: Scroll Locking & Intent Memory
            const [userHasScrolledUp, setUserHasScrolledUp] = useState(false);
            const intentMemory = useRef({ primaryEntity: null, lastIntent: null, lastTimestamp: 0 });


            const [loading, setLoading] = useState(false);
            const [progress, setProgress] = useState({ stage: '', percent: 0 });
            const inputRef = useRef(null);
            const chatContainerRef = useRef(null);
            const floatingButtonRef = useRef(null);
            const messagesEndRef = useRef(null);
            const messagesRef = useRef(null);
            const chartLegendStateRef = useRef({});
            const tableSearchRef = useRef({});
            const tableVisibleColumnsRef = useRef({});
            const tableSortRef = useRef({}); // { [blockId]: { column: string, direction: 'asc' | 'desc' } }
            const [expandedChatBlock, setExpandedChatBlock] = useState(null);
            const [exportDropdownOpen, setExportDropdownOpen] = useState(false);

            // --- EXPORT CHAT FUNCTIONS ---
            const exportChatAsPDF = async () => {
                if (!messagesRef.current || messages.length === 0) {
                    showToast('No chat history to export', 'error');
                    return;
                }
                try {
                    setLoading(true);
                    const timestamp = new Date().toISOString().split('T')[0];
                    const filename = `poppy-chat-${timestamp}`;
                    
                    // Create a temporary container for PDF export
                    const tempDiv = document.createElement('div');
                    tempDiv.style.cssText = `
                        position: absolute; left: -9999px; top: 0;
                        width: 800px; padding: 40px; background: white;
                        font-family: 'Inter', sans-serif;
                    `;
                    
                    // Build HTML content
                    let chatHTML = `
                        <div style="max-width: 720px; margin: 0 auto;">
                            <h1 style="font-size: 24px; font-weight: bold; color: #4f46e5; margin-bottom: 8px;">
                                 Poppy AI Chat Export
                            </h1>
                            <p style="font-size: 12px; color: #64748b; margin-bottom: 30px;">
                                Generated on ${new Date().toLocaleString()}
                            </p>
                            <hr style="border: none; border-top: 2px solid #e2e8f0; margin-bottom: 30px;">
                    `;
                    
                    messages.forEach((msg, idx) => {
                        const isUser = msg.role === 'user';
                        const time = new Date().toLocaleTimeString();
                        const content = msg.content || (msg.blocks ? msg.blocks.map(b => b.content || b.title || '').join('\n') : '');
                        
                        chatHTML += `
                            <div style="margin-bottom: 20px; ${isUser ? 'text-align: right;' : ''}">
                                <div style="
                                    display: inline-block; max-width: 80%;
                                    padding: 8px 12px; border-radius: 12px;
                                    background: ${isUser ? '#4f46e5' : '#f1f5f9'};
                                    color: ${isUser ? 'white' : '#1e293b'};
                                    font-size: 14px; line-height: 1.6;
                                    text-align: left;
                                ">
                                    <div style="font-size: 11px; font-weight: bold; margin-bottom: 6px; opacity: 0.7;">
                                        ${isUser ? 'You' : 'Poppy AI'}  ${time}
                                    </div>
                                    <div style="white-space: pre-wrap;">${content}</div>
                                </div>
                            </div>
                        `;
                    });
                    
                    chatHTML += '</div>';
                    tempDiv.innerHTML = chatHTML;
                    document.body.appendChild(tempDiv);
                    
                    // Use html2canvas to capture
                    const canvas = await html2canvas(tempDiv, {
                        scale: 2,
                        useCORS: true,
                        logging: false,
                        backgroundColor: '#ffffff'
                    });
                    
                    document.body.removeChild(tempDiv);
                    
                    // Create PDF
                    const { jsPDF } = window.jspdf;
                    const pdf = new jsPDF('p', 'mm', 'a4');
                    const imgData = canvas.toDataURL('image/png');
                    const imgWidth = 210;
                    const pageHeight = 297;
                    const imgHeight = (canvas.height * imgWidth) / canvas.width;
                    let heightLeft = imgHeight;
                    let position = 0;
                    
                    pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                    heightLeft -= pageHeight;
                    
                    while (heightLeft > 0) {
                        position = heightLeft - imgHeight;
                        pdf.addPage();
                        pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                        heightLeft -= pageHeight;
                    }
                    
                    pdf.save(`${filename}.pdf`);
                    showToast('Chat exported as PDF', 'success');
                } catch (e) {
                    console.error('PDF export error:', e);
                    showToast('Failed to export PDF', 'error');
                } finally {
                    setLoading(false);
                    setExportDropdownOpen(false);
                }
            };

            const exportChatAsWord = () => {
                if (messages.length === 0) {
                    showToast('No chat history to export', 'error');
                    return;
                }
                
                const timestamp = new Date().toISOString().split('T')[0];
                const filename = `poppy-chat-${timestamp}.doc`;
                
                // Build HTML content for Word
                let chatHTML = `
                    <html xmlns:o='urn:schemas-microsoft-com:office:office' 
                          xmlns:w='urn:schemas-microsoft-com:office:word' 
                          xmlns='http://www.w3.org/TR/REC-html40'>
                    <head>
                        <meta charset="utf-8">
                        <title>Poppy AI Chat Export</title>
                        <style>
                            body { font-family: 'Calibri', 'Arial', sans-serif; font-size: 11pt; }
                            .header { color: #4f46e5; margin-bottom: 20px; }
                            .message { margin-bottom: 15px; padding: 10px; border-radius: 8px; }
                            .user { background: #e0e7ff; margin-left: 50px; }
                            .assistant { background: #f1f5f9; margin-right: 50px; }
                            .meta { font-size: 9pt; color: #64748b; margin-bottom: 5px; font-weight: bold; }
                            .content { white-space: pre-wrap; }
                        </style>
                    </head>
                    <body>
                        <div class="header">
                            <h1> Poppy AI Chat Export</h1>
                            <p>Generated on ${new Date().toLocaleString()}</p>
                        </div>
                        <hr>
                `;
                
                messages.forEach((msg) => {
                    const isUser = msg.role === 'user';
                    const time = new Date().toLocaleTimeString();
                    const content = msg.content || (msg.blocks ? msg.blocks.map(b => b.content || b.title || '').join('\n') : '');
                    const roleClass = isUser ? 'user' : 'assistant';
                    const roleLabel = isUser ? 'You' : 'Poppy AI';
                    
                    chatHTML += `
                        <div class="message ${roleClass}">
                            <div class="meta">${roleLabel}  ${time}</div>
                            <div class="content">${content}</div>
                        </div>
                    `;
                });
                
                chatHTML += '</body></html>';
                
                // Create blob and download
                const blob = new Blob(['\ufeff', chatHTML], {
                    type: 'application/msword'
                });
                
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                showToast('Chat exported as Word document', 'success');
                setExportDropdownOpen(false);
            };

            // --- CHART INTENT PARSER ---
            const parseChartIntent = (text) => {
                const lower = text.toLowerCase();
                
                // FIX: Better detection for chart requests including specific agent names
                const chartKeywords = ['chart', 'graph', 'plot', 'visualization', 'visualise', 'visualize', 'show me', 'give me', 'display'];
                const hasChartKeyword = chartKeywords.some(kw => lower.includes(kw));
                
                // Chart type detection
                let chartType = null;
                if (lower.includes('bar') || lower.includes('column')) chartType = 'bar';
                else if (lower.includes('line') || lower.includes('trend')) chartType = 'line';
                else if (lower.includes('pie') || lower.includes('doughnut') || lower.includes('distribution')) chartType = 'pie';
                else if (lower.includes('area')) chartType = 'area';
                else if (hasChartKeyword) chartType = 'bar'; // default when chart keyword present
                
                if (!chartType) return null;
                
                // FIX: Detect specific agent names in the query
                const agentMatch = text.match(/(?:for|of|about)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/i);
                const specificAgent = agentMatch ? agentMatch[1] : null;
                
                // Metric detection - expanded list
                const metrics = ['rating', 'score', 'nps', 'qc', 'performance', 'failed', 'pass', 'error', 'count', 'total', 'audits', 'reviews'];
                let metric = 'Rating';
                for (const m of metrics) {
                    if (lower.includes(m)) {
                        metric = m.charAt(0).toUpperCase() + m.slice(1);
                        break;
                    }
                }
                
                // Dimension detection
                const dimensions = ['agent', 'date', 'category', 'tag', 'country', 'metric', 'status', 'type'];
                let dimension = 'Agent';
                for (const d of dimensions) {
                    if (lower.includes(`by ${d}`) || lower.includes(`per ${d}`)) {
                        dimension = d.charAt(0).toUpperCase() + d.slice(1);
                        break;
                    }
                }
                
                // Extract specific keywords for title
                let title = specificAgent 
                    ? `${metric} for ${specificAgent}` 
                    : `${metric} by ${dimension}`;
                if (lower.includes('top')) title = `Top ${title}`;
                if (lower.includes('failed')) title = `Failed ${title}`;
                if (lower.includes('error')) title = `Error ${title}`;
                
                return { chartType, metric, dimension, title, specificAgent };
            };

            // --- ASK AI HELPER ---
            const askAI = (query) => {
                if (typeof query === 'string') {
                    handleSubmit(null, query);
                } else if (query && query.type) {
                    // Handle sparkle data object
                    const queryText = `Analyze ${query.type} data: ${JSON.stringify(query)}`;
                    handleSubmit(null, queryText);
                }
            };


            // --- LISTENERS ---
            // Mission 1: Restrict Access - Auto-trigger logic removed per strict guardrails
            // Chatbot must only be opened via explicit user interaction (click)



            useEffect(() => {
                if (!isOpen) return;
                const handleClickOutside = (e) => {
                    if (chatContainerRef.current && !chatContainerRef.current.contains(e.target) &&
                        floatingButtonRef.current && !floatingButtonRef.current.contains(e.target)) {
                        setIsOpen(false);
                        if (onClose) onClose();
                    }
                    // Close export dropdown when clicking outside
                    if (exportDropdownOpen && !e.target.closest('.relative')) {
                        setExportDropdownOpen(false);
                    }
                };
                const handleKeydown = (e) => {
                    if (e.key === 'Escape') {
                        setIsOpen(false);
                        if (onClose) onClose();
                        setExportDropdownOpen(false);
                    }
                };
                document.addEventListener('mousedown', handleClickOutside);
                document.addEventListener('keydown', handleKeydown);
                return () => {
                    document.removeEventListener('mousedown', handleClickOutside);
                    document.removeEventListener('keydown', handleKeydown);
                };
            }, [isOpen, onClose, exportDropdownOpen]);


            useEffect(() => {
                const lastMsg = messages[messages.length - 1];
                if (lastMsg && lastMsg.role === 'assistant' && lastMsg.blocks) {
                    const hasVisuals = lastMsg.blocks.some(b => ['chart', 'table', 'kpi-grid'].includes(b.type));
                    setIsWide(hasVisuals);
                    setMode(hasVisuals ? 'analysis' : 'chat');
                }
            }, [messages]);


            // Hardening #7: Context Debouncing & Delta Tracking
            const [debouncedData, setDebouncedData] = useState(activeFilteredData);
            const [isDataStale, setIsDataStale] = useState(false);
            const [hasNewDataDelta, setHasNewDataDelta] = useState(false);
            const lastDataSize = useRef(activeFilteredData.length);


            useEffect(() => {
                const handler = setTimeout(() => {
                    setDebouncedData(activeFilteredData);
                    setIsDataStale(false);


                    if (activeFilteredData.length !== lastDataSize.current) {
                        setHasNewDataDelta(true);
                        PoppyLogger.info('AI', 'Significant data delta detected while chat open.');
                    }
                }, 500);


                setIsDataStale(true);
                return () => clearTimeout(handler);
            }, [activeFilteredData]);


            // Reset delta when user sends a new query
            useEffect(() => {
                if (loading) {
                    setHasNewDataDelta(false);
                    lastDataSize.current = activeFilteredData.length;
                }
            }, [loading, activeFilteredData.length]);


            useEffect(() => {
                // Sandbox: localStorage blocked
                // localStorage.setItem('poppySuite_chatHistory', JSON.stringify(messages));
                if (isOpen && !userHasScrolledUp) {
                    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
                }
            }, [messages, isOpen, isWide, userHasScrolledUp]);


            // Handle manual scrolling to toggle lock
            const handleScroll = (e) => {
                const { scrollTop, scrollHeight, clientHeight } = e.target;
                const isAtBottom = scrollHeight - scrollTop - clientHeight < 50;
                setUserHasScrolledUp(!isAtBottom);
            };
            
            // DRAG-AND-DROP HANDLERS (#81)
            const handleDragOver = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragOver(true);
            };
            
            const handleDragLeave = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragOver(false);
            };
            
            const handleDrop = async (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsDragOver(false);
                
                const files = Array.from(e.dataTransfer.files);
                if (files.length === 0) return;
                
                const file = files[0];
                
                // Try image validation first
                const imgValidation = ImageAnalyzer.validateFile(file);
                if (imgValidation.valid) {
                    try {
                        const base64 = await ImageAnalyzer.fileToBase64(file);
                        setSelectedImage(file);
                        setImagePreview(base64);
                        showToast('Image uploaded via drag-and-drop!', 'success');
                        return;
                    } catch (err) {
                        showToast('Failed to process image.', 'error');
                        return;
                    }
                }
                
                // Try document validation
                const docValidation = DocumentAnalysisEngine.validateDocument(file);
                if (docValidation.valid) {
                    try {
                        const text = await file.text();
                        // Store document content for analysis
                        setSelectedImage({ type: 'document', name: file.name, content: text });
                        setImagePreview(null);
                        showToast(`Document "${file.name}" uploaded! Ask me to analyze it.`, 'success');
                        return;
                    } catch (err) {
                        showToast('Failed to read document.', 'error');
                        return;
                    }
                }
                
                showToast(imgValidation.error || docValidation.error || 'Unsupported file type', 'error');
            };
            
            // KEYBOARD SHORTCUTS (#82)
            useEffect(() => {
                const handleGlobalKeyDown = (e) => {
                    // Only handle shortcuts when chat is open
                    if (!isOpen) {
                        // Open chat with Ctrl+/
                        if (e.ctrlKey && e.key === '/') {
                            e.preventDefault();
                            setIsOpen(true);
                            setTimeout(() => inputRef.current?.focus(), 100);
                        }
                        return;
                    }
                    
                    // Ctrl+Shift+C: Clear chat
                    if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                        e.preventDefault();
                        clearHistory();
                        showToast('Chat history cleared', 'success');
                        return;
                    }
                    
                    // Ctrl+Shift+E: Export chat
                    if (e.ctrlKey && e.shiftKey && e.key === 'E') {
                        e.preventDefault();
                        exportChatAsPDF();
                        return;
                    }
                    
                    // ?: Show shortcuts
                    if (e.key === '?' && !e.ctrlKey && !e.altKey) {
                        e.preventDefault();
                        setShowShortcuts(true);
                        return;
                    }
                    
                    // / : Focus input and clear (if not in input)
                    if (e.key === '/' && document.activeElement !== inputRef.current) {
                        e.preventDefault();
                        inputRef.current?.focus();
                        return;
                    }
                    
                    // Ctrl+/: Show help
                    if (e.ctrlKey && e.key === '/') {
                        e.preventDefault();
                        handleSubmit(null, 'What can you do?');
                        return;
                    }
                };
                
                window.addEventListener('keydown', handleGlobalKeyDown);
                return () => window.removeEventListener('keydown', handleGlobalKeyDown);
            }, [isOpen, messages]);


            // --- ACTIONS ---
            const clearHistory = () => {
                setMessages([{
                    role: 'assistant',
                    blocks: [],
                    suggestions: []
                }]);
                // Sandbox: localStorage blocked
                // localStorage.removeItem('poppySuite_chatHistory');
                setIsWide(false);
                setMode('chat');
            };


            const getAllData = () => ({
                npsData, qcData, combinedData: [...npsData, ...qcData], type: 'All'
            });





            // --- ENHANCED CORE LOGIC ---
            const handleSubmit = async (e, manualQuery) => {
                if (e && e.preventDefault) e.preventDefault();
                const text = manualQuery || query;
                if (!text.trim() || loading) return;

                const allData = getAllData();
                const lowerText = text.toLowerCase();
                
                // Check for context references (pronouns)
                const lastAssistantMsg = messages.slice().reverse().find(m => m.role === 'assistant');
                const lastUserMsg = messages.slice().reverse().find(m => m.role === 'user');
                const hasContextRef = /\b(he|she|him|her|his|hers|they|them|their|that|it|this|these|those)\b/i.test(text);
                
                // Determine intent domain early for data selection
                const domain = (lowerText.includes('nps') ? 'nps' : (lowerText.includes('qc') ? 'qc' : 'unified'));
                
                // Initialize metricData early to avoid TDZ (ReferenceError fix)
                let metricData = debouncedData || [];
                if (!metricData || metricData.length === 0) {
                    if (domain === 'nps') metricData = allData.npsData || [];
                    else if (domain === 'qc') metricData = allData.qcData || [];
                    else metricData = [...(allData.npsData || []), ...(allData.qcData || [])];
                }

                const detectedRules = extractUserRules(text);

                if (detectedRules.length > 0) {
                    const mem = AI_MEMORY_ENGINE.load();
                    const existing = Array.isArray(mem?.preferences?.userRules) ? mem.preferences.userRules : [];
                    const merged = [...new Set([...existing, ...detectedRules])];
                    AI_MEMORY_ENGINE.remember('preference', { userRules: merged });
                    ENHANCED_AI_MEMORY.saveUserPreferences({ userRules: merged });
                }
                
                // Remember this query for context
                ENHANCED_AI_MEMORY.rememberFact('user_query', text, { 
                    domain, 
                    hasContextRef,
                    timestamp: Date.now()
                });

                if (typeof setQuery === 'function') {
                    setQuery('');
                }
                setMessages(prev => [...prev, { role: 'user', content: text, id: `msg_${Date.now()}` }]);
                setLoading(true);
                setRetryCount(0);

                const classification = { intent: text.toLowerCase().includes('report') ? 'GENERATE' : 'ASK', confidence: 1.0 };
                const intent = {
                    type: classification.intent === 'GENERATE' ? 'report' : 'chat',
                    domain: domain,
                    classification: classification
                };

                // --- ENHANCED CONTENT TYPE DETECTION ---
                // Mission 1: The Dispatcher & Context Injection
                const POPPY_AI_CONTEXT = {
                    activeTab,
                    filteredCount: activeFilteredData ? activeFilteredData.length : 0,
                    selectedAgent: selectedAgentGlobal,
                    view: currentView,
                    // Mission 1: Inject sanitized context from props
                    contextData: context ? JSON.stringify(context).replace(/\(Chat Link :\-.*?\)/g, '') : null
                };
                
                let detectedContentType = 'chat';
                
                try {
                    // Mission 1: The Dispatcher
                    const classification = await ToolOrchestrator.classify(text);
                    const intent = classification.intent;
                    
                    if (intent === 'unrelated') {
                        setMessages(prev => [...prev, { 
                            role: 'assistant', 
                            content: "I am designed specifically for CX Analytics and QA Performance. I cannot assist with general queries unrelated to this domain." 
                        }]);
                        setLoading(false);
                        return;
                    }

                    if (intent === 'data_viz') detectedContentType = 'chart';
                    else if (intent === 'table_gen') detectedContentType = 'table';
                    else if (intent === 'workflow') {
                        // Mission 1: Goal-Based Planning
                        setProgress({ stage: 'Planning workflow...', percent: 10 });
                        
                        const planPrompt = `Plan 3-5 sequential steps to address: "${text}".
Context: ${JSON.stringify(POPPY_AI_CONTEXT)}.
Available Actions: "filter_data", "generate_chart", "generate_table", "generate_summary", "generate_executive_summary", "generate_slack", "generate_pdf", "generate_coaching_plan", "generate_1on1", "search_data", "compare_agents".
Return Strict JSON: 
[
  { "action": "filter_data", "params": { "agent": "Name" }, "label": "Filter data for Name" },
  { "action": "generate_chart", "params": { "type": "bar", "data": "Rating" }, "label": "Analyze ratings" }
]`;
                        try {
                            const planJson = await GeminiAI.generateJson(planPrompt);
                            const steps = JSON.parse(planJson);
                            
                            const planId = `plan_${Date.now()}`;
                            
                            // Initial Plan Message
                            setMessages(prev => [...prev, {
                                role: 'assistant',
                                id: planId,
                                blocks: [{
                                    type: 'plan_overview',
                                    steps: steps.map(s => ({ ...s, status: 'pending' }))
                                }]
                            }]);

                            // Execute Steps
                            for (let i = 0; i < steps.length; i++) {
                                const step = steps[i];
                                
                                // Update Plan Status -> in_progress
                                setMessages(prev => prev.map(m => {
                                    if (m.id === planId) {
                                        const newBlocks = [...m.blocks];
                                        if (newBlocks[0] && newBlocks[0].type === 'plan_overview') {
                                            const newSteps = [...newBlocks[0].steps];
                                            newSteps[i].status = 'in_progress';
                                            newBlocks[0] = { ...newBlocks[0], steps: newSteps };
                                            return { ...m, blocks: newBlocks };
                                        }
                                    }
                                    return m;
                                }));

                                setProgress({ stage: step.label, percent: 10 + ((i + 1) / steps.length) * 80 });
                                
                                // Execute Action
                                let result = null;
                                try {
                                    result = await executeStep(step, metricData);
                                } catch (err) {
                                    console.error(`Step ${i} failed:`, err);
                                    result = { type: 'text', content: ` Step failed: ${err.message}`, meta: { style: 'error' } };
                                }
                                
                                // Add Result Message
                                if (result) {
                                    setMessages(prev => [...prev, {
                                        role: 'assistant',
                                        blocks: [result],
                                        id: `res_${Date.now()}_${i}`
                                    }]);
                                }
                                
                                // Update Plan Status -> completed
                                setMessages(prev => prev.map(m => {
                                    if (m.id === planId) {
                                        const newBlocks = [...m.blocks];
                                        if (newBlocks[0] && newBlocks[0].type === 'plan_overview') {
                                            const newSteps = [...newBlocks[0].steps];
                                            newSteps[i].status = 'completed';
                                            newBlocks[0] = { ...newBlocks[0], steps: newSteps };
                                            return { ...m, blocks: newBlocks };
                                        }
                                    }
                                    return m;
                                }));
                                
                                await new Promise(r => setTimeout(r, 800)); // Visual delay
                            }
                        } catch (e) {
                            console.error("Workflow planning failed", e);
                            setMessages(prev => [...prev, { role: 'assistant', content: "I couldn't create a plan for that request." }]);
                        }
                        
                        detectedContentType = 'text'; // Handled by steps
                        setLoading(false);
                        return;
                    } else {
                        detectedContentType = 'chat';
                    }
                } catch(e) {
                    console.warn("Dispatcher error", e);
                    detectedContentType = AIContentEngine.detectContentType(text);
                }
                
                // Mission 1: Context Injection (Prepend to prompt)
                const enrichedText = `[SYSTEM_CONTEXT: ${JSON.stringify(POPPY_AI_CONTEXT)}]\n${text}`;
                // Use enrichedText for generation calls below
                
                // Handle content generation requests first (charts, tables, slack, pdf, etc.)
                const generativeTypes = ['chart', 'table', 'slack', 'pdf', 'executive_summary', 'coaching_plan', 'feedback_1on1', 'kpi_grid', 'snapshot', 'prediction'];
                
                if (generativeTypes.includes(detectedContentType)) {
                    setProgress({ stage: `Generating ${detectedContentType.replace('_', ' ')}...`, percent: 20 });
                    
                    try {
                        const contentResult = await AIContentEngine.generate(
                            detectedContentType, 
                            enrichedText, // Use enriched text
                            metricData, 
                            { domain, view: currentView }
                        );
                        
                        const blocks = [];
                        
                        // Add the generated content block based on type
                        if (detectedContentType === 'slack' || detectedContentType === 'pdf' || 
                            detectedContentType === 'executive_summary' || detectedContentType === 'coaching_plan' || 
                            detectedContentType === 'feedback_1on1' || detectedContentType === 'prediction') {
                            // These types return content to display
                            if (contentResult.content) {
                                blocks.push({ 
                                    type: 'text', 
                                    content: contentResult.content,
                                    meta: { contentType: detectedContentType, exportable: true }
                                });
                            }
                        } else {
                            // Chart, table, kpi_grid return structured data
                            blocks.push(contentResult);
                        }
                        
                        // Add copy/export hint
                        if (detectedContentType === 'slack') {
                            blocks.push({
                                type: 'text',
                                content: ' **Tip:** Click the copy button to copy this post for Slack.',
                                meta: { style: 'tip' }
                            });
                        } else if (detectedContentType === 'pdf') {
                            blocks.push({
                                type: 'text',
                                content: ' **Tip:** Use the capture button to save this as an image/PDF.',
                                meta: { style: 'tip' }
                            });
                        }
                        
                        // Add confidence indicator
                        blocks.push({
                            type: 'confidence',
                            level: 'High',
                            justification: `AI Generated ${detectedContentType.replace('_', ' ').toUpperCase()}`
                        });
                        
                        setMessages(prev => [...prev, {
                            role: 'assistant',
                            blocks,
                            suggestions: detectedContentType === 'slack' 
                                ? ['Share to team', 'Edit message', 'Save draft']
                                : detectedContentType === 'chart'
                                ? ['Add trend line', 'Compare agents', 'Export data']
                                : detectedContentType === 'table'
                                ? ['Sort by column', 'Export to CSV', 'Filter results', 'Top 10', 'Bottom 5']
                                : detectedContentType === 'snapshot'
                                ? ['Add annotation', 'Download image', 'Capture again', 'Share with team']
                                : detectedContentType === 'prediction'
                                ? ['Predict for specific agent', 'Show at-risk agents', 'Weekly forecast']
                                : ['Create another', 'Export', 'Share']
                        }]);
                        
                        setLoading(false);
                        setProgress({ stage: '', percent: 0 });
                        return;
                        
                    } catch (genError) {
                        console.error('Content generation error:', genError);
                        // Fall through to standard handling
                    }
                }
                
                // --- CHART GENERATION ON DEMAND ---
                // Parse natural language chart requests
                const chartIntent = parseChartIntent(text);
                if (chartIntent && !generativeTypes.includes(detectedContentType)) {
                    setProgress({ stage: `Generating ${chartIntent.chartType} chart...`, percent: 30 });
                    
                    try {
                        // Extract data based on chart intent
                        let chartData = [];
                        const hasData = metricData && metricData.length > 0;
                        
                        // FIX: Filter for specific agent if mentioned in query
                        let filteredData = metricData;
                        if (chartIntent.specificAgent && hasData) {
                            filteredData = metricData.filter(d => {
                                const agentName = DataEngine.normalizeAgent(d, domain === 'qc' ? 'QC' : 'NPS');
                                return agentName && agentName.toLowerCase().includes(chartIntent.specificAgent.toLowerCase());
                            });
                        }
                        
                        if (hasData) {
                            // Aggregate data based on dimension
                            const dimensionKey = chartIntent.dimension === 'Agent' ? 'Agent' : 
                                                chartIntent.dimension === 'Date' ? 'Date' : 
                                                chartIntent.dimension === 'Category' ? 'Chat Tag' :
                                                chartIntent.dimension === 'Tag' ? 'Chat Tag' :
                                                chartIntent.dimension === 'Country' ? 'Country' : 'Agent';
                            
                            const metricKey = chartIntent.metric === 'Rating' ? 'Rating' :
                                            chartIntent.metric === 'Score' ? 'QC Score' :
                                            chartIntent.metric === 'Nps' ? 'Rating' :
                                            chartIntent.metric === 'Qc' ? 'QC Score' : 'Rating';
                            
                            // Group data by dimension
                            const grouped = {};
                            // FIX: Use filteredData when specific agent is mentioned
                            const dataToUse = chartIntent.specificAgent ? filteredData : metricData;
                            dataToUse.forEach(d => {
                                const key = d[dimensionKey] || d['Agent'] || 'Unknown';
                                if (!grouped[key]) grouped[key] = { sum: 0, count: 0 };
                                const val = parseFloat(d[metricKey] || 0);
                                if (!isNaN(val)) {
                                    grouped[key].sum += val;
                                    grouped[key].count++;
                                }
                            });
                            
                            // Convert to chart data format
                            chartData = Object.entries(grouped)
                                .map(([name, stats]) => ({
                                    name: name.length > 30 ? name.substring(0, 20) + '...' : name,
                                    value: parseFloat((stats.sum / stats.count).toFixed(2))
                                }))
                                .sort((a, b) => b.value - a.value)
                                .slice(0, 15);
                        }
                        
                        // Generate fallback data if no real data
                        if (chartData.length === 0) {
                            chartData = AIContentEngine.generateMockData('chart');
                        }
                        
                        const chartBlock = {
                            type: 'chart',
                            chartType: chartIntent.chartType,
                            title: chartIntent.title,
                            data: chartData,
                            config: { xKey: 'name', yKey: 'value' },
                            meta: { isOnDemand: true, intent: chartIntent, isMockData: !hasData }
                        };
                        
                        setMessages(prev => [...prev, {
                            role: 'assistant',
                            blocks: [
                                chartBlock,
                                {
                                    type: 'confidence',
                                    level: hasData ? 'High' : 'Medium',
                                    justification: hasData ? 'AI Generated Chart from Current Data' : 'AI Generated Chart with Sample Data'
                                }
                            ],
                            suggestions: ['Show as line chart', 'Show as pie chart', 'Export chart data', 'Compare agents']
                        }]);
                        
                        setLoading(false);
                        setProgress({ stage: '', percent: 0 });
                        return;
                        
                    } catch (chartError) {
                        console.error('Chart generation error:', chartError);
                        // Fall through to standard handling
                    }
                }
                
                // Fast path for slack congratulations (existing)
                if (lowerText.includes('slack') && (lowerText.includes('congratulate') || lowerText.includes('congratulations') || lowerText.includes('celebrate'))) {
                    const response = await generateSlackCongratulations(text, allData);
                    setMessages(prev => [...prev, { role: 'assistant', content: response }]);
                    setLoading(false);
                    return;
                }


                const entityCheck = IntentEngine.resolveEntity(text, allAgents);


                // Hardening #10: Intent Memory & Rolling Context
                // If no entity found, check if we have one in memory (less than 10 mins old)
                let activeAgent = entityCheck.type === 'exact' ? entityCheck.match : null;
                if (!activeAgent && intentMemory.current.primaryEntity && (Date.now() - intentMemory.current.lastTimestamp < 600000)) {
                    // Check if query implies a continuation (pronouns or possessives)
                    const continuationTerms = ['he', 'she', 'him', 'her', 'his', 'hers', 'their', 'them', 'they', 'performance', 'score', 'results'];
                    if (continuationTerms.some(term => text.toLowerCase().includes(term))) {
                        activeAgent = intentMemory.current.primaryEntity;
                    }
                }


                if (activeAgent) {
                    intentMemory.current = {
                        primaryEntity: activeAgent,
                        lastIntent: classification.intent,
                        lastTimestamp: Date.now()
                    };
                }


                // 2. DISPATCHER
                try {
                    if (intent.type === 'report' && entityCheck.type !== 'none') {
                        if (entityCheck.type === 'exact') {
                            const agentName = entityCheck.match;
                            setProgress({ stage: 'Generating Report...', percent: 10 });


                            // Mock Report Generation
                            await generateHeadlessReport({
                                agentName,
                                startDate: intent.timeRange?.start || null,
                                endDate: intent.timeRange?.end || new Date(),
                                context: intent.domain === 'unified' ? 'Unified' : (intent.domain === 'nps' ? 'NPS' : 'QC')
                            }, allData, (p) => setProgress(p));


                            setMessages(prev => [...prev, { role: 'assistant', blocks: [{ type: 'text', content: `? **Report Ready!**\n\nPerformance report for **${agentName}** generated.` }] }]);
                        } else {
                            // Fuzzy Match Suggestions
                            setMessages(prev => [...prev, {
                                role: 'assistant',
                                blocks: [{ type: 'text', content: `Did you mean **${entityCheck.original}**? Select an agent:` }],
                                suggestions: entityCheck.match.map(a => `Report for ${a}`)
                            }]);
                        }
                    } else {
                        // --- ENHANCED AGENTIC AI LOGIC WITH MEMORY & RETRY ---
                        
                        // 1. Construct Enhanced Planning Prompt with Memory Context
                        const relevantMemory = ENHANCED_AI_MEMORY.recallRelevant(text, 5);
                        const agentContext = entityCheck.type === 'exact' 
                            ? ENHANCED_AI_MEMORY.getAgentContext(entityCheck.match)
                            : [];
                        
                        const promptContext = {
                             currentView, 
                             selectedAgent: selectedAgentGlobal, 
                             dataType: intent.domain === 'unified' ? 'Unified' : (intent.domain === 'nps' ? 'NPS' : 'QC'),
                             userQuery: text,
                             previousContext: hasContextRef && lastAssistantMsg 
                                ? 'User is referring to previous discussion.' 
                                : null,
                             relevantFacts: relevantMemory.map(f => f.content).join('\n'),
                             agentHistory: agentContext.length > 0 
                                ? `Previous interactions with ${entityCheck.match || 'this agent'}: ${agentContext.length} records` 
                                : null
                        };

                        const planningPrompt = `${AI_PERSONA}
${TL_PERSONA_PROMPT}

You are Poppy AI, an advanced CX Analytics Assistant with AGENTIC capabilities and MEMORY.

CONTEXT:
- Current View: '${promptContext.currentView}'
- Selected Agent: '${promptContext.selectedAgent || 'All'}'
- Data Type: '${promptContext.dataType}'
- User Query: "${promptContext.userQuery}"
- Has Data: ${(metricData && metricData.length > 0) ? 'true' : 'false (generate sample/mock data if needed)'}
${promptContext.previousContext ? `- Context: ${promptContext.previousContext}` : ''}
${promptContext.relevantFacts ? `- Relevant History:\n${promptContext.relevantFacts}` : ''}
${promptContext.agentHistory ? `- ${promptContext.agentHistory}` : ''}

RESPONSE FORMAT - Return ONLY valid JSON:
{
  "needsClarification": false,
  "clarificationQuestion": null,
  "plan": {
    "intent": "analyze|navigate|export|generate",
    "steps": [
      { "action": "action_name", "params": {} }
    ]
  },
  "response": "Markdown response to user (analysis/answer)",
  "proactiveSuggestions": ["suggestion1", "suggestion2"]
}

AVAILABLE ACTIONS:
- analyze_data: { "metric": "string", "dimension": "string" }
- filter_data: { "filters": { "agent": "name" }, "agent": "name" }
- switch_view: { "view": "nps|qc|unified", "tab": "Dashboard|Analysis" }
- generate_chart: { "type": "bar|line|pie|area", "data": "Rating|QC Score", "title": "string" }
- generate_table: { "title": "string", "columns": [] }
- generate_slack: { "query": "string" }
- generate_pdf: { "query": "string" }
- generate_executive_summary: { "query": "string" }
- generate_coaching_plan: { "query": "string", "agent": "name" }
- generate_1on1: { "query": "string", "agent": "name" }
- generate_kpi: { "query": "string" }
- generate_prediction: { "query": "string", "agent": "name" }
- export_pdf: { "elementId": "string", "filename": "string" }
- draft_email: { "to": "email", "subject": "string", "body": "string" }
- search_data: { "query": "string", "filters": {} }
- compare_agents: { "agents": [], "metrics": [] }
- analyze_image: { "imageData": "base64string", "query": "string" }

If user intent is unclear, set needsClarification: true and provide helpful clarificationQuestion.`;

                        // 2. Generate Plan with Retry
                        let responseJson;
                        try {
                            responseJson = await withRetry(
                                () => GeminiAI.generateJson(planningPrompt),
                                {
                                    maxRetries: 3,
                                    delay: 1000,
                                    onRetry: (attempt, max) => {
                                        setRetryCount(attempt);
                                        setProgress({ stage: `Retrying AI request (${attempt}/${max})...`, percent: 30 + attempt * 20 });
                                    }
                                }
                            );
                        } catch (apiError) {
                            console.error('API Error after retries:', apiError);
                            setMessages(prev => [...prev, {
                                role: 'assistant',
                                blocks: [{
                                    type: 'text',
                                    content: ` **Service Temporarily Unavailable**\n\nI'm having trouble connecting to my AI service. Here's what I can do:\n\n1. Try again in a moment\n2. Check your internet connection\n3. I can still perform basic actions like filtering and view switching\n\n**Error:** ${apiError.message || 'Unknown error'}`
                                }],
                                suggestions: ["Try again", "Show basic help", "Switch to NPS view"],
                                id: `msg_${Date.now()}`
                            }]);
                            setLoading(false);
                            setProgress({ stage: '', percent: 0 });
                            return;
                        }
                        
                        let parsed;
                        try {
                             parsed = JSON.parse(responseJson.replace(/```json/g, '').replace(/```/g, '').trim());
                        } catch (e) {
                             console.warn("JSON Parse Error", e);
                             parsed = { 
                                 response: responseJson,
                                 plan: { steps: [] },
                                 proactiveSuggestions: ["Analyze trends", "Show help"]
                             };
                        }

                        const blocks = [];

                        // 3. Execution Phase with Enhanced Error Handling
                        if (parsed.needsClarification) {
                             blocks.push({ 
                                 type: 'text', 
                                 content: parsed.clarificationQuestion || "Could you clarify what you'd like me to do?",
                                 meta: { style: 'clarification' }
                             });
                        } else {
                             // Execute Plan Steps
                             if (parsed.plan?.steps) {
                                  for (const step of parsed.plan.steps) {
                                      try {
                                          const result = await executeStep(step, metricData);
                                          if (result) {
                                              blocks.push(result);
                                              ENHANCED_AI_MEMORY.rememberFact('executed_action', 
                                                  `Executed: ${step.action}`,
                                                  { params: step.params, timestamp: Date.now() }
                                              );
                                          }
                                      } catch (stepError) {
                                          console.error('Step execution error:', stepError);
                                          blocks.push({
                                              type: 'text',
                                              content: ` Could not complete action "${step.action}": ${stepError.message}`,
                                              meta: { style: 'error' }
                                          });
                                      }
                                      
                                      if (step.action === 'start_quiz') {
                                            try {
                                                const quizData = await AIQueryEngine.generateQuiz(promptContext.dataType, metricData);
                                                setMessages(prev => [...prev, {
                                                    role: 'assistant',
                                                    type: 'quiz',
                                                    quizData: quizData,
                                                    blocks: [{ type: 'text', content: " **Quiz Ready!** Test your knowledge." }],
                                                    id: `msg_${Date.now()}`
                                                }]);
                                                setLoading(false);
                                                return;
                                            } catch (quizError) {
                                                blocks.push({
                                                    type: 'text',
                                                    content: ' Could not generate quiz at this time.'
                                                });
                                            }
                                      }
                                  }
                             }
                             
                             if (parsed.response) {
                                 blocks.push({ 
                                     type: 'text', 
                                     content: parsed.response,
                                     meta: { streaming: false }
                                 });
                             }
                             
                             const confidenceLevel = blocks.length > 2 ? 'High' : (blocks.length > 0 ? 'Medium' : 'Low');
                             blocks.push({
                                type: 'confidence',
                                level: confidenceLevel,
                                justification: parsed.plan?.steps?.length > 0 
                                    ? `Executed ${parsed.plan.steps.length} action(s)` 
                                    : 'Direct response'
                             });
                        }

                        const suggestions = parsed.proactiveSuggestions || 
                            (parsed.plan?.steps?.some(s => s.action === 'generate_chart') 
                                ? ['Add trend line', 'Export chart', 'Compare with last month']
                                : ["Deep Dive", "Show Trends", "Compare Agents"]);
                        
                        setMessages(prev => [...prev, {
                            role: 'assistant',
                            blocks,
                            navigate: parsed.plan?.steps?.find(s => s.action === 'switch_view')?.params,
                            suggestions,
                            id: `msg_${Date.now()}`
                        }]);
                    }
                } catch (err) {
                    PoppyLogger.error('AI', "AI Processing Error", err);
                    
                    const fallbackResponses = [
                        "I'm experiencing a temporary issue. Let me try a different approach - could you rephrase your question?",
                        "I encountered an error processing that request. I can still help with basic queries like viewing data or switching tabs.",
                        "Something went wrong on my end. Please try again or ask me about something else."
                    ];
                    const randomFallback = fallbackResponses[Math.floor(Math.random() * fallbackResponses.length)];
                    
                    setMessages(prev => [...prev, {
                        role: 'assistant',
                        blocks: [{ 
                            type: 'text', 
                            content: ` **${randomFallback}**`,
                            meta: { style: 'error' }
                        }],
                        suggestions: ["Try again", "Show basic help", "What can you do?"],
                        id: `msg_${Date.now()}`
                    }]);
                    
                    ENHANCED_AI_MEMORY.rememberFact('error', err.message || 'Unknown error', {
                        timestamp: Date.now(),
                        query: text
                    });
                }


                setLoading(false);
                setProgress({ stage: '', percent: 0 });
                setRetryCount(0);
            };


            // --- QUIZ HANDLER ---
            const handleQuizAnswer = (quizIndex, questionIndex, optionIndex) => {
                setMessages(prev => {
                    const newMsgs = [...prev];
                    const quizMsg = newMsgs[quizIndex];
                    if (!quizMsg.quizState) quizMsg.quizState = {};
                    quizMsg.quizState[questionIndex] = optionIndex;
                    return newMsgs;
                });
            };


            // --- RENDER HELPERS ---
            const handleCaptureReply = (index) => { if (onDownloadImage) onDownloadImage(`ai-message-${index}`, `AI_Reply_${index}`); };
            const handleBlockCapture = (id, title) => { if (onDownloadImage) onDownloadImage(id, title || 'AI_Export'); }
            const isNumericCellValue = (value) => {
                if (value === null || value === undefined) return false;
                const text = String(value).trim();
                if (!text) return false;
                if (/^[+-]?\d+(\.\d+)?%?$/.test(text)) return true;
                if (/^\d{1,3}(,\d{3})+(\.\d+)?%?$/.test(text)) return true;
                return false;
            };
            const getColumnAlignClass = (header, rows, headerIndex) => {
                if (!rows || rows.length === 0) return 'text-left';
                for (let i = 0; i < rows.length; i += 1) {
                    const row = rows[i];
                    const value = row?.[header] ?? row?.[headerIndex];
                    if (value !== undefined && value !== null && String(value).trim() !== '') {
                        return isNumericCellValue(value) ? 'text-center' : 'text-left';
                    }
                }
                return 'text-left';
            };


            const renderBlock = (block, idx, msgIndex) => {
                const blockId = `ai-block-${msgIndex}-${idx}`;


                // Wrappers for actions
                const sparkleData = { type: block.type, title: block.title, meta: block.meta || {} };
                const handleCopy = () => { copyRichText(blockId); showToast("Copied to clipboard", "success"); };
                const handleDownload = () => handleBlockCapture(blockId, block.title);
                const handleAsk = () => askAI(sparkleData);
                const handleExpand = () => setExpandedChatBlock({ block, blockId });


                if (block.type === 'confidence') {
                    return (
                        <div key={idx} className="flex items-center gap-2 text-[10px] text-slate-500 mt-1 mb-3 ml-1 px-4">
                            <ShieldCheck size={12} className={block.level === 'High' ? 'text-emerald-500' : (block.level === 'Medium' ? 'text-amber-500' : 'text-rose-500')} />
                            <span>Confidence: <b className={block.level === 'High' ? 'text-emerald-600' : (block.level === 'Medium' ? 'text-amber-600' : 'text-rose-600')}>{block.level}</b> ({block.justification})</span>
                        </div>
                    );
                }

                // Plan Overview Block
                if (block.type === 'plan_overview') {
                    return (
                        <div key={idx} className="mb-4 bg-white border border-slate-200 rounded-xl overflow-hidden shadow-sm">
                            <div className="bg-slate-50 px-4 py-3 border-b border-slate-200 flex justify-between items-center">
                                <h4 className="font-bold text-slate-700 text-sm flex items-center gap-2">
                                    <ListChecks size={16} className="text-indigo-600"/>
                                    Execution Plan
                                </h4>
                                <span className="text-xs font-medium text-slate-500">{block.steps.length} steps</span>
                            </div>
                            <div className="divide-y divide-slate-100">
                                {block.steps.map((step, sIdx) => (
                                    <div key={sIdx} className="px-4 py-3 flex items-center gap-3">
                                        <div className={`w-6 h-6 rounded-full flex items-center justify-center text-[10px] font-bold shrink-0
                                            ${step.status === 'completed' ? 'bg-emerald-100 text-emerald-700' : 
                                              step.status === 'in_progress' ? 'bg-indigo-100 text-indigo-700 animate-pulse' : 
                                              'bg-slate-100 text-slate-500'}`}>
                                            {step.status === 'completed' ? <Check size={14} /> : sIdx + 1}
                                        </div>
                                        <div className="flex-1 min-w-0">
                                            <div className={`text-xs font-medium ${step.status === 'pending' ? 'text-slate-500' : 'text-slate-900'}`}>
                                                {step.label}
                                            </div>
                                        </div>
                                        {step.status === 'in_progress' && <Loader2 size={14} className="animate-spin text-indigo-500" />}
                                    </div>
                                ))}
                            </div>
                        </div>
                    );
                }

                // Workflow Progress Block
                if (block.type === 'workflow_progress') {
                    return (
                        <div key={idx} className="mb-3 ml-2">
                            <div className="flex items-center gap-2 mb-2">
                                <div className={`w-6 h-6 rounded-full flex items-center justify-center text-xs font-bold ${block.isSummary ? 'bg-emerald-100 text-emerald-700' : 'bg-indigo-100 text-indigo-700'}`}>
                                    {block.stepNumber}
                                </div>
                                <div className="flex-1">
                                    <div className="text-xs font-semibold text-slate-700">{block.stepLabel}</div>
                                    <div className="w-full bg-slate-200 rounded-full h-1.5 mt-1">
                                        <div 
                                            className="bg-indigo-500 h-1.5 rounded-full transition-all duration-500" 
                                            style={{ width: `${(block.stepNumber / block.totalSteps) * 100}%` }}
                                        />
                                    </div>
                                </div>
                            </div>
                            <div className={`p-3 rounded-lg border ${block.isSummary ? 'bg-emerald-50 border-emerald-200' : 'bg-slate-50 border-slate-200'}`}>
                                <div className="text-sm text-slate-700 prose prose-sm max-w-none">
                                    <EnhancedMarkdownRenderer content={block.content} />
                                </div>
                            </div>
                        </div>
                    );
                }

                // Bulk Progress Block
                if (block.type === 'bulk_progress') {
                    return (
                        <div key={idx} className="mb-3 p-4 bg-blue-50 border border-blue-200 rounded-xl">
                            <div className="flex items-center justify-between mb-2">
                                <span className="text-sm font-semibold text-blue-900">Processing...</span>
                                <span className="text-xs text-blue-700">{block.percent}%</span>
                            </div>
                            <div className="w-full bg-blue-200 rounded-full h-2.5">
                                <div 
                                    className="bg-blue-600 h-2.5 rounded-full transition-all duration-300" 
                                    style={{ width: `${block.percent}%` }}
                                />
                            </div>
                            <div className="mt-2 text-xs text-blue-700">
                                {block.currentAgent ? `Processing: ${block.currentAgent}` : `Processing ${block.total} agents...`}
                            </div>
                            <div className="mt-1 text-xs text-blue-600">
                                {block.current} of {block.total} completed
                            </div>
                        </div>
                    );
                }

                // Bulk Summary Block
                if (block.type === 'bulk_summary') {
                    return (
                        <div key={idx} className="mb-3">
                            <div className="flex items-center gap-2 mb-3 p-3 bg-emerald-50 border border-emerald-200 rounded-xl">
                                <CheckCircle size={20} className="text-emerald-600" />
                                <span className="text-sm font-semibold text-emerald-900">Operation Complete!</span>
                            </div>
                            <div className="p-4 bg-white border border-slate-200 rounded-xl shadow-sm">
                                <div className="prose prose-sm max-w-none">
                                    <EnhancedMarkdownRenderer content={block.content} />
                                </div>
                            </div>
                            {block.data && (
                                <div className="mt-3 grid grid-cols-3 gap-2">
                                    <div className="text-center p-2 bg-slate-50 rounded-lg">
                                        <div className="text-lg font-bold text-slate-700">{block.data.total}</div>
                                        <div className="text-xs text-slate-500">Total</div>
                                    </div>
                                    <div className="text-center p-2 bg-emerald-50 rounded-lg">
                                        <div className="text-lg font-bold text-emerald-700">{block.data.successCount}</div>
                                        <div className="text-xs text-emerald-600">Success</div>
                                    </div>
                                    <div className="text-center p-2 bg-rose-50 rounded-lg">
                                        <div className="text-lg font-bold text-rose-700">{block.data.failedCount}</div>
                                        <div className="text-xs text-rose-600">Failed</div>
                                    </div>
                                </div>
                            )}
                        </div>
                    );
                }

                if (block.type === 'text') {
                    // Check if this is special content type (slack, pdf, executive summary, etc.)
                    const contentType = block.meta?.contentType;
                    const isExportable = block.meta?.exportable;
                    const isSlack = contentType === 'slack';
                    const isPDF = contentType === 'pdf';
                    const isExecutive = contentType === 'executive_summary';
                    const isCoaching = contentType === 'coaching_plan';
                    const isFeedback1on1 = contentType === 'feedback_1on1';
                    
                    // Use AI Wrappers for special content types
                    if (isSlack || isExecutive || isCoaching || isFeedback1on1) {
                        return (
                            <div key={idx} id={blockId} className="relative group mb-3 overflow-visible">
                                {/* Use SlackPostWrapper for full Slack posts and executive summaries */}
                                <SlackPostWrapper
                                    content={block.content}
                                    title={isSlack ? 'Slack Post' : isExecutive ? 'Executive Summary' : isCoaching ? 'Coaching Plan' : '1:1 Feedback'}
                                    onUpdate={(newContent) => {
                                        setMessages(prev => {
                                            const newMsgs = [...prev];
                                            const msg = { ...newMsgs[msgIndex] };
                                            const blocks = [...(msg.blocks || [])];
                                            blocks[idx] = { ...blocks[idx], content: newContent };
                                            msg.blocks = blocks;
                                            newMsgs[msgIndex] = msg;
                                            return newMsgs;
                                        });
                                    }}
                                    onRegenerate={(prompt) => {
                                        // Trigger regeneration with optional modification prompt
                                        askAI?.(prompt || `Regenerate ${isSlack ? 'Slack post' : isExecutive ? 'executive summary' : isCoaching ? 'coaching plan' : '1:1 feedback'}`);
                                    }}
                                    isLoading={false}
                                />
                            </div>
                        );
                    }
                    
                    // Default text block with Enhanced Markdown Renderer
                    return (
                        <div key={idx} id={blockId} className="relative group mb-3 overflow-visible">
                            {block.content && (block.content.includes('```') || block.content.includes('**')) ? (
                                <div className={`p-4 rounded-xl border ${block.meta?.style === 'error' ? 'bg-rose-50 border-rose-200' : block.meta?.style === 'clarification' ? 'bg-amber-50 border-amber-200' : 'bg-white border-slate-200'} shadow-sm`}>
                                    <EnhancedMarkdownRenderer content={block.content} />
                                </div>
                            ) : (
                                <QuickInsightWrapper
                                    content={block.content}
                                    onUpdate={(newContent) => {
                                        setMessages(prev => {
                                            const newMsgs = [...prev];
                                            const msg = { ...newMsgs[msgIndex] };
                                            const blocks = [...(msg.blocks || [])];
                                            blocks[idx] = { ...blocks[idx], content: newContent };
                                            msg.blocks = blocks;
                                            newMsgs[msgIndex] = msg;
                                            return newMsgs;
                                        });
                                    }}
                                    onRegenerate={(prompt) => askAI?.(prompt || 'Regenerate insight')}
                                    isLoading={false}
                                />
                            )}
                        </div>
                    );
                }
                
                if (block.type === 'quiz') {
                    return (
                        <div key={idx} id={blockId} className="relative group mb-3 overflow-visible">
                            <QuizWrapper
                                questions={block.questions || []}
                                onUpdate={(newQuestions) => {
                                    setMessages(prev => {
                                        const newMsgs = [...prev];
                                        const msg = { ...newMsgs[msgIndex] };
                                        const blocks = [...(msg.blocks || [])];
                                        blocks[idx] = { ...blocks[idx], questions: newQuestions };
                                        msg.blocks = blocks;
                                        newMsgs[msgIndex] = msg;
                                        return newMsgs;
                                    });
                                }}
                                onRegenerate={() => askAI?.('Regenerate quiz')}
                                isLoading={false}
                            />
                        </div>
                    );
                }


                if (block.type === 'kpi-card') {
                    return (
                        <div key={idx} className="group relative mb-3 overflow-visible hover:z-20 transition-all">
                                <ElementToolbar type="kpi" onAskAI={handleAsk} onExpand={handleExpand} onDownloadImage={() => handleDownload()} sparkleData={sparkleData} sparkleType="KPI" />
                            <div id={blockId} className={`p-0 text-center border border-slate-200 rounded-xl bg-white shadow-sm relative overflow-visible block-card-animated ${block.trend && block.trend.includes('+') ? 'bg-emerald-50 text-emerald-900' : 'bg-rose-50 text-rose-900'}`}>
                                <div className="text-xs font-bold uppercase opacity-70 mb-1">{block.title}</div>
                                <div className="text-3xl font-black">{block.value}</div>
                                {block.trend && <div className="text-xs font-bold mt-1">{block.trend}</div>}
                            </div>
                        </div>
                    );
                }


                if (block.type === 'table') {
                    return (
<div key={idx} className="group relative mb-4 overflow-visible hover:z-20 transition-all">
                            <ElementToolbar
                                type="table"
                                onAskAI={handleAsk}
                                onExpand={handleExpand}
                                onDownloadImage={() => handleDownload()}
                                onCopyTable={() => copyTableToClipboard(blockId)}
                                onDownloadCSV={() => ExportEngine.exportCSV(block.rows, block.title || 'table')}
                                onSearchHighlight={(q) => { tableSearchRef.current[blockId] = q; messagesRef.current?.scrollIntoView?.(); }}
                                visibleColumns={(() => {
                                    if (!tableVisibleColumnsRef.current[blockId]) {
                                        const map = {}; (block.headers || []).forEach(h => { map[h] = true; }); tableVisibleColumnsRef.current[blockId] = map;
                                    }
                                    return tableVisibleColumnsRef.current[blockId];
                                })()}
                                onToggleColumn={(col) => { const m = tableVisibleColumnsRef.current[blockId]; m[col] = !m[col]; setMessages(p => [...p]); }}
                                sparkleData={sparkleData}
                                sparkleType="Table"
                            />
                            <div id={blockId} className="overflow-x-auto overflow-y-auto border border-slate-200 rounded-xl bg-white shadow-sm relative block-card-animated w-full" style={{maxHeight: '400px'}}>
                                <table className="w-full text-xs text-left">
                                    <thead className="bg-slate-50 border-b border-slate-200 text-slate-500 font-bold uppercase">
                                        <tr>{(block.headers || []).map((h, i) => (tableVisibleColumnsRef.current[blockId]?.[h]) ? <th key={i} className={`p-3 ${getColumnAlignClass(h, block.rows, i)}`}>{h}</th> : null)}</tr>
                                    </thead>
                                    <tbody className="divide-y divide-slate-100">
                                        {(block.rows || []).filter(row => {
                                            const q = (tableSearchRef.current[blockId] || '').toLowerCase();
                                            if (!q) return true;
                                            return (block.headers || []).some(h => String(row[h] || '').toLowerCase().includes(q));
                                        }).map((row, r) => (
                                            <tr key={r} className="hover:bg-slate-50">
                                                {(block.headers || []).map((h, c) => {
                                                    if (!tableVisibleColumnsRef.current[blockId]?.[h]) return null;
                                                    const value = row[h] ?? row[c];
                                                    const cellAlign = isNumericCellValue(value) ? 'text-center' : 'text-left';
                                                    return <td key={c} className={`p-3 ${cellAlign}`}>{value}</td>;
                                                })}
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    );
                }


                if (block.type === 'chart') {
                    const isMockData = block.meta?.isMockData;
                    const isOnDemand = block.meta?.isOnDemand;
                    const chartType = block.chartType || 'bar';
                    
                    // Color palette for charts
                    const COLORS = ['#6366f1', '#8b5cf6', '#ec4899', '#f59e0b', '#10b981', '#3b82f6', '#f97316', '#ef4444'];
                    
                    const renderChart = () => {
                        switch (chartType) {
                            case 'pie':
                                return (
                                    <PieChart>
                                        <Pie
                                            data={block.data}
                                            cx="50%"
                                            cy="50%"
                                            innerRadius={40}
                                            outerRadius={80}
                                            paddingAngle={2}
                                            dataKey={block.config.yKey}
                                            nameKey={block.config.xKey}
                                        >
                                            {block.data.map((entry, index) => (
                                                <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                                            ))}
                                        </Pie>
                                        <Tooltip contentStyle={{ borderRadius: '8px', border: 'none', boxShadow: '0 4px 6px -1px rgb(0 0 0 / 0.1)' }} />
                                        {chartLegendStateRef.current[blockId] ? <Legend /> : null}
                                    </PieChart>
                                );
                            case 'area':
                                return (
                                    <AreaChart data={block.data}>
                                        <defs>
                                            <linearGradient id={`colorArea-${blockId}`} x1="0" y1="0" x2="0" y2="1">
                                                <stop offset="5%" stopColor="#6366f1" stopOpacity={0.3}/>
                                                <stop offset="95%" stopColor="#6366f1" stopOpacity={0}/>
                                            </linearGradient>
                                        </defs>
                                        <CartesianGrid strokeDasharray="3 3" vertical={false} stroke="#e2e8f0" />
                                        <XAxis dataKey={block.config.xKey} tick={<CustomizedAxisTick />} axisLine={false} tickLine={false} />
                                        <YAxis tick={{ fontSize: 10 }} axisLine={false} tickLine={false} />
                                        <Tooltip contentStyle={{ borderRadius: '8px', border: 'none', boxShadow: '0 4px 6px -1px rgb(0 0 0 / 0.1)' }} />
                                        {chartLegendStateRef.current[blockId] ? <Legend /> : null}
                                        <Area type="monotone" dataKey={block.config.yKey} stroke="#6366f1" fillOpacity={1} fill={`url(#colorArea-${blockId})`} strokeWidth={2} />
                                    </AreaChart>
                                );
                            case 'line':
                                return (
                                    <LineChart data={block.data}>
                                        <CartesianGrid strokeDasharray="3 3" vertical={false} stroke="#e2e8f0" />
                                        <XAxis dataKey={block.config.xKey} tick={<CustomizedAxisTick />} axisLine={false} tickLine={false} />
                                        <YAxis tick={{ fontSize: 10 }} axisLine={false} tickLine={false} />
                                        <Tooltip cursor={{ stroke: '#cbd5e1' }} contentStyle={{ borderRadius: '8px', border: 'none', boxShadow: '0 4px 6px -1px rgb(0 0 0 / 0.1)' }} />
                                        {chartLegendStateRef.current[blockId] ? <Legend /> : null}
                                        <Line type="monotone" dataKey={block.config.yKey} stroke="#8b5cf6" strokeWidth={3} dot={{ r: 4, fill: '#fff', strokeWidth: 2 }} activeDot={{ r: 6 }} />
                                    </LineChart>
                                );
                            case 'bar':
                            default:
                                return (
                                    <BarChart data={block.data}>
                                        <CartesianGrid strokeDasharray="3 3" vertical={false} stroke="#e2e8f0" />
                                        <XAxis dataKey={block.config.xKey} tick={<CustomizedAxisTick />} axisLine={false} tickLine={false} />
                                        <YAxis tick={{ fontSize: 10 }} axisLine={false} tickLine={false} />
                                        <Tooltip cursor={{ fill: '#f1f5f9' }} contentStyle={{ borderRadius: '8px', border: 'none', boxShadow: '0 4px 6px -1px rgb(0 0 0 / 0.1)' }} />
                                        {chartLegendStateRef.current[blockId] ? <Legend /> : null}
                                        <Bar dataKey={block.config.yKey} fill="#6366f1" radius={[4, 4, 0, 0]} />
                                    </BarChart>
                                );
                        }
                    };
                    
                    return (
                        <div key={idx} className="group relative mb-3 overflow-visible">
                            <ElementToolbar type="chart" onAskAI={handleAsk} onExpand={handleExpand} onDownloadImage={() => handleDownload()} onToggleNumbers={() => { chartLegendStateRef.current[blockId] = !chartLegendStateRef.current[blockId]; setMessages(p => [...p]); }} isNumbersVisible={!!chartLegendStateRef.current[blockId]} sparkleData={sparkleData} sparkleType="Chart" />
                            <div id={blockId} className="p-0 h-64 w-full bg-white border border-slate-200 rounded-xl shadow-sm relative overflow-visible block-card-animated">
                                <div className="flex items-center justify-between mb-2">
                                    <div className="flex items-center gap-2">
                                        <h4 className="text-xs font-bold text-slate-500 uppercase">{block.title}</h4>
                                        {isOnDemand && (
                                            <span className="text-[10px] px-2 py-0.5 bg-indigo-100 text-indigo-700 rounded-full font-bold">
                                                AI Generated
                                            </span>
                                        )}
                                    </div>
                                    {isMockData && (
                                        <span className="text-[10px] px-2 py-0.5 bg-amber-100 text-amber-700 rounded-full font-bold">
                                            Sample Data
                                        </span>
                                    )}
                                </div>
                                <ResponsiveContainer width="100%" height="85%">
                                    {renderChart()}
                                </ResponsiveContainer>
                            </div>
                        </div>
                    );
                }


                if (block.type === 'kpi-grid') {
                    const isMockData = block.meta?.isMockData;
                    return (
                        <div key={idx} id={blockId} className="group relative mb-4 overflow-visible hover:z-20 transition-all">
                            <ElementToolbar
                                type="kpi"
                                onAskAI={handleAsk}
                                onExpand={handleExpand}
                                onDownloadImage={() => handleDownload()}
                                onCopy={() => handleCopy()}
                                sparkleData={sparkleData}
                                sparkleType="KPI Grid"
                                customActions={isMockData ? (
                                    <span className="text-[10px] px-2 py-0.5 bg-amber-100 text-amber-700 rounded-full font-bold">
                                        Sample Data
                                    </span>
                                ) : null}
                            />
                            <div className="grid grid-cols-2 gap-3">
                                {block.data.map((kpi, kIdx) => {
                                    const Icon = { 'file-text': FileText, 'users': Users, 'alert-circle': AlertCircle, 'check-circle': CheckCircle, 'trending-up': TrendingUp, 'star': Star, 'clock': Clock, 'shield': ShieldCheck }[kpi.icon] || Star;
                                    const colorClass = { 'blue': 'bg-blue-50 text-blue-600', 'green': 'bg-emerald-50 text-emerald-600', 'red': 'bg-rose-50 text-rose-600', 'purple': 'bg-purple-50 text-purple-600', 'amber': 'bg-amber-50 text-amber-600', 'orange': 'bg-orange-50 text-orange-600' }[kpi.color] || 'bg-slate-50 text-slate-600';
                                    return (
                                        <div key={kIdx} className="p-4 bg-slate-50 border border-slate-100 rounded-xl flex items-center gap-3">
                                            <div className={`p-2.5 rounded-lg ${colorClass}`}><Icon size={18} /></div>
                                            <div><div className="text-[10px] text-slate-500 uppercase font-bold tracking-wide">{kpi.title}</div><div className="text-lg font-black text-slate-900">{kpi.value}</div></div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    );
                }

                // --- DASHBOARD SNAPSHOT BLOCK ---
                if (block.type === 'snapshot') {
                    return (
                        <DashboardSnapshotBlock 
                            key={idx} 
                            block={block} 
                            blockId={blockId}
                            onAsk={handleAsk}
                            onExpand={handleExpand}
                        />
                    );
                }
                return null;
            };


            // --- UI RENDER (Redesigned) ---
            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (isOpen && 
                        panelRef.current && 
                        !panelRef.current.contains(event.target) && 
                        floatingButtonRef.current && 
                        !floatingButtonRef.current.contains(event.target)) {
                        setIsOpen(false);
                    }
                };
                
                document.addEventListener('mousedown', handleClickOutside);
                return () => {
                    document.removeEventListener('mousedown', handleClickOutside);
                };
            }, [isOpen]);

            return createPortal(
                
                <>
                    {/* Floating Button - Modern Gradient & Animated */}
                    <button
                        id="ai-floating-btn"
                        data-html2canvas-ignore="true"
                        onClick={() => setIsOpen(!isOpen)}
                        ref={floatingButtonRef}
                        style={{ position: 'fixed', bottom: '24px', right: '24px', zIndex: 2147483647 }}
                        className={`group w-14 h-14 rounded-full shadow-2xl flex items-center justify-center transition-all duration-500 ease-in-out hover:scale-110 active:scale-95 ${isOpen ? 'bg-slate-900 rotate-90' : 'bg-indigo-600 ' + (aiTrigger?.query ? 'animate-pulse' : '')}`}
                        title={isOpen ? "Close Assistant" : "Open AI Analyst"}
                    >
                        {isOpen ? <XIcon size={24} className="text-white" /> : <BrainCircuit size={24} className="text-white" />}
                        {/* Notification Badge */}
                        {!isOpen && aiTrigger?.query && (
                            <span className="absolute -top-1 -right-1 w-4 h-4 bg-rose-500 rounded-full animate-ping"></span>
                        )}
                    </button>


                    {/* Main Chat Panel - Glassmorphism with Resizable Support & Drag-Drop (#77, #81) */}
                    <div
                        id="ai-chat-panel"
                        data-html2canvas-ignore="true"
                        ref={panelRef}
                        onMouseDown={handleMouseDown}
                        onMouseMove={(e) => { if (!isResizing) e.currentTarget.style.cursor = getCursorStyle(e); }}
                        onDragOver={handleDragOver}
                        onDragLeave={handleDragLeave}
                        onDrop={handleDrop}
                        style={{ 
                            position: 'fixed', 
                            bottom: '90px', 
                            right: '24px', 
                            zIndex: 2147483647,
                            width: isOpen ? (isWide ? Math.max(size.width, 700) : size.width) : (isWide ? 900 : 400),
                            height: isOpen ? (isWide ? Math.max(size.height, 600) : size.height) : (isWide ? 800 : 550)
                        }}
                        className={`
                                flex flex-col overflow-hidden transition-all duration-500 cubic-bezier(0.4, 0, 0.2, 1) origin-bottom-right
                                ${isOpen ? 'opacity-100 scale-100 translate-y-0' : 'opacity-0 scale-90 translate-y-10 pointer-events-none'}
                                bg-white/95 backdrop-blur-2xl border border-white/20 shadow-2xl rounded-2xl font-sans
                                ${mode === 'analysis' ? 'border-violet-200' : 'border-white/20'}
                                ${isResizing ? 'select-none' : ''}
                                max-w-[calc(100vw-48px)] max-h-[calc(100vh-110px)]
                            `}
                    >
                        {/* Resize Handles Visual Indicator */}
                        <div className="absolute inset-x-0 top-0 h-1 cursor-ns-resize opacity-0 hover:opacity-100 transition-opacity" title="Drag to resize height"></div>
                        <div className="absolute inset-y-0 right-0 w-1 cursor-ew-resize opacity-0 hover:opacity-100 transition-opacity" title="Drag to resize width"></div>
                        <div className="absolute top-0 right-0 w-3 h-3 cursor-nwse-resize opacity-0 hover:opacity-100 transition-opacity" title="Drag to resize"></div>
                        {/* Header - Compact Design */}
                        <div className={`
                                relative p-2 shrink-0 flex justify-between items-center shadow-sm z-10 transition-colors duration-500
                                ${mode === 'analysis' ? 'bg-slate-900' : 'bg-indigo-600'}
                            `}>
                            <div className="flex items-center gap-2 text-white">
                                <BrainCircuit size={16} className={loading ? "text-blue-200 animate-pulse" : "text-white"} />
                                <div className="flex items-center gap-2">
                                    <h3 className="font-bold text-xs text-white">Poppy AI</h3>
                                    <span className="text-[10px] opacity-70 border-l border-white/20 pl-2">
                                        {currentView}
                                    </span>
                                </div>
                            </div>


                            <div className="flex items-center gap-1">
                                <button 
                                    onClick={() => handleSubmit(null, 'Take a dashboard snapshot')} 
                                    className="p-1.5 text-white/70 hover:text-white hover:bg-white/10 rounded-lg transition-colors" 
                                    title="Capture Snapshot"
                                >
                                    <Camera size={16} />
                                </button>
                                <button onClick={clearHistory} className="p-1.5 text-white/70 hover:text-white hover:bg-white/10 rounded-lg transition-colors" title="Clear History"><Trash2 size={16} /></button>
                                <button onClick={() => setIsOpen(false)} className="p-1.5 text-white/70 hover:text-white hover:bg-white/10 rounded-lg transition-colors md:hidden"><ChevronDown size={16} /></button>
                            </div>
                        </div>


                        {/* Messages Area - Compact */}
                        <div
                            className="flex-1 overflow-y-auto p-3 space-y-4 custom-scrollbar scroll-smooth bg-slate-50/50"
                            ref={messagesRef}
                            onScroll={handleScroll}
                        >
                            {messages.length === 0 && (
                                <div className="flex flex-col items-center justify-center h-full text-center text-slate-500 space-y-3">
                                    <BrainCircuit size={32} className="text-slate-300" />
                                    <p className="text-xs font-medium">Ready to analyze.</p>
                                    
                                    {/* Quick Actions */}
                                    <div className="mt-4 space-y-2">
                                        <div className="flex flex-wrap justify-center gap-1.5">
                                            <button 
                                                onClick={() => handleSubmit(null, 'Table of top 10 agents by failures')}
                                                className="px-2.5 py-1 bg-white border border-slate-200 hover:border-indigo-300 hover:bg-indigo-50 text-slate-600 hover:text-indigo-700 rounded-lg text-[10px] font-medium transition-all"
                                            >
                                                 Top 10 failures
                                            </button>
                                            <button 
                                                onClick={() => handleSubmit(null, 'Compare NPS vs QC scores in table')}
                                                className="px-2.5 py-1 bg-white border border-slate-200 hover:border-indigo-300 hover:bg-indigo-50 text-slate-600 hover:text-indigo-700 rounded-lg text-[10px] font-medium transition-all"
                                            >
                                                 Compare Scores
                                            </button>
                                            <button 
                                                onClick={() => handleSubmit(null, 'Show all critical errors this week')}
                                                className="px-2.5 py-1 bg-white border border-slate-200 hover:border-indigo-300 hover:bg-indigo-50 text-slate-600 hover:text-indigo-700 rounded-lg text-[10px] font-medium transition-all"
                                            >
                                                 Critical errors
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            )}


                            {messages.map((msg, i) => (
                                <div key={msg.id || i} className={`flex flex-col ${msg.role === 'user' ? 'items-end' : 'items-start'} animate-in fade-in slide-in-from-bottom-2 duration-300`}>
                                    <div
                                        id={`ai-message-${i}`}
                                        className={`
                                                max-w-[95%] relative p-3 shadow-sm text-sm leading-relaxed group
                                                ${msg.role === 'user'
                                                ? 'bg-indigo-600 text-white rounded-2xl rounded-tr-sm shadow-indigo-200'
                                                : 'bg-white/90 backdrop-blur-md border border-slate-200 text-slate-900 rounded-2xl rounded-tl-sm shadow-sm'
                                            }
                                            `}
                                    >
                                        {/* Export controls for AI responses with Inline Editing (#80) */}
                                        {msg.role === 'assistant' && (
                                            <div className="absolute top-2 right-2 flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity z-10">
                                                <button onClick={() => {
                                                    const text = msg.blocks ? msg.blocks.map(b => b.content || '').join('\n') : msg.content;
                                                    safeCopyToClipboard(text);
                                                }} className="p-1.5 text-slate-500 hover:text-blue-600 bg-white/80 rounded-lg shadow-sm backdrop-blur" title="Copy Text"><Copy size={14} /></button>
                                                <button onClick={() => handleCaptureReply(i)} className="p-1.5 text-slate-500 hover:text-blue-600 bg-white/80 rounded-lg shadow-sm backdrop-blur" title="Save Image"><Camera size={14} /></button>
                                                <button 
                                                    onClick={() => {
                                                        // Enable inline editing
                                                        setMessages(prev => {
                                                            const newMsgs = [...prev];
                                                            newMsgs[i] = { ...newMsgs[i], isEditing: true };
                                                            return newMsgs;
                                                        });
                                                    }} 
                                                    className="p-1.5 text-slate-500 hover:text-emerald-600 bg-white/80 rounded-lg shadow-sm backdrop-blur" 
                                                    title="Edit Response"
                                                >
                                                    <Edit2 size={14} />
                                                </button>
                                            </div>
                                        )}
                                        
                                        {/* Inline Editing Mode (#80) */}
                                        {msg.isEditing && (
                                            <div className="mt-3 p-3 bg-slate-50 rounded-xl border border-slate-200">
                                                <textarea
                                                    defaultValue={msg.blocks ? msg.blocks.map(b => b.content || '').join('\n') : msg.content}
                                                    className="w-full h-32 p-3 text-sm border border-slate-200 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent resize-y"
                                                    onChange={(e) => {
                                                        // Store edited content temporarily
                                                        msg.editedContent = e.target.value;
                                                    }}
                                                />
                                                <div className="flex gap-2 mt-2">
                                                    <button
                                                        onClick={() => {
                                                            // Save edits
                                                            setMessages(prev => {
                                                                const newMsgs = [...prev];
                                                                const editedContent = newMsgs[i].editedContent || (newMsgs[i].blocks ? newMsgs[i].blocks.map(b => b.content || '').join('\n') : newMsgs[i].content);
                                                                newMsgs[i] = { 
                                                                    ...newMsgs[i], 
                                                                    isEditing: false,
                                                                    content: editedContent,
                                                                    blocks: [{ type: 'text', content: editedContent, meta: { edited: true } }]
                                                                };
                                                                return newMsgs;
                                                            });
                                                            showToast('Changes saved', 'success');
                                                        }}
                                                        className="px-3 py-1.5 bg-indigo-600 text-white rounded-lg text-xs font-bold hover:bg-indigo-700"
                                                    >
                                                        Save
                                                    </button>
                                                    <button
                                                        onClick={() => {
                                                            // Cancel edits
                                                            setMessages(prev => {
                                                                const newMsgs = [...prev];
                                                                newMsgs[i] = { ...newMsgs[i], isEditing: false };
                                                                return newMsgs;
                                                            });
                                                        }}
                                                        className="px-3 py-1.5 bg-slate-200 text-slate-700 rounded-lg text-xs font-bold hover:bg-slate-300"
                                                    >
                                                        Cancel
                                                    </button>
                                                </div>
                                            </div>
                                        )}
                                        
                                        {/* Message Content with Enhanced Rendering */}
                                        {msg.blocks ? (
                                            msg.blocks.map((b, idx) => {
                                                if (b.type === 'text' && b.meta?.contentType) {
                                                    // Use enhanced markdown renderer for special content
                                                    return (
                                                        <div key={idx} className="relative">
                                                            {renderBlock(b, idx, i)}
                                                        </div>
                                                    );
                                                }
                                                return renderBlock(b, idx, i);
                                            })
                                        ) : (
                                            <div className="whitespace-pre-wrap">
                                                {msg.content && msg.content.length > 500 ? (
                                                    <ExpandableMessage content={msg.content} maxLines={10} />
                                                ) : (
                                                    msg.content
                                                )}
                                            </div>
                                        )}
                                        



                                        {/* Mission 1: Dynamic UI Rendering (Charts/Tables) */}
                                        {msg.type === 'chart' && msg.data && (
                                            <div className="h-64 w-full mt-4 bg-white p-2 rounded-xl shadow-sm border border-slate-100">
                                                <ResponsiveContainer width="100%" height="100%">
                                                    <BarChart data={msg.data}>
                                                        <CartesianGrid strokeDasharray="3 3" vertical={false} stroke="#e2e8f0" />
                                                        <XAxis dataKey="name" tick={{fontSize: 10}} interval={0} angle={-30} textAnchor="end" />
                                                        <YAxis tick={{fontSize: 10}} />
                                                        <Tooltip contentStyle={{borderRadius: '8px', border: 'none', boxShadow: '0 4px 6px -1px rgb(0 0 0 / 0.1)'}} />
                                                        <Legend />
                                                        <Bar dataKey="value" fill="#6366f1" radius={[4, 4, 0, 0]} />
                                                    </BarChart>
                                                </ResponsiveContainer>
                                            </div>
                                        )}
                                        
                                        {msg.type === 'table' && msg.rows && (
                                            <div className="overflow-x-auto mt-4 rounded-xl border border-slate-200 shadow-sm">
                                                <table className="min-w-full divide-y divide-slate-200 text-sm">
                                                    <thead className="bg-slate-50">
                                                        <tr>
                                                            {msg.headers && msg.headers.map((h, hi) => (
                                                                <th key={hi} className="px-4 py-3 text-left font-semibold text-slate-600 uppercase tracking-wider text-xs">{h}</th>
                                                            ))}
                                                        </tr>
                                                    </thead>
                                                    <tbody className="bg-white divide-y divide-slate-100">
                                                        {msg.rows.map((row, ri) => (
                                                            <tr key={ri} className="hover:bg-slate-50 transition-colors">
                                                                {msg.headers && msg.headers.map((h, hi) => (
                                                                    <td key={hi} className="px-4 py-2 text-slate-600 whitespace-nowrap">{row[h]}</td>
                                                                ))}
                                                            </tr>
                                                        ))}
                                                    </tbody>
                                                </table>
                                            </div>
                                        )}

                                        {/* Quiz Renderer - Scoring Removed */}
                                        {msg.type === 'quiz' && msg.quizData && (
                                            <div className="bg-white rounded-2xl shadow-sm border border-slate-200 overflow-hidden mt-3 mb-2 text-left">
                                                <div className="bg-violet-600 text-white">
                                                    <div className="p-4 flex items-center justify-between">
                                                        <div className="flex items-center gap-2">
                                                            <BrainCircuit size={16} className="text-violet-100" />
                                                            <span className="font-bold text-xs uppercase tracking-wider">Assessment Quiz</span>
                                                        </div>
                                                        <div className="text-[10px] font-bold bg-violet-700/60 px-2 py-1 rounded-full">
                                                            {msg.quizData.length} Questions
                                                        </div>
                                                    </div>
                                                </div>
                                                <div className="p-5 space-y-6">
                                                    {msg.quizData.map((q, qIdx) => (
                                                        <div key={qIdx} className="bg-white rounded-xl border border-slate-200">
                                                            <div className="px-5 pt-5">
                                                                <div className="flex items-start justify-between gap-2">
                                                                    <p className="text-sm font-semibold text-slate-900">
                                                                        <span className="inline-flex items-center justify-center w-6 h-6 rounded-full bg-violet-100 text-violet-700 text-[11px] font-bold mr-2">Q{qIdx + 1}</span>
                                                                        {q.question}
                                                                    </p>
                                                                    <button onClick={() => safeCopyToClipboard(String(q.question || ''))} className="p-1.5 text-slate-500 hover:text-indigo-600 hover:bg-indigo-50 rounded-md transition-all" title="Copy Question"><Copy size={12} /></button>
                                                                </div>
                                                            </div>
                                                            <div className="p-5 space-y-2">
                                                                {q.options.map((opt, oIdx) => (
                                                                    <div key={oIdx} className="w-full text-left text-xs px-4 py-3 rounded-lg border bg-white border-slate-200 flex items-center gap-3">
                                                                        <span className="flex-1">{opt}</span>
                                                                        <button onClick={() => safeCopyToClipboard(String(opt || ''))} className="p-1 text-slate-500 hover:text-blue-600 hover:bg-blue-50 rounded transition-all" title="Copy Option"><Copy size={12} /></button>
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        )}


                                        {msg.role === 'assistant' && msg.suggestions && msg.suggestions.length > 0 && (
                                            <div className="mt-5 pt-4 border-t border-slate-100/50 flex flex-wrap gap-2">
                                                {msg.suggestions.map((s, si) => (
                                                    <button key={si} onClick={() => handleSubmit(null, s)} className="px-3 py-1.5 bg-indigo-50/80 hover:bg-indigo-100 text-indigo-700 rounded-full text-xs font-bold transition-all border border-indigo-100/50">{s}</button>
                                                ))}
                                            </div>
                                        )}
                                        {/* Capture Button */}
                                        {msg.role === 'assistant' && (
                                            <button onClick={() => handleCaptureReply(i)} className="absolute top-2 right-2 p-1.5 text-slate-300 hover:text-indigo-500 hover:bg-slate-50 rounded-lg transition-all opacity-0 group-hover:opacity-100" title="Capture"><Camera size={14} /></button>
                                        )}
                                    </div>
                                    <div className="text-[10px] text-slate-500 mt-1 px-1 font-medium">{msg.role === 'user' ? 'You' : 'Poppy AI'}</div>
                                </div>
                            ))}


                            {/* Progress Bar (Visible during long tasks) */}
                            {loading && progress.percent > 0 && (
                                <div className="flex justify-start w-full px-2">
                                    <div className="bg-white/90 backdrop-blur p-4 rounded-xl border border-slate-100 shadow-sm w-3/4">
                                        <div className="flex justify-between text-xs font-bold text-slate-600 uppercase tracking-wider mb-2">
                                            <span>{progress.stage}</span>
                                            <span className="text-violet-600">{progress.percent}%</span>
                                        </div>
                                        <div className="w-full bg-slate-100 rounded-full h-1.5 overflow-hidden">
                                            <div className="bg-gradient-to-r from-violet-500 to-fuchsia-500 h-full rounded-full transition-all duration-300 ease-out" style={{ width: `${progress.percent}%` }}></div>
                                        </div>
                                    </div>
                                </div>
                            )}


                            {/* Enhanced Typing Indicator */}
                            {loading && progress.percent === 0 && retryCount === 0 && (
                                <div className="flex justify-start w-full">
                                    <TypingIndicator />
                                </div>
                            )}
                            
                            {/* Retry Indicator */}
                            {loading && retryCount > 0 && (
                                <div className="flex justify-start w-full px-2">
                                    <div className="bg-amber-50/90 backdrop-blur p-3 rounded-xl border border-amber-100 shadow-sm flex items-center gap-3">
                                        <RefreshCw size={16} className="text-amber-500 animate-spin" />
                                        <span className="text-xs font-medium text-amber-700">Retrying connection ({retryCount}/3)...</span>
                                    </div>
                                </div>
                            )}
                            <div ref={messagesEndRef} />
                        </div>


                        {expandedChatBlock && (
                            <Modal
                                isOpen={!!expandedChatBlock}
                                onClose={() => setExpandedChatBlock(null)}
                                title={null}
                                atomic
                                onDownloadImage={onDownloadImage}
                            >
                                <ClonedBlock sourceId={expandedChatBlock.blockId} />
                            </Modal>
                        )}


                        {/* ENHANCED INPUT AREA WITH DRAG-AND-DROP (#81) & KEYBOARD SHORTCUTS (#82) */}
                        
                        {/* Keyboard Shortcuts Help Modal */}
                        {showShortcuts && (
                            <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center" onClick={() => setShowShortcuts(false)}>
                                <div className="bg-white rounded-2xl p-6 max-w-md w-full shadow-2xl" onClick={e => e.stopPropagation()}>
                                    <h3 className="text-lg font-bold text-slate-800 mb-4"> Keyboard Shortcuts</h3>
                                    <div className="space-y-2 text-sm">
                                        <div className="flex justify-between py-2 border-b border-slate-100">
                                            <span className="text-slate-600">Open/Close Chat</span>
                                            <kbd className="px-2 py-1 bg-slate-100 rounded text-slate-700 font-mono">Esc</kbd>
                                        </div>
                                        <div className="flex justify-between py-2 border-b border-slate-100">
                                            <span className="text-slate-600">Show Help</span>
                                            <kbd className="px-2 py-1 bg-slate-100 rounded text-slate-700 font-mono">/</kbd>
                                        </div>
                                        <div className="flex justify-between py-2 border-b border-slate-100">
                                            <span className="text-slate-600">Previous Message</span>
                                            <kbd className="px-2 py-1 bg-slate-100 rounded text-slate-700 font-mono"></kbd>
                                        </div>
                                        <div className="flex justify-between py-2 border-b border-slate-100">
                                            <span className="text-slate-600">New Line</span>
                                            <kbd className="px-2 py-1 bg-slate-100 rounded text-slate-700 font-mono">Shift + Enter</kbd>
                                        </div>
                                        <div className="flex justify-between py-2 border-b border-slate-100">
                                            <span className="text-slate-600">Focus Input</span>
                                            <kbd className="px-2 py-1 bg-slate-100 rounded text-slate-700 font-mono">Ctrl + /</kbd>
                                        </div>
                                        <div className="flex justify-between py-2 border-b border-slate-100">
                                            <span className="text-slate-600">Clear Chat</span>
                                            <kbd className="px-2 py-1 bg-slate-100 rounded text-slate-700 font-mono">Ctrl + Shift + C</kbd>
                                        </div>
                                        <div className="flex justify-between py-2">
                                            <span className="text-slate-600">Export Chat</span>
                                            <kbd className="px-2 py-1 bg-slate-100 rounded text-slate-700 font-mono">Ctrl + Shift + E</kbd>
                                        </div>
                                    </div>
                                    <button 
                                        onClick={() => setShowShortcuts(false)}
                                        className="w-full mt-4 px-4 py-2 bg-indigo-600 text-white rounded-xl font-bold hover:bg-indigo-700"
                                    >
                                        Got it
                                    </button>
                                </div>
                            </div>
                        )}
                        
                        {/* Drag-and-Drop Overlay */}
                        {isDragOver && (
                            <div className="absolute inset-0 bg-indigo-500/20 backdrop-blur-sm z-50 flex items-center justify-center border-4 border-dashed border-indigo-500 rounded-2xl m-4">
                                <div className="text-center">
                                    <UploadCloud size={48} className="mx-auto text-indigo-600 mb-2" />
                                    <p className="text-lg font-bold text-indigo-800">Drop files here</p>
                                    <p className="text-sm text-indigo-600">Images, PDFs, CSV, TXT</p>
                                </div>
                            </div>
                        )}
                        
                        {/* Fix Issue 15: Redesigned Contextual Suggestions as Dropdown */}
                        {contextualSuggestions.length > 0 && !loading && showSuggestions && (
                            <div className="px-5 py-2 bg-indigo-50/80 border-t border-indigo-100">
                                <div className="flex items-center justify-between mb-2">
                                    <span className="text-[10px] text-indigo-600 uppercase font-bold flex items-center">
                                        <Sparkles size={10} className="mr-1" /> Suggestions
                                    </span>
                                    <button 
                                        onClick={() => setShowSuggestions(false)}
                                        className="text-[10px] text-slate-400 hover:text-slate-600"
                                    >
                                        Hide
                                    </button>
                                </div>
                                <div className="flex flex-wrap gap-2">
                                    {contextualSuggestions.slice(0, 5).map((suggestion, idx) => (
                                        <button
                                            key={idx}
                                            onClick={() => {
                                                if (typeof setQuery === 'function') {
                                                    setQuery(suggestion);
                                                }
                                            }}
                                            className="px-2.5 py-1 bg-white hover:bg-indigo-100 text-indigo-600 text-[11px] font-medium rounded-full transition-all border border-indigo-200 hover:border-indigo-300 shadow-sm"
                                        >
                                            {suggestion.length > 40 ? suggestion.substring(0, 40) + '...' : suggestion}
                                        </button>
                                    ))}
                                </div>
                            </div>
                        )}
                        
                        {/* Image Preview */}
                        {imagePreview && (
                            <div className="px-5 pt-3 bg-white/50">
                                <div className="relative inline-block">
                                    <img 
                                        src={imagePreview} 
                                        alt="Preview" 
                                        className="h-16 w-auto rounded-lg border border-slate-200 shadow-sm"
                                    />
                                    <button
                                        onClick={() => {
                                            setSelectedImage(null);
                                            setImagePreview(null);
                                        }}
                                        className="absolute -top-2 -right-2 w-5 h-5 bg-rose-500 text-white rounded-full flex items-center justify-center hover:bg-rose-600 transition-colors"
                                        title="Remove image"
                                    >
                                        <XIcon size={12} />
                                    </button>
                                </div>
                                <span className="text-[10px] text-slate-500 ml-2">Image ready for analysis</span>
                            </div>
                        )}
                        
                        <form 
                            onSubmit={async (e) => {
                                e.preventDefault();
                                // If image is selected, analyze it
                                if (selectedImage && imagePreview) {
                                    const text = query || 'Please analyze this image.';
                                    if (typeof setQuery === 'function') {
                                        setQuery('');
                                    }
                                    setMessages(prev => [...prev, { 
                                        role: 'user', 
                                        content: text,
                                        hasImage: true,
                                        id: `msg_${Date.now()}` 
                                    }]);
                                    setLoading(true);
                                    
                                    try {
                                        const imagePrompt = ImageAnalyzer.buildImagePrompt(text, {
                                            currentView,
                                            activeTab,
                                            selectedAgent: selectedAgentGlobal
                                        });
                                        const analysisResult = await GeminiAI.generate(imagePrompt, '', { imageData: imagePreview });
                                        
                                        setMessages(prev => [...prev, {
                                            role: 'assistant',
                                            blocks: [{
                                                type: 'text',
                                                content: `\ud83d\uddbc\ufe0f **Image Analysis**\n\n${analysisResult}`,
                                                meta: { contentType: 'image_analysis', exportable: true }
                                            }],
                                            id: `msg_${Date.now()}`
                                        }]);
                                    } catch (error) {
                                        setMessages(prev => [...prev, {
                                            role: 'assistant',
                                            blocks: [{
                                                type: 'text',
                                                content: `\u26a0\ufe0f **Image Analysis Failed**\n\nI couldn't analyze the image. Please try again or describe what you see.`,
                                                meta: { style: 'error' }
                                            }],
                                            id: `msg_${Date.now()}`
                                        }]);
                                    }
                                    
                                    setLoading(false);
                                    setSelectedImage(null);
                                    setImagePreview(null);
                                    return;
                                }
                                // Regular text submission
                                handleSubmit(e);
                            }} 
                            className="p-3 bg-white/50 backdrop-blur-md border-t border-slate-100 flex gap-2 shrink-0 relative z-20"
                        >
                            {/* Image Upload Button */}
                            <input
                                type="file"
                                ref={fileInputRef}
                                accept="image/png,image/jpeg,image/jpg"
                                onChange={async (e) => {
                                    const file = e.target.files?.[0];
                                    if (!file) return;
                                    
                                    const validation = ImageAnalyzer.validateFile(file);
                                    if (!validation.valid) {
                                        showToast(validation.error, 'error');
                                        return;
                                    }
                                    
                                    try {
                                        const base64 = await ImageAnalyzer.fileToBase64(file);
                                        setSelectedImage(file);
                                        setImagePreview(base64);
                                        showToast('Image uploaded! Type your question and send.', 'success');
                                    } catch (err) {
                                        showToast('Failed to process image.', 'error');
                                    }
                                }}
                                className="hidden"
                            />
                            <button
                                type="button"
                                onClick={() => fileInputRef.current?.click()}
                                disabled={loading}
                                className={`w-10 h-10 flex items-center justify-center rounded-xl transition-all relative ${
                                    imagePreview 
                                        ? 'bg-emerald-500 text-white hover:bg-emerald-600' 
                                        : 'bg-slate-100 text-slate-600 hover:bg-slate-200 hover:text-indigo-600'
                                }`}
                                title={imagePreview ? 'Image selected' : 'Upload image (PNG, JPG, JPEG)'}
                            >
                                <UploadCloud size={18} />
                                {imagePreview && (
                                    <span className="absolute -top-1 -right-1 w-2.5 h-2.5 bg-emerald-400 rounded-full animate-pulse"></span>
                                )}
                            </button>
                            
                            <div className="flex-1 relative">
                                <input
                                    ref={inputRef}
                                    type="text"
                                    value={typeof chatInput !== 'undefined' ? chatInput : query}
                                    onChange={(e) => {
                                        if (typeof setChatInput === 'function') {
                                            setChatInput(e.target.value);
                                        } else if (typeof setQuery === 'function') {
                                             setQuery(e.target.value);
                                        }
                                    }}
                                    onKeyDown={(e) => {
                                        // Keyboard shortcuts
                                        if (e.key === 'Escape') {
                                            setIsOpen(false);
                                            if (onClose) onClose();
                                        }
                                        if (e.key === 'ArrowUp' && !query && messages.length > 0) {
                                            e.preventDefault();
                                            const lastUserMsg = messages.slice().reverse().find(m => m.role === 'user');
                                            if (lastUserMsg && typeof setChatInput === 'function') {
                                                setChatInput(lastUserMsg.content);
                                            } else if (lastUserMsg && typeof setQuery === 'function') {
                                                setQuery(lastUserMsg.content);
                                            }
                                        }
                                    }}
                                    placeholder={imagePreview ? "Ask about image..." : "Ask AI..."}
                                    className="w-full pl-4 pr-10 py-2 bg-white/80 border border-slate-200 focus:bg-white focus:border-indigo-500 focus:ring-4 focus:ring-indigo-500/10 rounded-xl text-sm text-slate-700 placeholder:text-slate-400 outline-none transition-all shadow-inner font-medium backdrop-blur-sm"
                                    disabled={loading}
                                />
                                {/* Input state indicator */}
                                {query !== debouncedQuery && (
                                    <div className="absolute right-3 top-1/2 -translate-y-1/2">
                                        <div className="w-1.5 h-1.5 bg-indigo-400 rounded-full animate-pulse"></div>
                                    </div>
                                )}
                            </div>
                            <button 
                                type="submit" 
                                disabled={loading || (!query.trim() && !imagePreview)} 
                                className="w-10 h-10 flex items-center justify-center bg-gradient-to-br from-violet-600 to-indigo-600 text-white rounded-xl hover:shadow-lg hover:shadow-indigo-200 hover:scale-105 active:scale-95 disabled:opacity-50 transition-all relative"
                                title={loading ? 'Processing...' : (imagePreview ? 'Analyze image' : 'Send message')}
                            >
                                <Send size={18} className={loading ? "opacity-0" : "ml-0.5"} />
                                {loading && <Loader size={18} className="absolute animate-spin" />}
                            </button>
                        </form>
                        

                    </div>
                </>,
                document.body
            );
        };


        // DashboardSnapshotBlock - Component for displaying dashboard snapshots
        const DashboardSnapshotBlock = ({ block, blockId, onAsk, onExpand }) => {
            const [isCapturing, setIsCapturing] = useState(false);
            const [captured, setCaptured] = useState(false);
            
            const handleCapture = async () => {
                setIsCapturing(true);
                try {
                    // Simulate capture delay
                    await new Promise(resolve => setTimeout(resolve, 1500));
                    setCaptured(true);
                    showToast('Dashboard snapshot captured!', 'success');
                } catch (e) {
                    showToast('Failed to capture snapshot', 'error');
                }
                setIsCapturing(false);
            };
            
            const handleDownload = () => {
                const snapshotData = JSON.stringify(block.data, null, 2);
                const blob = new Blob([snapshotData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `dashboard-snapshot-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
                showToast('Snapshot downloaded!', 'success');
            };
            
            return (
                <div className="group relative mb-4 overflow-visible">
                    <ElementToolbar
                        type="snapshot"
                        onAskAI={onAsk}
                        onExpand={onExpand}
                        onDownloadImage={handleDownload}
                        sparkleData={{ type: 'snapshot', title: block.title, meta: block.meta }}
                        sparkleType="Snapshot"
                    />
                    <div id={blockId} className="p-4 bg-gradient-to-br from-indigo-50 to-purple-50 border border-indigo-200 rounded-xl shadow-sm">
                        <div className="flex items-center justify-between mb-4">
                            <div className="flex items-center gap-3">
                                <div className="w-10 h-10 bg-indigo-100 rounded-lg flex items-center justify-center">
                                    <Camera size={20} className="text-indigo-600" />
                                </div>
                                <div>
                                    <h4 className="font-bold text-slate-800">{block.title || 'Dashboard Snapshot'}</h4>
                                    <p className="text-xs text-slate-500">
                                        {block.data?.timestamp ? new Date(block.data.timestamp).toLocaleString() : 'Just now'}
                                    </p>
                                </div>
                            </div>
                            {captured && (
                                <span className="px-2 py-1 bg-emerald-100 text-emerald-700 rounded-lg text-xs font-bold">
                                     Captured
                                </span>
                            )}
                        </div>
                        
                        <div className="bg-white rounded-lg p-4 border border-slate-200">
                            {block.data?.dataSummary ? (
                                <div className="space-y-2">
                                    <p className="text-sm text-slate-600">
                                        <b>Total Records:</b> {block.data.dataSummary.totalRecords}
                                    </p>
                                    <p className="text-xs text-slate-500">
                                        Snapshot includes current view data and filters
                                    </p>
                                </div>
                            ) : (
                                <p className="text-sm text-slate-500 text-center py-4">
                                    Dashboard snapshot ready to capture
                                </p>
                            )}
                        </div>
                        
                        <div className="flex gap-2 mt-4">
                            <button
                                onClick={handleCapture}
                                disabled={isCapturing || captured}
                                className="flex-1 px-3 py-2 bg-indigo-600 hover:bg-indigo-700 disabled:bg-slate-300 text-white rounded-lg text-sm font-bold flex items-center justify-center gap-2"
                            >
                                {isCapturing ? <Loader size={14} className="animate-spin" /> : <Camera size={14} />}
                                {isCapturing ? 'Capturing...' : captured ? 'Captured' : 'Capture Now'}
                            </button>
                            <button
                                onClick={handleDownload}
                                className="px-3 py-2 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-lg text-sm font-bold flex items-center gap-2"
                            >
                                <Download size={14} /> Save
                            </button>
                        </div>
                    </div>
                </div>
            );
        };


        // AIOutputWrapper - Enhanced version of AIActionWrapper (Issue #8)
        const AIOutputWrapper = ({
            content,
            children,
            onEdit,
            onRegenerate,
            onVersionChange,
            onClose,
            enableEdit = true,
            enablePreview = true,
            enableRegenerate = true,
            enableVersioning = true,
            enableExport = true,
            versions = [],
            currentVersionIndex = 0,
            title = "AI Output",
            description = "",
            className = "",
            isRegenerating,
            flat = false,
            hideHeader = false
        }) => {
            const [isEditing, setIsEditing] = useState(false);
            const [editedContent, setEditedContent] = useState(content || '');
            const [contentId] = useState(() => `ai-output-${title.replace(/\s/g, '-').toLowerCase()}-${Math.random().toString(36).substr(2, 5)}`);

            // NEW STATE for AI Modification
            const [instruction, setInstruction] = useState('');
            const [isModifying, setIsModifying] = useState(false);

            useEffect(() => {
                setEditedContent(content || '');
            }, [content]);


            const handleSaveEdit = () => {
                if (onEdit) onEdit(editedContent);
                setIsEditing(false);
            };


            const handleCancelEdit = () => {
                setEditedContent(content);
                setIsEditing(false);
            };

            const handleAIModify = async () => {
                if (!instruction.trim()) return;
                setIsModifying(true);
                try {
                    if (typeof regenController !== 'undefined') {
                        regenController.register(contentId, editedContent, title);
                        const newContent = await regenController.modify(contentId, instruction);
                        setEditedContent(newContent);
                        if (onEdit) onEdit(newContent);
                        setInstruction('');
                        showToast('Content updated via AI', 'success');
                    } else {
                        showToast('Regeneration Engine not ready', 'error');
                    }
                } catch (e) {
                    console.error(e);
                    showToast('Modification failed', 'error');
                } finally {
                    setIsModifying(false);
                }
            };


            return (
                <div className={`${flat ? 'border-none shadow-none bg-transparent' : 'border border-indigo-100 rounded-xl overflow-visible bg-white shadow-sm relative'} ${className}`}>
                    {!hideHeader && (
                        <div className="flex items-center justify-center p-3 bg-indigo-50/50 border-b border-indigo-100 relative">
                            <div className="flex flex-col absolute left-3">
                                <div className="flex items-center gap-2">
                                    <Sparkles size={14} className="text-indigo-500" />
                                    <span className="text-xs font-bold text-indigo-700 uppercase tracking-wider">{title}</span>
                                </div>
                                {description && (
                                    <span className="text-[10px] text-slate-500 mt-0.5 ml-5">{description}</span>
                                )}
                            </div>

                            <div className="flex gap-3 items-center flex-wrap justify-center">
                                {enableVersioning && versions.length > 1 && onVersionChange && (
                                    <div className="flex items-center gap-1 mr-2 px-2 py-1 bg-white/50 rounded-lg border border-indigo-100">
                                        <button
                                            onClick={() => onVersionChange(currentVersionIndex - 1)}
                                            disabled={currentVersionIndex === 0}
                                            className="p-1 hover:bg-white rounded disabled:opacity-30 text-indigo-600 transition-colors"
                                            title="Previous Version"
                                        >
                                            <ChevronLeft size={12} />
                                        </button>
                                        <span className="text-[10px] text-indigo-600 font-mono font-medium">v{currentVersionIndex + 1}/{versions.length}</span>
                                        <button
                                            onClick={() => onVersionChange(currentVersionIndex + 1)}
                                            disabled={currentVersionIndex === versions.length - 1}
                                            className="p-1 hover:bg-white rounded disabled:opacity-30 text-indigo-600 transition-colors"
                                            title="Next Version"
                                        >
                                            <ChevronRight size={12} />
                                        </button>
                                    </div>
                                )}

                                {isEditing ? (
                                    <>
                                        <button onClick={handleSaveEdit} className="p-1 px-2 bg-indigo-600 text-white rounded text-xs font-bold hover:bg-indigo-700 transition-colors">Save</button>
                                        <button onClick={handleCancelEdit} className="p-1 px-2 bg-slate-200 text-slate-600 rounded text-xs font-bold hover:bg-slate-300 transition-colors">Cancel</button>
                                    </>
                                ) : (
                                    <>
                                        {enableRegenerate && (
                                            <button
                                                onClick={onRegenerate}
                                                disabled={isRegenerating}
                                                className="p-1.5 text-indigo-500 hover:bg-indigo-100 rounded-lg transition-colors no-export"
                                                data-html2canvas-ignore="true"
                                                title="Regenerate"
                                            >
                                                <RefreshCw size={14} className={isRegenerating ? "animate-spin" : ""} />
                                            </button>
                                        )}
                                        {enableEdit && (
                                            <button onClick={() => setIsEditing(true)} className="p-1.5 text-slate-500 hover:bg-slate-100 rounded-lg transition-colors" title="Edit Manually">
                                                <Edit2 size={14} />
                                            </button>
                                        )}
                                        {enableExport && (
                                            <button onClick={(e) => { e.stopPropagation(); handleCopy('rtf', contentId); }} className="p-1.5 text-slate-500 hover:bg-slate-100 rounded-lg transition-colors" title="Copy Formatted">
                                                <Copy size={14} />
                                            </button>
                                        )}
                                    </>
                                )}
                            </div>
                        </div>
                    )}


                    <div className={`${flat ? 'p-0 pt-4' : 'p-4'} bg-white relative`}>
                        {/* Regenerating Overlay */}
                        {isRegenerating && (
                            <div className="absolute inset-0 bg-white/80 backdrop-blur-sm z-10 flex flex-col items-center justify-center rounded-xl">
                                <Loader size={32} className="animate-spin text-indigo-600 mb-3" />
                                <span className="text-sm font-medium text-indigo-700">Regenerating...</span>
                            </div>
                        )}
                        {isEditing ? (
                            <textarea
                                value={editedContent}
                                onChange={(e) => setEditedContent(e.target.value)}
                                className="w-full h-full min-h-[200px] p-3 text-sm border border-slate-200 rounded-lg focus:ring-2 focus:ring-indigo-500 outline-none font-mono"
                            />
                        ) : (
                            <>
                                {content ? (
                                    <div id={contentId} className="prose prose-sm markdown-content max-w-none text-slate-600 leading-relaxed whitespace-pre-wrap">
                                        <div dangerouslySetInnerHTML={{ __html: safeMarked(String(content || '')) }} />
                                    </div>
                                ) : null}
                                {/* FIXED: Render children when content is not provided */}
                                {children}
                            </>
                        )}
                    </div>

                    {!isEditing && (
                        <div className="bg-slate-50 border-t border-slate-100 p-3">
                            {/* Quick Modify Options */}
                            <div className="flex flex-wrap gap-2 mb-3 justify-center">
                                {['Make it shorter', 'Add more detail', 'Change tone to formal', 'Add more empathy', 'Simplify language'].map((option) => (
                                    <button
                                        key={option}
                                        onClick={() => setInstruction(option)}
                                        className="px-3 py-1.5 bg-white border border-slate-200 hover:border-indigo-300 hover:text-indigo-600 text-slate-600 rounded-full text-xs font-medium transition-all shadow-sm"
                                    >
                                        {option}
                                    </button>
                                ))}
                            </div>
                            <div className="flex gap-2">
                                <div className="flex-1 relative">
                                    <div className="absolute inset-y-0 left-3 flex items-center pointer-events-none text-slate-500">
                                        <Sparkles size={14} />
                                    </div>
                                    <input
                                        type="text"
                                        value={instruction}
                                        onChange={e => setInstruction(e.target.value)}
                                        onKeyDown={e => e.key === 'Enter' && handleAIModify()}
                                        placeholder="Modify with AI (e.g. 'Make it shorter', 'Add more empathy')..."
                                        className="w-full pl-9 pr-4 py-2 text-xs border border-slate-200 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none transition-all"
                                        disabled={isModifying}
                                    />
                                </div>
                                <button
                                    onClick={handleAIModify}
                                    disabled={!instruction.trim() || isModifying}
                                    className="px-3 py-2 bg-white border border-slate-200 hover:border-indigo-300 hover:text-indigo-600 text-slate-600 rounded-lg text-xs font-bold transition-all disabled:opacity-50 flex items-center gap-2 shadow-sm"
                                >
                                    {isModifying ? <Loader size={14} className="animate-spin" /> : "Modify"}
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const AIActionWrapper = AIOutputWrapper;


        // --- FEATURE 2: WEEKLY SUMMARY GENERATOR ---
        const WeeklySummaryGenerator = ({ npsData, qcData, onDownloadImage, askAI, mode = 'unified' }) => {
            const [summary, setSummary] = useState('');
            const [versions, setVersions] = useState([]);
            const [currentVersionIndex, setCurrentVersionIndex] = useState(0);
            const [loading, setLoading] = useState(false);
            const [progress, setProgress] = useState({ show: false, text: '' });
            const displayTitle = mode === 'nps' ? 'NPS Weekly Summary' : mode === 'qc' ? 'QC Weekly Summary' : 'Executive Weekly Summary';
            
            // Update summary when version changes
            useEffect(() => {
                if (versions.length > 0 && currentVersionIndex < versions.length) {
                    setSummary(versions[currentVersionIndex]?.content || '');
                }
            }, [versions, currentVersionIndex]);
            const combinedData = useMemo(() => ([...(npsData || []) , ...(qcData || [])]), [npsData, qcData]);
            const availableWeeks = useMemo(() => {
                const set = new Set();
                combinedData.forEach(d => {
                    const date = DataEngine.parseDate(d.Date || d['Review Date']);
                    if (date) set.add(DataEngine.getWeekStart(date));
                });
                return Array.from(set).sort((a, b) => {
                    const dA = DataEngine.parseDate(a);
                    const dB = DataEngine.parseDate(b);
                    return dB - dA;
                });
            }, [combinedData]);
            const [selectedWeeks, setSelectedWeeks] = useState([]);
            useEffect(() => { setSummary(''); }, [selectedWeeks.join('|'), mode]);

            const calculatePeriodStats = (weeks) => {
                const weeksSet = new Set((weeks || []).filter(Boolean));
                const inWeeks = (rows, isQC = false) => (rows || []).filter(d => {
                    if (DataEngine.isAppeal(d)) return false; // Fix: Keep passed NPS reviews for correct stats
                    const date = DataEngine.parseDate(d.Date || d['Review Date']);
                    if (!date) return false;
                    return weeksSet.has(DataEngine.getWeekStart(date));
                });

                const selectedNPS = inWeeks(npsData || []);
                const selectedQC = inWeeks(qcData || [], true);

                // NPS Pass Rate based on sub-metrics (not average Rating)
                const npsPassRate = (data) => {
                    const allSubMetrics = Object.values(NPS_METRIC_MAPPING).flat();
                    const passCount = (data || []).filter(d => {
                        return allSubMetrics.every(m => {
                            const val = d[m];
                            return val === true || String(val).toUpperCase() === 'TRUE' || val === 1 || val === '1';
                        });
                    }).length;
                    return data.length > 0 ? ((passCount / data.length) * 100).toFixed(1) : 0;
                };
                const npsPendingAcks = (data) => (data || []).filter(d => !DataEngine.normalizeBool(d.Acknowledged)).length;

                // QC Pass Rate (Score 0 = Pass) - NO TOTAL SCORE
                const qcPassRate = (data) => {
                    const passCount = (data || []).filter(d => parseFloat(d['QC Score']) === 0).length;
                    return data.length > 0 ? ((passCount / data.length) * 100).toFixed(2) : 0;
                };
                const qcAppeals = (data) => (data || []).filter(d => d['Appeal Status'] && String(d['Appeal Status']).trim() !== '').length;

                return {
                    weeks: Array.from(weeksSet),
                    nps: { count: selectedNPS.length, passRate: npsPassRate(selectedNPS), pendingAcks: npsPendingAcks(selectedNPS) },
                    qc: { count: selectedQC.length, passRate: qcPassRate(selectedQC), appeals: qcAppeals(selectedQC) }
                };
            };

            const getComparisonWeeks = () => {
                const indices = (selectedWeeks || []).map(w => availableWeeks.indexOf(w)).filter(i => i >= 0).sort((a, b) => a - b);
                if (indices.length === 0) return [];
                if (indices.length === 1) {
                    const prev = availableWeeks[indices[0] + 1];
                    return prev ? [prev] : [];
                }
                const oldestIdx = indices[indices.length - 1];
                const start = oldestIdx + 1;
                return availableWeeks.slice(start, start + indices.length);
            };

            const generateSummary = async () => {
                setLoading(true);
                setProgress({ show: true, text: 'Analyzing data...' });
                
                const comparisonWeeks = getComparisonWeeks();
                const stats = calculatePeriodStats(selectedWeeks);

                // FIX: Check if there is any data
                const hasNpsData = mode !== 'qc' && stats.nps.count > 0;
                const hasQcData = mode !== 'nps' && stats.qc.count > 0;
                
                if (!hasNpsData && !hasQcData) {
                    setSummary("No relevant performance data found for the selected period (all data may be filtered out as 'Passed' or 'Appealed').");
                    setLoading(false);
                    setProgress({ show: false, text: '' });
                    return;
                }

                const prevStats = comparisonWeeks.length ? calculatePeriodStats(comparisonWeeks) : null;
                const selectedLabel = stats.weeks.length === 1
                    ? stats.weeks[0]
                    : `${stats.weeks.length} weeks (${[...stats.weeks].sort((a, b) => availableWeeks.indexOf(a) - availableWeeks.indexOf(b)).join(', ')})`;
                const prevLabel = prevStats?.weeks?.length
                    ? (prevStats.weeks.length === 1 ? prevStats.weeks[0] : `${prevStats.weeks.length} weeks (${[...prevStats.weeks].sort((a, b) => availableWeeks.indexOf(a) - availableWeeks.indexOf(b)).join(', ')})`)
                    : 'N/A';
                
                // Recalculate selected data for failed metrics analysis
                const weeksSet = new Set((selectedWeeks || []).filter(Boolean));
                const inWeeks = (rows, isQC = false) => (rows || []).filter(d => {
                    if (DataEngine.isAppeal(d)) return false;
                    const date = DataEngine.parseDate(d.Date || d['Review Date']);
                    if (!date) return false;
                    return weeksSet.has(DataEngine.getWeekStart(date));
                });
                const currentSelectedNPS = inWeeks(npsData || []);
                const currentSelectedQC = inWeeks(qcData || [], true);
                
                // Calculate failed metrics
                const allNpsMetrics = Object.values(NPS_METRIC_MAPPING).flat();
                const npsFailCounts = {};
                currentSelectedNPS.forEach(row => {
                    allNpsMetrics.forEach(m => {
                        const val = row[m];
                        if (val === false || String(val).toUpperCase() === 'FALSE' || val === 0 || val === '0') {
                            npsFailCounts[m] = (npsFailCounts[m] || 0) + 1;
                        }
                    });
                });
                const topNpsFails = Object.entries(npsFailCounts).sort((a, b) => b[1] - a[1]).slice(0, 5);
                const qcFailCounts = { Critical: 0, Process: 0, Internal: 0 };
                currentSelectedQC.forEach(row => {
                    const score = parseFloat(row['QC Score']);
                    if (score === 1.0) qcFailCounts.Critical++;
                    else if (score === 0.5 || score === 0.67) qcFailCounts.Process++;
                    else if (score === 0.33) qcFailCounts.Internal++;
                });
                
                let failedMetricsText = '';
                if (mode !== 'qc' && topNpsFails.length > 0) {
                    failedMetricsText += 'Top NPS Failures:\n' + topNpsFails.map(([m, c]) => `- ${m}: ${c} failures`).join('\n') + '\n';
                }
                if (mode !== 'nps' && currentSelectedQC.length > 0) {
                    const qcFails = Object.entries(qcFailCounts).filter(([_, c]) => c > 0);
                    if (qcFails.length > 0) {
                        failedMetricsText += 'QC Failures by Category:\n' + qcFails.map(([cat, c]) => `- ${cat}: ${c} failures`).join('\n') + '\n';
                    }
                }
                if (!failedMetricsText) failedMetricsText = 'No failures in selected period.';
                
                let prompt = `${AI_PERSONA}
${TL_PERSONA_PROMPT}

Generate a weekly management summary for CX team performance.

WEEK(S): ${selectedLabel}${prevStats ? ` (vs ${prevLabel})` : ''}

STATS:
${mode !== 'qc' ? `NPS Selected: ${stats.nps.count} reviews, Pass Rate: ${stats.nps.passRate}%, Pending Acks: ${stats.nps.pendingAcks}${prevStats ? `\nNPS Previous: ${prevStats.nps.count} reviews, Pass Rate: ${prevStats.nps.passRate}%, Pending Acks: ${prevStats.nps.pendingAcks}` : ''}\n` : ''}
${mode !== 'nps' ? `QC Selected: ${stats.qc.count} audits, Pass Rate: ${stats.qc.passRate}%, Appeals: ${stats.qc.appeals}${prevStats ? `\nQC Previous: ${prevStats.qc.count} audits, Pass Rate: ${prevStats.qc.passRate}%, Appeals: ${prevStats.qc.appeals}` : ''}\n` : ''}

ACTUAL FAILED METRICS (USE ONLY THESE TERMS):
${failedMetricsText}

Return strict JSON:
{
  "title": "Title with stars",
  "performanceOverview": "2-3 sentence summary",
  "topWins": ["Win 1", "Win 2"],
  "keyConcerns": ["Concern 1", "Concern 2"],
  "actionItems": ["Action 1", "Action 2"],
  "keyInsight": "Strategic observation",
  "closure": "Closing remark"
}`;

                const schema = {
                    type: "OBJECT",
                    properties: {
                        title: { type: "STRING" },
                        performanceOverview: { type: "STRING" },
                        topWins: { type: "ARRAY", items: { type: "STRING" } },
                        keyConcerns: { type: "ARRAY", items: { type: "STRING" } },
                        actionItems: { type: "ARRAY", items: { type: "STRING" } },
                        keyInsight: { type: "STRING" },
                        closure: { type: "STRING" }
                    },
                    required: ["title", "performanceOverview", "topWins", "keyConcerns", "actionItems", "keyInsight", "closure"]
                };

                try {
                    const result = await GeminiAI.generateJson(prompt, schema);
                    const newVersion = {
                        content: result,
                        timestamp: new Date().toISOString(),
                        type: 'summary'
                    };
                    setVersions(prev => [...prev, newVersion]);
                    setSummary(result);
                    setCurrentVersionIndex(versions.length);
                } catch (e) {
                    console.error("Summary generation failed", e);
                    setSummary(null);
                    showToast('Failed to generate summary. Please try again.', 'error');
                }
                setLoading(false);
                setProgress({ show: false, text: '' });
            };

            return (
                <div className="space-y-4 w-full">
                    <div className="rounded-2xl border border-slate-200 bg-gradient-to-br from-slate-50 via-white to-indigo-50 p-5 shadow-sm w-full">
                            <div className="flex flex-col lg:flex-row lg:items-center gap-3 justify-between">
                                <div className="flex items-start gap-3 min-w-0">
                                    <div className="h-10 w-10 rounded-xl bg-slate-900 text-white flex items-center justify-center flex-shrink-0">
                                        <Sparkles size={18} />
                                    </div>
                                    <div className="min-w-0">
                                        <div className="text-sm font-black text-slate-900 tracking-tight truncate">
                                            {displayTitle}
                                        </div>
                                        <div className="text-xs text-slate-600 truncate">
                                            Select week(s), then generate the recap.
                                        </div>
                                    </div>
                                </div>
                                <div className="flex flex-col sm:flex-row gap-2 sm:items-center">
                                    <MultiSelect
                                        icon={Calendar}
                                        label="Weeks"
                                        options={availableWeeks}
                                        value={selectedWeeks}
                                        onChange={setSelectedWeeks}
                                        sortOrder="desc"
                                    />
                                    <button
                                        onClick={generateSummary}
                                        disabled={loading || selectedWeeks.length === 0}
                                        className="px-5 py-2 bg-slate-900 text-white rounded-xl font-bold text-xs hover:bg-black transition-all disabled:opacity-50 flex items-center justify-center gap-2"
                                    >
                                        {loading ? <Loader size={16} className="animate-spin" /> : <Sparkles size={16} />}
                                        {loading ? 'Generating' : (summary ? 'Regenerate' : 'Generate')}
                                    </button>
                                </div>
                            </div>

                            {selectedWeeks.length > 0 && (
                                <div className="mt-4 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-3">
                                    {(() => {
                                        const stats = calculatePeriodStats(selectedWeeks);
                                        return (
                                            <>
                                                {mode !== 'qc' && (
                                                    <>
                                                        <div className="rounded-xl border border-slate-200 bg-white p-4">
                                                            <div className="flex items-center justify-between">
                                                                <div className="text-[10px] font-black uppercase tracking-widest text-slate-500">NPS Reviews</div>
                                                                <TrendingUp size={14} className="text-indigo-600" />
                                                            </div>
                                                            <div className="mt-2 text-2xl font-black text-slate-900">{stats.nps.count}</div>
                                                            <div className="mt-1 text-xs text-slate-500">Selected period</div>
                                                        </div>
                                                        <div className="rounded-xl border border-slate-200 bg-white p-4">
                                                            <div className="flex items-center justify-between">
                                                                <div className="text-[10px] font-black uppercase tracking-widest text-slate-500">Pass Rate</div>
                                                                <Star size={14} className="text-amber-500" />
                                                            </div>
                                                            <div className="mt-2 text-2xl font-black text-slate-900">{stats.nps.passRate}%</div>
                                                            <div className="mt-1 text-xs text-slate-500">Across selected reviews</div>
                                                        </div>
                                                    </>
                                                )}
                                                {mode !== 'nps' && (
                                                    <>
                                                        <div className="rounded-xl border border-slate-200 bg-white p-4">
                                                            <div className="flex items-center justify-between">
                                                                <div className="text-[10px] font-black uppercase tracking-widest text-slate-500">QC Audits</div>
                                                                <CheckCircle size={14} className="text-emerald-600" />
                                                            </div>
                                                            <div className="mt-2 text-2xl font-black text-slate-900">{stats.qc.count}</div>
                                                            <div className="mt-1 text-xs text-slate-500">Selected period (excl. appeals)</div>
                                                        </div>
                                                        <div className="rounded-xl border border-slate-200 bg-white p-4">
                                                            <div className="flex items-center justify-between">
                                                                <div className="text-[10px] font-black uppercase tracking-widest text-slate-500">QC Pass Rate</div>
                                                                <Target size={14} className="text-blue-600" />
                                                            </div>
                                                            <div className="mt-2 text-2xl font-black text-slate-900">{stats.qc.passRate}%</div>
                                                            <div className="mt-1 text-xs text-slate-500">Across selected audits</div>
                                                        </div>
                                                    </>
                                                )}
                                            </>
                                        );
                                    })()}
                                </div>
                            )}
                        </div>

                        {summary && (
                            <div id="weekly-summary-content" className="rounded-2xl border border-slate-200 bg-white shadow-sm">
                                <div className="p-6">
                                    <AIOutputWrapper
                                        title={summary.title || "Weekly Summary"}
                                        content={JSON.stringify(summary)} // Pass object for versioning, but render custom UI
                                        onEdit={(newContent) => {
                                            // Handle edit if needed - for now readonly structured
                                        }}
                                        onRegenerate={generateSummary}
                                        isRegenerating={loading}
                                        enableVersioning={false} // Disable simple versioning for complex object for now
                                        enableExport={true}
                                    >
                                        <div className="space-y-6">
                                            <div className="bg-slate-50 p-4 rounded-xl border border-slate-100">
                                                <h4 className="text-sm font-bold text-slate-800 mb-2">Performance Overview</h4>
                                                <p className="text-sm text-slate-600 leading-relaxed">{summary.performanceOverview}</p>
                                            </div>
                                            
                                            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                                <div>
                                                    <h4 className="text-sm font-bold text-emerald-700 uppercase tracking-wider mb-3 flex items-center gap-2"><CheckCircle size={14}/> Top Wins</h4>
                                                    <ul className="space-y-2">
                                                        {summary.topWins?.map((item, i) => (
                                                            <li key={i} className="flex gap-3 text-sm text-slate-600 bg-emerald-50/50 p-3 rounded-lg border border-emerald-100">
                                                                <span className="font-bold text-emerald-500 shrink-0"></span>
                                                                {item}
                                                            </li>
                                                        ))}
                                                    </ul>
                                                </div>
                                                <div>
                                                    <h4 className="text-sm font-bold text-rose-700 uppercase tracking-wider mb-3 flex items-center gap-2"><AlertTriangle size={14}/> Key Concerns</h4>
                                                    <ul className="space-y-2">
                                                        {summary.keyConcerns?.map((item, i) => (
                                                            <li key={i} className="flex gap-3 text-sm text-slate-600 bg-rose-50/50 p-3 rounded-lg border border-rose-100">
                                                                <span className="font-bold text-rose-500 shrink-0"></span>
                                                                {item}
                                                            </li>
                                                        ))}
                                                    </ul>
                                                </div>
                                            </div>

                                            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                                <div>
                                                    <h4 className="text-sm font-bold text-blue-700 uppercase tracking-wider mb-3 flex items-center gap-2"><List size={14}/> Action Items</h4>
                                                    <ul className="space-y-2">
                                                        {summary.actionItems?.map((item, i) => (
                                                            <li key={i} className="flex gap-3 text-sm text-slate-600 bg-blue-50/50 p-3 rounded-lg border border-blue-100">
                                                                <span className="font-bold text-blue-500 shrink-0"></span>
                                                                {item}
                                                            </li>
                                                        ))}
                                                    </ul>
                                                </div>
                                                <div className="space-y-4">
                                                    <div className="bg-amber-50 p-4 rounded-xl border border-amber-100">
                                                        <h4 className="text-xs font-bold text-amber-800 uppercase mb-2 flex items-center gap-2"><Lightbulb size={12}/> Key Insight</h4>
                                                        <p className="text-sm text-amber-900 italic">{summary.keyInsight}</p>
                                                    </div>
                                                    <div className="bg-slate-100 p-4 rounded-xl border border-slate-200">
                                                        <p className="text-sm text-slate-700 font-medium">{summary.closure}</p>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </AIOutputWrapper>
                                </div>
                            </div>
                        )}
                </div>
            );
        };


        // --- FEATURE 3: SMART COACHING PRIORITIZATION ---
        const CoachingPriorityPanel = ({ npsData, qcData, onAgentSelect, onDownloadImage, askAI }) => {
            const priorityList = useMemo(() => {
                const agentMap = {};


                // Process NPS data
                npsData.forEach(d => {
                    const agent = DataEngine.normalizeAgent(d, 'NPS');
                    if (!agent) return;
                    if (!agentMap[agent]) {
                        agentMap[agent] = { agent, npsErrors: 0, qcErrors: 0, npsPendingAcks: 0, qcPendingAcks: 0, totalReviews: 0, lastReviewDate: null };
                    }
                    agentMap[agent].totalReviews++;
                    const reviewDate = DataEngine.parseDate(d.Date || d['Review Date']);
                    if (!agentMap[agent].lastReviewDate || (reviewDate && reviewDate > agentMap[agent].lastReviewDate)) {
                        agentMap[agent].lastReviewDate = reviewDate;
                    }
                    if (!DataEngine.normalizeBool(d.Acknowledged)) agentMap[agent].npsPendingAcks++;
                    Object.values(NPS_METRIC_MAPPING).flat().forEach(m => {
                        if (d[m] === false || d[m] === 'FALSE') agentMap[agent].npsErrors++;
                    });
                });


                // Process QC data
                qcData.forEach(d => {
                    const agent = DataEngine.normalizeAgent(d, 'QC');
                    if (!agent) return;
                    if (!agentMap[agent]) {
                        agentMap[agent] = { agent, npsErrors: 0, qcErrors: 0, npsPendingAcks: 0, qcPendingAcks: 0, totalReviews: 0, lastReviewDate: null };
                    }
                    agentMap[agent].totalReviews++;
                    const reviewDate = DataEngine.parseDate(d.Date || d['Review Date']);
                    if (!agentMap[agent].lastReviewDate || (reviewDate && reviewDate > agentMap[agent].lastReviewDate)) {
                        agentMap[agent].lastReviewDate = reviewDate;
                    }
                    if (!DataEngine.normalizeBool(d['Agent Ack.'])) agentMap[agent].qcPendingAcks++;
                    if (parseFloat(d['QC Score']) < 1) agentMap[agent].qcErrors++;
                });


                // Calculate priority score (New: Removed recency/days component)
                return Object.values(agentMap).map(a => {
                    const pendingScore = (a.npsPendingAcks + a.qcPendingAcks) * 3;
                    const errorScore = (a.npsErrors + a.qcErrors) * 2;
                    const urgencyScore = pendingScore + errorScore;


                    let priority = 'Low';
                    let priorityColor = 'emerald';
                    if (urgencyScore > 30) { priority = 'High'; priorityColor = 'rose'; }
                    else if (urgencyScore > 15) { priority = 'Medium'; priorityColor = 'amber'; }


                    return {
                        ...a,
                        urgencyScore,
                        priority,
                        priorityColor,
                        reason: `${a.npsPendingAcks + a.qcPendingAcks} pending acks, ${a.npsErrors + a.qcErrors} errors`
                    };
                }).filter(a => a.totalReviews > 0).sort((a, b) => b.urgencyScore - a.urgencyScore).slice(0, 10);
            }, [npsData, qcData]);


            return (
                <Card title=" Coaching Priority Queue" type="Table" infoText="Agents ranked by coaching urgency. Score based on: pending acknowledgements (x3), errors (x2), and days since last review. Higher score = more urgent." onDownloadImage={onDownloadImage} chartId="coaching-priority" askAI={askAI}>
                    <div className="space-y-2">
                        {priorityList.map((agent, i) => (
                            <div
                                key={i}
                                onClick={() => onAgentSelect?.(agent.agent)}
                                className="flex items-center gap-4 p-3 bg-slate-50 hover:bg-slate-100 rounded-xl cursor-pointer transition-all group"
                            >
                                <div className="w-8 h-8 bg-slate-200 rounded-full flex items-center justify-center text-sm font-bold text-slate-600">
                                    {i + 1}
                                </div>
                                <div className="flex-1">
                                    <div className="font-bold text-sm text-slate-800 group-hover:text-blue-600 transition-colors">{agent.agent}</div>
                                    <div className="text-[11px] text-slate-500">{agent.reason}</div>
                                </div>
                                <span className={`px-2 py-1 rounded text-[10px] font-bold ${agent.priority === 'High' ? 'bg-rose-100 text-rose-700' :
                                    agent.priority === 'Medium' ? 'bg-amber-100 text-amber-700' :
                                        'bg-emerald-100 text-emerald-700'
                                    }`}>
                                    {agent.priority}
                                </span>
                                <div className="text-xs font-bold text-slate-500">{agent.urgencyScore} pts</div>
                                <ChevronRight size={16} className="text-slate-300 group-hover:text-blue-500 transition-colors" />
                            </div>
                        ))}
                        {priorityList.length === 0 && (
                            <div className="text-center py-8 text-slate-500 text-sm">No agents found. Upload data to see coaching priorities.</div>
                        )}
                    </div>
                </Card>
            );
        };






        // --- FEATURE 6: SMART FEEDBACK GENERATOR ---
        const generateSmartFeedback = async (agentName, strengths, opportunities, feedbackLoopData, processedData, type) => {
            // Calculate agent history
            const agentData = processedData
                .filter(d => DataEngine.normalizeAgent(d, type) === agentName)
                .filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d)); // Apply Global Appeal & NPS Pass Filter


            const totalReviews = agentData.length;
            const recentReviews = agentData.slice(0, 10);


            // Find improvements (areas that were failing before but passing now)
            const improvements = [];
            if (type === 'NPS') {
                Object.values(NPS_METRIC_MAPPING).flat().forEach(m => {
                    const recentFails = recentReviews.filter(d => d[m] === false || d[m] === 'FALSE').length;
                    const oldFails = agentData.slice(10, 20).filter(d => d[m] === false || d[m] === 'FALSE').length;
                    if (recentFails < oldFails && oldFails > 0) {
                        improvements.push({ metric: m, improvement: Math.round(((oldFails - recentFails) / oldFails) * 100) });
                    }
                });
            }


            const prompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nGenerate a personalized, encouraging feedback message for agent "${agentName}".

AGENT PROFILE:
- Total reviews: ${totalReviews}
- Strengths: ${strengths?.map(s => s.name).join(', ') || 'Not identified'}
- Opportunities: ${opportunities?.map(o => o.name).join(', ') || 'Not identified'}
- Pending acknowledgements: ${feedbackLoopData?.pending || 0}
${improvements.length > 0 ? `- Recent improvements: ${improvements.map(i => `${i.metric} (+${i.improvement}%)`).join(', ')}` : ''}

CRITICAL FORMAT:
1. ** Personalized Feedback ** (Title wrapped in star emojis both sides, bold)

2. [Personalized Greeting - AI Generated, warm, uses agent name, different each time]

3. **Recognition**
   - Acknowledge specific **Sub-metric** strengths
   - Celebrate improvements if detected
   - Be genuine and specific

4. **Growth Area**
   - Frame **Question keywords** as growth potential
   - NOT criticism
   - Positive framing
   - Specific **Sub-metric** or **keyword** focus

5. **Specific Action**
   - One clear actionable step
   - Focus on **Sub-metric** or **Question keyword**
   - Single focus (not overwhelming)

6. Closure (NOT A HEADING)
   - 1-2 lines motivation
   - 1 line forward-looking
   - Combined as paragraph with emojis

NO SIGN-OFF. Max 150 words total.

STRICT KEYWORD RULES (CRITICAL - DO NOT VIOLATE):
- Use ONLY these exact sub-metric names: ${strengths?.map(s => s.name).concat(opportunities?.map(o => o.name)).filter(Boolean).join(', ') || 'From Strengths and Opportunities listed above'}
- **NEVER invent generic terms** like "communication skills", "customer focus", "attention to detail", "professionalism"
- **NEVER use** vague coaching terms like "time management", "work ethic", "attitude"
- Every mention must reference a specific metric from Strengths or Opportunities
- Bold (**text**) the metric name

FORMATTING RULES:
- Titles ALWAYS wrapped in star emojis () before and at end, in bold
- All headings and sub-headings in bold (**text**)
- Closure is NEVER a heading
- NO Sign-off
- Specific terms from raw data can be **bold** to highlight
- NO hashtags (#)
- Maximum 150 words total.`


            try {
                const result = await GeminiAI.generate(prompt);
                return formatSlackMessage(result, 'SmartFeedback');
            } catch (e) {
                return `Hi ${agentName}, I wanted to take a moment to discuss your recent performance and areas where we can work together to help you grow. Let's schedule some time to chat!`;
            }
        };


        // Phase 3.2: generateSmartSlackPost - Fixed: Title first, sub-metric feedback, error+feedback format
        const generateSmartSlackPost = async (processedData, metricMapping) => {
            const buckets = { Communication: [], Personalisation: [], Efficiency: [] };
            Object.entries(metricMapping).forEach(([pillar, metrics]) => {
                const failCounts = metrics.map(m => ({
                    name: m,
                    count: processedData
                        .filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d)) // Apply Global Appeal & NPS Pass Filter
                        .filter(d => d[m] === false || d[m] === 'FALSE').length
                })).sort((a, b) => b.count - a.count).slice(0, 3); // Top 3 per pillar
                failCounts.forEach(fc => {
                    if (fc.count > 0) {
                        // Get samples with both error context and feedback
                        const samples = processedData
                            .filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d)) // Apply Global Appeal & NPS Pass Filter
                            .filter(d => (d[fc.name] === false || d[fc.name] === 'FALSE') && (d["Remediation Feedback"] || d["Feedback"]))
                            .slice(0, 3)
                            .map(d => ({
                                error: d["User Problem"] || d["Chat Tag"] || "Issue identified",
                                feedback: d["Remediation Feedback"] || d["Feedback"] || d["Comment"] || d["Notes"] || d["Verbatim"] || ""
                            }));
                        buckets[pillar].push({ metric: fc.name, count: fc.count, samples });
                    }
                });
            });


            // Slack Post Generation: Feedback-centric, action-oriented
            const prompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nYou are a Team Leader writing a team Slack update for NPS performance.

DATA SUMMARY:
${JSON.stringify(buckets)}

CRITICAL FORMAT:
1. ** Team Update: NPS Performance ** (Title wrapped in star emojis both sides, bold)

2. [Intro - AI Generated 1 line context setting]

3. **Key Issues & Action**
   - **Sub-metric Name** :- [What happened] [Action/Guidance] (Chat:- [URL])
   - **Sub-metric Name** :- [What happened] [Action/Guidance] (Chat:- [URL])
   - **Sub-metric Name** :- [What happened] [Action/Guidance] (Chat:- [URL])
   (Max 3 bullets per pillar, use ONLY Sub-metric names from data)

4. Closure (NOT A HEADING)
   - Single motivating line with emoji
   - Forward-looking
   - Team-focused

STRICT KEYWORD RULES (CRITICAL - DO NOT VIOLATE):
- Use ONLY these exact sub-metric names from the data: ${Object.values(buckets).flat().map(b => b.metric).filter(Boolean).join(', ') || 'Check data summary above'}
- Use ONLY pillar names: Communication, Personalisation, Efficiency
- **NEVER invent generic terms** like "Volume Growth", "Proactive Engagement", "Process Adherence", "Customer Focus"
- **NEVER use** vague terms like "communication skills", "attention to detail", "time management"
- Every bullet must reference a specific sub-metric name from the data summary
- Bold (**text**) the sub-metric name followed by :- 

FORMATTING RULES:
- Titles ALWAYS wrapped in star emojis () before and at end, in bold
- All headings and sub-headings in bold (**text**)
- Closure is NEVER a heading
- NO Sign-off
- Proper line breaks between sections
- Structure bullets as: "[Sub-metric] :- [What happened] [Action/Guidance] (Chat:- URL)"
- Do NOT list raw counts only
- Base each bullet on actual sample feedback
- Include at most 3 bullets per pillar
- NO hashtags (#)

Return ONLY the raw Markdown text.`


            try {
                const system = "Output standard Markdown. Use **bold** for emphasis. No hashtags. Allowed Punctuation: . , : - ' \" @ &.";
                const result = await AIRequestManager.generate(prompt, system, { useMemory: true, validateAction: true });
                return formatSlackMessage(result, 'SlackPost');
            } catch (e) { return " AI generation failed." }
        };


        // Fix: generateSmartCoachingPlan - Updated format for NPS/QC and Unified views
        const generateSmartCoachingPlan = async (agentName, strengths, opportunities, feedbackContext = '', errorsContext = '', type = 'NPS', isUnified = false, styleContext = '', meetingNotes = '') => {
            const system = `${AI_PERSONA}
${TL_PERSONA_PROMPT}

Tone: Simple, polite, easy to understand. Output standard Markdown. Use **bold** for headers. NO hashtags (#). Allowed Punctuation: . , : - ' " @. Do not use exclamation marks.
CRITICAL: Do not output raw URLs. Always use Markdown links [Link](url) or Slack style <url|Link>.`;


            // Unified Spotlight Logic (Used for NPS, QC, and Unified Tabs)
            const prompt = `
Generate a Coaching Plan for agent "${agentName}".
Focus ONLY on the provided data type: ${type} (If Unified, use both). Do NOT invent data.
${styleContext}

CRITICAL FORMAT:
1. ** Coaching Plan ** (Title wrapped in star emojis both sides, bold)

2. Introduction (AI Generated)
   - 1-2 line logical introduction
   - Different each time based on relevance
   - Based on data context (${type})

${(type === 'NPS' || type === 'Unified' || isUnified) ? `
3. **NPS Feedback** (Only if NPS data)
   - MAX 3 items
   - Rewrite TL feedback - do NOT copy exact text
   - **Sub-metric** :- [Rewritten feedback] (Chat:- [actual URL])
   - Use **bold** for Sub-metric names
   - NO positive points
   - Exclude appealed items
` : ''}

${(type === 'QC' || type === 'Unified' || isUnified) ? `
4. **QC Feedback** (Only if QC data)
   - MAX 3 items
   - Only question keywords (NOT full question): "Didn't follow X", "Missed Y"
   - Rewrite based on TL RCA + Answer Comment combined
   - **Keyword** :- [Rewritten feedback] (Review:- [actual URL])
   - Use **bold** for keywords
   - NO positive points
   - Exclude appealed items
` : ''}

5. **Pending 1:1 File Actions** (ONLY INCLUDE IF PENDING ITEMS EXIST - If all counts are 0, SKIP this entire section)
   ${feedbackContext && feedbackContext.trim() ? '- Include each pending item with count and action required' : 'NO PENDING ITEMS - Skip this section completely'}

6. **Action Items**
   - 3-5 bullet points
   - Focus on what agent should actually do
   - ${meetingNotes ? 'Include actions from Meeting Notes.' : ''}

7. Closure (NOT A HEADING)
   - 1-2 lines closing statement relevant to post and data
   - 1 line forward-looking
   - Combined as paragraph with emojis
   - Encouraging, motivational

NO SIGN-OFF. This is not email. After closure, it ends.

STRICT KEYWORD RULES (CRITICAL - DO NOT VIOLATE):
- Use ONLY sub-metric names from the provided data
- Use ONLY pillar names: Communication, Personalisation, Efficiency
- Use ONLY QC categories: Critical, Process, Internal
- Use ONLY specific metric names from NPS_METRIC_MAPPING and QC_METRIC_MAPPING
- **NEVER invent generic terms** like "communication skills", "customer focus", "process improvement"
- **NEVER use** vague terms like "attention to detail", "time management", "professionalism" (unless from QC Internal metrics)
- Every feedback item must reference a specific metric from data
- Bold (**text**) the metric name followed by :- 

FORMATTING RULES:
- Titles ALWAYS wrapped in star emojis () before and at end, in bold
- All headings and sub-headings in bold (**text**)
- Closure is NEVER a heading
- NO Sign-off
- Proper 1-2 line breaks between sections
- Specific terms from raw data can be bold to highlight
- NO hashtags (#)
- Use standard Markdown bullets (-)

DATA:
Strengths: ${strengths.length > 0 ? strengths.map(s => s.name).join(', ') : 'None'}
Opportunities: ${opportunities.length > 0 ? opportunities.map(o => o.name).join(', ') : 'None'}
${feedbackContext}
${errorsContext}
${meetingNotes ? `MEETING NOTES:\n${meetingNotes}` : ''}
`
            const result = await AIRequestManager.generate(prompt, system, { useMemory: true });
            return formatSlackMessage(result, 'CoachingPlan');
        };


        const generateRefinement = async (originalText, instruction) => {
            const prompt = `${AI_PERSONA}
${TL_PERSONA_PROMPT}

Original: "${originalText}".
Instruction: "${instruction}".
Rewrite applying instruction to STRICT FORMAT.

STRICT RULES:
1. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.
2. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).
3. NO hashtags (#).
4. Use emojis sparingly (max 2 per line).
5. Do NOT use the word "Bold", "Underline", or "B" as text.
6. Do NOT bold emphasis words like "Always", "Never", "Note" inside descriptions.`;
            const result = await AIRequestManager.generate(prompt, "", { useMemory: true });
            return formatSlackMessage(result, 'General');
        };




        // --- MAIN APP COMPONENT ---
        // Fix: Table Export Buttons Component - Add to all tables
        const TableExportButtons = ({ tableId, tableData, filename, columns, visibleColumns, onToggleColumn, minimal = false, askAI, dataForAI, sparkleType, infoText, onExpand }) => {
            const handleDownloadTableImage = async () => {
                await downloadAsImage(tableId, filename || 'table');
            };


            const handleDownloadCSV = () => {
                if (tableData && tableData.length > 0) {
                    ExportEngine.exportCSV(tableData, filename || 'export');
                } else {
                    showToast("No data to export.");
                }
            };




            const handleCopyTable = () => {
                copyTableToClipboard(tableId);
            };


            return (
                <div className="flex gap-1 items-center group">


                    {dataForAI && (
                        <div className="scale-90 origin-center">
                            <GeminiSparkle data={dataForAI} type={sparkleType || 'General'} compact />
                        </div>
                    )}


                    {/* Info Tip - Hover Only */}
                    {infoText && (
                        <div className="opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                            <TooltipIcon text={infoText} />
                        </div>
                    )}


                    {columns && onToggleColumn && (
                        <ColumnFilterDropdown columns={columns} visibleColumns={visibleColumns} onToggle={onToggleColumn} />
                    )}


                    {!minimal && (
                        <>
                            {tableData && (
                                <button onClick={handleDownloadCSV} className="p-1.5 hover:bg-slate-100 rounded-lg hover:text-emerald-600" title="Download CSV">
                                    <Download size={16} />
                                </button>
                            )}
                            <button onClick={handleDownloadTableImage} className="p-1.5 hover:bg-slate-100 rounded-lg hover:text-indigo-600" title="Capture Image">
                                <Camera size={16} />
                            </button>
                            <button onClick={handleCopyTable} className="p-1.5 hover:bg-slate-100 rounded-lg hover:text-blue-600" title="Copy Table">
                                <ClipboardList size={16} />
                            </button>
                            {onExpand && (
                                <button onClick={onExpand} className="p-1.5 hover:bg-slate-100 rounded-lg hover:text-blue-600" title="Expand View">
                                    <Maximize2 size={16} />
                                </button>
                            )}
                        </>
                    )}
                </div>
            );
        };


        // useSortableTable - Custom hook for sorting and filtering table data
        const useSortableTable = (data, defaultKey = null) => {
            const [sortKey, setSortKey] = useState(defaultKey);
            const [direction, setDirection] = useState('desc');
            const [query, setQuery] = useState('');
            const [filters, setFilters] = useState({});


            const sortedData = useMemo(() => {
                let filtered = data || [];
                if (query) filtered = filtered.filter(row => Object.values(row).some(val => String(val).toLowerCase().includes(query.toLowerCase())));
                Object.keys(filters).forEach(key => {
                    if (filters[key] && filters[key].length > 0) {
                        filtered = filtered.filter(row => filters[key].includes(String(row[key])));
                    }
                });


                // Default sorting
                if (!sortKey) {
                    return [...filtered].sort((a, b) => {
                        // Default: Date desc, then Name asc
                        const dateA = DataEngine.parseDate(a.Date || a['Review Date'] || a.date);
                        const dateB = DataEngine.parseDate(b.Date || b['Review Date'] || b.date);
                        if (dateA && dateB) {
                            const dateDiff = dateB.getTime() - dateA.getTime();
                            if (dateDiff !== 0) return dateDiff;
                        }
                        const nameA = String(a.Agent || a['Agent Email'] || a.name || a.email || '').toLowerCase();
                        const nameB = String(b.Agent || b['Agent Email'] || b.name || b.email || '').toLowerCase();
                        return nameA.localeCompare(nameB);
                    });
                }


                return [...filtered].sort((a, b) => {
                    const x = a[sortKey]; const y = b[sortKey];
                    const dateX = DataEngine.parseDate(x);
                    const dateY = DataEngine.parseDate(y);
                    if (dateX && dateY) return direction === 'asc' ? dateX.getTime() - dateY.getTime() : dateY.getTime() - dateX.getTime();
                    if (typeof x === 'number' && typeof y === 'number') return direction === 'asc' ? x - y : y - x;
                    return direction === 'asc' ? String(x).localeCompare(String(y)) : String(y).localeCompare(String(x));
                });
            }, [data, sortKey, direction, query, filters]);


            const toggleSort = (key) => { if (sortKey === key) setDirection(direction === 'asc' ? 'desc' : 'asc'); else { setSortKey(key); setDirection('desc'); } };
            const setColumnFilter = (col, val) => setFilters(prev => ({ ...prev, [col]: val }));


            return { data: sortedData, toggleSort, setQuery, sortKey, direction, query, setColumnFilter, filters };
        };


        // SortableTableHeader - Clickable header with sort icons and filter dropdown
        const SortableTableHeader = ({ column, label, sortKey, sortDirection, onSort, onFilter, filterValue, data, className = '' }) => {
            const [showFilter, setShowFilter] = useState(false);
            const [localFilter, setLocalFilter] = useState(filterValue || '');
            const filterRef = useRef(null);


            // Get unique values for filter dropdown
            const uniqueValues = useMemo(() => {
                if (!data) return [];
                const values = [...new Set(data.map(row => row[column]).filter(v => v !== null && v !== undefined && v !== ''))];
                return values.sort().slice(0, 50); // Limit to 50 items
            }, [data, column]);


            useEffect(() => {
                const handleClickOutside = (e) => {
                    if (filterRef.current && !filterRef.current.contains(e.target)) {
                        setShowFilter(false);
                    }
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, []);


            const isSorted = sortKey === column;
            const isFiltered = filterValue && filterValue.length > 0;


            return (
                <th className={`p-3 font-bold text-slate-800 border-b border-slate-200 bg-slate-50 sticky top-0 z-10 ${className}`}>
                    <div className={`flex items-center gap-2 ${className.includes('text-center') ? 'justify-center' : className.includes('text-right') ? 'justify-end' : ''}`}>
                        <span
                            className="cursor-pointer hover:text-blue-600 flex items-center gap-1 select-none"
                            onClick={() => onSort(column)}
                        >
                            {label || column}
                            {isSorted && (
                                <span className="text-blue-600">
                                    {sortDirection === 'asc' ? <ChevronUp size={14} /> : <ChevronDown size={14} />}
                                </span>
                            )}
                        </span>


                        <div className="relative" ref={filterRef}>
                            <button
                                onClick={(e) => { e.stopPropagation(); setShowFilter(!showFilter); }}
                                className={`p-1 rounded hover:bg-slate-200 transition-colors ${isFiltered ? 'text-blue-600 bg-blue-50' : 'text-slate-500'}`}
                                title="Filter"
                            >
                                <Filter size={12} />
                            </button>


                            {showFilter && (
                                <div className="absolute left-0 top-full mt-1 bg-white rounded-xl shadow-xl border border-slate-200 p-2 min-w-[200px] z-50">
                                    <input
                                        type="text"
                                        placeholder="Filter..."
                                        value={localFilter}
                                        onChange={(e) => setLocalFilter(e.target.value)}
                                        onKeyDown={(e) => {
                                            if (e.key === 'Enter') {
                                                onFilter(column, localFilter);
                                                setShowFilter(false);
                                            }
                                        }}
                                        className="w-full px-2 py-1.5 text-xs border rounded-lg mb-2 focus:ring-2 ring-blue-500 outline-none"
                                        autoFocus
                                    />
                                    <div className="max-h-[200px] overflow-y-auto">
                                        {uniqueValues.map((val, i) => (
                                            <button
                                                key={i}
                                                onClick={() => { onFilter(column, String(val)); setShowFilter(false); }}
                                                className="w-full text-left px-2 py-1.5 text-xs hover:bg-slate-100 rounded truncate"
                                            >
                                                {String(val)}
                                            </button>
                                        ))}
                                    </div>
                                    {isFiltered && (
                                        <button
                                            onClick={() => { onFilter(column, ''); setLocalFilter(''); setShowFilter(false); }}
                                            className="w-full text-left px-2 py-1.5 text-xs text-rose-600 hover:bg-rose-50 rounded mt-1 border-t"
                                        >
                                            Clear Filter
                                        </button>
                                    )}
                                </div>
                            )}
                        </div>
                    </div>
                </th>
            );
        };


        const TooltipIcon = ({ text }) => {
            const [show, setShow] = useState(false);
            const [coords, setCoords] = useState({ top: 0, left: 0 });
            const triggerRef = useRef(null);


            const handleMouseEnter = () => {
                const rect = triggerRef.current.getBoundingClientRect();
                setCoords({
                    top: rect.top + window.scrollY - 12,
                    left: rect.left + window.scrollX + (rect.width / 2)
                });
                setShow(true);
            };


            return (
                <div className="inline-block" data-html2canvas-ignore="true">
                    <div
                        ref={triggerRef}
                        onMouseEnter={handleMouseEnter}
                        onMouseLeave={() => setShow(false)}
                        className="p-1 rounded-full hover:bg-indigo-50 transition-colors cursor-help"
                    >
                        <Info size={13} className="text-indigo-400/80 hover:text-indigo-600 transition-all infotip-pulse" />
                    </div>
                    {show && createPortal(
                        <div
                            style={{
                                position: 'absolute',
                                top: `${coords.top}px`,
                                left: `${coords.left}px`,
                                transform: 'translate(-50%, -100%)',
                                zIndex: 99999,
                                width: '280px'
                            }}
                            className="p-4 bg-slate-900/95 backdrop-blur-xl rounded-[1.5rem] shadow-2xl border border-gray-200 pointer-events-none"
                        >
                            <div className="flex gap-3 items-start">
                                <div className="p-2 bg-indigo-500/20 rounded-xl">
                                    <Sparkles size={14} className="text-indigo-300" />
                                </div>
                                <div className="flex-1">
                                    <div className="text-[11px] leading-relaxed text-slate-300 whitespace-pre-wrap font-medium">{text}</div>
                                </div>
                            </div>
                            <div className="absolute -bottom-1.5 left-1/2 -ml-1.5 border-[6px] border-transparent border-t-slate-900/95"></div>
                        </div>,
                        document.body
                    )}
                </div>
            );
        };


        // Skeleton - Loading state component
        const Skeleton = ({ className }) => <div className={`animate-pulse bg-slate-200 rounded ${className}`}></div>;


        // AIInsightBlock - Dynamic AI coaching insights for agents
        const AIInsightBlock = ({ data, type, agentName }) => {
            const [insight, setInsight] = useState('');
            const [loading, setLoading] = useState(false);

            useEffect(() => {
                if (!agentName || !data || data.length === 0) return;
                
                const generateInsight = async () => {
                    setLoading(true);
                    try {
                        const sampleData = data.slice(0, 10).map(r => ({
                            rating: r.Rating || r['QC Score'],
                            feedback: r.Feedback || r['Remediation Feedback'] || r['Comment'] || r['Notes'] || r['Verbatim'] || r['Answer Comment'] || r['TL RCA'] || '',
                            failedMetrics: r.failedMetrics || []
                        }));

                        const prompt = `System: You are Poppy, a senior CX Quality coach.
Context: Analyze these ${type} performance records for agent ${agentName}.
Data: ${JSON.stringify(sampleData)}
Task: Provide a concise, 3-sentence coaching insight. 
1st sentence: Identify the primary performance trend.
2nd sentence: Highlight the most critical friction point.
3rd sentence: Give a specific coaching recommendation.
Constraint: DO NOT include agent name. Keep it professional and actionable. Bold key terms using **text**.`;

                        const response = await GeminiAI.generate(prompt);
                        setInsight(response);
                    } catch (e) {
                        setInsight("Unable to generate automated insights at this time. Please review the raw feedback below.");
                    } finally {
                        setLoading(false);
                    }
                };

                generateInsight();
            }, [agentName, data, type]);

            if (loading) return (
                <div className="space-y-3">
                    <Skeleton className="h-4 w-3/4" />
                    <Skeleton className="h-4 w-5/6" />
                    <Skeleton className="h-4 w-1/2" />
                </div>
            );

            return (
                <div className="text-sm text-slate-700 leading-relaxed italic prose prose-slate max-w-none">
                    <div dangerouslySetInnerHTML={{ __html: safeMarked(insight || "Select an agent to view detailed coaching insights and behavioral patterns.") }} />
                </div>
            );
        };



        // VerticalAxisTick - Custom Y-axis tick for horizontal bar charts with text wrapping
        const VerticalAxisTick = ({ x, y, payload }) => {
            if (!payload || !payload.value) return null;
            const words = payload.value.split(' ');
            let lines = [], currentLine = words[0];


            for (let i = 1; i < words.length; i++) {
                if ((currentLine + " " + words[i]).length < 35) {
                    currentLine += " " + words[i];
                } else {
                    lines.push(currentLine);
                    currentLine = words[i];
                }
            }
            lines.push(currentLine);


            return (
                <g transform={`translate(${x},${y})`}>
                    {lines.map((line, index) => (
                        <text key={index} x={-10} y={-4 + (index * 11) - ((lines.length - 1) * 5)} dy={0} textAnchor="end" fill="#475569" style={{ fontSize: '10px', fontWeight: 600 }}>
                            {line}
                        </text>
                    ))}
                </g>
            );
        };


        // CardActions - Reusable action button group for cards
        const CardActions = ({ onCopy, onCSV, onExcel, onColumns, onImage, onGemini, onExpand, askAI, isNumbersVisible, toggleNumbers }) => (
            <div className="flex items-center gap-1.5" data-html2canvas-ignore="true">
                {toggleNumbers && (
                    <button
                        onClick={toggleNumbers}
                        className={`p-1.5 rounded-lg transition-all ${isNumbersVisible ? 'text-indigo-600 bg-indigo-50' : 'text-slate-500 hover:text-indigo-600 hover:bg-indigo-50'}`}
                        title={isNumbersVisible ? "Hide Data Labels" : "Show Data Labels"}
                    >
                        {isNumbersVisible ? <Eye size={14} /> : <EyeOff size={14} />}
                    </button>
                )}
                {onExpand && (
                    <button onClick={onExpand} className="p-1.5 hover:bg-slate-100 rounded-lg hover:text-blue-600" title="Expand View">
                        <Maximize2 size={16} />
                    </button>
                )}
                {onImage && (
                    <button onClick={handleDownloadTableImage} className="p-1.5 hover:bg-slate-100 rounded-lg hover:text-indigo-600" title="Capture Image">
                        <Camera size={16} />
                    </button>
                )}
                {onCopy && (
                    <button
                        onClick={onCopy}
                        className="p-1.5 text-slate-500 hover:text-indigo-600 hover:bg-indigo-50 rounded-lg transition-all"
                        title="Copy Table"
                    >
                        <ClipboardList size={14} />
                    </button>
                )}
                {onCSV && (
                    <button
                        onClick={onCSV}
                        className="p-1.5 text-slate-500 hover:text-emerald-600 hover:bg-emerald-50 rounded-lg transition-all"
                        title="Export CSV"
                    >
                        <FileSpreadsheet size={14} />
                    </button>
                )}
                {onExcel && (
                    <button
                        onClick={onExcel}
                        className="p-1.5 text-slate-500 hover:text-green-600 hover:bg-green-50 rounded-lg transition-all"
                        title="Export Excel"
                    >
                        <FileSpreadsheet size={14} className="text-green-600" />
                    </button>
                )}
                {onColumns && (
                    <div className="flex items-center gap-1">
                        {onColumns}
                    </div>
                )}
            </div>
        );


        // TruncatedText - Component for handling long text with tooltip
        const TruncatedText = ({ text, maxLength = 30 }) => {
            if (!text || text.length <= maxLength) return <span>{text}</span>;


            return (
                <div className="relative group inline-block">
                    <span className="cursor-help">{text.substring(0, maxLength)}...</span>
                    <div className="absolute hidden group-hover:block z-50 bg-slate-900 text-white text-xs px-3 py-2 rounded-lg shadow-xl -top-10 left-0 whitespace-nowrap pointer-events-none">
                        {text}
                    </div>
                </div>
            );
        };


        // CustomTick - Custom axis tick for charts with truncation
        const CustomTick = ({ x, y, payload, maxLength = 20 }) => {
            if (!payload || !payload.value) return null;
            const text = payload.value;
            const truncated = text.length > maxLength ? text.substring(0, maxLength) + '...' : text;


            return (
                <g transform={`translate(${x},${y})`}>
                    <text x={0} y={0} dy={16} textAnchor="middle" fill="#64748b" fontSize={12} fontWeight={700}>
                        <title>{text}</title>
                        {truncated}
                    </text>
                </g>
            );
        };


        // useDebounce - Hook for debouncing values
        const useDebounce = (value, delay) => {
            const [debouncedValue, setDebouncedValue] = useState(value);


            useEffect(() => {
                const handler = setTimeout(() => setDebouncedValue(value), delay);
                return () => clearTimeout(handler);
            }, [value, delay]);


            return debouncedValue;
        };


        // LazyChart - Component for lazy loading charts
        const LazyChart = ({ children, fallback }) => {
            const [isVisible, setIsVisible] = useState(false);
            const ref = useRef();


            useEffect(() => {
                const observer = new IntersectionObserver(
                    ([entry]) => {
                        if (entry.isIntersecting) {
                            setIsVisible(true);
                            observer.disconnect();
                        }
                    },
                    { rootMargin: '100px' }
                );


                if (ref.current) observer.observe(ref.current);
                return () => observer.disconnect();
            }, []);


            return (
                <div ref={ref}>
                    {isVisible ? children : (fallback || <Skeleton className="w-full h-[400px]" />)}
                </div>
            );
        };


        // --- REUSABLE COMPONENTS ---


        // StatusBadge - Reusable status badge component
        const StatusBadge = ({ status, className = "" }) => {
            const statusConfig = {
                'Complete': 'bg-green-100 text-green-700',
                'Pending Written': 'bg-amber-100 text-amber-700',
                'Pending Tick': 'bg-orange-100 text-orange-700',
                'Pending to be appealed': 'bg-purple-100 text-purple-700',
                'Yes': 'bg-green-100 text-green-700',
                'No': 'bg-red-100 text-red-700'
            };
            const badgeClass = statusConfig[status] || 'bg-slate-100 text-slate-700';
            return (
                <span className={`px-2 py-1 rounded text-xs font-bold ${badgeClass} ${className}`}>
                    {status}
                </span>
            );
        };


        // TableContainer - Reusable table wrapper
        // Smart height: fully expanded for <=20 rows, scrollable for >20 rows
        const TableContainer = ({ children, maxHeight, rowCount, className = "" }) => {
            const hasRowCount = typeof rowCount === 'number';
            const shouldScroll = hasRowCount ? rowCount > 20 : Boolean(maxHeight);
            const computedMaxHeight = shouldScroll ? (maxHeight || "1000px") : 'none';
            const overflowClass = shouldScroll ? 'overflow-auto' : 'overflow-visible';

            return (
                <div className={`${overflowClass} border border-slate-200 rounded-xl custom-scrollbar ${className}`} style={{ maxHeight: computedMaxHeight }}>
                    {children}
                </div>
            );
        };


        // useClickOutside - Reusable hook for detecting clicks outside element
        const useClickOutside = (ref, handler) => {
            useEffect(() => {
                const click = (e) => {
                    if (ref.current && !ref.current.contains(e.target)) {
                        handler();
                    }
                };
                document.addEventListener('mousedown', click);
                return () => document.removeEventListener('mousedown', click);
            }, []);
        };


        // feedbackLoopCalculator - Utility function to calculate feedback loop stats
        // feedbackLoopCalculator - Utility function to calculate feedback loop stats
        const feedbackLoopCalculator = (data, type) => {
            if (!data) return { provided: 0, ackTick: 0, ackWritten: 0, pendingTick: 0, pendingWritten: 0, notRequired: 0, ackRate: 0, participationRate: 0 };
            
            let provided = 0, ackTick = 0, ackWritten = 0, pendingTick = 0, pendingWritten = 0, notRequired = 0;

            data.forEach(row => {
                let needFeedback = false;
                
                if (type === 'NPS') {
                    // Need feedback: >=1 sub-metric failed AND Remediation Feedback has content
                    const metrics = Object.values(NPS_METRIC_MAPPING).flat();
                    const hasFail = metrics.some(m => {
                        const val = row[m];
                        return val === 'Fail' || val === 'FALSE' || val === 'No' || val === false;
                    });
                    const feedback = row['Remediation Feedback'] || row['Feedback'];
                    
                    if (hasFail && feedback && String(feedback).trim().length > 0) {
                        needFeedback = true;
                    }
                } else {
                    // QC: Need feedback if Failure AND (No Appeal OR Rejected Appeal)
                    const status = String(row['Appeal Status'] || '').trim();
                    const isRejected = status === 'Reject Appeal' || status === 'Rejected';
                    const isPending = status === 'To Do';
                    const qcScore = parseFloat(row['QC Score']) || 0;
                    const isAccepted = status === 'Accept Appeal' || status === 'Accepted' || qcScore === 0;
                    const isPendingToBeAppealed = (row['TL Appeal'] === true || row['TL Appeal'] === 'TRUE') && (String(row['TL RCA']).startsWith('Appeal') || String(row['TL RCA']).startsWith('Appealed')) && !status;
                    
                    // Check failure: Score > 0 or explicit Fail
                    const isFail = qcScore > 0 || row['Pass/Fail'] === 'Fail';

                    // Exclude Pending, Accepted, Pending to be appealed, and Passes
                    if (isFail && !isPending && !isAccepted && !isPendingToBeAppealed) {
                        needFeedback = true;
                    }
                }
                
                if (!needFeedback) {
                    notRequired++;
                    return;
                }
                
                provided++;
                
                // Check Compliance
                // Ack Tick
                const ackCol = type === 'NPS' ? 'Acknowledged' : 'Agent Ack.';
                const isAckTick = row[ackCol] === true || row[ackCol] === 'TRUE';
                
                // Written Justification
                // NPS: "Agent Reply" column | QC: "Answer Comment" column
                const justCol = type === 'NPS' ? 'Agent Reply' : 'Answer Comment';
                const justVal = row[justCol] || '';
                const isJustification = justVal && String(justVal).trim().length > 0;
                
                if (isAckTick) ackTick++; else pendingTick++;
                if (isJustification) ackWritten++; else pendingWritten++;
            });

            return {
                provided,
                ackTick,
                ackWritten,
                pendingTick,
                pendingWritten,
                pending: pendingTick + pendingWritten,
                notRequired
            };
        };


        // TableColumnMenu - Reusable column visibility toggle
        const TableColumnMenu = ({ visibleColumns, toggleColumn, labels = {} }) => {
            const [isOpen, setIsOpen] = useState(false);
            const ref = useRef(null);
            useClickOutside(ref, () => setIsOpen(false));


            return (
                <div className="relative inline-block" ref={ref}>
                    <button onClick={() => setIsOpen(!isOpen)} className="p-1.5 text-slate-500 hover:text-blue-600 hover:bg-blue-50 rounded-lg transition-colors" title="Show/Hide Columns">
                        <LayoutDashboard size={16} />
                    </button>
                    {isOpen && (
                        <div className="absolute right-0 top-full mt-2 bg-white rounded-xl shadow-xl border border-slate-200 p-2 min-w-[200px] z-50">
                            <div className="text-[10px] font-bold text-slate-500 uppercase mb-2 px-2 tracking-wider">Visible Columns</div>
                            {Object.keys(visibleColumns).map(col => (
                                <button key={col} onClick={() => toggleColumn(col)} className="w-full flex items-center justify-between px-2 py-1.5 text-xs text-slate-600 hover:bg-slate-50 rounded-lg transition-colors">
                                    <span>{labels[col] || col}</span>
                                    {visibleColumns[col] && <CheckCircle size={12} className="text-blue-500" />}
                                </button>
                            ))}
                        </div>
                    )}
                </div>
            )
        };






        // FeedbackLoopTable - Reusable feedback loop table component
        const FeedbackLoopTable = ({ data, type, onShowData, showDataButton = false, tableId, onDownloadImage, dataForAI, aiType, columnFilter, infoText, askAI }) => {
            if (!data || data.provided === 0) return null;


            const finalTableId = tableId || "feedback-loop-table";


            return (
                <Card
                    title="Feedback Loop Summary"
                    type="Table"
                    id={finalTableId}
                    infoText={infoText || "Summary of feedback lifecycle metrics. tracks Provided, Acknowledged (Tick/Written), and Pending counts."}
                    onDownloadImage={onDownloadImage}
                    onDownloadCSV={() => ExportEngine.exportCSV([data], `${type}_feedback_summary`)}
                    onCopyTable={() => copyTableToClipboard(null, [data])}
                    dataForAI={dataForAI || data}
                    aiType={aiType || type}
                    askAI={askAI}
                    columnFilter={columnFilter || (showDataButton && (
                        <button onClick={onShowData} className="px-3 py-1.5 bg-indigo-600 text-white text-[10px] font-black uppercase tracking-widest rounded-xl hover:bg-indigo-500 transition-all flex items-center gap-2 shadow-lg hover:shadow-indigo-200">
                            <FileText size={14} /> Full Log
                        </button>
                    ))}
                >
                    <table className="w-full text-xs text-left border-collapse" id={finalTableId}>
                        <thead className="bg-slate-50/50">
                            <tr className="border-b border-slate-200">
                                <th className="p-2 font-black text-slate-500 uppercase tracking-widest">Provided</th>
                                <th className="p-4 font-black text-slate-500 uppercase tracking-widest text-center">Tick Ack</th>
                                <th className="p-4 font-black text-slate-500 uppercase tracking-widest text-center">Written Ack</th>
                                <th className="p-4 font-black text-slate-500 uppercase tracking-widest text-center">Pending Tick</th>
                                <th className="p-4 font-black text-slate-500 uppercase tracking-widest text-center">Pending Written</th>
                                <th className="p-4 font-black text-slate-500 uppercase tracking-widest text-center">Total Pending</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr className="group hover:bg-slate-50 transition-colors">
                                <td className="p-2 font-bold text-slate-700">{data.provided}</td>
                                <td className="p-4 text-center font-black text-green-600">{data.ackTick}</td>
                                <td className="p-4 text-center font-black text-blue-600">{data.ackWritten}</td>
                                <td className="p-4 text-center font-black text-amber-500">{data.pendingTick}</td>
                                <td className="p-4 text-center font-black text-rose-500">{data.pendingWritten}</td>
                                <td className="p-2 text-center">
                                    <span className={`px-3 py-1 rounded-full font-black ${data.pending > 0 ? 'bg-rose-100 text-rose-700' : 'bg-green-100 text-green-700'}`}>
                                        {data.pending}
                                    </span>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </Card>
            );
        };


        // AgentFeedbackLoopTable - Detailed breakdown per agent
        const AgentFeedbackLoopTable = ({ data, type, onDownloadImage, onAgentClick, onExpand, askAI }) => {
            const [visibleColumns, setVisibleColumns] = useState({
                agent: true, provided: true, ackTick: true, ackWritten: true,
                pendingTick: true, pendingWritten: true, pending: true
            });
            const toggleColumn = (key) => setVisibleColumns(prev => ({ ...prev, [key]: !prev[key] }));


            const { data: sorted, toggleSort, sortKey, direction, setColumnFilter, filters } = useSortableTable(data);
            const tableId = `${type}-agent-loop-table`;


            const getExportData = () => {
                return sorted.map(d => {
                    const row = {};
                    if (visibleColumns.agent) row.Agent = d.agent;
                    if (visibleColumns.provided) row.Provided = d.provided;
                    if (visibleColumns.ackTick) row['Tick Ack'] = d.ackTick;
                    if (visibleColumns.ackWritten) row['Written Ack'] = d.ackWritten;
                    if (visibleColumns.pendingTick) row['Pending Tick'] = d.pendingTick;
                    if (visibleColumns.pendingWritten) row['Pending Written'] = d.pendingWritten;
                    if (visibleColumns.pending) row['Total Pending'] = d.pending;
                    return row;
                });
            };


            const columnLabels = {
                agent: 'Agent', provided: 'Provided', ackTick: 'Tick Ack', ackWritten: 'Written Ack',
                pendingTick: 'Pending Tick', pendingWritten: 'Pending Written', pending: 'Total Pending'
            };


            return (
                <Card
                    title="Agent Compliance Breakdown"
                    id={`${type}-agent-loop-breakdown`}
                    infoText="Individual performance metrics for feedback lifecycle compliance. Sorted to highlight agents with the highest action backlogs."
                    onDownloadImage={onDownloadImage}
                    onDownloadCSV={() => ExportEngine.exportCSV(getExportData(), `${type.toLowerCase()}_agent_backlog`)}
                    onCopyTable={() => copyTableToClipboard(null, getExportData())}
                    toolbarType="table"
                    visibleColumns={visibleColumns}
                    toggleColumn={toggleColumn}
                    columnLabels={columnLabels}
                    onSearchHighlight={(term) => {
                        setColumnFilter('agent', term);
                        setColumnFilter('provided', term);
                        setColumnFilter('ackTick', term);
                        setColumnFilter('ackWritten', term);
                        setColumnFilter('pendingTick', term);
                        setColumnFilter('pendingWritten', term);
                        setColumnFilter('pending', term);
                    }}
                    onExpand={onExpand}
                    askAI={askAI}
                    dataForAI={data}
                    aiType={type}
                >
                    <TableContainer rowCount={data.length} className="flex-1">
                        <table className="w-full text-xs text-left border-collapse">
                            <thead className="bg-slate-50 sticky top-0 z-10">
                                <tr className="border-b border-slate-200 text-slate-500">
                                    {visibleColumns.agent && <SortableTableHeader column="agent" label="Agent" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['agent']} data={data} className="border-r" />}
                                    {visibleColumns.provided && <SortableTableHeader column="provided" label="Provided" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['provided']} data={data} className="text-center border-r" />}
                                    {visibleColumns.ackTick && <SortableTableHeader column="ackTick" label="Tick Ack" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['ackTick']} data={data} className="text-center border-r text-green-600" />}
                                    {visibleColumns.ackWritten && <SortableTableHeader column="ackWritten" label="Written Ack" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['ackWritten']} data={data} className="text-center border-r text-blue-600" />}
                                    {visibleColumns.pendingTick && <SortableTableHeader column="pendingTick" label="Pending Tick" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['pendingTick']} data={data} className="text-center border-r text-amber-500" />}
                                    {visibleColumns.pendingWritten && <SortableTableHeader column="pendingWritten" label="Pending Written" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['pendingWritten']} data={data} className="text-center border-r text-orange-500" />}
                                    {visibleColumns.pending && <SortableTableHeader column="pending" label="Total Pending" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['pending']} data={data} className="text-center border-r text-slate-500" />}
                                </tr>
                            </thead>
                            <tbody className="divide-y divide-slate-100 bg-white">
                                {sorted && sorted.length > 0 ? (
                                    sorted.map((row, idx) => (
                                        <tr key={idx} className={`hover:bg-slate-50 ${onAgentClick ? 'cursor-pointer transition-colors' : ''}`} onClick={() => onAgentClick && onAgentClick(row.agent)}>
                                            {visibleColumns.agent && <td className={`p-3 font-semibold text-slate-700 border-r border-slate-100 ${onAgentClick ? 'underline decoration-blue-200 decoration-2 underline-offset-2 text-blue-600' : ''}`}><HighlightText text={row.agent} highlight={filters['agent']} /></td>}
                                            {visibleColumns.provided && <td className="p-3 text-center border-r border-slate-100">{row.provided}</td>}
                                            {visibleColumns.ackTick && <td className="p-3 text-center font-bold border-r border-slate-100 text-green-600">{row.ackTick}</td>}
                                            {visibleColumns.ackWritten && <td className="p-3 text-center font-bold border-r border-slate-100 text-blue-600">{row.ackWritten}</td>}
                                            {visibleColumns.pendingTick && <td className={`p-3 text-center font-bold border-r border-slate-100 ${row.pendingTick > 0 ? 'text-amber-600 bg-amber-50' : 'text-slate-300'}`}>{row.pendingTick}</td>}
                                            {visibleColumns.pendingWritten && <td className={`p-3 text-center font-bold border-r border-slate-100 ${row.pendingWritten > 0 ? 'text-orange-600 bg-orange-50' : 'text-slate-300'}`}>{row.pendingWritten}</td>}
                                            {visibleColumns.pending && <td className={`p-3 text-center font-black border-r border-slate-100 ${row.pending > 0 ? 'text-rose-600' : 'text-slate-300'}`}>{row.pending}</td>}
                                        </tr>
                                    ))
                                ) : (
                                    <tr><td colSpan="7" className="p-8 text-center text-slate-500">No feedback data available for agents.</td></tr>
                                )}
                            </tbody>
                        </table>
                    </TableContainer>
                </Card>
            );
        };


        const FeedbackDataModal = ({ isOpen, onClose, title, rows, type, onDownloadImage }) => {
            if (!isOpen || !rows || rows.length === 0) return null;


            const isNPS = type === 'NPS';
            const dateKey = isNPS ? 'Date' : ('Review Date' in rows[0] ? 'Review Date' : 'Date');
            const feedbackKey = isNPS ? 'Remediation Feedback' : 'TL RCA';
            const ackKey = 'Acknowledged';
            const justificationKey = 'Agent Reply';




            const handleCopy = () => {
                copyTableToClipboard(null, rows); // Using helper that accepts data directly if supported, or I might need to implement a data-to-clipboard manually or rely on table ID?
                // Wait, copyTableToClipboard usually takes an ID.
                // But passing data directly is better if the function supports it. 
                // Let's check copyTableToClipboard. 
                // Assuming it takes ID. I'll rely on Excel export mostly.
                // But I can try to find if there's a helper.
                // Actually, let's just stick to Excel for now as it's the main requirement.
                // I will skip onCopy for now to avoid breaking if function doesn't support data.
            };


            return (
                <Modal isOpen={isOpen} onClose={onClose} title={title} onDownloadImage={onDownloadImage} actions={{ onCSV: () => ExportEngine.exportCSV(rows, title || 'feedback_data') }}>
                    <TableContainer maxHeight="70vh" rowCount={rows.length}>
                        <table className="w-full text-xs text-left border-collapse">
                            <thead className="bg-slate-50 sticky top-0 z-20">
                                <tr className="border-b">
                                    <th className="p-3 font-bold">Date</th>
                                    <th className="p-3 font-bold">{isNPS ? 'TL Feedback' : 'TL RCA'}</th>
                                    <th className="p-3 font-bold text-center">Acknowledged (Tick)</th>
                                    <th className="p-3 font-bold">Agent Reply</th>
                                    <th className="p-3 font-bold text-center">Status</th>
                                </tr>
                            </thead>
                            <tbody className="divide-y">
                                {rows.map((row, idx) => (
                                    <tr key={idx} className="hover:bg-slate-50">
                                        <td className="p-3">{DataEngine.formatDate(row[dateKey] || row.Date)}</td>
                                        <td className="p-3 max-w-md">{row[feedbackKey] || row['Feedback'] || ''}</td>
                                        <td className="p-3 text-center">
                                            <StatusBadge status={row._isAck ? 'Yes' : 'No'} />
                                        </td>
                                        <td className="p-3 max-w-md">{row[justificationKey] || <span className="text-slate-500 italic">Empty</span>}</td>
                                        <td className="p-3 text-center">
                                            <StatusBadge status={row._status || 'Unknown'} />
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </TableContainer>
                </Modal>
            );
        };


        const WhatsAppChat = ({ data, agentName, title, onClose }) => {
            const [searchTerm, setSearchTerm] = useState("");


            const messages = useMemo(() => {
                if (!data || !Array.isArray(data)) return [];
                const msgs = [];


                data.forEach(row => {
                    if (row['Transcript'] || row['Chat Log']) {
                        const transcript = row['Transcript'] || row['Chat Log'];
                        const lines = transcript.split('\n');
                        lines.forEach(line => {
                            const [author, ...content] = line.split(':');
                            if (content.length > 0) {
                                const text = content.join(':').trim();
                                const isAgent = author.toLowerCase().includes('agent') || author.toLowerCase().includes(agentName?.toLowerCase());
                                msgs.push({
                                    id: Math.random().toString(36),
                                    sender: isAgent ? 'agent' : 'customer',
                                    author: author.trim(),
                                    text: text,
                                    timestamp: row['Date'] ? new Date(row['Date']) : new Date(),
                                    meta: row
                                });
                            }
                        });
                    } else if (row['Comments'] || row['Comment'] || row['Remediation Feedback']) {
                        const text = row['Comments'] || row['Comment'] || row['Remediation Feedback'];
                        if (text) {
                            msgs.push({
                                id: row.id || Math.random().toString(36),
                                sender: 'customer',
                                author: 'Customer',
                                text: text,
                                timestamp: row['Date'] ? new Date(row['Date']) : new Date(),
                                rating: row['Rating'],
                                meta: row
                            });


                            if (row['Agent Ack.'] && row['Agent Ack.'] !== 'FALSE') {
                                msgs.push({
                                    id: Math.random().toString(36) + '_ack',
                                    sender: 'agent',
                                    author: agentName || 'Agent',
                                    text: `(Acknowledged) ${row['Agent Ack.'] === 'TRUE' ? '' : row['Agent Ack.']}`,
                                    timestamp: row['Date'] ? new Date(row['Date']) : new Date(),
                                    meta: row
                                });
                            }
                        }
                    }
                });


                return msgs.sort((a, b) => a.timestamp - b.timestamp);
            }, [data, agentName]);


            const filteredMessages = messages.filter(m => m.text.toLowerCase().includes(searchTerm.toLowerCase()));


            return (
                <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black/50 backdrop-blur-sm p-4">
                    <div className="bg-white w-full max-w-lg h-[85vh] rounded-3xl shadow-2xl overflow-hidden flex flex-col font-sans border-t-8 border-[#008069]">
                        <div className="bg-[#008069] p-4 flex items-center gap-3 text-white shadow-md shrink-0">
                            <button onClick={onClose} className="hover:bg-white/80 backdrop-blur-md p-1.5 rounded-full transition-colors"><ArrowLeft size={24} /></button>
                            <div className="w-10 h-10 bg-white/20 rounded-full flex items-center justify-center relative">
                                <User size={24} className="text-white" />
                            </div>
                            <div className="flex-1 min-w-0">
                                <h3 className="font-bold text-lg truncate leading-tight">{title || agentName || "Chat History"}</h3>
                                <p className="text-xs text-white/80 truncate">Online | {messages.length} messages</p>
                            </div>
                            <div className="flex gap-1">
                                <button className="hover:bg-white/80 backdrop-blur-md p-2 rounded-full"><Phone size={20} /></button>
                                <button className="hover:bg-white/80 backdrop-blur-md p-2 rounded-full"><Video size={20} /></button>
                            </div>
                        </div>


                        <div className="bg-white p-3 border-b border-slate-100 z-10 shadow-sm">
                            <div className="bg-slate-100/80 rounded-full px-4 py-2 flex items-center gap-2 border border-slate-200 focus-within:bg-white focus-within:border-emerald-500 focus-within:ring-2 focus-within:ring-emerald-100 transition-all">
                                <Search size={16} className="text-slate-500" />
                                <input
                                    type="text"
                                    placeholder="Search in conversation..."
                                    className="bg-transparent border-none outline-none text-sm w-full placeholder:text-slate-500 text-slate-700"
                                    value={searchTerm}
                                    onChange={(e) => setSearchTerm(e.target.value)}
                                />
                            </div>
                        </div>


                        <div className="flex-1 overflow-y-auto p-4 space-y-4 bg-[#efeae2] custom-scrollbar scroll-smooth" style={{ backgroundImage: 'url("https://user-images.githubusercontent.com/15075759/28719144-86dc0f70-73b1-11e7-911d-60d70fcded21.png")', backgroundBlendMode: 'soft-light' }}>
                            {filteredMessages.map(msg => (
                                <div key={msg.id} className={`flex ${msg.sender === 'agent' ? 'justify-end' : 'justify-start'} group`}>
                                    <div className={`max-w-[85%] rounded-2xl p-3 text-sm relative shadow-sm transition-all hover:shadow-md ${msg.sender === 'agent' ? 'bg-[#d9fdd3] rounded-tr-none' : 'bg-white rounded-tl-none'}`}>
                                        <div className={`text-[11px] font-bold mb-1 ${msg.sender === 'agent' ? 'text-emerald-700' : 'text-slate-600'}`}>
                                            {msg.sender === 'agent' ? 'You' : msg.author}
                                        </div>
                                        <div className="text-slate-800 whitespace-pre-wrap leading-relaxed select-text">
                                            {msg.text}
                                        </div>
                                        {msg.rating && (
                                            <div className="mt-2 pt-2 border-t border-black/5 flex gap-1 items-center">
                                                <span className="text-[10px] text-slate-500 font-medium">Rating:</span>
                                                <div className="flex">
                                                    {Array.from({ length: 5 }).map((_, i) => (
                                                        <Star key={i} size={10} className={i < (msg.rating === 'WOW' ? 5 : (msg.rating === 'Great' ? 4 : (msg.rating === 'Good' ? 3 : 1))) ? "fill-amber-400 text-amber-400" : "text-slate-200"} />
                                                    ))}
                                                </div>
                                            </div>
                                        )}
                                        <div className="text-[10px] text-slate-500 text-right mt-1.5 flex items-center justify-end gap-1 opacity-80 group-hover:opacity-100 transition-opacity">
                                            {msg.timestamp.toLocaleDateString([], { month: 'short', day: 'numeric' })} {msg.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                                            {msg.sender === 'agent' && <CheckCheck size={12} className="text-blue-500" />}
                                        </div>
                                    </div>
                                </div>
                            ))}


                            {filteredMessages.length === 0 && (
                                <div className="text-center py-12 opacity-60">
                                    <div className="inline-block p-4 bg-slate-100 rounded-full mb-3"><MessageSquare size={24} className="text-slate-500" /></div>
                                    <p className="text-slate-500 text-sm">No messages found based on current data.</p>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };


        const AIWhatsAppAssistant = ({ npsData, qcData, activeFilteredData, currentView, activeTab, filters, setFilters, setView, setActiveTab, aiTrigger, setAiTrigger, context, selectedAgent }) => {
            const [isOpen, setIsOpen] = useState(false);
            const [isExpanded, setIsExpanded] = useState(false); // EXPANDABLE VIEW STATE
            const [input, setInput] = useState('');
            const [messages, setMessages] = useState(() => {
                try {
                    // Sandbox: localStorage blocked
                    const saved = null; // localStorage.getItem('poppy_whatsapp_chat_v2');
                    return saved ? JSON.parse(saved) : [{
                        id: 1,
                        role: 'assistant',
                        blocks: [{ type: 'text', content: "Hello! I'm Poppy AI. I can analyze your Data, generate charts, or help with coaching plans. How can I assist you today?" }],
                        timestamp: new Date()
                    }];
                } catch (e) { return []; }
            });
            const [isTyping, setIsTyping] = useState(false);
            const messagesEndRef = useRef(null);
            const [searchTerm, setSearchTerm] = useState('');


            useEffect(() => {
                // Sandbox: localStorage blocked
                // localStorage.setItem('poppy_whatsapp_chat_v2', JSON.stringify(messages));
            }, [messages]);


            useEffect(() => {
                if (aiTrigger && aiTrigger.open) {
                    setIsOpen(true);
                    if (aiTrigger.query) {
                        handleSend(null, aiTrigger.query);
                    }
                    if (setAiTrigger) setAiTrigger({ open: false, query: '' });
                }
            }, [aiTrigger]);


            useEffect(() => {
                if (isOpen) messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            }, [messages, isTyping, isOpen]);


            const handleClose = () => setIsOpen(false);


            const clearHistory = () => {
                setMessages([{
                    id: Date.now(),
                    role: 'assistant',
                    blocks: [{ type: 'text', content: "History cleared." }],
                    timestamp: new Date()
                }]);
                // Sandbox: localStorage blocked
                // localStorage.removeItem('poppy_whatsapp_chat_v2');
            };

            // Execute action steps for agentic behavior
            const executeStep = async (step, context) => {
                const { action, params } = step;
                
                try {
                    switch (action) {
                        case 'analyze_data':
                            // Analyze current data
                            const dataToAnalyze = activeFilteredData || [];
                            const analysis = {
                                total: dataToAnalyze.length,
                                summary: dataToAnalyze.slice(0, 10).map(r => ({
                                    agent: r.Agent || r['Agent Email'],
                                    score: r.Rating || r['QC Score'],
                                    issue: r['User Problem'] || r.Question
                                }))
                            };
                            return { type: 'data', data: analysis };
                        
                        case 'generate_chart':
                            // Generate chart data
                            const chartData = [];
                            const dataForChart = activeFilteredData || [];
                            
                            if (params.groupBy === 'agent') {
                                const agentGroups = {};
                                dataForChart.forEach(row => {
                                    const agent = row.Agent || row['Agent Email'] || 'Unknown';
                                    agentGroups[agent] = (agentGroups[agent] || 0) + 1;
                                });
                                Object.entries(agentGroups).slice(0, 10).forEach(([agent, count]) => {
                                    chartData.push({ name: agent, value: count });
                                });
                            } else if (params.groupBy === 'rating') {
                                const ratingGroups = {};
                                dataForChart.forEach(row => {
                                    const rating = row.Rating || 'Unknown';
                                    ratingGroups[rating] = (ratingGroups[rating] || 0) + 1;
                                });
                                Object.entries(ratingGroups).forEach(([rating, count]) => {
                                    chartData.push({ name: rating, value: count });
                                });
                            }
                            
                            return {
                                type: 'chart',
                                chartType: params.chartType || 'bar',
                                data: chartData
                            };
                        
                        case 'generate_table':
                            // Generate table data
                            const tableData = (activeFilteredData || []).slice(0, params.limit || 10);
                            const headers = params.columns || Object.keys(tableData[0] || {}).slice(0, 5);
                            const rows = tableData.map(row => headers.map(h => row[h] || '-'));
                            
                            return {
                                type: 'table',
                                headers: headers,
                                rows: rows
                            };
                        
                        case 'filter_data':
                            // Apply filters
                            if (params.filterType && params.filterValue) {
                                setFilters(prev => ({
                                    ...prev,
                                    [params.filterType]: params.filterValue
                                }));
                            }
                            return { type: 'action', success: true, message: 'Filters applied' };
                        
                        case 'switch_view':
                            // Change view
                            if (params.view) {
                                setView(params.view);
                            }
                            return { type: 'action', success: true, message: `Switched to ${params.view} view` };
                        
                        case 'export_data':
                            // Export or capture
                            setTimeout(() => {
                                ExportEngine.capturePage('root', `Poppy_Export_${Date.now()}`);
                            }, 500);
                            return { type: 'action', success: true, message: 'Export started' };
                        
                        case 'generate_prediction':
                            // Generate performance prediction
                            const hasData = activeFilteredData && activeFilteredData.length > 0;
                            const predResult = AIContentEngine.generatePrediction(
                                params.query || 'Predict performance',
                                activeFilteredData,
                                hasData,
                                { domain: currentView, agent: params.agent }
                            );
                            return { 
                                type: 'text', 
                                content: predResult.content,
                                meta: { contentType: 'prediction' }
                            };
                        
                        default:
                            return { type: 'error', message: 'Unknown action' };
                    }
                } catch (error) {
                    return { type: 'error', message: error.message };
                }
            };


            const handleSend = async (e, overrideText) => {
                if (e && e.preventDefault) e.preventDefault();
                const text = overrideText || input;
                if (!text || !text.trim()) return;


                const userMsg = {
                    id: Date.now(),
                    role: 'user',
                    blocks: [{ type: 'text', content: text }],
                    timestamp: new Date()
                };
                setMessages(prev => [...prev, userMsg]);
                setInput("");
                setIsTyping(true);


                // --- QUICK AUTOMATION INTENTS ---
                const lower = text.toLowerCase();
                if (lower.match(/(export|download|save|capture).*(pdf|image|screenshot)/)) {
                    setTimeout(async () => {
                        try {
                            await ExportEngine.capturePage('root', `Poppy_Export_${new Date().toISOString().slice(0, 10)}`);
                            setMessages(prev => [...prev, { id: Date.now(), role: 'assistant', blocks: [{ type: 'text', content: "? Page capture started." }], timestamp: new Date() }]);
                        } catch (err) {
                            setMessages(prev => [...prev, { id: Date.now(), role: 'assistant', blocks: [{ type: 'text', content: "? Export failed. Please try again." }], timestamp: new Date() }]);
                        } finally {
                            setIsTyping(false);
                        }
                    }, 500);
                    return;
                }


                // --- AGENTIC AI GENERATION WITH PLANNING ---
                // Calculate safe data count
                const dataCount = (activeFilteredData && activeFilteredData.length) || (npsData.length + qcData.length) || 0;


                const currentCtx = {
                    view: currentView || 'Start',
                    tab: activeTab || 'Overview',
                    dataSummary: `Rows: ${dataCount}`,
                    filters: filters || {},
                    selectedAgent: selectedAgent || 'None'
                };


                try {
                    // PHASE 1: Planning - Analyze user intent and create execution plan
                    const planningPrompt = `You are Poppy AI's planning engine.

User Query: "${text}"

Current Context:
- View: ${currentCtx.view}
- Tab: ${currentCtx.tab}
- Available Data: ${currentCtx.dataSummary}
- Selected Agent: ${currentCtx.selectedAgent}
- Filters: ${JSON.stringify(currentCtx.filters)}

Your task: Analyze the query and create an execution plan.

Output ONLY valid JSON in this exact format:
{
  "needsClarification": true/false,
  "clarificationQuestion": "question if needed",
  "steps": [
    {
      "action": "analyze_data|generate_chart|generate_table|filter_data|switch_view|export_data",
      "description": "what this step does",
      "params": {"key": "value"}
    }
  ],
  "expectedOutput": "text|chart|table|mixed"
}

Available actions:
- analyze_data: Analyze data and provide insights
- generate_chart: Create a chart visualization (params: {groupBy: "agent"|"rating", chartType: "bar"|"line"})
- generate_table: Create a data table (params: {columns: [...], limit: number})
- filter_data: Apply filters to data (params: {filterType: string, filterValue: string})
- switch_view: Change dashboard view (params: {view: "nps"|"qc"|"unified"})
- export_data: Export data or capture page

Rules:
- If query is ambiguous (e.g., "show agent performance" when no agent selected), set needsClarification=true
- If asking about specific agent but none selected, ask which agent
- Break complex requests into multiple steps
- Be specific about parameters needed
- Choose appropriate output format based on request
- For chart requests, determine groupBy and chartType
- For table requests, specify which columns to show`;

                    const planResponse = await GeminiAI.generate(planningPrompt);
                    let plan;
                    
                    try {
                        plan = JSON.parse(planResponse.replace(/```json|```/g, '').trim());
                    } catch (parseError) {
                        // If JSON parsing fails, fall back to simple response
                        const aiMsg = {
                            id: Date.now() + 1,
                            role: 'assistant',
                            blocks: [{ type: 'text', content: planResponse }],
                            timestamp: new Date()
                        };
                        setMessages(prev => [...prev, aiMsg]);
                        setIsTyping(false);
                        return;
                    }
                    
                    // PHASE 2: Check if clarification needed
                    if (plan.needsClarification) {
                        const clarMsg = {
                            id: Date.now() + 1,
                            role: 'assistant',
                            blocks: [{ 
                                type: 'text', 
                                content: plan.clarificationQuestion || "Could you provide more details to help me better?"
                            }],
                            timestamp: new Date()
                        };
                        setMessages(prev => [...prev, clarMsg]);
                        setIsTyping(false);
                        return;
                    }
                    
                    // PHASE 3: Execute plan steps
                    const results = [];
                    if (plan.steps && plan.steps.length > 0) {
                        for (const step of plan.steps) {
                            const result = await executeStep(step, currentCtx);
                            results.push(result);
                        }
                    }
                    
                    // PHASE 4: Generate final response based on results
                    const finalPrompt = `You are Poppy AI, presenting results to the user.

User asked: "${text}"
Execution results: ${JSON.stringify(results).slice(0, 2000)}
Context: ${JSON.stringify(currentCtx)}

Create a friendly, professional response that:
1. Summarizes what you did
2. Presents key findings from the data
3. Uses emojis appropriately (1-3 total)
4. Is concise but informative
5. If charts/tables were generated, mention they're shown below

Format in Markdown. Be conversational and helpful.`;

                    const finalResponse = await GeminiAI.generate(finalPrompt);
                    
                    // PHASE 5: Build message blocks (text + charts/tables if any)
                    const { text: processedText, sideEffects } = SuperAgentSystem.parseStructuredResponse(finalResponse);
                    const blocks = [{ type: 'text', content: processedText }];
                    
                    // Add charts if generated
                    results.forEach(result => {
                        if (result.type === 'chart' && result.data && result.data.length > 0) {
                            blocks.push({
                                type: 'chart',
                                chartData: result.data,
                                chartType: result.chartType
                            });
                        }
                        if (result.type === 'table' && result.rows && result.rows.length > 0) {
                            blocks.push({
                                type: 'table',
                                headers: result.headers,
                                rows: result.rows
                            });
                        }
                    });
                    
                    const aiMsg = {
                        id: Date.now() + 1,
                        role: 'assistant',
                        blocks: blocks,
                        timestamp: new Date()
                    };
                    setMessages(prev => [...prev, aiMsg]);
                    
                    // Trigger side effects for embedded charts/tables
                    if (sideEffects && sideEffects.length > 0) {
                        setTimeout(() => {
                            sideEffects.forEach(effect => {
                                try { effect(); } catch (e) { console.error("Side effect error:", e); }
                            });
                        }, 100);
                    }
                    
                } catch (e) {
                    console.error("Poppy AI Error:", e);
                    setMessages(prev => [...prev, { 
                        id: Date.now() + 1, 
                        role: 'assistant', 
                        blocks: [{ type: 'text', content: "I encountered an error processing your request. Could you try rephrasing it?" }], 
                        timestamp: new Date() 
                    }]);
                } finally {
                    setIsTyping(false);
                }
            };


            // Task 8: Handle Tool Submit
            const handleToolSubmit = (toolId, data) => {
                setActiveTool(null);
                if (PromptBuilder.templates[toolId]) {
                    const prompt = PromptBuilder.templates[toolId].construct(data);
                    handleSubmit(null, prompt);
                }
            };

            const filteredMessages = messages.filter(m => {
                if (!searchTerm) return true;
                const content = m.blocks?.map(b => b.content).join(' ') || '';
                return content.toLowerCase().includes(searchTerm.toLowerCase());
            });


            return (
                <>
                    <ToolModal 
                        isOpen={!!activeTool} 
                        toolId={activeTool} 
                        onClose={() => setActiveTool(null)} 
                        onSubmit={handleToolSubmit} 
                    />
                    {!isOpen && (
                        <button
                            onClick={() => setIsOpen(true)}
                            className="fixed bottom-6 right-6 z-[70] w-16 h-16 rounded-full shadow-2xl flex items-center justify-center transition-all duration-300 ease-in-out hover:scale-110 active:scale-95 bg-[#008069]"
                            title="Open WhatsApp AI"
                        >
                            <MessageCircle size={28} className="text-white" />
                        </button>
                    )}
                    {isOpen && (
                        <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black/50 backdrop-blur-sm p-4 animate-in fade-in duration-200">
                            <div className={`bg-white w-full ${isExpanded ? 'max-w-7xl' : 'max-w-2xl'} h-[85vh] rounded-3xl shadow-2xl overflow-hidden flex flex-col font-sans border-t-8 border-[#008069] transition-all duration-300`}>
                                {/* Header */}
                                <div className="bg-[#008069] p-4 flex items-center gap-3 text-white shadow-md shrink-0">
                                    <button onClick={handleClose} className="hover:bg-white/80 backdrop-blur-md p-1.5 rounded-full transition-colors"><ArrowLeft size={24} /></button>
                                    <div className="w-10 h-10 bg-white/20 rounded-full flex items-center justify-center relative"><BrainCircuit size={22} className="text-white" /></div>
                                    <div className="flex-1 min-w-0">
                                        <h3 className="font-bold text-lg truncate leading-tight">Poppy AI Assistant</h3>
                                        <p className="text-xs text-white/80 truncate">{isTyping ? 'Typing...' : 'Online'}</p>
                                    </div>
                                    <button onClick={() => setIsExpanded(!isExpanded)} className="hover:bg-white/80 backdrop-blur-md p-2 rounded-full hidden md:block" title={isExpanded ? "Collapse" : "Expand"}>
                                        {isExpanded ? <Minimize2 size={20} /> : <Maximize2 size={20} />}
                                    </button>
                                    <button onClick={clearHistory} className="hover:bg-white/80 backdrop-blur-md p-2 rounded-full" title="Clear Chat"><Trash2 size={20} /></button>
                                </div>


                                {/* Messages */}
                                <div className="flex-1 overflow-y-auto p-4 space-y-4 bg-[#efeae2] custom-scrollbar scroll-smooth" style={{ backgroundImage: 'url("https://user-images.githubusercontent.com/15075759/28719144-86dc0f70-73b1-11e7-911d-60d70fcded21.png")', backgroundBlendMode: 'soft-light' }}>
                                    {filteredMessages.map((msg, idx) => (
                                        <div key={idx} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'} group mb-4`}>
                                            <div className={`max-w-[85%] rounded-2xl p-3 text-sm relative shadow-sm transition-all hover:shadow-md ${msg.role === 'user' ? 'bg-[#d9fdd3] rounded-tr-none' : 'bg-white rounded-tl-none'}`}>
                                                <div className={`text-[11px] font-bold mb-1 ${msg.role === 'user' ? 'text-emerald-700' : 'text-slate-600'}`}>{msg.role === 'user' ? 'You' : 'Poppy AI'}</div>
                                                {msg.blocks && msg.blocks.map((b, bi) => {
                                                    if (b.type === 'text') {
                                                        return (
                                                            <div key={bi} className="text-slate-800 whitespace-pre-wrap leading-relaxed select-text markdown-content" dangerouslySetInnerHTML={{ __html: safeMarked(b.content || '') }} />
                                                        );
                                                    }
                                                    
                                                    if (b.type === 'chart' && b.chartData && b.chartData.length > 0) {
                                                        return (
                                                            <div key={bi} className="mt-4 bg-white p-4 rounded-xl border border-slate-200">
                                                                <ResponsiveContainer width="100%" height={250}>
                                                                    {b.chartType === 'bar' ? (
                                                                        <BarChart data={b.chartData}>
                                                                            <CartesianGrid strokeDasharray="3 3" stroke="#e2e8f0" />
                                                                            <XAxis dataKey="name" tick={{ fontSize: 10 }} />
                                                                            <YAxis tick={{ fontSize: 10 }} />
                                                                            <Tooltip />
                                                                            <Bar dataKey="value" fill="#3b82f6" radius={[8, 8, 0, 0]} />
                                                                        </BarChart>
                                                                    ) : (
                                                                        <LineChart data={b.chartData}>
                                                                            <CartesianGrid strokeDasharray="3 3" stroke="#e2e8f0" />
                                                                            <XAxis dataKey="name" tick={{ fontSize: 10 }} />
                                                                            <YAxis tick={{ fontSize: 10 }} />
                                                                            <Tooltip />
                                                                            <Line type="monotone" dataKey="value" stroke="#3b82f6" strokeWidth={2} dot={{ r: 4 }} />
                                                                        </LineChart>
                                                                    )}
                                                                </ResponsiveContainer>
                                                            </div>
                                                        );
                                                    }
                                                    
                                                    if (b.type === 'table' && b.rows && b.rows.length > 0) {
                                                        return (
                                                            <div key={bi} className="mt-4 overflow-x-auto">
                                                                <table className="w-full text-xs bg-white rounded-lg overflow-hidden border border-slate-200">
                                                                    <thead className="bg-slate-100">
                                                                        <tr>
                                                                            {b.headers.map((h, i) => (
                                                                                <th key={i} className="p-2 text-left font-bold text-slate-700">{h}</th>
                                                                            ))}
                                                                        </tr>
                                                                    </thead>
                                                                    <tbody>
                                                                        {b.rows.map((row, i) => (
                                                                            <tr key={i} className="border-b border-slate-100 hover:bg-slate-50">
                                                                                {row.map((cell, j) => (
                                                                                    <td key={j} className="p-2 text-slate-600">{cell}</td>
                                                                                ))}
                                                                            </tr>
                                                                        ))}
                                                                    </tbody>
                                                                </table>
                                                            </div>
                                                        );
                                                    }
                                                    
                                                    return null;
                                                })}
                                                <div className="text-[10px] text-slate-500 text-right mt-1.5">{new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
                                            </div>
                                        </div>
                                    ))}
                                    <div ref={messagesEndRef} />
                                </div>


                                {/* Input */}
                                <form onSubmit={(e) => handleSend(e)} className="bg-[#f0f2f5] p-3 flex items-center gap-2 border-t border-black/5">
                                    <input
                                        type="text"
                                        className="flex-1 bg-white rounded-full px-4 py-2 text-sm border border-slate-200 outline-none focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500"
                                        placeholder="Type a message..."
                                        value={input}
                                        onChange={(e) => setInput(e.target.value)}
                                    />
                                    <button type="submit" disabled={isTyping || !input.trim()} className="w-9 h-9 rounded-full flex items-center justify-center bg-[#008069] text-white disabled:opacity-50 transition-all active:scale-95">
                                        <Send size={18} className={isTyping ? "animate-pulse" : ""} />
                                    </button>
                                </form>
                            </div>
                        </div>
                    )}
                </>
            );
        };


        const VirtualTable = ({ rows, visibleColumns, rowHeight = 56 }) => {
            const [scrollTop, setScrollTop] = useState(0);
            const containerRef = useRef(null);


            const totalHeight = rows.length * rowHeight;
            const containerHeight = 600;
            const startIndex = Math.floor(scrollTop / rowHeight);
            const visibleCount = Math.ceil(containerHeight / rowHeight);
            const endIndex = Math.min(rows.length, startIndex + visibleCount + 5);
            const visibleRows = rows.slice(startIndex, endIndex);
            const offsetY = startIndex * rowHeight;


            return (
                <div
                    ref={containerRef}
                    className="overflow-auto relative -mx-6"
                    style={{ height: containerHeight }}
                    onScroll={(e) => setScrollTop(e.target.scrollTop)}
                >
                    <div style={{ height: totalHeight, position: 'relative' }}>
                        <table className="w-full text-sm text-left border-collapse absolute top-0 left-0" style={{ transform: `translateY(${offsetY}px)` }}>
                            <thead>
                                <tr className="bg-slate-50 border-b border-slate-200 sticky top-0 z-10" style={{ transform: `translateY(${-offsetY}px)` }}>
                                    {visibleColumns.metric && <th className="p-4 text-left font-semibold text-slate-600 bg-slate-50">Metric</th>}
                                    {visibleColumns.pass && <th className="p-4 text-left font-semibold text-slate-600 bg-slate-50">Pass</th>}
                                    {visibleColumns.fail && <th className="p-4 text-left font-semibold text-slate-600 bg-slate-50">Fail</th>}
                                    {visibleColumns.rate && <th className="p-4 text-left font-semibold text-slate-600 bg-slate-50">Fail Rate %</th>}
                                </tr>
                            </thead>
                            <tbody>
                                {visibleRows.map((row, idx) => (
                                    <tr key={startIndex + idx} className="border-b border-slate-100 hover:bg-slate-50 transition-colors h-[56px]">
                                        {visibleColumns.metric && <td className="p-4 font-bold text-slate-700 truncate max-w-xs" title={row.metric}>{row.metric}</td>}
                                        {visibleColumns.pass && <td className="p-4 text-slate-600">{row.pass}</td>}
                                        {visibleColumns.fail && <td className="p-4 text-slate-600">{row.fail}</td>}
                                        {visibleColumns.rate && <td className="p-4 text-slate-600">{row.total > 0 ? `${row.rate.toFixed(1)}%` : ''}</td>}
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                </div>
            );
        };


        const DetailedScorecardTable = ({ title, data, type, onDownloadImage, tableId, infoText, dataForAI, aiType, columnFilter, onExpand, askAI, npsData, qcData }) => {
            // ALL HOOKS MUST BE CALLED FIRST - before any conditional logic or early returns
            const isNPS = type === 'NPS';
            const [visibleColumns, setVisibleColumns] = useState({
                metric: true,
                pass: isNPS,
                fail: true,
                total: true,
                rate: true
            });
            const toggleColumn = (key) => setVisibleColumns(prev => ({ ...prev, [key]: !prev[key] }));

            const sourceData = useMemo(() => {
                if (type === 'Unified' && npsData && qcData) {
                    const normalize = (source, label) => {
                        if (!source) return [];
                        if (Array.isArray(source)) {
                            return source.map((row) => {
                                const metricName = row.metric || row.name || row.Agent || row.Metric || 'Unknown';
                                const pass = typeof row.pass === 'number' ? row.pass : (typeof row.Pass === 'number' ? row.Pass : 0);
                                const fail = typeof row.fail === 'number' ? row.fail : (typeof row.Fail === 'number' ? row.Fail : 0);
                                return { metric: `[${label}] ${metricName}`, pass, fail };
                            });
                        }
                        return Object.entries(source).map(([metricName, stats]) => {
                            const pass = stats && typeof stats.pass === 'number' ? stats.pass : 0;
                            const fail = stats && typeof stats.fail === 'number' ? stats.fail : 0;
                            return { metric: `[${label}] ${metricName}`, pass, fail };
                        });
                    };
                    return [...normalize(npsData, 'NPS'), ...normalize(qcData, 'QC')];
                }
                if (data) return data;
                if (type === 'NPS' && npsData) return npsData;
                if (type === 'QC' && qcData) return qcData;
                return data;
            }, [type, data, npsData, qcData]);

            const tableArray = useMemo(() => {
                if (Array.isArray(sourceData)) {
                    return sourceData.map(row => {
                        const metricName = row.metric || row.name || row.Agent || row.Metric || 'Unknown';
                        const pass = typeof row.pass === 'number' ? row.pass : (typeof row.Pass === 'number' ? row.Pass : 0);
                        const fail = typeof row.fail === 'number' ? row.fail : (typeof row.Fail === 'number' ? row.Fail : 0);
                        const total = pass + fail;
                        const rate = total > 0 ? (fail / total) * 100 : 0;
                        return { metric: metricName, pass, fail, total, rate };
                    });
                }
                if (sourceData && typeof sourceData === 'object') {
                    return Object.entries(sourceData).map(([metricName, stats]) => {
                        const pass = stats && typeof stats.pass === 'number' ? stats.pass : 0;
                        const fail = stats && typeof stats.fail === 'number' ? stats.fail : 0;
                        const total = pass + fail || fail;
                        const rate = total > 0 ? (fail / total) * 100 : 0;
                        return { metric: metricName, pass, fail, total, rate };
                    });
                }
                return [];
            }, [sourceData]);

            const { data: sorted, toggleSort, sortKey, direction, setColumnFilter, filters } = useSortableTable(tableArray, 'fail');
            const rows = sorted;

            // NOW we can check for empty data and return early (after all hooks have been called)
            const isArray = Array.isArray(sourceData);
            const hasNoData = !sourceData || (isArray && sourceData.length === 0) || (!isArray && Object.keys(sourceData).length === 0);
            
            if (hasNoData) {
                return (
                    <Card title={title} onDownloadImage={onDownloadImage} chartId={tableId} infoText={infoText} onExpand={onExpand} askAI={askAI}>
                        <div className="text-center py-8 text-slate-500 italic">No data available</div>
                    </Card>
                );
            }


            const getExportData = () => {
                return rows.map(d => {
                    const row = { Metric: d.metric };
                    if (visibleColumns.pass) row.Pass = d.pass;
                    if (visibleColumns.fail) row.Fail = d.fail;
                    if (visibleColumns.rate) row['Fail Rate %'] = d.total > 0 ? parseFloat((d.rate).toFixed(1)) : 0;
                    return row;
                });
            };


            const toolbarControls = (
                <div className="flex items-center gap-2">
                    <TableColumnMenu
                        visibleColumns={visibleColumns}
                        toggleColumn={toggleColumn}
                        labels={{ metric: 'Metric', pass: 'Pass', fail: 'Fail', total: 'Total', rate: 'Fail Rate %' }}
                    />
                    {columnFilter}
                </div>
            );


            return (
                <Card
                    title={title}
                    onDownloadImage={onDownloadImage}
                    id={tableId}
                    infoText={infoText || `Detailed ${type} performance breakdown across all evaluated metrics.`}
                    dataForAI={dataForAI || data}
                    aiType={aiType || type}
                    type="Table"
                    onExpand={onExpand}
                    onDownloadCSV={() => ExportEngine.exportCSV(getExportData(), `${type.toLowerCase()}_scorecard`)}
                    onCopyTable={() => copyTableToClipboard(null, getExportData())}
                    columnFilter={toolbarControls}
                    askAI={askAI}
                >
                    {rows.length > 50 ? (
                        <VirtualTable rows={rows} visibleColumns={visibleColumns} rowHeight={56} />
                    ) : (
                        <div id={tableId} className="overflow-x-auto w-full">
                            <table className="w-full text-sm text-left border-collapse">
                                <thead>
                                    <tr className="bg-slate-50 border-b border-slate-200">
                                        {visibleColumns.metric && <SortableTableHeader column="metric" label="Metric" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['metric']} data={tableArray} className="p-4 text-left" />}
                                        {visibleColumns.pass && <SortableTableHeader column="pass" label="Pass" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['pass']} data={tableArray} className="p-2 text-center" />}
                                        {visibleColumns.fail && <SortableTableHeader column="fail" label="Fail" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['fail']} data={tableArray} className="p-2 text-center" />}
                                        {visibleColumns.total && <SortableTableHeader column="total" label="Total" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['total']} data={tableArray} className="p-2 text-center" />}
                                        {visibleColumns.rate && <SortableTableHeader column="rate" label="Fail Rate %" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['rate']} data={tableArray} className="p-2 text-center" />}
                                    </tr>
                                </thead>
                                <tbody>
                                    {rows.map((row, idx) => (
                                        <tr key={idx} className="border-b border-slate-100 hover:bg-slate-50 transition-colors">
                                            {visibleColumns.metric && <td className="p-2 font-bold text-slate-700">{row.metric}</td>}
                                            {visibleColumns.pass && <td className="p-4 text-center text-slate-600">{row.pass}</td>}
                                            {visibleColumns.fail && <td className="p-4 text-center text-slate-600">{row.fail}</td>}
                                            {visibleColumns.total && <td className="p-4 text-center text-slate-600 font-semibold">{row.total}</td>}
                                            {visibleColumns.rate && <td className="p-4 text-center text-slate-600 font-bold">{row.total > 0 ? `${row.rate.toFixed(1)}%` : ''}</td>}
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    )}
                </Card>
            );
        };


        const SmartTable = ({
            title,
            rows,
            columns,
            tableId,
            type = 'Table',
            infoText,
            askAI,
            dataForAI,
            aiType,
            onDownloadImage,
            onExpand,
            searchPlaceholder = 'Search...',
            getExportData
        }) => {
            const [query, setQuery] = useState('');
            const [visibleColumns, setVisibleColumns] = useState(() => {
                const initial = {};
                (columns || []).forEach(col => {
                    initial[col.key] = col.defaultVisible !== false;
                });
                return initial;
            });


            const toggleColumn = (key) => setVisibleColumns(prev => ({ ...prev, [key]: !prev[key] }));


            const filteredRows = useMemo(() => {
                if (!rows || rows.length === 0) return [];
                if (!query) return rows;
                const q = query.toLowerCase();
                return rows.filter(row =>
                    Object.values(row || {}).some(val =>
                        val !== null &&
                        val !== undefined &&
                        String(val).toLowerCase().includes(q)
                    )
                );
            }, [rows, query]);


            if (!rows || rows.length === 0) {
                return (
                    <Card title={title} onDownloadImage={onDownloadImage} chartId={tableId} infoText={infoText} onExpand={onExpand} askAI={askAI}>
                        <div className="text-center py-8 text-slate-500 italic">No data available</div>
                    </Card>
                );
            }


            const effectiveRows = filteredRows.length ? filteredRows : rows;
            const labels = (columns || []).reduce((acc, col) => {
                acc[col.key] = col.label || col.key;
                return acc;
            }, {});


            const exportRows = getExportData ? getExportData(effectiveRows) : effectiveRows;


            const toolbarControls = (
                <div className="flex items-center gap-2 w-full">
                    <div className="relative w-full max-w-xs">
                        <Search className="absolute left-3 top-2.5 text-slate-500" size={14} />
                        <input
                            value={query}
                            onChange={(e) => setQuery(e.target.value)}
                            placeholder={searchPlaceholder}
                            className="w-full pl-9 pr-3 py-1.5 text-xs bg-white border border-slate-200 rounded-xl outline-none focus:ring-2 focus:ring-blue-500"
                        />
                    </div>
                    <TableColumnMenu
                        visibleColumns={visibleColumns}
                        toggleColumn={toggleColumn}
                        labels={labels}
                    />
                </div>
            );


            const handleDownloadImage = () => {
                if (onDownloadImage) onDownloadImage(tableId, title);
                else downloadAsImage(tableId, title);
            };


            const handleCSV = () => {
                ExportEngine.exportCSV(exportRows, `${(tableId || title).toLowerCase().replace(/\s+/g, '_')}`);
            };


            const handleCopyTable = () => {
                if (exportRows && exportRows.length) {
                    copyTableToClipboard(null, exportRows);
                }
            };


            const handleAskAI = askAI
                ? () => askAI(`Analyze the table "${title}". Focus on patterns and weak areas.`)
                : null;


            return (
                <Card
                    title={title}
                    onDownloadImage={handleDownloadImage}
                    id={tableId}
                    infoText={infoText}
                    dataForAI={dataForAI || exportRows}
                    aiType={aiType || type}
                    type={type || "Table"}
                    onExpand={onExpand}
                    onDownloadCSV={handleCSV}
                    onCopyTable={handleCopyTable}
                    columnFilter={toolbarControls}
                    askAI={handleAskAI}
                >
                    <TableContainer rowCount={effectiveRows.length}>
                        <table className="w-full text-xs text-left border-collapse">
                            <thead className="bg-slate-50">
                                <tr className="border-b border-slate-200">
                                    {(columns || []).map(col => (
                                        visibleColumns[col.key] && (
                                            <th
                                                key={col.key}
                                                className={`p-3 font-semibold text-slate-600 ${col.headerClassName || ''}`}
                                            >
                                                {col.label || col.key}
                                            </th>
                                        )
                                    ))}
                                </tr>
                            </thead>
                            <tbody>
                                {effectiveRows.map((row, idx) => (
                                    <tr key={idx} className="border-b border-slate-100 hover:bg-slate-50 transition-colors">
                                        {(columns || []).map(col => (
                                            visibleColumns[col.key] && (
                                                <td
                                                    key={col.key}
                                                    className={`p-3 text-slate-600 ${col.cellClassName || ''}`}
                                                >
                                                    {col.render ? col.render(row) : row[col.key]}
                                                </td>
                                            )
                                        ))}
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </TableContainer>
                </Card>
            );
        };


        // AgentSelector - Reusable agent selector dropdown (matches Unified View style)
        const AgentSelector = ({ value, onChange, options, label = "Agent Selector", className = "", selectedAgent, action }) => {
            // Sort options alphabetically
            const sortedOptions = useMemo(() => {
                return [...options].filter(a => a && a.trim() !== '').sort((a, b) => a.localeCompare(b));
            }, [options]);


            return (
                <div className={`flex justify-between items-center glass-card p-6 rounded-2xl ${className}`} data-html2canvas-ignore="true">
                    <div className="flex items-center gap-4">
                        <div className="w-12 h-12 bg-gradient-to-tr from-indigo-500 to-purple-600 rounded-full flex items-center justify-center text-white font-bold text-xl">
                            {selectedAgent ? selectedAgent.charAt(0).toUpperCase() : '?'}
                        </div>
                        <div>
                            <h2 className="text-xl font-bold text-slate-900">{selectedAgent || 'Select Agent'}</h2>
                            <p className="text-xs text-slate-500 font-bold uppercase tracking-wider">{label}</p>
                        </div>
                    </div>
                    <div className="flex items-center gap-4">
                        <select
                            className="p-2 bg-slate-50 border border-slate-200 rounded-lg text-sm"
                            value={value}
                            onChange={onChange}
                        >
                            <option value="">-- Choose Agent --</option>
                            {sortedOptions.map(a => (
                                <option key={a} value={a}>{a}</option>
                            ))}
                        </select>
                        {action}
                    </div>
                </div>
            );
        };


        // TopIssuesList - Reusable top issues list with progress bars
        const TopIssuesList = ({ data, maxItems = 5, title, onDownloadImage, infoText, dataForAI, askAI, onExpand }) => {
            const [showValues, setShowValues] = useState(true);

            if (!data || data.length === 0) return null;


            const topItems = data.slice(0, maxItems);
            const totalCount = data.reduce((sum, [, count]) => sum + count, 0);


            return (
                <Card
                    title={title}
                    onDownloadImage={onDownloadImage}
                    infoText={infoText}
                    dataForAI={topItems}
                    askAI={askAI}
                    onExpand={onExpand}
                    type="List"
                    toggleValues={() => setShowValues(!showValues)}
                    showValues={showValues}
                    onCopyTable={() => copyTableToClipboard(null, topItems.map(i => ({ [title]: i[0], Count: i[1] })))}
                >
                    <div className="space-y-6 px-4">
                        {topItems.map(([item, count], idx) => (
                            <div key={idx}>
                                <div className="flex justify-between items-center mb-2">
                                    <span className="text-xs font-semibold text-slate-600 truncate pr-4">{item}</span>
                                    {showValues && <span className="text-xs font-bold text-rose-600 flex-shrink-0">{count}</span>}
                                </div>
                                <div className="w-full bg-slate-100 rounded-full h-2.5">
                                    <div className="bg-gradient-to-r from-rose-400 to-rose-500 h-2.5 rounded-full" style={{ width: `${totalCount > 0 ? (count / totalCount) * 100 : 0}%` }}></div>
                                </div>
                            </div>
                        ))}
                    </div>
                </Card>
            );
        };


        // KPICardGrid - Reusable KPI card grid component
        const KPICardGrid = ({ cards, columns = 6, className = "" }) => (
            <div className={`grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-${columns} gap-4 overflow-visible ${className}`}>
                {cards.map((card, idx) => (
                    <KPICard key={idx} {...card} />
                ))}
            </div>
        );


        // REMOVED: SlackMessageRenderer - All AI outputs now use AIOutputWrapper with built-in rendering


        // (AIOutputWrapper moved to standardized location ~line 6063)




        // --- UNIVERSAL AI FOOTER (Section 4) ---
        // --- UNIVERSAL AI FOOTER (Section 4) ---
        const UniversalAIFooter = ({ data, view, context, askAI, post, onChange }) => {
            const [versions, setVersions] = useState(post ? [post] : []);
            const [currentIndex, setCurrentIndex] = useState(0);
            const [mode, setMode] = useState('Executive');
            const [isRegenerating, setIsRegenerating] = useState(false);
            const [isLoading, setIsLoading] = useState(false);
            const [showOutput, setShowOutput] = useState(false);
            const outputRef = useRef(null);

            // Per-page isolation: Reset state when view/context changes
            useEffect(() => {
                if (post) {
                    setVersions([post]);
                    setCurrentIndex(0);
                    setShowOutput(true);
                } else {
                    setVersions([]);
                    setCurrentIndex(0);
                    setShowOutput(false);
                }
            }, [post, view, context]);

            const scrollToOutput = () => {
                setTimeout(() => {
                    outputRef.current?.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            };

            const addVersion = (text) => {
                setVersions(prev => [...prev, text]);
                setCurrentIndex(prev => prev + 1);
                if (onChange) onChange(text);
                setIsLoading(false);
                setIsRegenerating(false);
                setShowOutput(true);
                scrollToOutput();
            };

            const updateCurrentVersion = (text) => {
                setVersions(prev => {
                    const next = [...prev];
                    next[currentIndex] = text;
                    return next;
                });
                if (onChange) onChange(text);
            };

            const handleAnalysis = async (targetMode) => {
                setMode(targetMode);
                setShowOutput(true);
                setIsLoading(true);
                scrollToOutput();

                let analysisResult = ""; // Audit Fix: Renamed result to analysisResult to avoid ReferenceError (Issue #9)

                try {
                    // Audit Fix: Increased context limit from 50 to 500 rows
                    const sample = Array.isArray(data) ? data.slice(0, 500) : [];

                    if (targetMode === 'Executive') {
                        // Better metric calculation for AI context
                        const metrics = (() => {
                            try {
                                if (view === 'nps') {
                                    const ratings = sample.reduce((acc, r) => { const k = String(r.Rating || r.rating || 'Unknown'); acc[k] = (acc[k] || 0) + 1; return acc; }, {});
                                    const fails = sample.reduce((acc, r) => { const m = (r.mistakes && r.mistakes.Total) ? r.mistakes.Total : 0; acc.totalFails = (acc.totalFails || 0) + m; return acc; }, {});
                                    const topIssues = Object.entries(NPS_METRIC_MAPPING).reduce((acc, [pillar, ms]) => {
                                        ms.forEach(m => {
                                            const count = sample.filter(r => r[m] === false || String(r[m]).toUpperCase() === 'FAIL').length;
                                            if (count > 0) acc[m] = count;
                                        });
                                        return acc;
                                    }, {});
                                    return { ratings, totalFails: fails.totalFails || 0, topIssues };
                                } else if (view === 'qc') {
                                    const scores = sample.map(r => parseFloat(r['QC Score'] || r.qcScore || 0)).filter(v => !isNaN(v));
                                    const total = scores.length ? scores.reduce((a, b) => a + b, 0) : 0;
                                    const fails = sample.filter(r => r['Pass/Fail'] === 'Fail').length;
                                    return { totalScore: total, audits: scores.length, fails };
                                }
                                return { records: sample.length };
                            } catch { return { records: sample.length }; }
                        })();

                        // Extract qualitative context for better analysis
                        const qualitative = sample.slice(0, 50).map(r => r['User Problem'] || r['Summary'] || r['Reason'] || r['Action'] || '').filter(Boolean).join('; ');

                        const prompt = `${AI_PERSONA}
${TL_PERSONA_PROMPT}

Role: Senior Ops Lead. Task: Write a punchy Executive Summary for ${view.toUpperCase()} performance.

QUANTITATIVE DATA: ${JSON.stringify(metrics)}
QUALITATIVE SAMPLES: ${qualitative.slice(0, 2000)}

CRITICAL FORMAT:
1. ** Executive Summary: ${view.toUpperCase()} ** (Title wrapped in star emojis both sides, bold)

2. [Overview - AI Generated 2-3 sentences high-level]

3. **Key Metrics**
   - Concise bullet points
   - Most important numbers only
   - Comparative data if available

4. **Critical Findings**
   - Top 3 issues/opportunities
   - Use **Sub-metric names** and **Question keywords**
   - Data-backed

5. **Strategic Recommendations**
   - Action-oriented
   - Decision-support focus
   - Prioritized

6. [Closure - NOT A HEADING]
   - Forward-looking statement with emoji

STRICT RULES:
1. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.
2. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).
3. NO hashtags (#).
4. Use emojis sparingly (max 2 per line).
5. Do NOT use the word "Bold", "Underline", or "B" as text.
6. Do NOT bold emphasis words like "Always", "Never", "Note" inside descriptions.
7. NO Sign-off

Tone: Professional, direct, no fluff.`;

                        const rawResult = await AIRequestManager.generate(prompt);
                        analysisResult = formatSlackMessage(rawResult, 'General'); // Use General to avoid extra Slack formatting if just summary

                    } else {
                        // Slack Draft Mode
                        const prompt = `${AI_PERSONA}
${TL_PERSONA_PROMPT}

Write a Slack message to the team about ${view.toUpperCase()} results.
Title: "**Team Update: ${view.toUpperCase()} Performance**"
Data: ${JSON.stringify(sample.slice(0, 20))}... (truncated for brevity)
Mood: Motivating but accountability-focused.

STRICT RULES:
1. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.
2. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).
3. NO hashtags (#).
4. Use emojis sparingly (max 2 per line).
5. Do NOT use the word "Bold", "Underline", or "B" as text.
6. Do NOT bold emphasis words like "Always", "Never", "Note" inside descriptions.`;
                        analysisResult = await AIRequestManager.generate(prompt);
                    }

                    // Audit Fix: result is now accessible here
                    addVersion(analysisResult);

                } catch (e) {
                    console.error(e);
                    addVersion(" Analysis failed. Please try again.");
                }
            };

            return (
                <div className="mt-16 no-export" data-html2canvas-ignore="true">
                    <div className="h-px bg-slate-200 w-full mb-8"></div>
                    <div className="grid grid-cols-1 md:grid-cols-3 items-center gap-6 py-6 px-10 bg-white shadow-[0_20px_50px_rgba(0,0,0,0.08)] rounded-[2.5rem] border border-slate-100 transition-all hover:shadow-[0_25px_60px_rgba(0,0,0,0.12)]">
                        <div className="flex justify-start order-2 md:order-1">
                            <button
                                onClick={() => handleAnalysis('Executive')}
                                disabled={isLoading}
                                className="flex items-center gap-3 px-6 py-3 bg-slate-900 hover:bg-black text-white rounded-2xl text-[10px] font-black uppercase tracking-[0.15em] shadow-xl transition-all active:scale-95 group border border-slate-800 disabled:opacity-70 disabled:cursor-not-allowed whitespace-nowrap"
                            >
                                {isLoading && mode === 'Executive' ? <Loader size={18} className="animate-spin" /> : <BrainCircuit size={18} className="text-indigo-400 group-hover:rotate-12 transition-transform" />}
                                Exec Summary
                            </button>
                        </div>
                        <div className="flex flex-col items-center justify-center order-1 md:order-2">
                            <div className="flex items-center gap-3 mb-1">
                                <div className="bg-slate-900 text-white p-2 rounded-xl shadow-lg ring-4 ring-slate-50">
                                    <LayoutDashboard size={20} />
                                </div>
                                <h4 className="text-sm font-black text-slate-900 tracking-tight leading-none uppercase">POPPY SUITE <span className="text-blue-600">v2.0</span></h4>
                            </div>
                            <p className="text-[10px] font-bold text-slate-500 uppercase tracking-widest">Advanced CX Intelligence</p>
                        </div>
                        <div className="flex justify-end order-3">
                            <button
                                onClick={() => handleAnalysis('Slack')}
                                disabled={isLoading}
                                className="flex items-center gap-3 px-6 py-3 bg-indigo-600 hover:bg-indigo-700 text-white rounded-2xl text-[10px] font-black uppercase tracking-[0.15em] shadow-xl shadow-indigo-100 transition-all active:scale-95 group border border-indigo-500 disabled:opacity-70 disabled:cursor-not-allowed whitespace-nowrap"
                            >
                                {isLoading && mode === 'Slack' ? <Loader size={18} className="animate-spin" /> : <MessageSquare size={18} className="group-hover:-translate-y-0.5 transition-transform" />}
                                Slack Draft
                            </button>
                        </div>
                    </div>

                    {showOutput && (
                        <div ref={outputRef} className="mt-8 relative" id="footer-ai-output">
                            {/* Close Button */}
                            <div className="absolute -top-3 -right-3 z-50 flex gap-2">
                                <button onClick={() => ExportEngine.captureCard('footer-ai-output', `${view.toUpperCase()}_${mode.replace(' ', '_')}`)} className="p-2 bg-white hover:bg-slate-50 text-blue-600 rounded-full shadow-lg border border-slate-200 transition-all hover:scale-105 active:scale-95" title="Download Image">
                                    <Camera size={16} />
                                </button>
                                <button onClick={() => setShowOutput(false)} className="p-2 bg-white hover:bg-slate-50 text-slate-500 hover:text-slate-600 rounded-full shadow-lg border border-slate-200 transition-all hover:scale-105 active:scale-95" title="Close">
                                    <XIcon size={16} />
                                </button>
                            </div>

                            {isLoading ? (
                                <div className="p-12 text-center bg-white rounded-3xl border border-slate-100 shadow-xl">
                                    <Loader size={32} className="animate-spin text-indigo-500 mx-auto mb-4" />
                                    <p className="text-sm font-bold text-slate-600 animate-pulse">
                                        Generating {mode} Analysis...
                                    </p>
                                    <p className="text-xs text-slate-500 mt-2">Analyzing {data.length} records</p>
                                </div>
                            ) : (
                                <AIWrapper
                                    data={versions[currentIndex] || ''}
                                    onRegenerate={async () => {
                                        // Wrapper handles loading state, just need to return the new string
                                        let prompt = "";
                                        if (mode === 'Executive') {
                                             prompt = `${AI_PERSONA}
${TL_PERSONA_PROMPT}

You are a Senior Ops Lead.
Task: Write a punchy Executive Summary for ${view.toUpperCase()} performance.
Data: ${JSON.stringify(sample.slice(0, 20))}... (truncated for brevity)
Tone: Professional, direct, no fluff.

Structure:
1. ** Executive Summary: ${view.toUpperCase()} ** (Title wrapped in star emojis both sides, bold)
2. **Top Achievements**
   - Use bullet points
   - Focus on wins
3. **Key Challenges**
   - Data-backed
4. **Strategic Recommendations**
   - Action-oriented
   - Decision-support focus
   - Prioritized
5. [Closure - NOT A HEADING]
   - Forward-looking statement with emoji

STRICT RULES:
1. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.
2. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).
3. NO hashtags (#).
4. Use emojis sparingly (max 2 per line).
5. Do NOT use the word "Bold", "Underline", or "B" as text.
6. Do NOT bold emphasis words like "Always", "Never", "Note" inside descriptions.
7. NO Sign-off`;
                                        } else {
                                             prompt = `${AI_PERSONA}
${TL_PERSONA_PROMPT}

Write a Slack message to the team about ${view.toUpperCase()} results.
Title: "**Team Update: ${view.toUpperCase()} Performance**"
Data: ${JSON.stringify(sample.slice(0, 20))}... (truncated for brevity)
Mood: Motivating but accountability-focused.

STRICT RULES:
1. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.
2. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).
3. NO hashtags (#).
4. Use emojis sparingly (max 2 per line).
5. Do NOT use the word "Bold", "Underline", or "B" as text.
6. Do NOT bold emphasis words like "Always", "Never", "Note" inside descriptions.`;
                                        }

                                        try {
                                            const rawResult = await AIRequestManager.generate(prompt);
                                            return mode === 'Executive' ? formatSlackMessage(rawResult, 'General') : await AIRequestManager.generate(prompt);
                                        } catch (e) {
                                            console.error(e);
                                            return " Analysis failed. Please try again.";
                                        }
                                    }}
                                    title={mode === 'Slack' ? 'Slack Draft' : 'Executive Summary'}
                                    isPaginated={false}
                                />
                            )}
                        </div>
                    )}
                </div>
            );
        };


        const TableHeaderFilter = ({ column, data, onFilter, currentFilters }) => {
            const [isOpen, setIsOpen] = useState(false);
            const ref = useRef(null);
            const uniqueValues = useMemo(() => {
                if (!data) return [];
                const values = [...new Set(data.map(r => String(r[column])))].filter(v => v && v !== 'undefined' && v !== 'null' && v.toLowerCase() !== 'nan');
                // Sort: dates first (if they look like dates), then alphabetically
                return values.sort((a, b) => {
                    const dateA = DataEngine.parseDate(a);
                    const dateB = DataEngine.parseDate(b);
                    if (dateA && dateB) {
                        return dateA.getTime() - dateB.getTime(); // Old to new
                    }
                    if (dateA) return -1;
                    if (dateB) return 1;


                    // Try parsing as numbers
                    const numA = parseFloat(a);
                    const numB = parseFloat(b);
                    if (!isNaN(numA) && !isNaN(numB)) {
                        return numA - numB; // Small to large
                    }
                    if (!isNaN(numA)) return -1;
                    if (!isNaN(numB)) return 1;


                    return a.localeCompare(b); // Alphabetical
                });
            }, [data, column]);
            const selected = currentFilters[column] || [];
            const toggleValue = (val) => { const newSelected = selected.includes(val) ? selected.filter(s => s !== val) : [...selected, val]; onFilter(column, newSelected.length > 0 ? newSelected : null); };
            const selectAll = () => onFilter(column, null);
            useClickOutside(ref, () => setIsOpen(false));
            return (
                <div className="relative inline-block ml-1" ref={ref}>
                    <button onClick={(e) => { e.stopPropagation(); setIsOpen(!isOpen); }} className={`p-1 rounded hover:bg-slate-200 transition-colors ${selected.length > 0 ? 'text-blue-600 bg-blue-50' : 'text-slate-500'}`}><Filter size={10} /></button>
                    {isOpen && (<div className="absolute top-full left-0 mt-1 w-48 bg-white border border-slate-200 rounded-xl shadow-xl z-dropdown p-2 max-h-60 overflow-y-auto" onClick={(e) => e.stopPropagation()}><div onClick={selectAll} className="flex items-center px-2 py-1.5 hover:bg-slate-50 rounded cursor-pointer border-b border-slate-100 mb-1"><div className={`w-3 h-3 border rounded mr-2 flex items-center justify-center ${selected.length === 0 ? 'bg-blue-600 border-blue-600' : 'border-slate-300'}`}>{selected.length === 0 && <CheckCircle size={8} className="text-white" />}</div><span className="text-[10px] font-bold text-slate-500 uppercase">Select All</span></div>{uniqueValues.map((val, idx) => (<div key={idx} onClick={() => toggleValue(val)} className="flex items-center px-2 py-1.5 hover:bg-slate-50 rounded cursor-pointer"><div className={`w-3 h-3 border rounded mr-2 flex items-center justify-center ${selected.includes(val) ? 'bg-blue-600 border-blue-600' : 'border-slate-300'}`}>{selected.includes(val) && <CheckCircle size={8} className="text-white" />}</div><span className="text-[10px] text-slate-700 truncate w-full">{val}</span></div>))}</div>)}
                </div>
            );
        };


        const ColumnFilterDropdown = ({ columns, visibleColumns, onToggle }) => {
            const [isOpen, setIsOpen] = useState(false);
            const ref = useRef(null);
            useClickOutside(ref, () => setIsOpen(false));
            return (
                <div className="relative inline-block" ref={ref}>
                    <button onClick={() => setIsOpen(!isOpen)} className="p-1.5 text-slate-500 hover:text-blue-600 hover:bg-blue-50 rounded-lg transition-all" title="Toggle Columns"><Settings2 size={16} /></button>
                    {isOpen && (<div className="absolute right-0 mt-2 w-56 bg-white border border-slate-100 rounded-xl shadow-2xl z-dropdown p-2 max-h-[300px] overflow-y-auto"><p className="text-[10px] font-black text-slate-500 uppercase tracking-widest px-2 py-1 mb-1 border-b">Display Columns</p>{columns.map(col => (<div key={col} onClick={() => onToggle(col)} className="flex items-center px-2 py-1.5 hover:bg-slate-50 rounded-lg cursor-pointer"><div className={`w-3 h-3 rounded border flex items-center justify-center mr-2 ${visibleColumns.includes(col) ? 'bg-blue-600 border-blue-600' : 'border-slate-300'}`}>{visibleColumns.includes(col) && <CheckCircle size={8} className="text-white" />}</div><span className="text-[10px] font-bold text-slate-700 truncate">{col}</span></div>))}</div>)}
                </div>
            );
        };


        const MultiSelect = ({ label, options, value, onChange, icon: Icon, sortOrder = 'asc' }) => {
            const [isOpen, setIsOpen] = useState(false);
            const [coords, setCoords] = useState({ top: 0, left: 0, width: 0 });
            const buttonRef = useRef(null);


            useEffect(() => {
                if (isOpen && buttonRef.current) {
                    const updatePosition = () => {
                        const rect = buttonRef.current.getBoundingClientRect();
                        const viewportHeight = window.innerHeight;
                        const dropdownHeight = 300; // Estimated max height


                        let top = rect.bottom; // Default: below button


                        // Flip up if close to bottom of screen
                        if (top + dropdownHeight > viewportHeight - 20) {
                            top = rect.top - dropdownHeight;
                            // If flipping up goes off top, stick to bottom of screen
                            if (top < 0) top = 20;
                        }


                        setCoords({
                            top: top,
                            left: rect.left,
                            width: Math.max(rect.width, 220)
                        });
                    };


                    updatePosition();
                    // Update on scroll/resize to keep attached
                    window.addEventListener('resize', updatePosition);
                    window.addEventListener('scroll', updatePosition, true); // Capture all scroll events


                    return () => {
                        window.removeEventListener('resize', updatePosition);
                        window.removeEventListener('scroll', updatePosition, true);
                    };
                }
            }, [isOpen]);


            // Handle clicking outside
            useEffect(() => {
                const handleClickOutside = (e) => {
                    // Don't close if clicking inside the dropdown or on the button
                    if (buttonRef.current && !buttonRef.current.contains(e.target) && !e.target.closest('.multiselect-dropdown')) {
                        setIsOpen(false);
                    }
                };
                if (isOpen) document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, [isOpen]);


            const sortedOptions = useMemo(() => {
                if (!options || options.length === 0) return [];
                return [...options].sort((a, b) => {
                    const dateA = DataEngine.parseDate(a);
                    const dateB = DataEngine.parseDate(b);
                    if (dateA && dateB) return sortOrder === 'desc' ? (dateB.getTime() - dateA.getTime()) : (dateA.getTime() - dateB.getTime());
                    if (dateA) return sortOrder === 'desc' ? 1 : -1;
                    if (dateB) return sortOrder === 'desc' ? -1 : 1;
                    const numA = parseFloat(a);
                    const numB = parseFloat(b);
                    if (!isNaN(numA) && !isNaN(numB)) return sortOrder === 'desc' ? (numB - numA) : (numA - numB);
                    return a.localeCompare(b);
                });
            }, [options, sortOrder]);


            return (
                <>
                    <button ref={buttonRef} onClick={() => setIsOpen(!isOpen)} className={`flex items-center bg-white border border-slate-200 rounded-lg px-2 py-1.5 text-[10px] font-semibold text-slate-600 shadow-sm hover:border-blue-400 min-w-[100px] justify-between h-8 transition-all ${isOpen ? 'ring-2 ring-blue-100 border-blue-400' : ''}`}>
                        <div className="flex items-center gap-1.5 truncate max-w-[120px]">
                            {Icon && <Icon size={12} className="text-slate-500" />}
                            <span>{value.length ? `${value.length} selected` : label}</span>
                        </div>
                        <ChevronDown size={10} className={`transition-transform ${isOpen ? 'rotate-180' : ''}`} />
                    </button>
                    {isOpen && createPortal(
                        <div
                            className="multiselect-dropdown fixed bg-white border border-slate-200 rounded-xl shadow-2xl z-[9999] flex flex-col"
                            style={{ top: `${coords.top}px`, left: `${coords.left}px`, width: `${coords.width}px`, maxHeight: '300px' }}
                        >
                            <div className="flex border-b border-slate-100 sticky top-0 bg-white z-10 rounded-t-xl">
                                <div onClick={() => onChange([...sortedOptions])} className="flex-1 p-2.5 cursor-pointer text-[10px] font-bold text-blue-600 text-center border-r border-slate-100 hover:bg-blue-50 transition-colors uppercase tracking-wide">Select All</div>
                                <div onClick={() => onChange([])} className="flex-1 p-2.5 cursor-pointer text-[10px] font-bold text-slate-500 text-center hover:text-rose-500 hover:bg-rose-50 transition-colors uppercase tracking-wide">Clear</div>
                            </div>
                            <div className="p-1 overflow-y-auto custom-scrollbar">
                                {sortedOptions.map(opt => (
                                    <div key={opt} onClick={() => onChange(value.includes(opt) ? value.filter(v => v !== opt) : [...value, opt])} className={`p-2 hover:bg-slate-50 cursor-pointer text-[10px] flex items-center gap-2 rounded-lg mb-0.5 transition-colors ${value.includes(opt) ? 'bg-blue-50 text-blue-700 font-semibold' : 'text-slate-600'}`}>
                                        <div className={`w-3.5 h-3.5 rounded border flex items-center justify-center flex-shrink-0 ${value.includes(opt) ? 'bg-blue-500 border-blue-500' : 'border-slate-300 bg-white'}`}>{value.includes(opt) && <CheckCircle size={10} className="text-white" />}</div>
                                        <span className="truncate">{opt}</span>
                                    </div>
                                ))}
                                {sortedOptions.length === 0 && <div className="p-4 text-center text-slate-500 text-xs italic">No options available</div>}
                            </div>
                        </div >,
                        document.body
                    )}
                </>
            );
        };


        // --- ANOMALY DETECTION ENGINE (Issue 13/212) ---
        const detectAnomaly = (value, historicalData) => {
            if (!historicalData || historicalData.length < 3) return null;
            const numericValue = parseFloat(value);
            if (isNaN(numericValue)) return null;


            const values = historicalData.map(v => parseFloat(v)).filter(v => !isNaN(v));
            if (values.length < 3) return null;


            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
            const stdDev = Math.sqrt(variance);
            const zScore = stdDev === 0 ? 0 : (numericValue - mean) / stdDev;


            // Trigger if z-score > 1.5 OR if it deviates > 25% from mean
            if (Math.abs(zScore) > 1.5 || Math.abs((numericValue - mean) / (mean || 1)) > 0.25) {
                return {
                    severity: Math.abs(zScore) > 2 ? 'High' : 'Medium',
                    direction: numericValue > mean ? 'spike' : 'drop',
                    deviation: (((numericValue - mean) / (mean || 1)) * 100).toFixed(1)
                };
            }
            return null;
        };






        // Phase 3.3: generateQuickInsight - Robust Data Handling
        const generateQuickInsight = async (dataContext, type = 'NPS') => {
            // Normalize input to array for consistent processing
            const dataArray = Array.isArray(dataContext) ? dataContext : [dataContext];
            if (!dataArray || dataArray.length === 0) return "No data available for analysis.";

            let dataToAnalyze = dataArray;
            let feedbackData = [];
            const firstItem = dataArray[0] || {};

            // 1. Detect Data Shape & Extract Feedback
            if (firstItem.mistakes !== undefined || firstItem.Rating !== undefined) {
                // NPS Data Structure
                dataToAnalyze = dataArray
                    .filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d))
                    .map(d => ({
                    mistakes: d.mistakes?.Total || 0,
                    rating: d.Rating,
                    agent: d.Agent || d['Agent Email'],
                    failedMetrics: d.failedMetrics || []
                }));
                feedbackData = dataArray
                    .filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d))
                    .filter(d => d['Remediation Feedback'] || d['Feedback'] || d['feedback'] || d['comment'])
                    .map(d => d['Remediation Feedback'] || d['Feedback'] || d['feedback'] || d['comment']);

            } else if (firstItem.isFail !== undefined || firstItem['QC Score'] !== undefined || firstItem.qcScore !== undefined) {
                // QC Data Structure
                // Apply global appeal filter to exclude invalid appeals from Quick Insight analysis
                dataToAnalyze = dataArray
                    .filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d))
                    .map(d => ({
                        score: d.numericScore || d['QC Score'] || d.qcScore,
                        isFail: d.isFail,
                        question: d.calculatedTag || d.Question,
                        agent: d['Agent Email'] || d.Agent
                    }));
                feedbackData = dataArray
                    .filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d))
                    .filter(d => d['TL RCA'] || d['Answer Comment'] || d['answer_comment'])
                    .map(d => {
                        const tlRCA = d['TL RCA'] || '';
                        const answerComment = d['Answer Comment'] || d['answer_comment'] || '';
                        return tlRCA && answerComment ? `${tlRCA} ${answerComment}` : (tlRCA || answerComment);
                    });

            } else if (
                (firstItem.name !== undefined || firstItem.label !== undefined || firstItem.x !== undefined || firstItem.week !== undefined) &&
                (firstItem.value !== undefined || firstItem.count !== undefined || firstItem.total !== undefined || firstItem.y !== undefined)
            ) {
                // Chart / Series Data Structure
                dataToAnalyze = dataArray.map(d => ({
                    label: d.name ?? d.label ?? d.x ?? d.week ?? d.date ?? d.key ?? 'Item',
                    value: d.value ?? d.count ?? d.total ?? d.y ?? null,
                    group: d.group ?? d.type ?? d.series ?? ''
                }));
                feedbackData = dataArray
                    .filter(d => d.feedback || d.comment || d.notes)
                    .map(d => d.feedback || d.comment || d.notes);

            } else {
                // Generic / KPI / Card Payload Structure
                dataToAnalyze = dataArray.map(d => ({
                    title: d.title || d.name || 'Metric',
                    value: d.value ?? d.count ?? d.total ?? null,
                    info: d.info || d.infoText || ''
                }));

                // Extract nested rows if available (keys: rows, data, exportRows)
                const allRows = dataArray.flatMap(d => d.rows || d.data || d.exportRows || []);
                if (allRows.length > 0) {
                    feedbackData = allRows
                        .filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d)) // Apply Global Appeal Filter
                        .filter(d => d['Remediation Feedback'] || d['Feedback'] || d['TL RCA'])
                        .map(d => d['Remediation Feedback'] || d['Feedback'] || d['TL RCA']);
                }
            }

            // Fix: Stop if no data remains after filtering
            if (!dataToAnalyze || dataToAnalyze.length === 0) {
                return "No relevant data found for analysis (all records may be passed or appealed).";
            }


            const styleContext = StyleEngine.getStyleContext(firstItem);
            const tlStyleContext = extractTLStyleContext(dataArray, type);

            // Construct Prompt
            let prompt = `Analyze this dataset to identify the Root Causes of failure.
                Context: The user wants to know WHAT went wrong and WHY.
                ${styleContext}
                ${tlStyleContext}
                ${AI_PERSONA}
                
                Inputs:
                - Performance Data: ${JSON.stringify(dataToAnalyze.slice(0, 200))}...
                - Feedbacks/Comments: ${JSON.stringify(feedbackData.slice(0, 50))} // Limit feedback volume
                
                CRITICAL INSTRUCTIONS:
                1. DO NOT simply count errors. Find the *underlying reason*.
                2. SYNTHESIZE the "Feedbacks/Comments".
                3. IGNORE standard positive feedback.
                
                OUTPUT FORMATTING RULES (STRICT):
                1. Return exactly 4-6 bullet points.
                2. Format: "**[What Went Wrong]** because [Why it happened/Root Cause]".
                3. **CRITICAL**: Return ONLY the bullet points using standard Markdown format (-). NO titles. NO intro text. NO line breaks between bullet points.
                4. NO emojis.
                5. **Strict Keywords:** Use ONLY Pillar names and Sub-metric names from the data.
                `;

            // Fallback for missing feedback (KPIs/Charts without row data)
            if ((!feedbackData || feedbackData.length === 0)) {
                const primary = dataToAnalyze[0] || {};
                const t = primary.title || 'Metric';
                const v = primary.value != null ? String(primary.value) : '';
                const i = primary.info || '';

                prompt = `Provide crisp, actionable quick insights for ${t}${v ? ` (${v})` : ''}.
                    Context: ${i || 'Analyze significance and likely causes based on typical CX patterns.'}
                    ${AI_PERSONA}
                    
                    RULES:
                    - 4-6 bullets: "**[What Went Wrong]** because [Likely Cause]".
                    - **CRITICAL**: Return ONLY the bullet points using standard Markdown format (-). NO titles. NO intro text. NO line breaks between bullet points.
                    - No emojis.
                    - Prefer precision over generalities. Tie each point to plausible operational factors.
                    - If truly insufficient data to form ANY hypothesis, only then say "Insufficient Data".
                    - **Strict Keywords:** Use ONLY Pillar names and Sub-metric names from the data.`;
            }

            try {
                const result = await AIRequestManager.generate(prompt, "", { useMemory: true });
                const formatted = formatSlackMessage(result, 'QuickInsight');
                return formatted || "No insight generated.";
            } catch (e) {
                console.error("Quick Insight Error:", e);
                return "Error generating insight.";
            }
        };




        // Phase 3.3: GeminiSparkle with dynamic positioning (from NPS.txt GeminiReader)
        // Fix Issue 3: Added data validation for sparkleData prop
        const GeminiSparkle = ({ data, type }) => {
            const [isOpen, setIsOpen] = useState(false);
            const [insight, setInsight] = useState(null);
            const [loading, setLoading] = useState(false);
            const [coords, setCoords] = useState({ top: 0, left: 0 });
            const triggerRef = useRef(null);
            const popupRef = useRef(null);
            
            // Validate data prop - ensure it's not null/undefined
            const validData = data || {};


            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (popupRef.current && !popupRef.current.contains(event.target) &&
                        triggerRef.current && !triggerRef.current.contains(event.target)) {
                        setIsOpen(false);
                    }
                };
                if (isOpen) document.addEventListener("mousedown", handleClickOutside);
                return () => document.removeEventListener("mousedown", handleClickOutside);
            }, [isOpen]);


            const handleAnalyze = async () => {
                const rect = triggerRef.current.getBoundingClientRect();

                // Increase width to 650px
                const POPUP_WIDTH = 650;

                // This makes the popup float on top of the whole screen
                let left = rect.right + 10 + window.scrollX;
                // If it hits the right edge of your screen, flip it to the left side
                if (left + POPUP_WIDTH > window.innerWidth) {
                    left = rect.left - POPUP_WIDTH - 10 + window.scrollX;
                }
                // Ensure it doesn't go off-screen left
                if (left < 10) left = 10;


                setCoords({ top: rect.top + window.scrollY, left: left });
                setIsOpen(true);


                if (!insight) {
                    setLoading(true);
                    try {
                        // Fix Issue 3: Use validated data and ensure proper array conversion
                        const dataContext = Array.isArray(validData) ? validData : (validData ? [validData] : []);
                        if (dataContext.length === 0 || !dataContext[0]) {
                            setInsight("No data available for analysis. Please ensure data is loaded.");
                        } else {
                            const res = await generateQuickInsight(dataContext, type);
                            setInsight(res || "No insights generated.");
                        }
                    } catch (err) {
                        console.error('GeminiSparkle error:', err);
                        setInsight("Error generating insight. Please try again.");
                    }
                    setLoading(false);
                }
            };


            return (
                <div className="relative inline-block ml-2">
                    <button
                        ref={triggerRef}
                        onClick={handleAnalyze}
                        className="p-1.5 text-slate-100 hover:bg-slate-800 rounded-full transition-all active:scale-95"
                        title="AI Quick Insight"
                    >
                        <Sparkles size={14} />
                    </button>
                    {isOpen && createPortal(
                        <div
                            ref={popupRef}
                            style={{
                                position: 'absolute',
                                top: `${coords.top}px`,
                                left: `${coords.left}px`,
                                zIndex: 99999,
                                width: '650px',
                                maxHeight: '600px'
                            }}
                            className="animate-in fade-in zoom-in duration-200 flex flex-col"
                        >
                            {/* Close Button Overlay */}
                            <button
                                onClick={() => setIsOpen(false)}
                                className="absolute top-3 right-3 z-[100000] p-1 text-indigo-400 hover:text-indigo-700 bg-white/50 hover:bg-white rounded-full transition-all"
                                title="Close"
                            >
                                <XIcon size={16} />
                            </button>

                            <div className="flex-1 overflow-y-auto custom-scrollbar">
                                {loading ? (
                                    <div className="bg-white p-6 rounded-xl shadow-2xl border border-indigo-100 flex items-center justify-center gap-3 text-sm text-indigo-600 font-bold">
                                        <Loader size={18} className="animate-spin" />
                                        <span>Analyzing outliers with AI...</span>
                                    </div>
                                ) : (
                                    <div id="gemini-sparkle-insight">
                                        <AIWrapper
                                            data={insight || ''}
                                            title="Quick Insight"
                                            isPaginated={false}
                                            onRegenerate={async () => {
                                                // Fix Issue 3: Use validated data for regeneration
                                                const dataContext = Array.isArray(validData) ? validData : (validData ? [validData] : []);
                                                if (dataContext.length === 0 || !dataContext[0]) {
                                                    return "No data available for analysis.";
                                                }
                                                const res = await generateQuickInsight(dataContext, type);
                                                return res || "No insights generated.";
                                            }}
                                        />
                                    </div>
                                )}
                            </div>
                        </div>,
                        document.body
                    )}
                </div>
            );
        };


        const Modal = ({ isOpen, onClose, title, content, children, actions, onDownloadImage, atomic = false }) => {
            if (!isOpen) return null;
            const displayContent = content || children;
            const [isAtomic, setIsAtomic] = React.useState(!!atomic);
            const areaRef = React.useRef(null);
            React.useEffect(() => {
                const handleEsc = (e) => { if (e.key === 'Escape') onClose && onClose(); };
                window.addEventListener('keydown', handleEsc);
                return () => window.removeEventListener('keydown', handleEsc);
            }, [onClose]);
            React.useEffect(() => {
                const area = areaRef.current;
                if (!area) return;
                const wantsAtomic = !!area.querySelector('[data-expanded-atomic="true"]');
                if (wantsAtomic) setIsAtomic(true);
            }, [displayContent]);
            // FIXED: Use createPortal directly as it is imported as a named export
            return createPortal(
                <div className="fixed inset-0 z-[10000] flex items-center justify-center bg-slate-900/60 backdrop-blur-sm p-8 animate-in fade-in duration-200" onClick={() => onClose && onClose()}>
                    <div className={`bg-white ${isAtomic ? 'w-auto max-w-[90vw] max-h-[90vh]' : 'w-full max-w-6xl max-h-[85vh]'} rounded-3xl shadow-2xl flex flex-col overflow-hidden border border-slate-200 scale-100 animate-in zoom-in-95 duration-200 relative`} role="dialog" aria-modal="true" onClick={(e) => e.stopPropagation()}>
                        {!isAtomic && (
                            <div className="flex justify-between items-center px-8 py-5 border-b border-slate-100 bg-gradient-to-r from-slate-50 to-white flex-shrink-0">
                                <h2 className="text-lg font-bold text-slate-800 tracking-tight">{title}</h2>
                                <div className="flex items-center gap-2">
                                    {actions?.onCSV && <button onClick={actions.onCSV} className="p-2 hover:bg-slate-200 rounded-lg text-slate-500" title="Export CSV"><FileSpreadsheet size={18} /></button>}
                                    {actions?.onCopy && <button onClick={actions.onCopy} className="p-2 hover:bg-slate-200 rounded-lg text-slate-500" title="Copy"><ClipboardList size={18} /></button>}
                                    {onDownloadImage && <button onClick={() => onDownloadImage('modal-zoom-area', typeof title === 'string' ? title : 'Export')} className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-xl text-xs font-semibold uppercase hover:bg-blue-700 transition-all shadow-md"><Camera size={16} /> Capture</button>}
                                    <button onClick={onClose} className="p-2 hover:bg-slate-100 rounded-xl transition-all">
                                        <XIcon size={20} className="text-slate-600" />
                                    </button>
                                </div>
                            </div>
                        )}
                        {/* Atomic close button */}
                        {isAtomic && (
                            <button onClick={onClose} className="absolute top-3 right-3 p-2 rounded-full bg-slate-900/80 text-white hover:bg-slate-900 transition-colors" title="Close">
                                <XIcon size={16} />
                            </button>
                        )}
                        <div
                            ref={areaRef}
                            className={`flex-1 ${isAtomic ? 'p-0 overflow-visible flex items-center justify-center' : 'p-8 overflow-y-auto'} bg-white`}
                            id="modal-zoom-area"
                            style={{ visibility: 'visible' }}
                        >
                            <div className={isAtomic ? 'inline-block' : ''} data-modal-content="true">
                                {displayContent}
                            </div>
                        </div>
                    </div>
                </div>,
                document.body
            );
        };


        // ModernChartCard - Enhanced chart card wrapper
        // ModernChartCard - Enhanced chart card wrapper
        // ModernChartCard - Enhanced chart card wrapper
        // ModernChartCard - Enhanced chart card wrapper
        const ModernChartCard = ({ title, children, onExpand, infoText, icon: Icon, askAI, dataForAI, onToggleNumbers, showValues }) => {
            return (
                // FIX APPLIED HERE: Added 'hover:z-[100]'
                // This forces the active card to rise above ALL other neighbors so the toolbar can't be covered.
                <div className="group relative transition-all hover:z-[100] h-full">


                    {/* Inner Card */}
                    <div className="glass-card rounded-2xl p-6 h-full relative border border-slate-200 shadow-sm bg-white">
                        <ElementToolbar
                            type="chart"
                            data={dataForAI || { title, infoText }}
                            onAskAI={askAI ? (() => askAI(`Analyze the chart "${title}". Info: ${infoText || ''}.`)) : null}
                            onExpand={onExpand}
                            onToggleNumbers={onToggleNumbers}
                            isNumbersVisible={showValues}
                            onDownloadImage={() => downloadAsImage(`chart-${title.replace(/\s+/g, '-').toLowerCase()}`, title)}
                        />
                        <div className="absolute top-0 left-0 right-0 h-1 bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500 rounded-t-2xl opacity-0 group-hover:opacity-100 transition-opacity"></div>


                        <div className="card-header-tint flex justify-between items-start mb-4">
                            <div className="flex items-center gap-3">
                                {Icon && (
                                    <div className="w-10 h-10 bg-gradient-to-br from-blue-500 to-purple-600 rounded-xl flex items-center justify-center shadow-lg">
                                        <Icon size={20} className="text-white" />
                                    </div>
                                )}
                                <div>
                                    <h3 className="text-sm font-black text-slate-900 uppercase tracking-tight">{title}</h3>
                                    <div className="flex items-center gap-2 mt-0.5">
                                        {infoText && (
                                            <div className="flex items-center gap-1.5">
                                                <p className="text-[10px] font-bold text-slate-500">{infoText}</p>
                                                <div className="opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                                                    <TooltipIcon text={infoText} />
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        </div>


                        <div className="relative">
                            {children}
                        </div>
                    </div>
                </div>
            );
        };






        // DownloadUtils - Specialized capture functions
        const DownloadUtils = {
            captureCard: async (elementId, filename) => CaptureEngine.downloadKPI(elementId, filename),
            captureTable: async (elementId, filename) => CaptureEngine.downloadTable(elementId, filename),
            captureFullscreen: async (filename) => CaptureEngine.captureFullPage(filename)
        };


        const copyRawText = async (text) => {
            try {
                await safeCopyToClipboard(text);
                return { success: true, message: 'Text copied to clipboard' };
            } catch (error) {
                console.error('Copy failed:', error);
                return { success: false, message: 'Copy failed' };
            }
        };


        const copyRTF = async (elementId) => {
            try {
                const element = document.getElementById(elementId);
                if (!element) throw new Error('Element not found');

                // FIX: Better plain text extraction (Bullets + Spacing)
                const clone = element.cloneNode(true);

                // 1. Explicitly add bullets to list items for plain text
                const listItems = clone.querySelectorAll('li');
                listItems.forEach(li => {
                    if (!li.innerText.trim().startsWith('') && !li.innerText.trim().startsWith('-')) {
                        li.prepend(document.createTextNode(' '));
                    }
                });

                // 2. Get text and normalize newlines (remove gaps)
                let text = clone.innerText || clone.textContent || '';
                text = text.replace(/\n\s*\n/g, '\n').trim();

                const html = element.innerHTML;
                await safeCopyToClipboard(text, html);
                return { success: true, message: 'Formatted text copied' };
            } catch (error) {
                console.error('RTF copy failed:', error);
                return { success: false, message: 'Copy failed' };
            }
        };


        const copyTableData = async (tableId) => {
            try {
                await copyTableToClipboard(tableId);
                return { success: true, message: 'Table copied with formatting' };
            } catch (error) {
                console.error('Table copy failed:', error);
                return { success: false, message: 'Copy failed' };
            }
        };


        const handleCopy = async (type, payload) => {
            let result;
            switch (type) {
                case 'raw': result = await copyRawText(payload); break;
                case 'rtf': result = await copyRTF(payload); break;
                case 'table': result = await copyTableData(payload); break;
                default: result = { success: false, message: 'Unknown copy type' };
            }
            if (result.success) showToast(result.message);
            else showToast(result.message, 'error');
        };


        const CopyUtils = {
            copyPlainText: (text) => {
                const fallback = () => {
                    const textArea = document.createElement("textarea");
                    textArea.value = text;
                    textArea.style.position = "fixed";
                    textArea.style.left = "-9999px";
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        showToast("Copied to clipboard");
                    } catch (err) {
                        console.error('Copy failed', err);
                        showToast("Copy failed", 'error');
                    }
                    document.body.removeChild(textArea);
                };

                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(text)
                        .then(() => showToast("Copied to clipboard"))
                        .catch(err => {
                            console.warn("Clipboard API failed, using fallback:", err);
                            fallback();
                        });
                } else {
                    fallback();
                }
            },
            copyTable: async (tableId) => {
                await copyTableToClipboard(tableId);
                showToast("Table copied to clipboard");
            },
            copyRichText: (elementId) => {
                const element = document.getElementById(elementId);
                if (!element) return;
                const range = document.createRange();
                range.selectNode(element);
                window.getSelection().removeAllRanges();
                window.getSelection().addRange(range);
                document.execCommand('copy');
                window.getSelection().removeAllRanges();
                showToast("Content copied!");
            },
            copyTableCSV: (tableData, columns) => {
                if (!tableData || !columns) return;
                const header = columns.join(',');
                const rows = tableData.map(row => columns.map(col => `"${String(row[col] || '').replace(/"/g, '""')}"`).join(',')).join('\n');
                const csv = header + '\n' + rows;
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `export_${new Date().getTime()}.csv`;
                a.click();
            }
        };


        // Expanded View Components (Issue #6)
        const ExpandedView = ({ type, title, subtitle, children, toolbarActions }) => {
            return (
                <div className="flex flex-col h-full bg-slate-50">
                    <div className="flex justify-between items-center p-4 border-b border-slate-200 bg-white shadow-sm flex-shrink-0">
                        <div>
                            <h2 className="text-xl font-bold text-slate-800 tracking-tight">{title}</h2>
                            {subtitle && <p className="text-sm text-slate-500 mt-1 font-medium">{subtitle}</p>}
                        </div>
                        <div className="flex gap-2">
                            {/* Re-use ElementToolbar but forcing transparency usually */}
                            <ElementToolbar
                                type={type}
                                className="!opacity-100 !shadow-none"
                                {...toolbarActions}
                            />
                        </div>
                    </div>
                    <div className="flex-1 p-6 overflow-hidden relative">
                        <div className="h-full w-full overflow-auto custom-scrollbar rounded-xl bg-white border border-slate-200 shadow-sm p-4">
                            {children}
                        </div>
                    </div>
                </div>
            );
        };


        const ExpandedChartView = ({ title, subtitle, chartContent, toolbarActions }) => (
            <ExpandedView type="chart" title={title} subtitle={subtitle} toolbarActions={toolbarActions}>
                <div className="h-full w-full min-h-[500px]">
                    {chartContent}
                </div>
            </ExpandedView>
        );


        const ExpandedListView = ({ title, subtitle, listContent, toolbarActions }) => (
            <ExpandedView type="list" title={title} subtitle={subtitle} toolbarActions={toolbarActions}>
                <div className="w-full">
                    {listContent}
                </div>
            </ExpandedView>
        );


        const ExpandedTableView = ({ title, subtitle, tableContent, toolbarActions }) => (
            <ExpandedView type="table" title={title} subtitle={subtitle} toolbarActions={toolbarActions}>
                <div className="w-full h-full flex flex-col overflow-x-auto">
                    {tableContent}
                </div>
            </ExpandedView>
        );


            const ClonedBlock = ({ sourceId }) => {
            const mountRef = useRef(null);
            useEffect(() => {
                const mount = mountRef.current;
                const src = document.getElementById(sourceId);
                if (!mount || !src) return;
                mount.innerHTML = '';
                const clone = src.cloneNode(true);
                    clone.querySelectorAll('[data-role="element-toolbar"] button[title="Expand View"]').forEach(el => el.remove());
                // Ensure clone stretches naturally without extra margins
                clone.style.margin = '0';
                clone.style.width = 'auto';
                mount.appendChild(clone);
            }, [sourceId]);
            return <div className="inline-block" data-expanded-atomic="true" ref={mountRef} />;
        };





        const ElementToolbar = ({ type = "kpi", className = "", onSparkle, onAskAI, onExpand, onDownloadImage, onCapture, onToggleNumbers, isNumbersVisible, toggleValues, showValues, onSearchHighlight, onDownloadCSV, onCopyTable, onCopy, data, visibleColumns, onToggleColumn, columnLabels, sparkleData, sparkleType, customActions }) => {
            const toolbarRef = React.useRef(null);

            // Context State
            const [hasTable, setHasTable] = React.useState(false);
            const [hasChart, setHasChart] = React.useState(false);
            
            // Check context
            React.useEffect(() => {
                const root = toolbarRef.current?.closest('.glass-card') || toolbarRef.current?.parentElement;
                if (!root) return;
                setHasTable(!!root.querySelector('table'));
                setHasChart(!!root.querySelector('.recharts-wrapper'));
            }, []);

            // User Requirement Matrix
            const normalizedType = (type || 'KPI').toLowerCase();
            const isKPI = normalizedType === 'kpi';
            const isChart = normalizedType === 'chart' || hasChart;
            const isList = normalizedType === 'list';
            const isTable = normalizedType === 'table' || hasTable;
            const isChartOrList = isChart || isList;

            // Feature Flags
            const allowSparkle = true;
            const allowAskAI = true;
            const allowExpand = true;
            const allowCapture = true;
            
            // Conditional Logic
            const showLabels = isChartOrList;
            const showCSV = isTable;
            const showSearch = isTable;
            const showCopy = isTable;
            const showColumns = isTable;

            // Button styles
            const btn = "p-1.5 rounded hover:bg-slate-800 text-slate-500 hover:text-white transition-colors relative z-30 opacity-80 hover:opacity-100";

            // Handlers
            const fallbackNearestTable = () => {
                let root = (toolbarRef.current && toolbarRef.current.closest('.glass-card')) || null;
                if (!root) root = document.querySelector('.glass-card');
                return root ? root.querySelector('table') : document.querySelector('table');
            };

            const handleCaptureClick = () => {
                const element = toolbarRef.current?.closest('.glass-card') || toolbarRef.current?.parentElement;
                const elementId = element?.id;
                if (!elementId) {
                    showToast('Element ID not found', 'error');
                    return;
                }
                if (isKPI) return CaptureEngine.downloadKPI(elementId, `${elementId}-kpi`);
                if (isChart) return CaptureEngine.downloadChart(elementId, `${elementId}-chart`);
                if (isTable) return CaptureEngine.downloadTable(elementId, `${elementId}-table`);
                return onDownloadImage?.(elementId) || onCapture?.(elementId);
            };

            const prepareElementForCapture = async (elementId) => {
                const element = document.getElementById(elementId);
                if (!element) {
                    console.warn(`Element with id "${elementId}" not found for capture`);
                    return null;
                }
                const clone = element.cloneNode(true);
                clone.querySelectorAll('[data-html2canvas-ignore]').forEach(el => el.remove());
                clone.style.overflow = 'visible';
                clone.style.maxHeight = 'none';
                return clone;
            };

            const handleCopyClick = async () => {
                const table = fallbackNearestTable();
                if (table) return CopyEngine.copyTableWithFormatting(table);
                return onCopyTable?.() || onCopy?.();
            };

            const handleAutoRCA = async () => {
                const table = fallbackNearestTable();
                if (!table && !data && !sparkleData) return showToast("No data to analyze", "error");
                showToast("Starting Auto-RCA...", "info");
                if (onAskAI) onAskAI("Auto-RCA");
            };

            const handleDraftCoaching = async () => {
                const table = fallbackNearestTable();
                if (!table && !data && !sparkleData) return showToast("No data for coaching", "error");
                showToast("Drafting Coaching Plan...", "info");
                if (onAskAI) onAskAI("Draft Coaching");
            };

            // Column Dropdown State
            const [columnsOpen, setColumnsOpen] = React.useState(false);
            const [internalColumns, setInternalColumns] = React.useState([]);
            const [columnsVisible, setColumnsVisible] = React.useState({});
            const [internalVisible, setInternalVisible] = React.useState(true);
            const effectiveVisible = isNumbersVisible !== undefined ? isNumbersVisible : (showValues !== undefined ? showValues : internalVisible);

            const handleLegendToggle = (e) => {
                if (e) { e.preventDefault(); e.stopPropagation(); }
                if (typeof onToggleNumbers === 'function') onToggleNumbers();
                else if (typeof toggleValues === 'function') toggleValues();
                else setInternalVisible(!effectiveVisible);
            };

            const handleCSV = () => {
                if (typeof onDownloadCSV === 'function') return onDownloadCSV();
                const table = fallbackNearestTable();
                if (!table) return;
                const headers = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim());
                const rows = Array.from(table.querySelectorAll('tbody tr')).map(tr => Array.from(tr.querySelectorAll('td')).map(td => String(td.textContent || '').trim()));
                const data = rows.map(r => { const o = {}; r.forEach((v, i) => { o[headers[i] || `col${i + 1}`] = v; }); return o; });
                ExportEngine.exportCSV(data, 'table_export');
            };

            const handleCopyMarkdown = async () => {
                const table = fallbackNearestTable();
                if (!table) return showToast("No table found to copy", "error");
                const headers = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim());
                const rows = Array.from(table.querySelectorAll('tbody tr')).filter(tr => tr.style.display !== 'none').slice(0, 100).map(tr => Array.from(tr.querySelectorAll('td')).map(td => String(td.textContent || '').trim()));
                const data = rows.map(r => { const o = {}; r.forEach((v, i) => { o[headers[i] || `col${i + 1}`] = v; }); return o; });
                const md = CanvasBridge.toMarkdown(data, "Table Data");
                await CopyUtils.copyPlainText(md);
                showToast(`Copied ${rows.length} rows as Markdown!`, "success");
            };

            const handleCopyTableFallback = async () => {
                const table = fallbackNearestTable();
                if (table) copyTableElementToClipboard(table);
            };

            const ensureInternalColumns = () => {
                if (internalColumns.length > 0) return;
                const table = fallbackNearestTable();
                if (!table) return;
                const heads = Array.from(table.querySelectorAll('thead th'));
                const cols = heads.map((th, i) => ({ name: th.textContent.trim() || `Column ${i + 1}`, index: i }));
                setInternalColumns(cols);
                const vis = {};
                cols.forEach(c => { vis[c.name] = true; });
                setColumnsVisible(vis);
            };

            const handleSearchInput = (q) => {
                if (typeof onSearchHighlight === 'function') return onSearchHighlight(q);
                const table = fallbackNearestTable();
                if (!table) return;
                const query = String(q || '').toLowerCase();
                const rows = Array.from(table.querySelectorAll('tbody tr'));
                rows.forEach(tr => {
                    const cells = Array.from(tr.querySelectorAll('td'));
                    let matchRow = false;
                    cells.forEach(td => {
                        if (!td.dataset.originalText) td.dataset.originalText = td.textContent;
                        const original = td.dataset.originalText;
                        if (!query) { td.innerHTML = original; } else {
                            const lower = original.toLowerCase();
                            if (lower.includes(query)) {
                                matchRow = true;
                                const re = new RegExp(`(${q.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')})`, 'ig');
                                td.innerHTML = original.replace(re, '<span class="table-search-highlight">$1</span>');
                            } else { td.innerHTML = original; }
                        }
                    });
                    tr.style.display = query ? (matchRow ? '' : 'none') : '';
                });
            };

            const toggleColumnInternal = (colName) => {
                const table = fallbackNearestTable();
                if (!table) return;
                ensureInternalColumns();
                const colIndex = internalColumns.find(c => c.name === colName)?.index;
                if (colIndex == null) return;
                const newVisible = { ...columnsVisible, [colName]: !columnsVisible[colName] };
                setColumnsVisible(newVisible);
                const selectorHead = `thead th:nth-child(${colIndex + 1})`;
                const selectorBody = `tbody td:nth-child(${colIndex + 1})`;
                const displayVal = newVisible[colName] ? '' : 'none';
                table.querySelectorAll(selectorHead).forEach(el => { el.style.display = displayVal; });
                table.querySelectorAll(selectorBody).forEach(el => { el.style.display = displayVal; });
            };

            return (
                <div 
                    ref={toolbarRef}
                    className={`sunrise-toolbar ${className}`} 
                    data-html2canvas-ignore="true" 
                    data-role="element-toolbar"
                >
                    {/* 1. Sparkle & AI Group */}
                            <div className="flex items-center gap-1 border-r border-slate-700 pr-1 mr-1">
                                {allowSparkle && (onSparkle || sparkleData || data) && (
                                    <span data-role="gemini-sparkle">
                                        <GeminiSparkle data={sparkleData || data} type={sparkleType || type} />
                                    </span>
                                )}
                                {allowAskAI && onAskAI && (
                                    <>
                                        <button onClick={handleAutoRCA} className={btn} title=" Auto-RCA">
                                            <span className="flex items-center gap-1 text-[10px] font-bold uppercase tracking-wider">
                                                <Sparkles size={10} className="text-amber-400" /> RCA
                                            </span>
                                        </button>
                                        <button onClick={handleDraftCoaching} className={btn} title=" Draft Coaching">
                                            <span className="flex items-center gap-1 text-[10px] font-bold uppercase tracking-wider">
                                                <Feather size={10} className="text-violet-400" /> Coach
                                            </span>
                                        </button>
                                    </>
                                )}
                            </div>

                            {/* 2. Chart/List Extras */}
                            {(isChartOrList) && (onToggleNumbers || toggleValues) && (
                                <button onClick={handleLegendToggle} className={`${btn} ${effectiveVisible ? 'text-blue-400 opacity-100' : ''}`} title={effectiveVisible ? "Hide Data Numbers" : "Show Data Numbers"}>
                                    {effectiveVisible ? <Eye size={14} className="text-blue-500" /> : <EyeOff size={14} />}
                                </button>
                            )}

                            {/* 3. Table Tools */}
                            {isTable && (
                                <>
                                    {showSearch && (
                                        <div className="flex items-center px-2 border-r border-slate-700 mr-1">
                                            <Search size={12} className="text-slate-500 mr-2" />
                                            <input className="bg-transparent border-0 w-20 text-xs text-white focus:w-28 transition-all outline-none placeholder:text-slate-500" placeholder="Live search..." onChange={e => handleSearchInput(e.target.value)} onClick={e => e.stopPropagation()} />
                                        </div>
                                    )}
                                    {showColumns && (
                                        <div className="relative">
                                            <button onClick={() => { ensureInternalColumns(); setColumnsOpen(!columnsOpen); }} className={btn} title="Show/Hide Columns"><LayoutDashboard size={14} /></button>
                                            {columnsOpen && (
                                                <div className="absolute right-0 top-full mt-2 bg-white rounded-xl shadow-xl border border-slate-200 p-2 min-w-[200px] z-50">
                                                    <div className="text-[10px] font-bold text-slate-500 uppercase mb-2 px-2 tracking-wider">Visible Columns</div>
                                                    {(visibleColumns && Object.keys(visibleColumns).length > 0 && onToggleColumn) ? (
                                                        Object.keys(visibleColumns).map(col => (
                                                            <button key={col} onClick={() => onToggleColumn(col)} className="w-full flex items-center justify-between px-2 py-1.5 text-xs text-slate-600 hover:bg-slate-50 rounded-lg transition-colors"><span>{(columnLabels && columnLabels[col]) || col}</span>{visibleColumns[col] && <CheckCircle size={12} className="text-blue-500" />}</button>
                                                        ))
                                                    ) : (
                                                        internalColumns.map(c => (
                                                            <button key={c.name} onClick={() => toggleColumnInternal(c.name)} className="w-full flex items-center justify-between px-2 py-1.5 text-xs text-slate-600 hover:bg-slate-50 rounded-lg transition-colors"><span>{c.name}</span>{columnsVisible[c.name] && <CheckCircle size={12} className="text-blue-500" />}</button>
                                                        ))
                                                    )}
                                                </div>
                                            )}
                                        </div>
                                    )}
                                    {showCSV && <button onClick={handleCSV} className={btn} title="Download CSV"><FileSpreadsheet size={14} /></button>}
                                    {showCopy && (
                                        <div className="flex items-center">
                                            <button onClick={handleCopyClick || handleCopyTableFallback} className={btn} title="Copy Table"><Copy size={14} /></button>
                                            <button onClick={handleCopyMarkdown} className={btn} title="Copy as Markdown"><FileText size={14} className="text-indigo-400" /></button>
                                        </div>
                                    )}
                                </>
                            )}

                            {/* 4. Common Extras */}
                            {allowExpand && onExpand && <button onClick={onExpand} className={btn} title="Expand View"><Maximize2 size={14} /></button>}
                            {allowCapture && handleCaptureClick && <button onClick={handleCaptureClick} className={btn} title="Capture"><Camera size={14} /></button>}

                            {/* 5. Custom Actions */}
                            {customActions && <div className="pl-1 ml-1 border-l border-slate-700 flex items-center gap-1">{customActions}</div>}
                        </div>
            );
        };


        const SmartKPI = ({
            title,
            value,
            subValue,
            trend,
            trendValue,
            delta,
            icon: Icon,
            color = "blue",
            type,
            info,
            infoText,
            onDownloadImage,
            onExpand,
            askAI,
            dataForAI,
            sparkleType,
            sparkleData,
            id,
            historicalData,
            loading,
            chartId
        }) => {
            const containerId = id || chartId || `kpi-${title.replace(/\s+/g, '-').toLowerCase()}`;
            const [isExpanded, setIsExpanded] = useState(false);
            const kpiInfo = infoText || info || "";
            const payload = dataForAI || { title, value, info: kpiInfo, type };
            const derivedSparkleData = sparkleData || (Array.isArray(dataForAI) ? dataForAI : (dataForAI && Array.isArray(dataForAI.rows) ? dataForAI.rows : null));
            const anomaly = useMemo(() => detectAnomaly(value, historicalData), [value, historicalData]);
            const isPositive = trend === 'up' || (delta && delta.isPositive !== false);
            const trendColor = isPositive ? 'text-emerald-500' : 'text-rose-500';
            const TrendIcon = isPositive ? TrendingUp : TrendingDown;
            const handleDefaultCapture = () => CaptureEngine.downloadKPI(containerId, title);
            const handleAskAI = () => {
                if (askAI) return askAI(`Analyze KPI: ${title} is ${value}`);
                window.dispatchEvent(new CustomEvent('poppy-ai-open', { detail: { query: `Analyze KPI: ${title} is ${value}` } }));
            };
            const handleCapture = () => {
                if (onDownloadImage) onDownloadImage(containerId, title);
                else handleDefaultCapture();
            };
            const handleExpand = onExpand || (() => setIsExpanded(true));


            if (loading) {
                return (
                    <div className="bg-white p-3 rounded-2xl border border-slate-200 h-full">
                        <div className="flex justify-between mb-4">
                            <Skeleton className="w-10 h-10 rounded-xl" />
                            <Skeleton className="w-12 h-6 rounded-full" />
                        </div>
                        <Skeleton className="w-24 h-4 mb-2" />
                        <Skeleton className="w-16 h-8" />
                    </div>
                );
            }


            return (
                <>
                    <div id={containerId} className={`glass-card rounded-2xl p-5 border border-slate-200 shadow-sm relative group hover:z-[60] bg-white export-atomic block-card-animated flex flex-col items-center text-center ${anomaly ? 'ring-2 ring-rose-100' : ''}`}>
                        <div className="absolute -top-6 right-0 w-24 h-8" data-html2canvas-ignore="true"></div>
                        {anomaly && (
                            <div
                                className={`absolute top-0 right-0 px-3 py-1 rounded-bl-xl text-[10px] font-black uppercase tracking-wider z-20 flex items-center gap-1 cursor-pointer transition-transform hover:scale-105 ${anomaly.severity === 'High' ? 'bg-rose-500 text-white animate-pulse' : 'bg-amber-400 text-slate-900'}`}
                                onClick={() => {
                                    showToast(`Anomaly detected for ${title}: ${anomaly.deviation}% ${anomaly.direction}.`);
                                }}
                                title="Click to Investigate Anomaly"
                            >
                                <Zap size={10} /> {anomaly.severity} {anomaly.direction}
                            </div>
                        )}


                        <ElementToolbar
                            type="kpi"
                            data={payload}
                            sparkleData={derivedSparkleData}
                            sparkleType={sparkleType || type || 'KPI'}
                            onAskAI={handleAskAI}
                            onExpand={handleExpand}
                            onDownloadImage={() => handleCapture()}
                        />


                        {/* Row 1: Icon + Title (centered together) */}
                        <div className="flex items-center justify-center gap-2 w-full">
                            {Icon && (
                                <div className={`w-8 h-8 rounded-lg flex items-center justify-center shadow-lg ${getKpiColorClasses(color)}`}>
                                    <Icon size={18} />
                                </div>
                            )}
                            <div className="flex items-center gap-1.5">
                                <h3 className="text-[11px] font-black text-slate-900 uppercase tracking-tight leading-tight">{title}</h3>
                                {kpiInfo && (
                                    <div className="opacity-0 group-hover:opacity-100 transition-opacity duration-200 z-50">
                                        <TooltipIcon text={kpiInfo} />
                                    </div>
                                )}
                            </div>
                            {(trendValue || delta) && (
                                <div className={`flex items-center gap-1 text-xs font-semibold px-2 py-1 rounded-lg bg-white/70 ${trendColor}`}>
                                    <TrendIcon size={14} />
                                    <span>{trendValue || (delta && (delta.value || delta))}</span>
                                </div>
                            )}
                        </div>

                        {/* Row 2: Data (centered) */}
                        <div className="flex items-baseline justify-center gap-2">
                            <span className="text-3xl font-black text-slate-900 tracking-tight leading-none">{value}</span>
                            {subValue && <span className="text-sm font-medium text-slate-500">{subValue}</span>}
                        </div>
                    </div>
                    <Modal isOpen={isExpanded} onClose={() => setIsExpanded(false)} title={title} content={<ClonedBlock sourceId={containerId} />} onDownloadImage={onDownloadImage} />
                </>
            );
        };


        const KPICard = (props) => <SmartKPI {...props} />;

        // --- MISSING COMPONENTS RESTORATION [Orchestrated Fix] ---

        // 1. Data Health Logic (Renamed to avoid conflict)
        const calculateDataHealthUnified = (data, type) => {
            if (!data || data.length === 0) return { score: 0, grade: 'F', issues: ['No data loaded'] };
            let score = 100;
            const issues = [];
            
            // 1. Completeness
            const totalCells = data.length * Object.keys(data[0]).length;
            const emptyCells = data.reduce((acc, row) => acc + Object.values(row).filter(v => v === null || v === '' || v === undefined).length, 0);
            const completeness = 1 - (emptyCells / totalCells);
            if (completeness < 0.8) { score -= 20; issues.push('High missing data rate'); }
            
            // 2. Consistency (Date Validation)
            const dateField = type === 'NPS' ? 'Date' : 'Review Date';
            const invalidDates = data.filter(r => !DataEngine.parseDate(r[dateField])).length;
            if (invalidDates > 0) { score -= 10; issues.push(`${invalidDates} rows have invalid dates`); }

            // 3. ID Uniqueness
            const ids = new Set(data.map(r => r.id || JSON.stringify(r)));
            if (ids.size < data.length) { score -= 10; issues.push('Duplicate records detected'); }

            return { score: Math.max(0, Math.round(score)), grade: score > 90 ? 'A' : score > 70 ? 'B' : 'C', issues };
        };

        // Component removed as part of cleanup

        const MetricCard = (props) => <SmartKPI {...props} />;






        const buildKPIExpand = (title, value, trend = null) => {
            const containerId = `kpi-${String(title || '').replace(/\s+/g, '-').toLowerCase()}`;
            return (<ClonedBlock sourceId={containerId} />);
        };




        const Card = ({ children, title, chartId, type = "Chart", onExpand, onDownloadImage, onCopy, onDownloadCSV, onExcel, infoText, columnFilter, onToggleColumns, toggleValues, showValues, className = "", dataForAI, aiType, loading, askAI, hideTitle, customToolbarActions, headerActions, rowCount }) => {
            const [localShowValues, setLocalShowValues] = useState(showValues || false);
            const [isExpanded, setIsExpanded] = useState(false);

            // Sync local state when prop changes
            React.useEffect(() => {
                if (showValues !== undefined) setLocalShowValues(showValues);
            }, [showValues]);

            const handleToggleValues = () => {
                const newState = !localShowValues;
                setLocalShowValues(newState);
                if (typeof toggleValues === 'function') toggleValues(newState);
            };

            const containerId = chartId ? `card-container-${chartId}` : `card-container-${title?.replace(/\s+/g, '-').toLowerCase()}`;
            const isTable = type === 'Table';
            const isList = type === 'List';
            const shouldScroll = isTable && typeof rowCount === 'number' && rowCount > 20;
            const cardPadding = isTable ? 'p-0' : (isList ? 'p-6' : 'p-6');


            const handleCopy = onCopy || (type === "Table" ? () => copyTableToClipboard(chartId || containerId) : () => CopyUtils.copyRichText(containerId));
            const handleCapture = onDownloadImage ? () => onDownloadImage(containerId, title) : () => CaptureEngine.downloadKPI(containerId, title);
            const handleAskAI = (query) => {
                if (askAI) return askAI(query || `Analyze ${title} data`);
                const queryText = query || `Analyze ${title} data`;
                window.dispatchEvent(new CustomEvent('poppy-ai-open', { detail: { query: queryText } }));
            };
            const handleExpand = onExpand || (() => setIsExpanded(true));


            return (
                <>
                    <div id={containerId} className={`glass-card rounded-2xl border border-slate-200 shadow-sm relative group bg-white overflow-visible block-card-animated flex flex-col ${cardPadding} ${className}`}>
                        {/* Popup Toolbar - Outside header for sunrise effect */}
                        <ElementToolbar
                            type={type}
                            onAskAI={handleAskAI}
                            onExpand={handleExpand}
                            onCapture={handleCapture}
                            onCopy={handleCopy}
                            onDownloadCSV={onDownloadCSV}
                            onExcel={onExcel}
                            onToggleColumns={onToggleColumns}
                            onToggleNumbers={(type === 'Chart' || type === 'List' || type === 'Unified' || toggleValues) ? handleToggleValues : null}
                            isNumbersVisible={localShowValues}
                            sparkleData={dataForAI || { title }}
                            sparkleType={aiType || type}
                            customActions={customToolbarActions}
                        />
                        
                        {/* Header Section */}
                        <div className={`card-header-flat flex justify-between items-center relative z-20 ${hideTitle ? 'border-b-0 pb-0 mb-0' : `border-b border-slate-100 ${isTable ? 'pb-0 mb-0' : (isList ? 'pb-3 mb-3' : 'pb-1 mb-1')}`}`}>
                            <div className="flex items-center gap-2 min-w-0 flex-1 pr-24">
                                {!hideTitle ? (
                                    <>
                                        <h3 className="font-bold text-slate-800 uppercase tracking-tight text-[13px] leading-tight mb-0 break-words" title={title}>{title}</h3>
                                        {infoText && (
                                            <div className="opacity-0 group-hover:opacity-100 transition-opacity duration-200 flex-shrink-0" data-html2canvas-ignore="true">
                                                <InfoTooltip text={infoText} position="top">
                                                    <Info size={14} className="text-slate-500 hover:text-blue-600 cursor-help" />
                                                </InfoTooltip>
                                            </div>
                                        )}
                                    </>
                                ) : <div className="flex-1" />}
                            </div>
                            
                            {/* Header Actions */}
                            {headerActions && (
                                <div className="flex items-center gap-2 mr-3" data-html2canvas-ignore="true">
                                    {headerActions}
                                </div>
                            )}
                        </div>

                        {/* Content Section */}
                        <div id={chartId || 'card-content'} className={`w-full relative z-10 select-text flex flex-col ${isTable ? (shouldScroll ? 'overflow-auto max-h-[1000px] flex-1 min-h-0' : 'overflow-visible h-auto') : 'flex-1 min-h-0'}`}>
                            {loading ? <div className="space-y-4 py-2"><Skeleton className="w-full h-4" /><Skeleton className="w-full h-32" /></div> :
                                React.Children.map(children, child => {
                                    if (React.isValidElement(child)) {
                                        return React.cloneElement(child, { showValues: localShowValues });
                                    }
                                    return child;
                                })
                            }
                        </div>
                    </div>
                    <Modal isOpen={isExpanded} onClose={() => setIsExpanded(false)} title={title} content={<ClonedBlock sourceId={containerId} />} onDownloadImage={onDownloadImage} />
                </>
            );
        };


        // --- TREND CHART COMPONENT ---
        const SmartChart = ({
            title,
            data,
            children,
            infoText,
            dataForAI,
            askAI,
            height = 300,
            onDownloadImage,
            onExpand,
            onDownloadCSV,
            onCopyTable,
            chartId,
            toggleValues,
            showValues
        }) => {
            // Audit Fix: Eye icon should toggle showValues (Issue #10)
            const [localShowValues, setLocalShowValues] = useState(showValues || false);

            // Sync local state when prop changes
            React.useEffect(() => {
                if (showValues !== undefined) setLocalShowValues(showValues);
            }, [showValues]);

            const handleToggleValues = () => {
                const newState = !localShowValues;
                setLocalShowValues(newState);
                if (toggleValues) toggleValues(newState);
            };

            if (!data || data.length === 0) {
                return (
                    <Card title={title} infoText={infoText} aiType="Chart" askAI={askAI}>
                        <div className="flex flex-col items-center justify-center h-48 text-slate-500">
                            <Activity size={24} className="mb-2 opacity-50" />
                            <span className="text-xs font-bold uppercase tracking-wider">No data available</span>
                        </div>
                    </Card>
                );
            }

            return (
                <Card
                    title={title}
                    infoText={infoText}
                    dataForAI={dataForAI || data}
                    askAI={askAI}
                    chartId={chartId}
                    type="Chart"
                    onExpand={onExpand}
                    onDownloadImage={onDownloadImage}
                    onDownloadCSV={onDownloadCSV}
                    onCopy={onCopyTable}
                    // Pass the toggle handler and state down to the toolbar
                    toggleValues={handleToggleValues}
                    showValues={localShowValues}
                >
                    <div style={{ height: `${height}px`, width: '100%' }}>
                        {/* Inject showValues prop into children charts */}
                        {React.Children.map(children, child => {
                            if (React.isValidElement(child)) {
                                return React.cloneElement(child, { showValues: localShowValues });
                            }
                            return child;
                        })}
                    </div>
                </Card>
            );
        };










        const TrendChart = ({ data, xKey, yKeys, colors, title, type = 'area', infoText, dataForAI, askAI, height = 300, onDownloadImage, onExpand, toggleValues, showValues }) => {
            const [localShowValues, setLocalShowValues] = useState(showValues || false);

            // Sync local state when prop changes
            useEffect(() => {
                if (showValues !== undefined) setLocalShowValues(showValues);
            }, [showValues]);

            return (
                <SmartChart
                    title={title}
                    data={data}
                    infoText={infoText}
                    dataForAI={dataForAI}
                    askAI={askAI}
                    height={height}
                    onDownloadImage={onDownloadImage}
                    onExpand={onExpand}
                    toggleValues={() => setLocalShowValues(!localShowValues)}
                    showValues={localShowValues}
                >
                    <ResponsiveContainer width="100%" height="100%">
                        {type === 'line' ? (
                            <LineChart data={data} margin={{ top: 10, right: 10, left: -20, bottom: 0 }}>
                                <CartesianGrid strokeDasharray="3 3" vertical={false} stroke="#f1f5f9" />
                                <XAxis dataKey={xKey} axisLine={false} tickLine={false} tick={{ fontSize: 10, fill: '#64748b', fontWeight: 600 }} dy={10} />
                                <YAxis axisLine={false} tickLine={false} tick={{ fontSize: 10, fill: '#64748b', fontWeight: 600 }} />
                                <Tooltip contentStyle={{ borderRadius: '12px', border: 'none', boxShadow: '0 10px 15px -3px rgb(0 0 0 / 0.1)' }} cursor={{ stroke: '#cbd5e1', strokeWidth: 1 }} />
                                <Legend verticalAlign="top" align="right" iconType="circle" wrapperStyle={{ paddingBottom: '20px', fontSize: '10px', fontWeight: 700, textTransform: 'uppercase' }} />
                                {yKeys.map((key, i) => (
                                    <Line key={key} type="monotone" dataKey={key} stroke={colors[i] || '#3b82f6'} strokeWidth={3} dot={{ r: 4, strokeWidth: 2, fill: '#fff' }} activeDot={{ r: 6, strokeWidth: 0 }} label={localShowValues ? { position: 'top', fill: '#64748b', fontSize: 10, fontWeight: 700 } : false} />
                                ))}
                            </LineChart>
                        ) : (
                            <AreaChart data={data} margin={{ top: 10, right: 10, left: -20, bottom: 0 }}>
                                <defs>
                                    {yKeys.map((key, i) => (
                                        <linearGradient key={`gradient-${key}`} id={`gradient-${key}`} x1="0" y1="0" x2="0" y2="1">
                                            <stop offset="5%" stopColor={colors[i] || '#3b82f6'} stopOpacity={0.3} />
                                            <stop offset="95%" stopColor={colors[i] || '#3b82f6'} stopOpacity={0} />
                                        </linearGradient>
                                    ))}
                                </defs>
                                <CartesianGrid strokeDasharray="3 3" vertical={false} stroke="#f1f5f9" />
                                <XAxis dataKey={xKey} axisLine={false} tickLine={false} tick={{ fontSize: 10, fill: '#64748b', fontWeight: 600 }} dy={10} />
                                <YAxis axisLine={false} tickLine={false} tick={{ fontSize: 10, fill: '#64748b', fontWeight: 600 }} />
                                <Tooltip contentStyle={{ borderRadius: '12px', border: 'none', boxShadow: '0 10px 15px -3px rgb(0 0 0 / 0.1)' }} cursor={{ stroke: '#cbd5e1', strokeWidth: 1 }} />
                                <Legend verticalAlign="top" align="right" iconType="circle" wrapperStyle={{ paddingBottom: '20px', fontSize: '10px', fontWeight: 700, textTransform: 'uppercase' }} />
                                {yKeys.map((key, i) => (
                                    <Area key={key} type="monotone" dataKey={key} stroke={colors[i] || '#3b82f6'} fillOpacity={1} fill={`url(#gradient-${key})`} strokeWidth={3} dot={{ r: 4, strokeWidth: 2, fill: '#fff' }} activeDot={{ r: 6, strokeWidth: 0 }} label={localShowValues ? { position: 'top', fill: '#64748b', fontSize: 10, fontWeight: 700 } : false} />
                                ))}
                            </AreaChart>
                        )}
                    </ResponsiveContainer>
                </SmartChart>
            );
        };




        // Fix: Increase chart text size - make all charts consistent with Pillar Impact Analysis (14px, bold)



        // Fix: CoachingGenerator - shorter, include feedback loop and errors/feedbacks
        // Issue #8: Added Versioning
        const CoachingGenerator = ({ agentName, strengths, opportunities, onDownload, onLogSummary, feedbackLoopData, processedData, type, askAI }) => {
            // Versioning State
            const [planVersions, setPlanVersions] = useState([]);
            const [currentPlanIndex, setCurrentPlanIndex] = useState(0);
            const plan = planVersions[currentPlanIndex] || null;


            const [isLoading, setIsLoading] = useState(false);
            const [isExpanded, setIsExpanded] = useState(false);
            const [refineText, setRefineText] = useState("");



            // Helpers
            const addVersion = (newPlan) => {
                setPlanVersions(prev => {
                    const next = [...prev, newPlan];
                    setCurrentPlanIndex(next.length - 1);
                    return next;
                });
            };


            const updateCurrentVersion = (updatedPlan) => {
                setPlanVersions(prev => {
                    const newVers = [...prev];
                    newVers[currentPlanIndex] = updatedPlan;
                    return newVers;
                });
            };


            const generate = async () => {
                if (!agentName) return showToast("Select an agent.");
                setIsLoading(true);


                // Format feedback context with explicit counts for NPS and QC
                // Apply Global Filters
                const cleanData = processedData ? processedData.filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d)) : [];
                
                let feedbackContext = '';
                const npsRows = cleanData.filter(r => r && r['QC Score'] === undefined);
                const qcRows = cleanData.filter(r => r && r['QC Score'] !== undefined);
                const npsCounts = npsRows.length ? feedbackLoopCalculator(npsRows, 'NPS') : null;
                const qcCounts = qcRows.length ? feedbackLoopCalculator(qcRows, 'QC') : null;
                const x = npsCounts?.pendingTick || 0;
                const y = npsCounts?.pendingWritten || 0;
                const a = qcCounts?.pendingTick || 0;
                const b = qcCounts?.pendingWritten || 0;
                
                // Build pending actions list, only including non-zero items
                const pendingActions = [];
                if (x > 0) pendingActions.push(`- ${x} Chat reviews pending to be acknowledged.`);
                if (y > 0) pendingActions.push(`- ${y} Chat reviews pending written justification.`);
                if (a > 0) pendingActions.push(`- ${a} Quality reviews pending to be acknowledged.`);
                if (b > 0) pendingActions.push(`- ${b} Quality reviews pending written justification.`);
                
                if (pendingActions.length > 0) {
                    feedbackContext = `Pending 1:1 File actions:\n${pendingActions.join('\n')}\n`;
                } else {
                    feedbackContext = ''; // No pending items - section should be skipped
                }


                let formattedFeedbacks = [];
                if (cleanData && cleanData.length > 0) {
                    if (type === 'NPS') {
                        // Group by sub-metric and take first feedback for each to avoid duplicates
                        const seenMetrics = new Set();
                        formattedFeedbacks = cleanData
                            .filter(d => d["Remediation Feedback"] || d["Feedback"])
                            .filter(d => {
                                const metric = d["Sub-metric"] || "General";
                                if (seenMetrics.has(metric)) return false;
                                seenMetrics.add(metric);
                                return true;
                            })
                            .map(d => `${d["Sub-metric"] || "General"} [Link: ${d["Chat Link"] || "N/A"}]: ${d["Remediation Feedback"] || d["Feedback"]}`)
                            .slice(0, 3); // Max 3 different sub-metrics
                    } else if (type === 'QC') {
                        // Group by Question to avoid duplicates
                        const seenQuestions = new Set();
                        formattedFeedbacks = cleanData
                            .filter(d => (d['TL RCA'] || d['Answer Comment']))
                            .filter(d => {
                                const q = d['Question'] || 'General';
                                if (seenQuestions.has(q)) return false;
                                seenQuestions.add(q);
                                return true;
                            })
                            .map(d => {
                                const tlRCA = d['TL RCA'] || '';
                                const answerComment = d['Answer Comment'] || '';
                                const q = d['Question'] || 'General';
                                return `${q} [Link: ${d["Dante/Bo Link"] || "N/A"}]: ${tlRCA && answerComment ? `${tlRCA} ${answerComment}` : (tlRCA || answerComment)}`;
                            })
                            .slice(0, 3); // Max 3 different questions
                    } else {
                        formattedFeedbacks = cleanData.slice(0, 3).map(d => `${d["Feedback"] || d["TL RCA"] || "Feedback"}`);
                    }
                }
                const errorsContext = formattedFeedbacks.length > 0 ? `\n\n${type} Feedback List:\n${formattedFeedbacks.join('\n')}` : '';


                const styleContextObj = StyleEngine.getStyleContext((cleanData && cleanData.length > 0) ? cleanData[0] : {});
                const tlStyleContext = extractTLStyleContext(cleanData, type);
                const styleCtx = `Style Guidance: ${styleContextObj && styleContextObj.stylePrompt ? styleContextObj.stylePrompt : ''}\n${tlStyleContext}`;
                const res = await generateSmartCoachingPlan(agentName, strengths, opportunities, feedbackContext, errorsContext, type, type === 'Unified' || type === 'QC' || type === 'NPS', styleCtx);


                addVersion(res); // Issue #8
                if (onLogSummary) onLogSummary(res);
                setIsLoading(false);
            };


            const refine = async () => {
                if (!plan || !refineText) return;
                setIsLoading(true);
                const res = await generateRefinement(plan, refineText);
                addVersion(res); // Issue #8
                if (onLogSummary) onLogSummary(res);
                setIsLoading(false);
            };





            return (
                <React.Fragment>
                    <Card title="AI Coaching Action Plan" type="Table" chartId="coaching-card-content" onExpand={() => setIsExpanded(true)} onDownloadImage={() => onDownload("coaching-card-content", `Coach_${agentName}`)} infoText="Automated coaching message generation based on identified strengths and weaknesses." askAI={askAI}>
                        <div className="p-6">
                            <div className="flex justify-between items-center mb-3"><p className="text-[10px] font-semibold text-slate-500 uppercase">Slack coaching script (DM format)</p><button onClick={generate} disabled={isLoading} className="px-5 py-2 bg-blue-600 text-white text-[10px] font-bold uppercase rounded-xl flex items-center gap-2 shadow-lg hover:bg-blue-700 transition-all no-export" data-html2canvas-ignore="true">{isLoading ? <Loader size={12} className="animate-spin" /> : <Sparkles size={12} />} Generate</button></div>






                            {plan ? (
                                <div className="space-y-4">
                                    <AIOutputWrapper
                                        content={plan}
                                        onEdit={updateCurrentVersion}
                                        onRegenerate={generate}
                                        onVersionChange={setCurrentPlanIndex}
                                        versions={planVersions}
                                        currentVersionIndex={currentPlanIndex}
                                        type="Coaching"
                                        title="Coaching Plan"
                                        flat={true}
                                    />
                                    <div className="flex gap-3 p-2 bg-slate-50 border border-slate-200 rounded-2xl">
                                        <div className="relative flex-1">
                                            <Sparkles className="absolute left-3 top-2.5 text-blue-400" size={14} />
                                            <input type="text" value={refineText} onChange={(e) => setRefineText(e.target.value)} onKeyDown={e => e.key === 'Enter' && refine()} placeholder="Refine this plan..." className="w-full pl-9 pr-4 py-2 text-xs bg-white border border-slate-200 rounded-xl outline-none focus:ring-2 focus:ring-blue-500 transition-all" />
                                        </div>
                                        <button onClick={refine} disabled={isLoading} className="px-5 py-2 bg-blue-600 text-white rounded-xl text-xs font-bold uppercase transition-all hover:bg-blue-700">Adjust</button>
                                    </div>
                                </div>
                            ) : <div className="text-center py-12 text-slate-500 italic bg-slate-50/50 border-2 border-dashed border-slate-200 rounded-[2rem]">Select agent and generate plan</div>}
                        </div>
                    </Card>

                    <Modal isOpen={isExpanded} onClose={() => setIsExpanded(false)} title="Coaching DM Preview" onDownloadImage={onDownload}>
                        <div className="p-6 space-y-6">
                            <AIOutputWrapper
                                content={plan}
                                onEdit={updateCurrentVersion}
                                onRegenerate={generate}
                                onVersionChange={setCurrentPlanIndex}
                                versions={planVersions}
                                currentVersionIndex={currentPlanIndex}
                                type="Coaching"
                                title="Coaching Plan (Expanded)"
                            />
                            <div className="flex justify-end gap-2">
                                <button onClick={generate} className="px-4 py-2 bg-blue-600 text-white rounded-xl flex items-center gap-2 text-xs font-bold uppercase shadow-lg shadow-blue-100 no-export" data-html2canvas-ignore="true"><Sparkles size={14} /> Regenerate</button>
                            </div>
                        </div>
                    </Modal>
                </React.Fragment>
            );
        };


        // --- 8. HOOKS ---


        const ChatView = ({ data, onDownloadImage, onExpand, askAI }) => {
            const keys = useMemo(() => {
                if (!data.length) return [];
                const all = Object.keys(data[0]).filter(k => !k.startsWith('_'));
                return all;
            }, [data]);


            const defaultVisibleCols = useMemo(() => {
                if (!keys.length) return [];
                let defaultCols = keys.slice(0, 8);
                defaultCols = defaultCols.filter(c => !c.includes('Ownership') && !c.includes('Escalation'));
                const priority = ['TL Feedback', 'Feedback', 'Review', 'Comment', 'Why mistake', 'RCA', 'Date', 'Agent'];
                priority.forEach(p => {
                    const found = keys.find(c => c.toLowerCase().includes(p.toLowerCase()));
                    if (found && !defaultCols.includes(found)) defaultCols.push(found);
                });
                return defaultCols;
            }, [keys]);


            const [visible, setVisible] = useState([]);
            useEffect(() => {
                if (defaultVisibleCols.length > 0 && visible.length === 0) {
                    setVisible(defaultVisibleCols);
                }
            }, [defaultVisibleCols]);


            // DESTUCTURE query from hook to pass to HighlightText
            const { data: sorted, toggleSort, setQuery, query, sortKey, direction, setColumnFilter, filters } = useSortableTable(data);


            return (
                <div className="space-y-6">
                    <Card
                        title={`Narrative Logs (${data.length})`}
                        id="chat-view-container"
                        askAI={askAI}
                        onExpand={onExpand}
                        onDownloadImage={onDownloadImage}
                        onDownloadCSV={() => ExportEngine.exportCSV(sorted.map(row => {
                            const exportRow = {};
                            keys.filter(k => visible.includes(k)).forEach(col => {
                                exportRow[col] = col.toLowerCase().includes('date') ? DataEngine.formatDate(row[col]) : (row[col] || '');
                            });
                            return exportRow;
                        }), "chat_narrative_logs")}
                        onCopyTable={() => copyTableToClipboard(null, sorted.map(row => {
                            const exportRow = {};
                            keys.filter(k => visible.includes(k)).forEach(col => {
                                exportRow[col] = col.toLowerCase().includes('date') ? DataEngine.formatDate(row[col]) : (row[col] || '');
                            });
                            return exportRow;
                        }))}
                        infoText="Raw interaction data logs. Dates are formatted as DD/MM/YYYY. Use search to isolate specific keywords or agents."
                        dataForAI={sorted.slice(0, 10)}
                        columnFilter={
                            <div className="flex gap-2 items-center">
                                <TableColumnMenu
                                    visibleColumns={Object.fromEntries(keys.map(k => [k, visible.includes(k)]))}
                                    toggleColumn={c => setVisible(p => p.includes(c) ? p.filter(x => x !== c) : [...p, c])}
                                    labels={Object.fromEntries(keys.map(k => [k, k]))}
                                />
                                <div className="relative">
                                    <Search className="absolute left-3 top-2 text-slate-500" size={14} />
                                    <input
                                        type="text"
                                        placeholder="Quick Filter..."
                                        value={query}
                                        onChange={e => setQuery(e.target.value)}
                                        className="pl-9 pr-4 py-1.5 bg-slate-50 border border-slate-200 rounded-xl text-[10px] w-48 focus:ring-2 ring-indigo-500 outline-none transition-all"
                                    />
                                </div>
                            </div>
                        }
                    >
                        <div id="chat-view-container" className="h-full flex flex-col">
                            <div id="chat-view-container-table" className={`${sorted.length > 30 ? 'overflow-auto max-h-[1000px] flex-1' : 'overflow-visible h-auto'}`}>
                                <table className="w-full text-xs text-left border-collapse">
                                    <thead className="bg-slate-50 sticky top-0 z-20">
                                        <tr>{keys.filter(k => visible.includes(k)).map(col => (<SortableTableHeader key={col} column={col} label={col} sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters[col]} data={data} className="text-slate-700 whitespace-nowrap" />))}</tr>
                                    </thead>
                                    <tbody className="bg-white divide-y divide-slate-100">
                                        {sorted.filter(row => {
                                            const visibleCols = keys.filter(k => visible.includes(k));
                                            const nonEmptyCount = visibleCols.filter(col => row[col] !== undefined && row[col] !== null && row[col] !== '' && String(row[col]).trim() !== '').length;
                                            return nonEmptyCount >= 2;
                                        }).map((row, idx) => (
                                            <tr key={idx} className="hover:bg-slate-50 transition-colors">
                                                {keys.filter(k => visible.includes(k)).map(col => {
                                                    const val = row[col];
                                                    const isEmpty = val === undefined || val === null || String(val).trim() === '';
                                                    const displayVal = isEmpty ? '-' : (col.toLowerCase().includes('date') ? DataEngine.formatDate(val) : String(val));
                                                    return (
                                                        <td key={`${idx}-${col}`} className={`p-3 text-slate-700 border-r border-slate-100 last:border-r-0 whitespace-pre-wrap ${isEmpty ? 'text-slate-500 italic' : ''} ${col.toLowerCase().includes('feedback') ? 'min-w-[300px]' : 'max-w-xs truncate'}`}>
                                                            {/* IMPLEMENTED HIGHLIGHTING HERE */}
                                                            <HighlightText text={displayVal} highlight={query} />
                                                        </td>
                                                    );
                                                })}
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </Card>
                </div>
            );
        };


        const LegacyMatrixView = ({ data, metricsMapping, onDownload, onExpand, askAI }) => {
            const [filterRisk, setFilterRisk] = useState('All');
            const [selectedAgent, setSelectedAgent] = useState(null);
            const [actionPlans, setActionPlans] = useState({});
            const [loadingPlans, setLoadingPlans] = useState({});


            // 1. Process Data for Repeat Offenders
            const stats = useMemo(() => {
                const agentMap = {};
                let totalAudits = 0;


                data.forEach(row => {
                    const agent = DataEngine.normalizeAgent(row, 'NPS') || DataEngine.normalizeAgent(row, 'QC') || 'Unknown';
                    if (!agent || agent === 'Unknown') return;
                    totalAudits++;


                    if (!agentMap[agent]) {
                        agentMap[agent] = {
                            name: agent,
                            audits: 0,
                            fails: 0,
                            tags: {},
                            scores: [],
                            dates: [],
                            riskScore: 0
                        };
                    }
                    agentMap[agent].audits++;


                    // Determine Failure
                    let isFail = false;
                    let tag = 'General';


                    // Logic for NPS vs QC
                    if (row._type === 'QC' || row['QC Score']) {
                        const score = parseFloat(row['QC Score']);
                        isFail = (score < 100) || row['Pass/Fail'] === 'Fail';
                        tag = extractQCTag(row);
                    } else {
                        // NPS - Check sub-metrics, not Rating
                        const allSubMetrics = Object.values(NPS_METRIC_MAPPING).flat();
                        isFail = allSubMetrics.some(metric => {
                            const val = row[metric];
                            return val === false || String(val).toUpperCase() === 'FALSE' || val === 0 || val === '0';
                        });
                        tag = row['User Problem'] || row['Sub-metric'] || 'General';
                    }


                    if (isFail) {
                        agentMap[agent].fails++;
                        agentMap[agent].tags[tag] = (agentMap[agent].tags[tag] || 0) + 1;
                    }
                    agentMap[agent].dates.push(row.Date || row['Review Date']);
                });


                // Calculate Risk Tiers
                let critical = 0, atRisk = 0, watchlist = 0;
                const agents = Object.values(agentMap).map(a => {
                    // Recidivism Logic
                    const repeatTags = Object.entries(a.tags).filter(([t, c]) => c > 1);
                    const isRepeatOffender = repeatTags.length > 0;


                    // Simple Risk Algo
                    let risk = 0;
                    if (a.fails > 3) risk += 50;
                    if (isRepeatOffender) risk += 30;
                    if (a.fails > 0 && a.audits < 5) risk += 10; // Newbie risk


                    a.riskScore = Math.min(100, risk);
                    a.topIssue = Object.entries(a.tags).sort((x, y) => y[1] - x[1])[0]?.[0] || 'None';
                    a.recidivism = isRepeatOffender;


                    if (a.riskScore >= 50) { a.tier = 'Critical'; critical++; }
                    else if (a.riskScore >= 30) { a.tier = 'At Risk'; atRisk++; }
                    else if (a.fails > 0) { a.tier = 'Watchlist'; watchlist++; }
                    else { a.tier = 'Safe'; }


                    return a;
                }).filter(a => a.fails > 0).sort((a, b) => b.riskScore - a.riskScore); // Show only offenders


                const recidivismRate = agents.length > 0 ? ((agents.filter(a => a.recidivism).length / agents.length) * 100).toFixed(0) : 0;


                return { agents, critical, atRisk, watchlist, recidivismRate, totalAudits };
            }, [data]);


            const filteredAgents = filterRisk === 'All' ? stats.agents : stats.agents.filter(a => a.tier === filterRisk);


            // Sortable Hooks
            const offendersTable = useSortableTable(filteredAgents);


            const pillarData = useMemo(() => {
                return Object.values(data.reduce((acc, row) => {
                    const agent = DataEngine.normalizeAgent(row, 'NPS') || 'Unknown';
                    if (!acc[agent]) acc[agent] = { Agent: agent, audits: 0, Communication: {}, Personalisation: {}, Efficiency: {} };
                    acc[agent].audits++;
                    Object.entries(NPS_METRIC_MAPPING).forEach(([p, metrics]) => {
                        metrics.forEach(m => {
                            const val = row[m];
                            const isFail = val === false || String(val).toUpperCase() === 'FALSE' || 
                                          String(val).toUpperCase() === 'NO' || val === 0;
                            if (isFail) {
                                acc[agent][p][m] = (acc[agent][p][m] || 0) + 1;
                            }
                        });
                    });
                    return acc;
                }, {}));
            }, [data]);
            const pillarTable = useSortableTable(pillarData);






            return (
                <div className="space-y-6">
                    {/* Header Stats */}
                    {/* Header Stats removed and moved to Agent Review page */}



                    {/* Main Content */}



                    <Card title="Pillar-Wise Behavioral Analysis" chartId="pillar-analysis-table" type="Table" rowCount={pillarTable.data.length} infoText="Detailed breakdown of failures per behavior pillar for each agent."
                        onDownloadImage={onDownload}
                        onCopy={() => copyTableToClipboard('pillar-analysis-table-el')}
                        askAI={askAI}
                        onDownloadCSV={() => {
                            const exportData = Object.values(data.reduce((acc, row) => {
                                const agent = DataEngine.normalizeAgent(row, 'NPS') || 'Unknown';
                                if (!acc[agent]) acc[agent] = { Agent: agent, audits: 0, Communication: [], Personalisation: [], Efficiency: [] };
                                acc[agent].audits++;
                                Object.entries(NPS_METRIC_MAPPING).forEach(([p, metrics]) => {
                                    metrics.forEach(m => {
                                        const val = row[m];
                                        const isFail = val === false || String(val).toUpperCase() === 'FALSE' || String(val).toUpperCase() === 'NO' || String(val).toUpperCase() === 'FAIL' || val === 0 || val === '0';
                                        if (isFail && !acc[agent][p].includes(m)) acc[agent][p].push(m);
                                    });
                                });
                                return acc;
                            }, {})).map(a => ({ ...a, Communication: a.Communication.join(', '), Personalisation: a.Personalisation.join(', '), Efficiency: a.Efficiency.join(', ') }));
                            DataEngine.exportToCSV(exportData, "pillar_analysis");
                        }}
                        onExcel={() => {
                            const exportData = Object.values(data.reduce((acc, row) => {
                                const agent = DataEngine.normalizeAgent(row, 'NPS') || 'Unknown';
                                if (!acc[agent]) acc[agent] = { Agent: agent, audits: 0, Communication: [], Personalisation: [], Efficiency: [] };
                                acc[agent].audits++;
                                Object.entries(NPS_METRIC_MAPPING).forEach(([p, metrics]) => {
                                    metrics.forEach(m => {
                                        const val = row[m];
                                        const isFail = val === false || String(val).toUpperCase() === 'FALSE' || String(val).toUpperCase() === 'NO' || String(val).toUpperCase() === 'FAIL' || val === 0 || val === '0';
                                        if (isFail && !acc[agent][p].includes(m)) acc[agent][p].push(m);
                                    });
                                });
                                return acc;
                            }, {})).map(a => ({ ...a, Communication: a.Communication.join(', '), Personalisation: a.Personalisation.join(', '), Efficiency: a.Efficiency.join(', ') }));
                            ExportEngine.exportCSV(exportData, "pillar_analysis");
                        }}
                        onToggleColumns={() => showToast("Columns are fixed for pillar analysis")}
                        askAI={askAI}
                        headerActions={(
                            <button
                                onClick={async () => {
                                    if (pillarTable.data.length === 0) {
                                        showToast("No data to generate plans for", 'error');
                                        return;
                                    }
                                    if (!confirm(`Generate draft plans for ${pillarTable.data.length} visible agents? This may take a moment.`)) return;
                                    showToast(`Starting batch generation for ${pillarTable.data.length} agents...`, 'info');
                                    let successCount = 0;
                                    const chunk = (arr, size) => Array.from({ length: Math.ceil(arr.length / size) }, (v, i) => arr.slice(i * size, i * size + size));
                                    const batches = chunk(pillarTable.data, 3);
                                    for (const batch of batches) {
                                        await Promise.all(batch.map(async (d) => {
                                            const commFails = Object.keys(d.Communication).join(', ');
                                            const persFails = Object.keys(d.Personalisation).join(', ');
                                            const effFails = Object.keys(d.Efficiency).join(', ');
                                            if (!commFails && !persFails && !effFails) return;
                                            const p = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nGenerate 2-3 specific, actionable bullet points for a Team Leader Action Plan for agent ${d.Agent}. Failures: Communication (${commFails}), Personalisation (${persFails}), Efficiency (${effFails}).\n\nSTRICT RULES:\n1. Use simple plain text (no bold, no markdown).\n2. Each bullet should be a single actionable statement.\n3. RETURN ONLY THE BULLET POINTS as plain text lines.`;
                                            try {
                                                const resp = await AIRequestManager.generate(p);
                                                const lines = resp.split('\n').map(l => l.replace(/^[-*] /, '').trim()).filter(l => l.length > 5);
                                                setActionPlans(prev => ({ ...prev, [d.Agent]: [...(prev[d.Agent] || []), ...lines] }));
                                                successCount++;
                                            } catch (e) {
                                                console.error(`Failed for ${d.Agent}`, e);
                                            }
                                        }));
                                    }
                                    showToast(`Draft generation complete! Updated plans for ${successCount} agents.`, 'success');
                                }}
                                className="px-2 py-1 rounded bg-indigo-50 text-indigo-600 hover:bg-indigo-100 hover:text-indigo-700 transition-all font-bold text-[10px] flex items-center gap-1 uppercase tracking-wider border border-indigo-200 no-export"
                                data-html2canvas-ignore="true"
                                title="Generate Draft Plans for All Visible Agents"
                            >
                                <Sparkles size={12} /> Draft All
                            </button>
                        )}
                    >
                        <div className="w-full border-t border-slate-100">
                            <table id="pillar-analysis-table-el" className="w-full text-[11px] text-left border-collapse">
                                <thead className="bg-slate-50 sticky top-0 z-10">
                                    <tr className="border-b border-slate-200">
                                        <SortableTableHeader column="Agent" label="Agent Email" sortKey={pillarTable.sortKey} sortDirection={pillarTable.direction} onSort={pillarTable.toggleSort} onFilter={pillarTable.setColumnFilter} filterValue={pillarTable.filters['Agent']} data={pillarData} className="p-3 pl-6" />
                                        <SortableTableHeader column="audits" label="Audits" sortKey={pillarTable.sortKey} sortDirection={pillarTable.direction} onSort={pillarTable.toggleSort} onFilter={pillarTable.setColumnFilter} filterValue={pillarTable.filters['audits']} data={pillarData} className="p-3 text-center" />
                                        <th className="p-3 font-bold text-blue-700">Communication</th>
                                        <th className="p-3 font-bold text-purple-700">Personalisation</th>
                                        <th className="p-3 font-bold text-emerald-700">Efficiency</th>
                                        <th className="p-3 font-bold text-slate-700 min-w-[300px]">TL Action Plan</th>
                                    </tr>
                                </thead>
                                <tbody className="divide-y divide-slate-100">
                                    {pillarTable.data.map((d, i) => (
                                        <tr key={i} className="hover:bg-slate-50 transition-colors">
                                            <td className="p-3 pl-6 font-bold text-slate-700">{d.Agent}</td>
                                            <td className="p-3 text-center">{d.audits}</td>
                                            <td className="p-3">
                                                <ul className="list-disc ml-4 text-blue-600">
                                                    {Object.keys(d.Communication).length > 0 ? Object.entries(d.Communication).map(([m, count], idx) => <li key={idx}><span className="font-medium text-slate-600">{m}</span> :- <span className="font-bold text-slate-800">{count}</span></li>) : <span className="text-slate-300 italic">None</span>}
                                                </ul>
                                            </td>
                                            <td className="p-3">
                                                <ul className="list-disc ml-4 text-purple-600">
                                                    {Object.keys(d.Personalisation).length > 0 ? Object.entries(d.Personalisation).map(([m, count], idx) => <li key={idx}><span className="font-medium text-slate-600">{m}</span> :- <span className="font-bold text-slate-800">{count}</span></li>) : <span className="text-slate-300 italic">None</span>}
                                                </ul>
                                            </td>
                                            <td className="p-3">
                                                <ul className="list-disc ml-4 text-emerald-600">
                                                    {Object.keys(d.Efficiency).length > 0 ? Object.entries(d.Efficiency).map(([m, count], idx) => <li key={idx}><span className="font-medium text-slate-600">{m}</span> :- <span className="font-bold text-slate-800">{count}</span></li>) : <span className="text-slate-300 italic">None</span>}
                                                </ul>
                                            </td>
                                            <td className="p-3 min-w-[300px] max-w-[400px] whitespace-normal break-words">
                                                <ul className="text-xs space-y-2 text-slate-800 list-disc pl-4 font-bold" style={{ color: '#1e293b' }}>
                                                    <li>121 File feedback</li>
                                                    <li>Weekly Performance Summary in Slack group DM.</li>
                                                    <li>Additional Chat Reviews.</li>
                                                    {actionPlans[d.Agent] && actionPlans[d.Agent].map((item, idx) => (
                                                        <li key={`gen-${idx}`} className="text-indigo-600 animate-in fade-in font-bold">{item}</li>
                                                    ))}
                                                </ul>
                                                <button
                                                    onClick={async () => {
                                                        if (loadingPlans[d.Agent]) return;
                                                        setLoadingPlans(prev => ({ ...prev, [d.Agent]: true }));
                                                        showToast("Generating plan...", 'info');
                                                        const commFails = Object.keys(d.Communication).join(', ');
                                                        const persFails = Object.keys(d.Personalisation).join(', ');
                                                        const effFails = Object.keys(d.Efficiency).join(', ');


                                                        const p = `Generate a Team Leader Action Plan for agent ${d.Agent}.
                                                        Failures: Communication (${commFails}), Personalisation (${persFails}), Efficiency (${effFails}).
                                                        
                                                        Structure:
                                                        1. Title: "**? TL Action Plan: ${d.Agent} ?**"
                                                        2. **Actionable Steps**: 2-3 specific bullet points.
                                                        
                                                        RETURN ONLY THE TITLE AND BULLET POINTS as plain text lines.`;
                                                        try {
                                                            const resp = await GeminiAI.generate(p);
                                                            const lines = resp.split('\n').map(l => l.replace(/^[-*] /, '').trim()).filter(l => l.length > 5);
                                                            setActionPlans(prev => ({ ...prev, [d.Agent]: [...(prev[d.Agent] || []), ...lines] }));
                                                            showToast("Plan updated!", 'success');
                                                        } catch (e) {
                                                            console.error(e);
                                                            showToast("Generation failed", 'error');
                                                        } finally {
                                                            setLoadingPlans(prev => ({ ...prev, [d.Agent]: false }));
                                                        }
                                                    }}
                                                    disabled={loadingPlans[d.Agent]}
                                                    className={`mt-3 px-2 py-1 bg-blue-50 text-blue-600 rounded font-bold hover:bg-blue-100 transition-all text-[10px] no-export flex items-center gap-1 ${loadingPlans[d.Agent] ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                    data-html2canvas-ignore="true"
                                                >
                                                    {loadingPlans[d.Agent] ? <div className="w-3 h-3 border-2 border-blue-600 border-t-transparent rounded-full animate-spin" /> : <Sparkles size={10} />}
                                                    {loadingPlans[d.Agent] ? 'Drafting...' : 'Draft Plan'}
                                                </button>
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </Card>
                </div>
            );
        };


        const CoachingPlanGenerator = ({ agents, onGenerate, onCancel, onEditSelection }) => {
            const [step, setStep] = useState('config'); // config, generating, results
            const [config, setConfig] = useState({ includeNPS: true, includeQC: true, includeCompliance: true });
            const [progress, setProgress] = useState(0);
            const [results, setResults] = useState([]);
            const [currentPage, setCurrentPage] = useState(0);
            const [generatingPage, setGeneratingPage] = useState(null);

            const handleGenerate = async () => {
                setStep('generating');
                setProgress(0);
                // Start with empty results for incremental display
                setResults([]);

                // Stream generation - append results as they complete
                for (let i = 0; i < agents.length; i++) {
                    const agent = agents[i];
                    setGeneratingPage(i);
                    
                    try {
                        const result = await onGenerate(agent, config);
                        const version = { content: result, timestamp: Date.now() };
                        
                        setResults(prev => [
                            ...prev,
                            {
                                agent,
                                content: result,
                                versions: [version],
                                currentVersionIndex: 0,
                                isGenerating: false
                            }
                        ]);
                    } catch (e) {
                        setResults(prev => [
                            ...prev,
                            {
                                agent,
                                content: "Error generating report.",
                                versions: [{ content: "Error generating report.", timestamp: Date.now() }],
                                currentVersionIndex: 0,
                                isGenerating: false
                            }
                        ]);
                    }
                    
                    setProgress(Math.round(((i + 1) / agents.length) * 100));
                }
                
                setGeneratingPage(null);
                setStep('results');
            };

            const handleUpdateResult = (pageIndex, content, versions, versionIndex) => {
                setResults(prev => {
                    const newResults = [...prev];
                    newResults[pageIndex] = {
                        ...newResults[pageIndex],
                        content,
                        versions,
                        currentVersionIndex: versionIndex
                    };
                    return newResults;
                });
            };

            const handleRegeneratePage = async (pageIndex) => {
                const agent = results[pageIndex]?.agent;
                if (!agent) return;
                
                try {
                    const newContent = await onGenerate(agent, config);
                    const newVersion = { content: newContent, timestamp: Date.now() };
                    
                    setResults(prev => {
                        const newResults = [...prev];
                        const existingVersions = newResults[pageIndex].versions || [];
                        newResults[pageIndex] = {
                            ...newResults[pageIndex],
                            content: newContent,
                            versions: [...existingVersions, newVersion],
                            currentVersionIndex: existingVersions.length
                        };
                        return newResults;
                    });
                    
                    return newContent;
                } catch (e) {
                    showToast('Regeneration failed', 'error');
                    throw e;
                }
            };

            const copyAllContent = () => {
                const allContent = results.map(r => `## ${r.agent}\n\n${r.content}`).join('\n\n---\n\n');
                safeCopyToClipboard(allContent);
            };

            const completedResults = results.filter(r => !r.isGenerating).length;

            return (
                <div className="space-y-8 animate-in fade-in slide-in-from-bottom-4">
                    {/* Header Section */}
                    <div className="flex items-center justify-between">
                        <div>
                            <h2 className="text-2xl font-black text-slate-900">Coaching Plan Generator</h2>
                            <p className="text-sm text-slate-500 mt-1">
                                {step === 'config' 
                                    ? `Configure generation for ${agents.length} selected agents` 
                                    : `Generating plans for ${agents.length} agents`}
                            </p>
                        </div>
                        <div className="flex gap-2">
                             {(step === 'results' || (step === 'generating' && completedResults > 0)) && (
                                <button 
                                    onClick={copyAllContent}
                                    className="px-3 py-2 bg-white border border-slate-200 text-slate-600 text-xs font-bold rounded-lg hover:bg-slate-50 transition-all flex items-center gap-2"
                                >
                                    <Copy size={14} /> Copy All
                                </button>
                            )}
                            <button onClick={onCancel} className="p-2 hover:bg-slate-100 rounded-full transition-colors text-slate-500">
                                <XIcon size={20} />
                            </button>
                        </div>
                    </div>

                    {step === 'config' && (
                        <div className="bg-white rounded-2xl border border-slate-200 shadow-sm p-6">
                            <div className="flex justify-between items-center mb-6">
                                <div className="flex items-center gap-2">
                                    <span className="text-sm font-bold text-slate-600">{agents.length} Agents Selected</span>
                                    <div className="flex -space-x-2">
                                        {agents.slice(0, 5).map((a, i) => (
                                            <div key={i} className="w-6 h-6 rounded-full bg-violet-100 border-2 border-white flex items-center justify-center text-[10px] font-bold text-violet-700" title={a}>
                                                {a.charAt(0)}
                                            </div>
                                        ))}
                                        {agents.length > 5 && (
                                            <div className="w-6 h-6 rounded-full bg-slate-100 border-2 border-white flex items-center justify-center text-[8px] font-bold text-slate-600">
                                                +{agents.length - 5}
                                            </div>
                                        )}
                                    </div>
                                </div>
                                <button onClick={onEditSelection} className="text-xs font-bold text-indigo-600 hover:text-indigo-700">
                                    Edit Selection
                                </button>
                            </div>

                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
                                <label className={`p-4 rounded-xl border cursor-pointer transition-all ${config.includeNPS ? 'bg-blue-50 border-blue-200 ring-1 ring-blue-200' : 'bg-white border-slate-200 hover:border-slate-300'}`}>
                                    <div className="flex items-center gap-3">
                                        <input type="checkbox" checked={config.includeNPS} onChange={(e) => setConfig({ ...config, includeNPS: e.target.checked })} className="w-4 h-4 text-blue-600 rounded" />
                                        <div>
                                            <div className="font-bold text-sm text-slate-700">NPS Reviews</div>
                                            <div className="text-xs text-slate-500">Include sentiment data</div>
                                        </div>
                                    </div>
                                </label>
                                <label className={`p-4 rounded-xl border cursor-pointer transition-all ${config.includeQC ? 'bg-amber-50 border-amber-200 ring-1 ring-amber-200' : 'bg-white border-slate-200 hover:border-slate-300'}`}>
                                    <div className="flex items-center gap-3">
                                        <input type="checkbox" checked={config.includeQC} onChange={(e) => setConfig({ ...config, includeQC: e.target.checked })} className="w-4 h-4 text-amber-600 rounded" />
                                        <div>
                                            <div className="font-bold text-sm text-slate-700">QC Audits</div>
                                            <div className="text-xs text-slate-500">Include quality scores</div>
                                        </div>
                                    </div>
                                </label>
                                <label className={`p-4 rounded-xl border cursor-pointer transition-all ${config.includeCompliance ? 'bg-emerald-50 border-emerald-200 ring-1 ring-emerald-200' : 'bg-white border-slate-200 hover:border-slate-300'}`}>
                                    <div className="flex items-center gap-3">
                                        <input type="checkbox" checked={config.includeCompliance} onChange={(e) => setConfig({ ...config, includeCompliance: e.target.checked })} className="w-4 h-4 text-emerald-600 rounded" />
                                        <div>
                                            <div className="font-bold text-sm text-slate-700">Compliance</div>
                                            <div className="text-xs text-slate-500">Pending actions</div>
                                        </div>
                                    </div>
                                </label>
                            </div>

                            <button onClick={handleGenerate} className="w-full px-6 py-4 bg-slate-900 text-white rounded-xl text-sm font-bold uppercase hover:bg-black transition-all shadow-xl hover:shadow-2xl hover:-translate-y-0.5 flex items-center justify-center gap-3">
                                <Zap size={18} />
                                Generate Coaching Plans
                            </button>
                        </div>
                    )}

                    {(step === 'generating' || step === 'results') && (
                        <div className="space-y-6">
                            {/* Progress */}
                            {step === 'generating' && (
                                <div className="bg-white rounded-xl border border-slate-200 p-4">
                                    <div className="flex justify-between text-sm font-bold text-slate-700 mb-2">
                                        <span>Processing...</span>
                                        <span className="text-violet-600">{progress}%</span>
                                    </div>
                                    <div className="w-full bg-slate-100 rounded-full h-2 overflow-hidden">
                                        <div className="bg-violet-600 h-full transition-all duration-500 ease-out" style={{ width: `${progress}%` }}></div>
                                    </div>
                                </div>
                            )}

                            {/* Result Display */}
                            {results.length > 0 && currentPage < results.length && (
                                <div className="space-y-4">
                                    <div className="flex items-center gap-2">
                                        <span className="px-3 py-1 bg-violet-100 text-violet-700 text-xs font-black uppercase rounded-full tracking-wider">
                                            {results[currentPage]?.agent}
                                        </span>
                                        {results[currentPage]?.isGenerating && (
                                            <span className="text-xs text-violet-600 animate-pulse flex items-center gap-1">
                                                <Loader2 size={12} className="animate-spin" /> Generating...
                                            </span>
                                        )}
                                    </div>
                                    
                                    <BulkResultWrapper 
                                        result={results[currentPage]}
                                        isGenerating={results[currentPage]?.isGenerating}
                                        onUpdate={(content, versions, versionIndex) => handleUpdateResult(currentPage, content, versions, versionIndex)}
                                        onRegenerate={() => handleRegeneratePage(currentPage)}
                                    />
                                </div>
                            )}

                            {/* Pagination */}
                            {results.length > 1 && (
                                <div className="bg-white rounded-xl border border-slate-200 p-4 flex justify-between items-center">
                                    <div className="text-xs font-bold text-slate-500">
                                        {currentPage + 1} of {results.length} Plans
                                    </div>
                                    <PaginationControls 
                                        currentPage={currentPage}
                                        totalPages={results.length}
                                        onPageChange={setCurrentPage}
                                        generatingPage={generatingPage}
                                    />
                                </div>
                            )}
                        </div>
                    )}
                </div>
            );
        };


        const SpotlightView = ({
            spotlightAgent,
            filterOptions,
            setSpotlightAgent,
            processedData,
            METRIC_MAPPING,
            downloadAsImage,
            type = 'NPS',
            askAI,
            npsData: _npsData,
            qcData: _qcData,
            setActiveTab,
            masterData,
            onExpand: handleExpand,
            bulkAction,
            bulkAgents,
            setBulkAgents,
            onBulkGenerate
        }) => {
            if (bulkAgents && bulkAgents.length > 0) {
                return (
                    <CoachingPlanGenerator 
                        agents={bulkAgents}
                        onGenerate={onBulkGenerate}
                        onCancel={() => setBulkAgents([])}
                        onEditSelection={bulkAction?.onClick} 
                    />
                );
            }

            const [showChartValues, setShowChartValues] = useState(true);
            const [selectedAgent, setSelectedAgent] = useState(spotlightAgent || "");
            const [loadingRoleplay, setLoadingRoleplay] = useState(false);
            const [showWhatsApp, setShowWhatsApp] = useState(false);
            const [roleplayScript, setRoleplayScript] = useState("");
            const [showDataModal, setShowDataModal] = useState(false);
            const [showQCDataModal, setShowQCDataModal] = useState(false);
            const [slackPost, setSlackPost] = useState("");


            const normalizeNpsRow = (row) => {
                if (row?.mistakes) return row;
                const mistakes = { Communication: 0, Personalisation: 0, Efficiency: 0, Total: 0 };
                const failedMetrics = [];
                Object.entries(NPS_METRIC_MAPPING).forEach(([p, metrics]) => {
                    metrics.forEach(m => {
                        const val = row[m];
                        const isFail = val === false || String(val).toUpperCase() === 'FALSE' || String(val).toUpperCase() === 'NO' || String(val).toUpperCase() === 'FAIL' || val === 0 || val === '0';
                        if (isFail) {
                            mistakes[p]++;
                            mistakes.Total++;
                            failedMetrics.push(m);
                        }
                    });
                });
                return { ...row, mistakes, failedMetrics };
            };
            const normalizeQcRow = (row) => {
                if (row?.calculatedTag || row?.isFail !== undefined) return row;
                const tag = extractQCTag(row);
                const score = parseFloat(row['QC Score']);
                const isFail = score < 100 || row['Pass/Fail'] === 'Fail' || row['Pass/Fail'] === 'FALSE';
                const isFatal = row['Fatal'] === 'TRUE' || row['Fatal'] === true;
                return { ...row, calculatedTag: tag, isFail, isFatal, numericScore: isNaN(score) ? 0 : score };
            };


            const npsRecords = type === 'Unified'
                ? (_npsData || []).map(normalizeNpsRow)
                : (type === 'NPS' ? (processedData || []) : []);
            const qcRecords = type === 'Unified'
                ? (_qcData || []).map(normalizeQcRow)
                : (type === 'QC' ? (processedData || []) : []);
            const agentNPS = spotlightAgent ? npsRecords.filter(r => DataEngine.normalizeAgent(r, 'NPS') === spotlightAgent) : [];
            const agentQC = spotlightAgent ? qcRecords.filter(r => DataEngine.normalizeAgent(r, 'QC') === spotlightAgent) : [];


            const npsFeedbackLoop = (!spotlightAgent || (type !== 'NPS' && type !== 'Unified')) ? null : feedbackLoopCalculator(agentNPS, 'NPS');
            const qcFeedbackLoop = (!spotlightAgent || (type !== 'QC' && type !== 'Unified')) ? null : feedbackLoopCalculator(agentQC, 'QC');


            const spotlightStats = useMemo(() => {
                if (!spotlightAgent) return null;


                const npsMetricScores = {};
                const mapping = type === 'Unified' ? NPS_METRIC_MAPPING : METRIC_MAPPING || NPS_METRIC_MAPPING;
                Object.values(mapping).flat().forEach(m => npsMetricScores[m] = { pass: 0, fail: 0 });
                let npsAuditCount = 0, poorCount = 0, greatOkCount = 0, wowCount = 0, unratedCount = 0;


                agentNPS.forEach(row => {
                    npsAuditCount++;
                    // Check sub-metrics for pass/fail (not Rating)
                    const allSubMetrics = Object.values(mapping).flat();
                    const hasFailedMetric = allSubMetrics.some(m => {
                        const val = row[m];
                        return val === false || String(val).toUpperCase() === 'FALSE' || val === 0 || val === '0';
                    });
                    if (hasFailedMetric) poorCount++; else greatOkCount++;
                    // All metrics pass = WOW equivalent
                    const allMetricsPass = allSubMetrics.every(m => {
                        const val = row[m];
                        return val === true || String(val).toUpperCase() === 'TRUE' || val === 1 || val === '1';
                    });
                    if (allMetricsPass) wowCount++;
                    const hasAnyMetric = allSubMetrics.some(m => row[m] !== undefined && row[m] !== null && row[m] !== '');
                    if (!hasAnyMetric) unratedCount++;
                    const isAuditFail = hasFailedMetric;
                    Object.entries(mapping).forEach(([p, metrics]) => {
                        metrics.forEach(m => {
                            const val = row[m];
                            const isMetricFail = val === false || val === 'FALSE' || val === 'No' || val === 'Fail' || val === 0 || val === '0';
                            if (isAuditFail && isMetricFail) npsMetricScores[m].fail++; else npsMetricScores[m].pass++;
                        });
                    });
                });


                const qcMetricScores = {};
                let qcAuditCount = 0, appealAccepted = 0, appealRejected = 0, qcScoreSum = 0;
                const failTags = {};


                agentQC.forEach(r => {
                    qcAuditCount++;
                    if (String(r['Appeal Status'] || '').toLowerCase().includes('accept')) appealAccepted++;
                    if (String(r['Appeal Status'] || '').toLowerCase().includes('reject')) appealRejected++;
                    qcScoreSum += parseFloat(r['QC Score'] || 0);
                    if (r.isFail) {
                        const tag = r.calculatedTag || r.Question || 'Unknown';
                        if (!qcMetricScores[tag]) qcMetricScores[tag] = { fail: 0 };
                        qcMetricScores[tag].fail++;
                        failTags[tag] = true;
                    }
                });


                const npsMetricsList = Object.entries(npsMetricScores).map(([n, s]) => {
                    const total = s.pass + s.fail || s.fail;
                    return { name: n, failRate: (total > 0 ? (s.fail / total) * 100 : 0) };
                });


                const qcMetricsList = Object.entries(qcMetricScores).map(([n, s]) => ({
                    name: n,
                    failRate: (s.fail / (qcAuditCount || 1)) * 100
                }));


                return {
                    nps: {
                        auditCount: npsAuditCount,
                        poorCount,
                        greatOkCount,
                        wowCount,
                        unratedCount,
                        metricScores: npsMetricScores,
                        strengths: npsMetricsList.slice(0, 3),
                        opportunities: [...npsMetricsList].sort((a, b) => b.failRate - a.failRate).slice(0, 3)
                    },
                    qc: {
                        auditCount: qcAuditCount,
                        appealAccepted,
                        appealRejected,
                        totalScore: qcScoreSum,
                        metricScores: qcMetricScores,
                        strengths: qcMetricsList.slice(0, 3),
                        opportunities: [...qcMetricsList].sort((a, b) => b.failRate - a.failRate).slice(0, 3)
                    },
                    strengths: [...npsMetricsList, ...qcMetricsList].sort((a, b) => a.failRate - b.failRate).slice(0, 3),
                    opportunities: [...npsMetricsList, ...qcMetricsList].sort((a, b) => b.failRate - a.failRate).slice(0, 3)
                };
            }, [spotlightAgent, agentNPS, agentQC, type, METRIC_MAPPING]);


            const handleAgentSelect = (e) => {
                const val = e.target.value;
                setSpotlightAgent(val);
                setSelectedAgent(val);
            };


            const downloadDashboardPDF = async () => {
                const elementId = `${type.toLowerCase()}-spotlight-dashboard`;
                const filename = `${spotlightAgent || 'Spotlight'}_Report`;
                try {
                    await ExportEngine.exportToPDFSmart(elementId, filename, { sectionSelector: '.export-atomic' });
                } catch (e) {
                    showToast("PDF Export Failed", 'error');
                }
            };


            const generateRoleplayScript = async () => {
                setLoadingRoleplay(true);
                setRoleplayScript(null);
                try {
                    // 1. Calculate Top Weaknesses
                    const failCounts = {};
                    processedData.forEach(row => {
                        const mapping = type === 'NPS' ? NPS_METRIC_MAPPING : QC_METRIC_MAPPING;
                        Object.entries(mapping).forEach(([p, metrics]) => {
                            metrics.forEach(m => {
                                const val = row[m];
                                const isFail = val === false || String(val).toUpperCase() === 'FALSE' || String(val).toUpperCase() === 'NO' || String(val).toUpperCase() === 'FAIL' || val === 0 || val === '0';
                                if (isFail) failCounts[m] = (failCounts[m] || 0) + 1;
                            });
                        });
                    });

                    const topIssue = Object.entries(failCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || (type === 'NPS' ? "Communication" : "Accuracy");
                    const strengthsString = spotlightStats?.strengths?.map(s => s.name).join(', ') || 'N/A';
                    const opportunitiesString = spotlightStats?.opportunities?.map(o => o.name).join(', ') || 'N/A';

                    const prompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nRole: Expert CX Coach. Task: Generate a Roleplay Script for ${spotlightAgent}.\nContext: ${type} performance.\nTop Issue for Roleplay: ${topIssue}\nAgent Strengths: ${strengthsString}\nAgent Opportunities: ${opportunitiesString}\n\nSTRICT RULES:\n1. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.\n2. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).\n3. NO hashtags (#).\n4. Do NOT use the word "Bold", "Underline", or "B" as text.\n\nTone: Constructive, Professional, Realistic.\n\nStructure:\n**Roleplay Scenario**: Set the scene.\n**Instructions for the Coach**: How to play the customer/user.\n**Script Flow**:\nCustomer: [Line]\nAgent: [Line]\n...\n**Coach's Note**: 1 secret tip for the coach.`;

                    const script = await GeminiAI.generate(prompt);
                    setRoleplayScript(script);
                } catch (e) {
                    console.error("Roleplay Generation Error:", e);
                    showToast("Failed to generate roleplay script. Please try again.", 'error');
                } finally {
                    setLoadingRoleplay(false);
                }
            };


            const feedbackLoopData = type === 'Unified'
                ? {
                    provided: (npsFeedbackLoop?.provided || 0) + (qcFeedbackLoop?.provided || 0),
                    pendingTick: (npsFeedbackLoop?.pendingTick || 0) + (qcFeedbackLoop?.pendingTick || 0),
                    pendingWritten: (npsFeedbackLoop?.pendingWritten || 0) + (qcFeedbackLoop?.pendingWritten || 0)
                }
                : (type === 'NPS' ? npsFeedbackLoop : qcFeedbackLoop);


            const qcFeedbackProvidedRows = useMemo(() => {
                if (!spotlightAgent) return [];
                const agentData = agentQC;
                const normalized = agentData.map(d => normalizeCompliance(d, 'QC'));
                const rows = [];
                normalized.forEach((d, i) => {
                    if (d.isMandatory) {
                        rows.push({
                            ...agentData[i],
                            _isAck: d.isAck,
                            _hasJustification: d.hasJustification,
                            _status: d.status
                        });
                    }
                });
                return rows;
            }, [spotlightAgent, agentQC]);


            const feedbackProvidedRows = useMemo(() => {
                if (!spotlightAgent) return [];
                const normalized = agentNPS.map(d => normalizeCompliance(d, 'NPS'));
                return normalized
                    .filter(d => d.isMandatory)
                    .map((d, i) => ({
                        ...agentNPS[i],
                        _isAck: d.isAck,
                        _hasJustification: d.hasJustification,
                        _status: d.status
                    }));
            }, [spotlightAgent, agentNPS]);


            const hasAgent = !!spotlightAgent;


            return (
                <div id={`${type.toLowerCase()}-spotlight-dashboard`} className="space-y-6">
                    <AgentSelector
                        value={spotlightAgent}
                        onChange={handleAgentSelect}
                        options={filterOptions.agent || []}
                        label={`${type} Spotlight`}
                        selectedAgent={spotlightAgent}
                        action={bulkAction && bulkAction.onClick && (
                            <button
                                onClick={bulkAction.onClick}
                                className="px-4 py-2 bg-violet-600 text-white rounded-xl font-bold text-xs hover:bg-violet-700 transition-all shadow-md flex items-center gap-2"
                                data-html2canvas-ignore="true"
                            >
                                <Users size={16} /> {bulkAction.label || 'Bulk Generate'}
                            </button>
                        )}
                    />


                    {!hasAgent && (
                        <div className="text-center py-20 bg-slate-50 border-2 border-dashed border-slate-200 rounded-[2.5rem]">
                            <Users className="text-slate-500 mx-auto mb-4" size={48} />
                            <h3 className="text-slate-800 font-bold text-lg">No Agent Selected</h3>
                        </div>
                    )}


                    {hasAgent && (
                        <div className="space-y-6">
                            <div data-html2canvas-ignore="true" className="flex flex-col gap-6">
                                <CoachingGenerator
                                    agentName={spotlightAgent}
                                    strengths={spotlightStats?.strengths || []}
                                    opportunities={spotlightStats?.opportunities || []}
                                    onDownload={downloadAsImage}
                                    feedbackLoopData={feedbackLoopData}
                                    processedData={[...agentNPS, ...agentQC]}
                                    type={type}
                                    askAI={askAI}
                                />


                                <div className="flex justify-end gap-2 flex-wrap">
                                    <button
                                        onClick={generateRoleplayScript}
                                        disabled={loadingRoleplay}
                                        className="px-4 py-2 bg-gradient-to-r from-pink-600 to-rose-600 text-white rounded-lg text-xs font-bold uppercase flex items-center gap-2 hover:shadow-lg transition-all disabled:opacity-50"
                                    >
                                        {loadingRoleplay
                                            ? <div className="w-3 h-3 border-2 border-white border-t-transparent rounded-full animate-spin" />
                                            : <MessageSquare size={14} />}
                                        Active Roleplay
                                    </button>

                                    <button
                                        onClick={downloadDashboardPDF}
                                        className="px-4 py-2 bg-rose-600 text-white rounded-lg text-xs font-bold uppercase flex items-center gap-2 hover:bg-rose-700 transition-all shadow-md"
                                    >
                                        <FileText size={14} /> Export PDF
                                    </button>
                                </div>
                            </div>


                            <div className="space-y-8">
                                {spotlightStats && (
                                    <div className="space-y-6">
                                        {type !== 'Unified' && (
                                            <div className="grid grid-cols-1 md:grid-cols-2 gap-6 overflow-visible">
                                                {type === 'NPS' && (
                                                    <Card
                                                        title="NPS Performance"
                                                        id="nps-perf-card"
                                                        type="List"
                                                        onDownloadImage={downloadAsImage}
                                                        sparkleType="NPS"
                                                        askAI={askAI}
                                                    >
                                                        <div className="flex justify-between items-center mb-4">
                                                            <div className="text-2xl font-black text-slate-800">
                                                                {spotlightStats.nps.auditCount}{' '}
                                                                <span className="text-xs text-slate-500 font-bold uppercase">Audits</span>
                                                            </div>
                                                            <div className="px-3 py-1 bg-blue-50 text-blue-600 rounded-full text-xs font-bold uppercase">
                                                                Rating:{' '}
                                                                {spotlightStats.nps.auditCount > 0
                                                                    ? (spotlightStats.nps.greatOkCount / spotlightStats.nps.auditCount * 100).toFixed(0)
                                                                    : 0}
                                                                %
                                                            </div>
                                                        </div>
                                                        <div className="space-y-2">
                                                            {Object.entries(spotlightStats.nps.metricScores).slice(0, 3).map(([m, s]) => {
                                                                const total = s.pass + s.fail;
                                                                const score = total > 0 ? (s.pass / total * 100).toFixed(0) : 0;
                                                                return (
                                                                    <div key={m} className="flex justify-between items-center text-[10px]">
                                                                        <span className="text-slate-500 font-bold">{m}</span>
                                                                        <span className={`font-black ${score < 80 ? 'text-rose-600' : 'text-emerald-600'}`}>
                                                                            {score}%
                                                                        </span>
                                                                    </div>
                                                                );
                                                            })}
                                                        </div>
                                                    </Card>
                                                )}
                                                {type === 'QC' && (
                                                    <Card
                                                        title="QC Performance"
                                                        id="qc-perf-card"
                                                        type="List"
                                                        onDownloadImage={downloadAsImage}
                                                        sparkleType="QC"
                                                        askAI={askAI}
                                                    >
                                                        <div className="flex justify-between items-center mb-4">
                                                            <div className="text-2xl font-black text-slate-800">
                                                                {spotlightStats.qc.auditCount}{' '}
                                                                <span className="text-xs text-slate-500 font-bold uppercase">Audits</span>
                                                            </div>
                                                            <div className="px-3 py-1 bg-purple-50 text-purple-600 rounded-full text-xs font-bold uppercase">
                                                                Total: {spotlightStats.qc.totalScore ? spotlightStats.qc.totalScore.toFixed(2) : '0.00'}
                                                            </div>
                                                        </div>
                                                        <div className="space-y-2">
                                                            {(spotlightStats.qc.strengths || []).slice(0, 3).map((s) => (
                                                                <div key={s.name} className="flex justify-between items-center text-[10px]">
                                                                    <span className="text-slate-500 font-bold">{s.name}</span>
                                                                    <span className="font-black text-emerald-600">
                                                                        {(100 - s.failRate).toFixed(0)}%
                                                                    </span>
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </Card>
                                                )}
                                                <Card
                                                    title="Strengths & Focus"
                                                    id="spotlight-strengths-card"
                                                    type="List"
                                                    onDownloadImage={downloadAsImage}
                                                    sparkleType={type}
                                                    askAI={askAI}
                                                    infoText="Top performing and low performing metrics."
                                                >
                                                    <div className="grid grid-cols-2 gap-4 text-xs h-32 overflow-y-auto custom-scrollbar">
                                                        <div>
                                                            <h4 className="font-bold text-emerald-600 mb-2 border-b border-emerald-100 pb-1">
                                                                Strengths
                                                            </h4>
                                                            {(type === 'NPS' ? spotlightStats.nps.strengths : spotlightStats.qc.strengths).map(s => (
                                                                <div key={s.name} className="flex justify-between mb-1">
                                                                    <span className="text-slate-600 truncate mr-1" title={s.name}>
                                                                        {s.name}
                                                                    </span>
                                                                    <span className="font-bold text-emerald-600">
                                                                        {(100 - s.failRate).toFixed(0)}%
                                                                    </span>
                                                                </div>
                                                            ))}
                                                        </div>
                                                        <div>
                                                            <h4 className="font-bold text-rose-600 mb-2 border-b border-rose-100 pb-1">
                                                                Focus Areas
                                                            </h4>
                                                            {(type === 'NPS' ? spotlightStats.nps.opportunities : spotlightStats.qc.opportunities).map(s => (
                                                                <div key={s.name} className="flex justify-between mb-1">
                                                                    <span className="text-slate-600 truncate mr-1" title={s.name}>
                                                                        {s.name}
                                                                    </span>
                                                                    <span className="font-bold text-rose-600">
                                                                        {s.failRate.toFixed(0)}%
                                                                    </span>
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                </Card>
                                            </div>
                                        )}
                                        {type === 'Unified' && (
                                            <div className="space-y-8">
                                                <div className="space-y-3">
                                                    <div className="text-xs font-bold uppercase tracking-wide text-slate-500">NPS Spotlight</div>
                                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6 overflow-visible">
                                                        <Card
                                                            title="NPS Performance"
                                                            id="nps-perf-card"
                                                            type="List"
                                                            onDownloadImage={downloadAsImage}
                                                            sparkleType="NPS"
                                                            askAI={askAI}
                                                        >
                                                            <div className="flex justify-between items-center mb-4">
                                                                <div className="text-2xl font-black text-slate-800">
                                                                    {spotlightStats.nps.auditCount}{' '}
                                                                    <span className="text-xs text-slate-500 font-bold uppercase">Audits</span>
                                                                </div>
                                                                <div className="px-3 py-1 bg-blue-50 text-blue-600 rounded-full text-xs font-bold uppercase">
                                                                    Rating:{' '}
                                                                    {spotlightStats.nps.auditCount > 0
                                                                        ? (spotlightStats.nps.greatOkCount / spotlightStats.nps.auditCount * 100).toFixed(0)
                                                                        : 0}
                                                                    %
                                                                </div>
                                                            </div>
                                                            <div className="space-y-2">
                                                                {Object.entries(spotlightStats.nps.metricScores).slice(0, 3).map(([m, s]) => {
                                                                    const total = s.pass + s.fail;
                                                                    const score = total > 0 ? (s.pass / total * 100).toFixed(0) : 0;
                                                                    return (
                                                                        <div key={m} className="flex justify-between items-center text-[10px]">
                                                                            <span className="text-slate-500 font-bold">{m}</span>
                                                                            <span className={`font-black ${score < 80 ? 'text-rose-600' : 'text-emerald-600'}`}>
                                                                                {score}%
                                                                            </span>
                                                                        </div>
                                                                    );
                                                                })}
                                                            </div>
                                                        </Card>
                                                        <Card
                                                            title="Strengths & Focus"
                                                            id="nps-strengths-card"
                                                            type="List"
                                                            onDownloadImage={downloadAsImage}
                                                            sparkleType="NPS"
                                                            askAI={askAI}
                                                            infoText="Top performing and low performing metrics."
                                                        >
                                                            <div className="grid grid-cols-2 gap-4 text-xs h-32 overflow-y-auto custom-scrollbar">
                                                                <div>
                                                                    <h4 className="font-bold text-emerald-600 mb-2 border-b border-emerald-100 pb-1">
                                                                        Strengths
                                                                    </h4>
                                                                    {(spotlightStats.nps.strengths || []).map(s => (
                                                                        <div key={s.name} className="flex justify-between mb-1">
                                                                            <span className="text-slate-600 truncate mr-1" title={s.name}>
                                                                                {s.name}
                                                                            </span>
                                                                            <span className="font-bold text-emerald-600">
                                                                                {(100 - s.failRate).toFixed(0)}%
                                                                            </span>
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                                <div>
                                                                    <h4 className="font-bold text-rose-600 mb-2 border-b border-rose-100 pb-1">
                                                                        Focus Areas
                                                                    </h4>
                                                                    {(spotlightStats.nps.opportunities || []).map(s => (
                                                                        <div key={s.name} className="flex justify-between mb-1">
                                                                            <span className="text-slate-600 truncate mr-1" title={s.name}>
                                                                                {s.name}
                                                                            </span>
                                                                            <span className="font-bold text-rose-600">
                                                                                {s.failRate.toFixed(0)}%
                                                                            </span>
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            </div>
                                                        </Card>
                                                    </div>
                                                </div>
                                                <div className="space-y-3">
                                                    <div className="text-xs font-bold uppercase tracking-wide text-slate-500">QC Spotlight</div>
                                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6 overflow-visible">
                                                        <Card
                                                            title="QC Performance"
                                                            id="qc-perf-card"
                                                            type="List"
                                                            onDownloadImage={downloadAsImage}
                                                            sparkleType="QC"
                                                            askAI={askAI}
                                                        >
                                                            <div className="flex justify-between items-center mb-4">
                                                                <div className="text-2xl font-black text-slate-800">
                                                                    {spotlightStats.qc.auditCount}{' '}
                                                                    <span className="text-xs text-slate-500 font-bold uppercase">Audits</span>
                                                                </div>
                                                                <div className="px-3 py-1 bg-purple-50 text-purple-600 rounded-full text-xs font-bold uppercase">
                                                                    Total: {spotlightStats.qc.totalScore ? spotlightStats.qc.totalScore.toFixed(2) : '0.00'}
                                                                </div>
                                                            </div>
                                                            <div className="space-y-2">
                                                                {(spotlightStats.qc.strengths || []).slice(0, 3).map((s) => (
                                                                    <div key={s.name} className="flex justify-between items-center text-[10px]">
                                                                        <span className="text-slate-500 font-bold">{s.name}</span>
                                                                        <span className="font-black text-emerald-600">
                                                                            {(100 - s.failRate).toFixed(0)}%
                                                                        </span>
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        </Card>
                                                        <Card
                                                            title="Strengths & Focus"
                                                            id="qc-strengths-card"
                                                            type="List"
                                                            onDownloadImage={downloadAsImage}
                                                            sparkleType="QC"
                                                            askAI={askAI}
                                                            infoText="Top performing and low performing metrics."
                                                        >
                                                            <div className="grid grid-cols-2 gap-4 text-xs h-32 overflow-y-auto custom-scrollbar">
                                                                <div>
                                                                    <h4 className="font-bold text-emerald-600 mb-2 border-b border-emerald-100 pb-1">
                                                                        Strengths
                                                                    </h4>
                                                                    {(spotlightStats.qc.strengths || []).map(s => (
                                                                        <div key={s.name} className="flex justify-between mb-1">
                                                                            <span className="text-slate-600 truncate mr-1" title={s.name}>
                                                                                {s.name}
                                                                            </span>
                                                                            <span className="font-bold text-emerald-600">
                                                                                {(100 - s.failRate).toFixed(0)}%
                                                                            </span>
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                                <div>
                                                                    <h4 className="font-bold text-rose-600 mb-2 border-b border-rose-100 pb-1">
                                                                        Focus Areas
                                                                    </h4>
                                                                    {(spotlightStats.qc.opportunities || []).map(s => (
                                                                        <div key={s.name} className="flex justify-between mb-1">
                                                                            <span className="text-slate-600 truncate mr-1" title={s.name}>
                                                                                {s.name}
                                                                            </span>
                                                                            <span className="font-bold text-rose-600">
                                                                                {s.failRate.toFixed(0)}%
                                                                            </span>
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            </div>
                                                        </Card>
                                                    </div>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                )}


                                {spotlightStats && (
                                    <div className="space-y-6">
                                        {type === 'NPS' && (
                                            <div className="grid grid-cols-1 md:grid-cols-5 gap-6">
                                                <KPICard
                                                    title="Audit Count"
                                                    value={spotlightStats.nps.auditCount}
                                                    icon={FileText}
                                                    color="blue"
                                                    info="Total number of NPS survey responses."
                                                    onDownloadImage={downloadAsImage}
                                                    askAI={askAI}
                                                />
                                                <KPICard
                                                    title="Poor Count"
                                                    value={spotlightStats.nps.poorCount}
                                                    icon={AlertCircle}
                                                    color="red"
                                                    info="Number of surveys rated as 'Poor'."
                                                    onDownloadImage={downloadAsImage}
                                                    askAI={askAI}
                                                />
                                                <KPICard
                                                    title="Great/Ok Count"
                                                    value={spotlightStats.nps.greatOkCount}
                                                    icon={CheckCircle}
                                                    color="green"
                                                    info="Number of surveys rated as 'Great' or 'Ok'."
                                                    onDownloadImage={downloadAsImage}
                                                    askAI={askAI}
                                                />
                                                <KPICard
                                                    title="WOW Count"
                                                    value={spotlightStats.nps.wowCount}
                                                    icon={Sparkles}
                                                    color="purple"
                                                    info="Number of surveys rated as 'WOW'."
                                                    onDownloadImage={downloadAsImage}
                                                    askAI={askAI}
                                                />
                                                <KPICard
                                                    title="Unrated Count"
                                                    value={spotlightStats.nps.unratedCount}
                                                    icon={MessageSquare}
                                                    color="slate"
                                                    info="Number of surveys without a clear rating."
                                                    onDownloadImage={downloadAsImage}
                                                    askAI={askAI}
                                                />
                                            </div>
                                        )}
                                        {type === 'QC' && (
                                            <div className="grid grid-cols-1 md:grid-cols-5 gap-6">
                                                <KPICard
                                                    title="QC Audits"
                                                    value={spotlightStats.qc.auditCount}
                                                    icon={FileText}
                                                    color="blue"
                                                    info="Total number of Quality Control audits."
                                                    onDownloadImage={downloadAsImage}
                                                    askAI={askAI}
                                                />
                                                <KPICard
                                                    title="Appeals Accepted"
                                                    value={spotlightStats.qc.appealAccepted}
                                                    icon={CheckCircle}
                                                    color="green"
                                                    info="Number of accepted appeals."
                                                    onDownloadImage={downloadAsImage}
                                                    askAI={askAI}
                                                />
                                                <KPICard
                                                    title="Appeals Rejected"
                                                    value={spotlightStats.qc.appealRejected}
                                                    icon={AlertCircle}
                                                    color="red"
                                                    info="Number of rejected appeals."
                                                    onDownloadImage={downloadAsImage}
                                                    askAI={askAI}
                                                />
                                                <KPICard
                                                    title="Total Score"
                                                    value={typeof spotlightStats.qc.totalScore === 'number' ? spotlightStats.qc.totalScore.toFixed(2) : (parseFloat(spotlightStats.qc.totalScore) || 0).toFixed(2)}
                                                    icon={Target}
                                                    color="indigo"
                                                    info="Total QC score across audits."
                                                    onDownloadImage={downloadAsImage}
                                                    askAI={askAI}
                                                />
                                                <KPICard
                                                    title="Loop Completion"
                                                    value={`${((qcFeedbackLoop?.ackTick || 0) / ((qcFeedbackLoop?.provided || 0) || 1) * 100).toFixed(0)}%`}
                                                    icon={RefreshCw}
                                                    color="blue"
                                                    info="QC feedback loop acknowledgement rate."
                                                    onDownloadImage={downloadAsImage}
                                                    askAI={askAI}
                                                />
                                            </div>
                                        )}
                                        {type === 'Unified' && (
                                            <div className="space-y-8">
                                                <div className="space-y-4">
                                                    <div className="text-xs font-bold uppercase tracking-wide text-slate-500">NPS Spotlight</div>
                                                    <div className="grid grid-cols-1 md:grid-cols-5 gap-6">
                                                        <KPICard
                                                            title="Audit Count"
                                                            value={spotlightStats.nps.auditCount}
                                                            icon={FileText}
                                                            color="blue"
                                                            info="Total number of NPS survey responses."
                                                            onDownloadImage={downloadAsImage}
                                                            askAI={askAI}
                                                        />
                                                        <KPICard
                                                            title="Poor Count"
                                                            value={spotlightStats.nps.poorCount}
                                                            icon={AlertCircle}
                                                            color="red"
                                                            info="Number of surveys rated as 'Poor'."
                                                            onDownloadImage={downloadAsImage}
                                                            askAI={askAI}
                                                        />
                                                        <KPICard
                                                            title="Great/Ok Count"
                                                            value={spotlightStats.nps.greatOkCount}
                                                            icon={CheckCircle}
                                                            color="green"
                                                            info="Number of surveys rated as 'Great' or 'Ok'."
                                                            onDownloadImage={downloadAsImage}
                                                            askAI={askAI}
                                                        />
                                                        <KPICard
                                                            title="WOW Count"
                                                            value={spotlightStats.nps.wowCount}
                                                            icon={Sparkles}
                                                            color="purple"
                                                            info="Number of surveys rated as 'WOW'."
                                                            onDownloadImage={downloadAsImage}
                                                            askAI={askAI}
                                                        />
                                                        <KPICard
                                                            title="Unrated Count"
                                                            value={spotlightStats.nps.unratedCount}
                                                            icon={MessageSquare}
                                                            color="slate"
                                                            info="Number of surveys without a clear rating."
                                                            onDownloadImage={downloadAsImage}
                                                            askAI={askAI}
                                                        />
                                                    </div>
                                                    <DetailedScorecardTable
                                                        title="NPS Scorecard"
                                                        data={spotlightStats.nps.metricScores}
                                                        type="NPS"
                                                        onDownloadImage={downloadAsImage}
                                                        tableId="nps-scorecard"
                                                        askAI={askAI}
                                                    />
                                                    {npsFeedbackLoop && (
                                                        <FeedbackLoopTable
                                                            data={npsFeedbackLoop}
                                                            type="NPS"
                                                            onShowData={() => setShowDataModal(true)}
                                                            showDataButton={true}
                                                            tableId="nps-loop"
                                                            onDownloadImage={downloadAsImage}
                                                            askAI={askAI}
                                                        />
                                                    )}
                                                </div>
                                                <div className="space-y-4">
                                                    <div className="text-xs font-bold uppercase tracking-wide text-slate-500">QC Spotlight</div>
                                                    <div className="grid grid-cols-1 md:grid-cols-5 gap-6">
                                                        <KPICard
                                                            title="QC Audits"
                                                            value={spotlightStats.qc.auditCount}
                                                            icon={FileText}
                                                            color="blue"
                                                            info="Total number of Quality Control audits."
                                                            onDownloadImage={downloadAsImage}
                                                            askAI={askAI}
                                                        />
                                                        <KPICard
                                                            title="Appeals Accepted"
                                                            value={spotlightStats.qc.appealAccepted}
                                                            icon={CheckCircle}
                                                            color="green"
                                                            info="Number of accepted appeals."
                                                            onDownloadImage={downloadAsImage}
                                                            askAI={askAI}
                                                        />
                                                        <KPICard
                                                            title="Appeals Rejected"
                                                            value={spotlightStats.qc.appealRejected}
                                                            icon={AlertCircle}
                                                            color="red"
                                                            info="Number of rejected appeals."
                                                            onDownloadImage={downloadAsImage}
                                                            askAI={askAI}
                                                        />
                                                        <KPICard
                                                            title="Total Score"
                                                            value={typeof spotlightStats.qc.totalScore === 'number' ? spotlightStats.qc.totalScore.toFixed(2) : (parseFloat(spotlightStats.qc.totalScore) || 0).toFixed(2)}
                                                            icon={Target}
                                                            color="indigo"
                                                            info="Total QC score across audits."
                                                            onDownloadImage={downloadAsImage}
                                                            askAI={askAI}
                                                        />
                                                        <KPICard
                                                            title="Loop Completion"
                                                            value={`${((qcFeedbackLoop?.ackTick || 0) / ((qcFeedbackLoop?.provided || 0) || 1) * 100).toFixed(0)}%`}
                                                            icon={RefreshCw}
                                                            color="blue"
                                                            info="QC feedback loop acknowledgement rate."
                                                            onDownloadImage={downloadAsImage}
                                                            askAI={askAI}
                                                        />
                                                    </div>
                                                    <DetailedScorecardTable
                                                        title="QC Scorecard"
                                                        data={spotlightStats.qc.metricScores}
                                                        type="QC"
                                                        onDownloadImage={downloadAsImage}
                                                        tableId="qc-scorecard"
                                                        askAI={askAI}
                                                    />
                                                    {qcFeedbackLoop && (
                                                        <FeedbackLoopTable
                                                            data={qcFeedbackLoop}
                                                            type="QC"
                                                            onShowData={() => setShowQCDataModal(true)}
                                                            showDataButton={true}
                                                            tableId="qc-loop"
                                                            onDownloadImage={downloadAsImage}
                                                            askAI={askAI}
                                                        />
                                                    )}
                                                </div>
                                            </div>
                                        )}


                                        {type === 'NPS' && (
                                            <DetailedScorecardTable
                                                title="NPS Scorecard"
                                                data={spotlightStats.nps.metricScores}
                                                type="NPS"
                                                onDownloadImage={downloadAsImage}
                                                tableId="nps-scorecard"
                                                askAI={askAI}
                                            />
                                        )}
                                        {type === 'QC' && (
                                            <DetailedScorecardTable
                                                title="QC Scorecard"
                                                data={spotlightStats.qc.metricScores}
                                                type="QC"
                                                onDownloadImage={downloadAsImage}
                                                tableId="qc-scorecard"
                                                askAI={askAI}
                                            />
                                        )}
                                        {type === 'NPS' && npsFeedbackLoop && (
                                            <FeedbackLoopTable
                                                data={npsFeedbackLoop}
                                                type="NPS"
                                                onShowData={() => setShowDataModal(true)}
                                                showDataButton={true}
                                                tableId="nps-loop"
                                                onDownloadImage={downloadAsImage}
                                                askAI={askAI}
                                            />
                                        )}
                                        {type === 'QC' && qcFeedbackLoop && (
                                            <FeedbackLoopTable
                                                data={qcFeedbackLoop}
                                                type="QC"
                                                onShowData={() => setShowQCDataModal(true)}
                                                showDataButton={true}
                                                tableId="qc-loop"
                                                onDownloadImage={downloadAsImage}
                                                askAI={askAI}
                                            />
                                        )}
                                    </div>
                                )}
                            </div>


                            <div data-html2canvas-ignore="true">
                                <FeedbackDataModal
                                    isOpen={showDataModal}
                                    onClose={() => setShowDataModal(false)}
                                    title="NPS Feedback Data"
                                    rows={feedbackProvidedRows}
                                    type="NPS"
                                    onDownloadImage={downloadAsImage}
                                />
                                <FeedbackDataModal
                                    isOpen={showQCDataModal}
                                    onClose={() => setShowQCDataModal(false)}
                                    title="QC Feedback Data"
                                    rows={qcFeedbackProvidedRows}
                                    type="QC"
                                    onDownloadImage={downloadAsImage}
                                />
                                {roleplayScript && (
                                    <Modal
                                        isOpen={!!roleplayScript}
                                        onClose={() => setRoleplayScript("")}
                                        title="Roleplay Script"
                                    >
                                        <div
                                            className="p-6 bg-slate-50 rounded-xl markdown-content text-sm"
                                            dangerouslySetInnerHTML={{ __html: safeMarked(roleplayScript) }}
                                        />
                                    </Modal>
                                )}
                                {showWhatsApp && (
                                    <WhatsAppChat
                                        data={[...agentNPS, ...agentQC]}
                                        agentName={spotlightAgent}
                                        onClose={() => setShowWhatsApp(false)}
                                    />
                                )}
                            </div>
                        </div>
                    )}
                </div>
            );
        };




        const MatrixView = ({ data, metricsMapping, onDownload, onAgentSelect, askAI }) => {
            const [mode, setMode] = useState('summary');
            const [showValues, setShowValues] = useState(true);
            const [expandedKey, setExpandedKey] = useState(null); // Local Expansion State
            const agentMatrix = useMemo(() => {
                const agents = {};
                if (!data || !Array.isArray(data) || !metricsMapping) return [];
                data.forEach(row => {
                    const a = row.Agent;
                    if (!a) return;
                    if (!agents[a]) {
                        agents[a] = {
                            name: a,
                            audits: 0,
                            poorCount: 0,
                            greatOkCount: 0,
                            stats: { Communication: { fail: 0, sub: {} }, Personalisation: { fail: 0, sub: {} }, Efficiency: { fail: 0, sub: {} } }
                        };
                        Object.keys(metricsMapping).forEach(p => {
                            if (metricsMapping[p] && Array.isArray(metricsMapping[p])) {
                                metricsMapping[p].forEach(m => {
                                    if (agents[a].stats[p] && agents[a].stats[p].sub) {
                                        agents[a].stats[p].sub[m] = 0;
                                    }
                                });
                            }
                        });
                    }
                    agents[a].audits++;
                    // Count based on sub-metrics (not Rating)
                    const hasFailedMetric = Object.values(metricsMapping).flat().some(m => {
                        const val = row[m];
                        return val === false || String(val).toUpperCase() === 'FALSE' || val === 0 || val === '0';
                    });
                    if (hasFailedMetric) agents[a].poorCount++; else agents[a].greatOkCount++;
                    Object.keys(metricsMapping).forEach(p => {
                        if (metricsMapping[p] && Array.isArray(metricsMapping[p]) && agents[a].stats[p]) {
                            metricsMapping[p].forEach(m => {
                                if (row[m] === false || row[m] === 'FALSE') {
                                    if (agents[a].stats[p].sub) agents[a].stats[p].sub[m]++;
                                    agents[a].stats[p].fail++;
                                }
                            });
                        }
                    });
                });
                return Object.values(agents).map(a => {
                    const totalFails = (a.stats.Communication?.fail || 0) + (a.stats.Personalisation?.fail || 0) + (a.stats.Efficiency?.fail || 0);
                    const flat = { ...a, passRate: a.audits > 0 ? ((1 - (totalFails / (a.audits * 15))) * 100).toFixed(0) : '100' };


                    // Flatten stats for sorting
                    Object.keys(a.stats).forEach(pillar => {
                        flat[pillar] = a.stats[pillar]?.fail || 0;
                        if (a.stats[pillar]?.sub) {
                            Object.keys(a.stats[pillar].sub).forEach(sub => {
                                flat[sub] = a.stats[pillar].sub[sub];
                            });
                        }
                    });
                    return flat;
                });
            }, [data, metricsMapping]);


            const cols = useMemo(() => {
                if (mode === 'summary') return ['Agent', 'Audits', 'Poor Count', 'Great/Ok Count', 'Communication', 'Personalisation', 'Efficiency'];
                return ['Agent', 'Audits', 'Poor Count', 'Great/Ok Count', ...metricsMapping[mode]];
            }, [mode, metricsMapping]);
            const [visible, setVisible] = useState(cols); useEffect(() => setVisible(cols), [cols]);


            // FIX: Destructure 'query' here
            const { data: sorted, toggleSort, setQuery, query, sortKey, direction, setColumnFilter, filters } = useSortableTable(agentMatrix, 'audits');


            // Fix: QC Matrix colors - High (1.0) = red (bad), Low (0.33) = blue (bad), Medium (0.5/0.67) = amber
            const getClr = (v) => {
                if (v === 0) return 'bg-emerald-50 text-emerald-600 font-bold border border-emerald-100';
                // More points = more risk = red. Less points but still bad = blue
                if (v >= 3) return 'bg-red-500 text-white font-bold';
                if (v >= 2) return 'bg-rose-500 text-white font-bold';
                return 'bg-blue-500 text-white font-bold'; // Low count but still bad
            };


            return (
                <div className="space-y-8">
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-8 overflow-visible">
                        <Card
                            title="CX Champions (Top 5)"
                            onDownloadImage={onDownload}
                            onExpand={() => setExpandedKey('CX Champions')}
                            chartId="champions-list"
                            className="border-l-4 border-emerald-500 shadow-lg"
                            infoText="Top 5 agents with highest pass rates. Pass Rate = (1 - Total Fails / (Audits * 15 metrics)) * 100. Click agent name to view detailed spotlight."
                            dataForAI={agentMatrix.sort((a, b) => b.passRate - a.passRate).slice(0, 5).map(a => ({ Agent: a.name, PassRate: a.passRate }))}
                            aiType="NPS"
                            askAI={askAI}
                            showValues={showValues}
                            toggleValues={() => setShowValues(!showValues)}
                        >
                            <div id="champions-list" className="space-y-2 px-4">
                                {agentMatrix.sort((a, b) => {
                                    if (b.passRate !== a.passRate) return b.passRate - a.passRate;
                                    return a.name.localeCompare(b.name);
                                }).slice(0, 5).map((a, i) => (
                                    <div key={i} onClick={() => onAgentSelect(a.name)} className="flex justify-between items-center p-2.5 bg-emerald-50 rounded-xl cursor-pointer hover:scale-[1.02] transition-all">
                                        <span className="font-bold text-emerald-800 text-xs truncate min-w-0 flex-1 pr-2">{a.name}</span>
                                        <span className="text-xs font-bold px-2 py-1 bg-white rounded-lg shadow-sm text-emerald-600 whitespace-nowrap">
                                            {showValues ? `${a.passRate}% SCORE` : 'SCORE'}
                                        </span>
                                    </div>
                                ))}
                            </div>
                        </Card>
                        <Card
                            title="High Risk Focus (Bottom 5)"
                            onDownloadImage={onDownload}
                            onExpand={() => setExpandedKey('High Risk Focus')}
                            chartId="risk-list"
                            className="border-l-4 border-rose-500 shadow-lg"
                            infoText="Bottom 5 agents with lowest pass rates requiring immediate attention. Pass Rate = (1 - Total Fails / (Audits * 15 metrics)) * 100. Click agent name to view detailed spotlight."
                            dataForAI={agentMatrix.sort((a, b) => a.passRate - b.passRate).slice(0, 5).map(a => ({ Agent: a.name, PassRate: a.passRate }))}
                            aiType="NPS"
                            askAI={askAI}
                            showValues={showValues}
                            toggleValues={() => setShowValues(!showValues)}
                        >
                            <div id="risk-list" className="space-y-2 px-4">
                                {agentMatrix.sort((a, b) => {
                                    if (a.passRate !== b.passRate) return a.passRate - b.passRate;
                                    return a.name.localeCompare(b.name);
                                }).slice(0, 5).map((a, i) => (
                                    <div key={i} onClick={() => onAgentSelect(a.name)} className="flex justify-between items-center p-2.5 bg-rose-50 rounded-xl cursor-pointer hover:scale-[1.02] transition-all">
                                        <span className="font-bold text-rose-800 text-xs truncate min-w-0 flex-1 pr-2">{a.name}</span>
                                        <span className="text-xs font-bold px-2 py-1 bg-white rounded-lg shadow-sm text-rose-600 whitespace-nowrap">
                                            {showValues ? `${a.passRate}% SCORE` : 'SCORE'}
                                        </span>
                                    </div>
                                ))}
                            </div>
                        </Card>
                    </div>
                    {/* Repeat Offender Registry removed and moved to Agent Review page (Point 1) */}

                    
                    {sorted.length > 0 &&
                        <Card
                            title="Behavioral Performance Matrix"
                            id="matrix-card-container"
                            onExpand={() => setExpandedKey('Performance Matrix')}
                            onDownloadImage={onDownload}
                            onDownloadCSV={() => ExportEngine.exportCSV(sorted.map(a => {
                                const row = { Agent: a.name, Audits: a.audits, 'Poor Count': a.poorCount, 'Great/Ok Count': a.greatOkCount };
                                if (mode === 'summary') {
                                    row.Communication = a.stats.Communication.fail;
                                    row.Personalisation = a.stats.Personalisation.fail;
                                    row.Efficiency = a.stats.Efficiency.fail;
                                } else {
                                    metricsMapping[mode]?.forEach(m => row[m] = a.stats[mode].sub[m] || 0);
                                }
                                return row;
                            }), `performance_matrix_${mode}`)}
                            onCopyTable={() => copyTableToClipboard(null, sorted.map(a => {
                                const row = { Agent: a.name, Audits: a.audits, 'Poor Count': a.poorCount, 'Great/Ok Count': a.greatOkCount };
                                if (mode === 'summary') {
                                    row.Communication = a.stats.Communication.fail;
                                    row.Personalisation = a.stats.Personalisation.fail;
                                    row.Efficiency = a.stats.Efficiency.fail;
                                } else {
                                    metricsMapping[mode]?.forEach(m => row[m] = a.stats[mode].sub[m] || 0);
                                }
                                return row;
                            }))}
                            infoText="Heatmap of agent performance across all behavior pillars. Red cells indicate higher failure volumes. Filter by pillar to see specific metric breakdowns."
                            dataForAI={sorted.slice(0, 15)}
                            askAI={askAI}
                            showValues={showValues}
                            toggleValues={() => setShowValues(!showValues)}
                            type="Table"
                            headerActions={
                                <div className="flex items-center gap-3">
                                    <div className="flex gap-1 p-1 bg-slate-100 rounded-xl border border-slate-200">
                                        {['summary', ...Object.keys(metricsMapping)].map(p => (
                                            <button
                                                key={p}
                                                onClick={() => setMode(p)}
                                                className={`px-3 py-1 text-[10px] font-black rounded-lg transition-all ${mode === p ? 'bg-white text-indigo-600 shadow-sm' : 'text-slate-500 hover:text-slate-700'}`}
                                            >
                                                {p.toUpperCase()}
                                            </button>
                                        ))}
                                    </div>
                                    <TableColumnMenu
                                        visibleColumns={Object.fromEntries(cols.map(c => [c, visible.includes(c)]))}
                                        toggleColumn={c => setVisible(p => p.includes(c) ? p.filter(x => x !== c) : [...p, c])}
                                        labels={Object.fromEntries(cols.map(c => [c, c]))}
                                    />
                                    <div className="relative">
                                        <Search className="absolute left-3 top-2 text-slate-500" size={14} />
                                        <input
                                            type="text"
                                            placeholder="Quick Search..."
                                            value={query}
                                            onChange={e => setQuery(e.target.value)}
                                            className="pl-9 pr-4 py-1.5 bg-white border border-slate-200 rounded-xl text-[10px] w-48 focus:ring-2 ring-indigo-500 outline-none transition-all"
                                        />
                                    </div>
                                </div>
                            }
                        >
                            <div id="matrix-card-container-table" className="overflow-x-auto flex-1 border-t border-slate-200 custom-scrollbar w-full">
                                <table className="w-full text-xs text-left border-collapse">
                                    <thead className="sticky top-0 z-20">
                                        <tr className="bg-slate-50 border-b border-slate-200 text-slate-500">
                                            {visible.includes('Agent') && <SortableTableHeader column="name" label="Agent" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['name']} data={agentMatrix} className="border-r w-48 sticky left-0 z-20 bg-slate-50" />}
                                            {visible.includes('Audits') && <SortableTableHeader column="audits" label="Audits" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['audits']} data={agentMatrix} className="border-r text-center font-black" />}
                                            {visible.includes('Poor Count') && <SortableTableHeader column="poorCount" label="Poor Count" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['poorCount']} data={agentMatrix} className="border-r text-center font-black" />}
                                            {visible.includes('Great/Ok Count') && <SortableTableHeader column="greatOkCount" label="Great/Ok Count" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['greatOkCount']} data={agentMatrix} className="border-r text-center font-black" />}
                                            {mode === 'summary' ? (
                                                ['Communication', 'Personalisation', 'Efficiency'].filter(p => visible.includes(p)).map(p => (
                                                    <SortableTableHeader key={p} column={p} label={p} sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters[p]} data={agentMatrix} className="border-r text-center font-black" />
                                                ))
                                            ) : (
                                                metricsMapping[mode]?.filter(m => visible.includes(m)).map(m => (
                                                    <SortableTableHeader key={m} column={m} label={m} sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters[m]} data={agentMatrix} className="border-r text-center font-black min-w-[120px]" />
                                                )) || []
                                            )}
                                        </tr></thead>
                                    <tbody className="divide-y divide-slate-100 bg-white">
                                        {sorted.map(a => (
                                            <tr key={a.name} className="hover:bg-slate-50 transition-colors">
                                                {visible.includes('Agent') && (
                                                    <td onClick={() => onAgentSelect(a.name)} className="p-4 font-semibold text-slate-700 sticky left-0 bg-white z-10 border-r border-slate-100 cursor-pointer hover:text-blue-600 underline decoration-blue-200 decoration-2 underline-offset-2">
                                                        <HighlightText text={a.name} highlight={query} />
                                                    </td>
                                                )}
                                                {visible.includes('Audits') && <td className="p-4 text-center font-medium text-slate-500 border-r border-slate-100">{a.audits}</td>}
                                                {visible.includes('Poor Count') && <td className="p-4 text-center font-bold text-rose-600 border-r border-slate-100">{a.poorCount}</td>}
                                                {visible.includes('Great/Ok Count') && <td className="p-4 text-center font-bold text-emerald-600 border-r border-slate-100">{a.greatOkCount}</td>}
                                                {mode === 'summary' ? (
                                                    ['Communication', 'Personalisation', 'Efficiency'].filter(p => visible.includes(p)).map(p => (
                                                        <td key={p} className={`p-4 text-center border-r border-slate-100 ${a.stats[p].fail === 0 ? 'text-emerald-600 bg-emerald-50 font-bold' : 'text-rose-600 bg-rose-50/20 font-bold'}`}>
                                                            {a.stats[p].fail}
                                                        </td>
                                                    ))
                                                ) : (
                                                    metricsMapping[mode]?.filter(m => visible.includes(m)).map(m => (
                                                        <td key={m} className="p-2 border-r border-slate-100 text-center">
                                                            <div className={`inline-flex items-center justify-center w-8 h-8 rounded-lg text-[10px] ${getClr(a.stats[mode].sub[m])}`}>
                                                                {a.stats[mode].sub[m]}
                                                            </div>
                                                        </td>
                                                    )) || []
                                                )}
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                            <Modal isOpen={!!expandedKey} onClose={() => setExpandedKey(null)} title={expandedKey} onDownloadImage={onDownload}>
                                <div className="p-4">
                                    {expandedKey === 'CX Champions' && (
                                        <div id="champions-list-expanded" className="space-y-3">
                                            {agentMatrix.sort((a, b) => b.passRate - a.passRate).slice(0, 5).map((a, i) => (
                                                <div key={i} className="flex justify-between items-center p-4 bg-emerald-50 rounded-xl">
                                                    <span className="font-bold text-emerald-800 text-lg">{a.name}</span>
                                                    <span className="text-lg font-bold px-3 py-1 bg-white rounded-lg shadow-sm text-emerald-600 border border-emerald-100">{a.passRate}% SCORE</span>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                    {expandedKey === 'High Risk Focus' && (
                                        <div id="risk-list-expanded" className="space-y-3">
                                            {agentMatrix.sort((a, b) => a.passRate - b.passRate).slice(0, 5).map((a, i) => (
                                                <div key={i} className="flex justify-between items-center p-4 bg-rose-50 rounded-xl">
                                                    <span className="font-bold text-rose-800 text-lg">{a.name}</span>
                                                    <span className="text-lg font-bold px-3 py-1 bg-white rounded-lg shadow-sm text-rose-600 border border-rose-100">{a.passRate}% SCORE</span>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                    {expandedKey === 'Repeat Offender Registry' && (
                                        <div className={`${agentMatrix.filter(a => Object.values(a.stats).some(p => p.sub && Object.values(p.sub).some(c => c > 1))).length > 30 ? 'overflow-x-auto max-h-[80vh]' : 'overflow-visible h-auto'} border border-slate-200 rounded-xl custom-scrollbar`} id="offender-registry-expanded">
                                            <table className="w-full text-xs text-left border-collapse">
                                                <thead className="sticky top-0 z-20 bg-rose-50/50">
                                                    <tr className="border-b border-rose-200 text-rose-900">
                                                        <th className="p-3 font-bold">Agent</th>
                                                        <th className="p-3 font-bold text-center">Risk Tier</th>
                                                        <th className="p-3 font-bold text-center">Audits</th>
                                                        <th className="p-3 font-bold text-center">Repeat Failures</th>
                                                        <th className="p-3 font-bold">Top Issue</th>
                                                        <th className="p-3 font-bold text-center">Repeat Offender?</th>
                                                    </tr>
                                                </thead>
                                                <tbody className="divide-y divide-rose-50 bg-white">
                                                    {(() => {
                                                        const offenderData = agentMatrix.map(a => {
                                                            const failedMetrics = [];
                                                            Object.entries(a.stats).forEach(([pillar, data]) => {
                                                                if (data.sub) {
                                                                    Object.entries(data.sub).forEach(([metric, count]) => {
                                                                        if (count > 1) failedMetrics.push({ metric, count, pillar });
                                                                    });
                                                                }
                                                            });
                                                            const isRepeatOffender = failedMetrics.length > 0;
                                                            const topIssue = failedMetrics.sort((x, y) => y.count - x.count)[0]?.metric || 'None';
                                                            const totalFails = failedMetrics.reduce((sum, f) => sum + f.count, 0);
                                                            let tier = 'Safe';
                                                            if (totalFails > 5) tier = 'Critical';
                                                            else if (totalFails > 3) tier = 'At Risk';
                                                            else if (totalFails > 0) tier = 'Watchlist';
                                                            return { ...a, failedMetrics, isRepeatOffender, topIssue, totalFails, tier };
                                                        }).filter(a => a.totalFails > 0).sort((a, b) => b.totalFails - a.totalFails);
                                                        return offenderData.map((agent, idx) => (
                                                            <tr key={idx} className="hover:bg-rose-50/30">
                                                                <td className="p-3 font-medium text-slate-700">{agent.name}</td>
                                                                <td className="p-3 text-center">
                                                                    <span className={`inline-flex px-2 py-1 rounded-full text-[10px] font-bold ${
                                                                        agent.tier === 'Critical' ? 'bg-rose-100 text-rose-700' :
                                                                        agent.tier === 'At Risk' ? 'bg-orange-100 text-orange-700' :
                                                                        agent.tier === 'Watchlist' ? 'bg-amber-100 text-amber-700' :
                                                                        'bg-emerald-100 text-emerald-700'
                                                                    }`}>{agent.tier}</span>
                                                                </td>
                                                                <td className="p-3 text-center text-slate-500">{agent.audits}</td>
                                                                <td className="p-3 text-center font-bold text-rose-600">{agent.totalFails}</td>
                                                                <td className="p-3 text-slate-600">{agent.topIssue}</td>
                                                                <td className="p-3 text-center">
                                                                    {agent.isRepeatOffender ? (
                                                                        <span className="inline-flex items-center gap-1 px-2 py-1 bg-rose-100 text-rose-700 rounded-full text-[10px] font-bold">
                                                                            <AlertCircle size={10} /> YES
                                                                        </span>
                                                                    ) : (
                                                                        <span className="text-slate-400 text-[10px]">No</span>
                                                                    )}
                                                                </td>
                                                            </tr>
                                                        ));
                                                    })()}
                                                </tbody>
                                            </table>
                                        </div>
                                    )}
                                    {expandedKey === 'Performance Matrix' && (
                                        <div id="matrix-card-container-expanded">
                                            <TableContainer rowCount={sorted.length}>
                                            <table className="w-full text-xs text-left border-collapse">
                                                <thead className="sticky top-0 z-20">
                                                    <tr className="bg-slate-50 border-b border-slate-200 text-slate-500">
                                                        <th className="p-3 border-r font-bold">Agent</th>
                                                        <th className="p-3 border-r font-bold text-center">Audits</th>
                                                        <th className="p-3 border-r font-bold text-center">Poor Count</th>
                                                        <th className="p-3 border-r font-bold text-center">Great/Ok Count</th>
                                                        {mode === 'summary' ?
                                                            ['Communication', 'Personalisation', 'Efficiency'].map(p => <th key={p} className="p-3 border-r font-bold text-center">{p}</th>) :
                                                            metricsMapping[mode]?.map(m => <th key={m} className="p-3 border-r font-bold text-center min-w-[120px]">{m}</th>)
                                                        }
                                                    </tr>
                                                </thead>
                                                <tbody className="divide-y divide-slate-100 bg-white">
                                                    {sorted.map(a => (
                                                        <tr key={a.name} className="hover:bg-slate-50">
                                                            <td className="p-3 font-semibold text-slate-700 border-r">{a.name}</td>
                                                            <td className="p-3 text-center font-medium text-slate-500 border-r">{a.audits}</td>
                                                            <td className="p-3 text-center font-bold text-rose-600 border-r">{a.poorCount}</td>
                                                            <td className="p-3 text-center font-bold text-emerald-600 border-r">{a.greatOkCount}</td>
                                                            {mode === 'summary' ?
                                                                ['Communication', 'Personalisation', 'Efficiency'].map(p => (
                                                                    <td key={p} className={`p-3 text-center border-r font-bold ${a.stats[p].fail === 0 ? 'text-emerald-600 bg-emerald-50' : 'text-rose-600 bg-rose-50/20'}`}>{a.stats[p].fail}</td>
                                                                )) :
                                                                metricsMapping[mode]?.map(m => (
                                                                    <td key={m} className="p-2 border-r text-center">
                                                                        <div className={`inline-flex items-center justify-center w-8 h-8 rounded-lg text-[10px] ${getClr(a.stats[mode].sub[m])}`}>{a.stats[mode].sub[m]}</div>
                                                                    </td>
                                                                ))
                                                            }
                                                        </tr>
                                                    ))}
                                                </tbody>
                                            </table>
                                            </TableContainer>
                                        </div>
                                    )}
                                </div>
                            </Modal>
                        </Card>
                        }
                </div>
            );
        };


        const StrategicRCAView = ({ processedData, metricsMapping, onDownload, queues, askAI }) => {
            const [expandedKey, setExpandedKey] = useState(null);
            const isQCContext = metricsMapping.Critical !== undefined;
            const isNPSContext = !isQCContext;
            const [gapViewMode, setGapViewMode] = useState(isQCContext ? 'Point' : 'User Problem');
            const [dimension, setDimension] = useState(isQCContext ? 'Question' : 'User Problem');
            const [aiRCA, setAiRCA] = useState({});
            const [loading, setLoading] = useState(false);
            const [showChartValues, setShowChartValues] = useState(true);
            const cols = ['Context', 'Breakdown', 'Strategic Analysis'];
            const [visible, setVisible] = useState(cols);
            const [tableFilters, setTableFilters] = useState({});
            const [rcaWizardOpen, setRcaWizardOpen] = useState(false);
            const [rcaWizardContext, setRcaWizardContext] = useState('');
            const [rcaWizardQuery, setRcaWizardQuery] = useState('');
            const [rcaWizardSelected, setRcaWizardSelected] = useState({});
            const [rcaDraftVersions, setRcaDraftVersions] = useState([]);
            const [rcaDraftIndex, setRcaDraftIndex] = useState(0);
            const rcaDraft = rcaDraftVersions[rcaDraftIndex] || null;
            const [rcaDraftLoading, setRcaDraftLoading] = useState(false);
            const [rcaDraftRefine, setRcaDraftRefine] = useState('');


            const rcaData = useMemo(() => {
                if (!processedData) return [];
                const groups = {};
                processedData.forEach(d => {
                    let key;
                    if (dimension === 'Agent') {
                        key = DataEngine.normalizeAgent(d, isQCContext ? 'QC' : 'NPS') || '(Blank)';
                    } else {
                        key = d[dimension] || d['Question'] || d.calculatedTag || '(Blank)';
                    }
                    if (!groups[key]) groups[key] = { name: key, count: 0, mistakes: 0, metricFails: {}, feedbacks: [] };
                    groups[key].count++;
                    groups[key].mistakes += d.mistakes?.Total || 0;
                    Object.entries(metricsMapping).forEach(([pillar, metrics]) => {
                        metrics.forEach(m => {
                            if (d[m] === false || d[m] === 'FALSE') {
                                if (!groups[key].metricFails[pillar]) groups[key].metricFails[pillar] = {};
                                groups[key].metricFails[pillar][m] = (groups[key].metricFails[pillar][m] || 0) + 1;
                            }
                        });
                    });
                    if (d["Remediation Feedback"] || d["TL RCA"]) groups[key].feedbacks.push(d["Remediation Feedback"] || d["TL RCA"]);
                });
                return Object.values(groups).sort((a, b) => b.mistakes - a.mistakes);
            }, [processedData, dimension, metricsMapping, isQCContext]);


            const sorted = rcaData;


            useEffect(() => {
                if (!rcaWizardOpen) return;
                if (!rcaWizardContext && sorted && sorted.length > 0) {
                    setRcaWizardContext(sorted[0].name);
                }
            }, [rcaWizardOpen, rcaWizardContext, sorted]);


            const wizardRows = useMemo(() => {
                if (!processedData || !rcaWizardContext) return [];
                const rows = processedData.filter(d => {
                    if (dimension === 'Agent') {
                        const agent = DataEngine.normalizeAgent(d, isQCContext ? 'QC' : 'NPS') || '(Blank)';
                        return agent === rcaWizardContext;
                    }
                    const key = d[dimension] || d['Question'] || d.calculatedTag || '(Blank)';
                    return key === rcaWizardContext;
                }).map((d, idx) => {
                    const agent = DataEngine.normalizeAgent(d, isQCContext ? 'QC' : 'NPS') || d.Agent || d['Agent Email'] || '';
                    const question = d['Question'] || d.calculatedTag || '';
                    const dateRaw = d.Date || d['Review Date'] || '';
                    const date = dateRaw ? DataEngine.formatDate(dateRaw) : '';
                    const link = d['Chat Link'] || d['Dante/Bo Link'] || d['Chat link'] || '';
                    const feedback = d['Remediation Feedback'] || d['TL RCA'] || d['Answer Comment'] || d['Feedback'] || d['Outcome'] || '';
                    const label = [agent, question || (d[dimension] || ''), date].filter(Boolean).join('  ') || `Record ${idx + 1}`;
                    const id = `${agent}|${question}|${link}|${date}|${idx}`;
                    return { id, label, link, feedback, row: d };
                });
                return rows.slice(0, 250);
            }, [processedData, rcaWizardContext, dimension, isQCContext]);


            const filteredWizardRows = useMemo(() => {
                const q = rcaWizardQuery.trim().toLowerCase();
                if (!q) return wizardRows;
                return wizardRows.filter(r =>
                    String(r.label || '').toLowerCase().includes(q) ||
                    String(r.feedback || '').toLowerCase().includes(q) ||
                    String(r.link || '').toLowerCase().includes(q)
                );
            }, [wizardRows, rcaWizardQuery]);


            const toggleWizardRow = (id) => {
                setRcaWizardSelected(prev => ({ ...prev, [id]: !prev[id] }));
            };


            const clearWizardSelection = () => setRcaWizardSelected({});


            const selectTopWizard = (n) => {
                const next = {};
                filteredWizardRows.slice(0, n).forEach(r => { next[r.id] = true; });
                setRcaWizardSelected(next);
            };


            const addDraftVersion = (text) => {
                setRcaDraftVersions(prev => {
                    const next = [...prev, text];
                    setRcaDraftIndex(next.length - 1);
                    return next;
                });
            };


            const buildRcaDraftPrompt = (contextName, selectedRows) => {
                const dimensionLabel = dimension;
                const records = selectedRows.slice(0, 15).map(r => {
                    const d = r.row || {};
                    const base = {
                        Agent: DataEngine.normalizeAgent(d, isQCContext ? 'QC' : 'NPS') || d.Agent || d['Agent Email'] || '',
                        Date: (d.Date || d['Review Date']) ? DataEngine.formatDate(d.Date || d['Review Date']) : '',
                        Link: d['Chat Link'] || d['Dante/Bo Link'] || '',
                        Feedback: d['Remediation Feedback'] || d['TL RCA'] || d['Answer Comment'] || d['Feedback'] || d['Outcome'] || ''
                    };
                    if (isQCContext) {
                        base.Question = d['Question'] || d.calculatedTag || '';
                        base.Score = d['QC Score'] || d.numericScore || '';
                        base.Appeal_Status = d['Appeal Status'] || '';
                    } else {
                        base.Rating = d.Rating || '';
                        base.Sub_Metric = d['Sub-metric'] || d['Sub metric'] || '';
                        base.User_Problem = d['User Problem'] || d['Chat Tag'] || '';
                    }
                    return base;
                });
                const recordBullets = records.map(rec => `- ${Object.entries(rec).map(([k, v]) => `${k}: ${String(v || '').trim()}`).join('; ')}`).join('\n');
                return `${AI_PERSONA}
${TL_PERSONA_PROMPT}

Create a Strategic RCA based only on the selected records.

Context:
- Dimension: ${dimensionLabel}
- Focus: "${contextName}"
- Records: ${records.length}

Selected Records:
${recordBullets}

CRITICAL FORMAT:
1. ** Strategic RCA: ${contextName} ** (Title wrapped in star emojis both sides, bold)

2. **Observation**
   - Clear statement of the issue
   - Based on data
   - Objective description

3. **Impact**
   - Quantify if possible
   - Business impact
   - Scope of issue

4. **Root Causes** (3-5 items)
   - Deeper analysis
   - Not just symptoms
   - Underlying issues

5. **Recommendations**
   - Actionable solutions
   - Address root causes
   - Prioritized by impact
   - Use **Sub-metric** / **Question keywords**

6. [Closure - NOT A HEADING]
   - Summary statement with emoji

STRICT OUTPUT RULES:
1. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.
2. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).
3. NO hashtags (#).
4. Do NOT use the word "Bold", "Underline", or "B" as text.
5. NO Sign-off`;
            };


            const generateRcaDraft = async () => {
                if (!rcaWizardContext) return showToast("Select a context.");
                // Filter selected records: Must be selected AND not an appeal (if QC)
                const selected = wizardRows
                    .filter(r => !!rcaWizardSelected[r.id])
                    .filter(r => !DataEngine.isAppeal(r.dataRef) && !DataEngine.isNpsPassAllSubmetrics(r.dataRef)); // Apply Global Appeal & NPS Pass Filter

                if (selected.length === 0) return showToast("Select at least one record (appealed items excluded).");
                setRcaDraftLoading(true);
                try {
                    const prompt = buildRcaDraftPrompt(rcaWizardContext, selected);
                    const text = await GeminiAI.generate(prompt);
                    const formatted = formatSlackMessage(text, 'RCADraft');
                    addDraftVersion(formatted || '');
                } catch (e) {
                    addDraftVersion("Error generating draft.");
                }
                setRcaDraftLoading(false);
            };


            const refineRcaDraft = async () => {
                if (!rcaDraft || !rcaDraftRefine) return;
                setRcaDraftLoading(true);
                try {
                    const text = await generateRefinement(rcaDraft, rcaDraftRefine);
                    addDraftVersion(text || '');
                } catch (e) {
                    addDraftVersion("Error refining draft.");
                }
                setRcaDraftLoading(false);
            };


            const parseRCAFromMarkdown = (text) => {
                const lines = String(text || '').split('\n').map(l => l.trim());
                const getSection = (names) => {
                    let start = -1;
                    for (let i = 0; i < lines.length; i++) {
                        const l = lines[i].toLowerCase();
                        if (names.some(n => l.includes(n))) { start = i; break; }
                    }
                    if (start === -1) return [];
                    const bullets = [];
                    for (let i = start + 1; i < lines.length; i++) {
                        const li = lines[i];
                        if (/^\*\*.+\*\*/.test(li)) break;
                        if (li.startsWith('- ')) bullets.push(li);
                    }
                    return bullets;
                };
                const issues = getSection(['what went wrong', 'issue']);
                const causes = getSection(['root cause', 'root causes']);
                const actions = getSection(['actions', 'action']);
                const maxLen = Math.max(issues.length, causes.length, actions.length);
                const rows = [];
                if (maxLen === 0) {
                    rows.push({ issue: text, root_cause: '', action: '' });
                    return rows;
                }
                for (let i = 0; i < maxLen; i++) {
                    rows.push({
                        issue: issues[i] || '',
                        root_cause: causes[i] || '',
                        action: actions[i] || ''
                    });
                }
                return rows;
            };
            const generateAdvancedRCA = async (type, name, breakdownData, feedbacks, processedData, contextType) => {
                // Issue 3 Fix: Direct API call with header injection
                const apiKey = AIRequestManager.getApiKey();
                
                // Helper for direct fetch with header auth
                const callGeminiDirect = async (prompt, isJson = false, sysInstr = "") => {
                     const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent`;
                     const payload = {
                        contents: [{ parts: [{ text: prompt }] }],
                        systemInstruction: { parts: [{ text: sysInstr }] }
                     };
                     if (isJson) payload.generationConfig = { responseMimeType: "application/json" };
                     
                     const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-goog-api-key': apiKey // Critical Fix: Inject API key in header
                        },
                        body: JSON.stringify(payload)
                     });
                     
                     if (!response.ok) throw new Error(`API Error: ${response.status}`);
                     const data = await response.json();
                     return data.candidates?.[0]?.content?.parts?.[0]?.text;
                };

                // Build context string based on QC dimension
                let contextStr = '';
                if (isQCContext && type === 'Question') {
                    contextStr = `Question: "${name}". Agents who failed this question: ${Array.isArray(breakdownData) ? breakdownData.join(', ') : String(breakdownData)}.`;
                } else if (isQCContext && type === 'Agent') {
                    contextStr = `Agent: "${name}". Questions this agent failed: ${Array.isArray(breakdownData) ? breakdownData.join(', ') : String(breakdownData)}.`;
                } else {
                    contextStr = `Fails: ${Array.isArray(breakdownData) ? breakdownData.join(', ') : String(breakdownData)}.`;
                }


                // For QC: Merge TL RCA + Answer Comment. For NPS: Use Remediation Feedback only
                let mergedFeedbacks = [];
                if (contextType === 'QC') {
                    // Get relevant rows for this context
                    const relevantRows = processedData
                        .filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d)) // Apply Global Appeal & NPS Pass Filter
                        .filter(d => {
                            if (type === 'Question') {
                                const qName = d['Question'] || d.calculatedTag || d.Question;
                                return qName === name && d.mistakes?.Total > 0;
                            } else if (type === 'Agent') {
                                const agentName = DataEngine.normalizeAgent(d, 'QC');
                                return agentName === name && d.mistakes?.Total > 0;
                            } else {
                                return d[type] === name;
                            }
                        });


                    // Merge TL RCA and Answer Comment
                    mergedFeedbacks = relevantRows
                        .filter(d => d['TL RCA'] || d['Answer Comment'])
                        .map(d => {
                            const tlRCA = d['TL RCA'] || '';
                            const answerComment = d['Answer Comment'] || '';
                            return tlRCA && answerComment ? `${tlRCA} ${answerComment}` : (tlRCA || answerComment);
                        })
                        .slice(0, 5);
                } else {
                    // NPS: Use Remediation Feedback only
                    mergedFeedbacks = feedbacks.slice(0, 5);
                }


                const feedbackList = mergedFeedbacks.map(f => `- ${String(f || '').trim()}`).join('\n');
                try {
                    const jsonPrompt = `Strategic RCA for ${type}: "${name}". ${contextStr}
Feedbacks:
${feedbackList}


CRITICAL:
1. Return ONLY a valid JSON object. No Markdown.
2. JSON Structure: { "analysis": [ { "issue": "string", "root_cause": "string", "action": "string" } ] }
3. "issue" must use exact metric/question naming from the input context.
4. Keep values short and actionable.`;
                    
                    // Call Direct
                    const jsonText = await callGeminiDirect(jsonPrompt, true, "Return ONLY valid JSON. No Markdown. No extra text.");
                    
                    try {
                        const parsed = JSON.parse(jsonText || "{}");
                        if (parsed && Array.isArray(parsed.analysis) && parsed.analysis.length > 0) return parsed.analysis;
                    } catch { }


                    const mdPrompt = `${AI_PERSONA}
Strategic RCA for ${type}: "${name}".
${contextStr}


Feedbacks:
${feedbackList}


OUTPUT:
- Use Markdown with **bold** section headers.
- Professional, direct tone.
- Include sections: **Context**, **What Went Wrong**, **Root Cause**, **Actions (next 7 days)**.
- Bullet points only under each section.
- **Bullet Points:** ALWAYS use standard Markdown bullets (-).

STRICT KEYWORD RULES (CRITICAL - DO NOT VIOLATE):
- Use ONLY the exact metric/question names from the input context: "${name}"
- Use ONLY pillar names from NPS data: Communication, Personalisation, Efficiency
- Use ONLY QC categories: Critical, Process, Internal
- **NEVER invent generic terms** like "systemic issues", "process gaps", "training needs"
- **NEVER use** vague analysis terms like "operational challenges", "quality concerns", "performance gaps"
- Every issue and root cause must reference specific metrics from the feedback data
- Bold (**text**) metric names when referenced`;
                    
                    // Call Direct
                    const text = await callGeminiDirect(mdPrompt);
                    
                    const analysis = parseRCAFromMarkdown(text);
                    return analysis.length > 0 ? analysis : [{ issue: text || "Analysis pending", root_cause: "", action: "" }];
                } catch (e) { return [{ issue: "Error generating analysis", root_cause: "", action: "" }]; }
            };


            // FEATURE 4: KNOWLEDGE GAP DETECTOR
            const [kbDraft, setKbDraft] = useState(null);
            const [kbLoading, setKbLoading] = useState(false);
            const [kbBatchLoading, setKbBatchLoading] = useState(false);


            // Fix Issue 33: Agent switch removing table - Fixed logic for Agent view mode
            const knowledgeGaps = useMemo(() => {
                // Apply Global Filters
                const cleanData = processedData ? processedData.filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d)) : [];
                
                if (cleanData.length === 0) return [];
                
                // For Agent view mode, we track different data
                if (gapViewMode === 'Agent') {
                    const agentFails = {};
                    cleanData.forEach(d => {
                        const isRowFail = d.isFail || (d.mistakes && d.mistakes.Total > 0) || d.Rating === 'Poor';
                        if (isRowFail) {
                            const agent = DataEngine.normalizeAgent(d, isQCContext ? 'QC' : 'NPS');
                            if (agent) {
                                // Get what the agent failed on
                                let failKey = '';
                                if (isQCContext) {
                                    failKey = d['Question'] || d.calculatedTag || d.Question || 'Unknown';
                                } else {
                                    failKey = d['User Problem'] || d['User problem'] || d['Chat Tag'] || d['Chat tag'] || d.tag || d['Issue'] || 'Unknown';
                                }
                                if (!agentFails[agent]) agentFails[agent] = new Set();
                                agentFails[agent].add(failKey);
                            }
                        }
                    });
                    const totalAgents = Object.keys(agentFails).length || 1;
                    return Object.entries(agentFails)
                        .map(([agent, failSet]) => ({
                            question: agent,
                            count: failSet.size,
                            impact: Math.round((failSet.size / (isQCContext ? 20 : 10)) * 100), // Approximate impact
                            agents: Array.from(failSet)
                        }))
                        .filter(g => g.count >= 2) // Show agents with 2+ different failures
                        .sort((a, b) => b.count - a.count)
                        .slice(0, 5);
                }
                
                const totalAgents = new Set(cleanData.map(d => DataEngine.normalizeAgent(d, isQCContext ? 'QC' : 'NPS'))).size || 1;

                const gaps = {};
                cleanData.forEach(d => {
                    const isRowFail = d.isFail || (d.mistakes && d.mistakes.Total > 0) || d.Rating === 'Poor';
                    if (isRowFail) {
                        let key = null;
                        if (isQCContext) {
                            if (gapViewMode === 'Point') key = d['Question'] || d.calculatedTag || d.Question;
                            else if (gapViewMode === 'Section') key = d['Category'] || d.Category || d.Pillar || 'Unclassified';
                            else key = d['Question'] || d.calculatedTag || d.Question;
                        } else {
                            if (gapViewMode === 'User Problem') key = d['User Problem'] || d['User problem'];
                            else if (gapViewMode === 'Chat Tag') key = d['Chat Tag'] || d['Chat tag'] || d.tag;
                        }

                        if (!key && gapViewMode === 'User Problem') key = d['Issue'] || d['Sub-metric'];

                        if (key) {
                            const agent = DataEngine.normalizeAgent(d, isQCContext ? 'QC' : 'NPS');
                            if (agent) {
                                if (!gaps[key]) gaps[key] = new Set();
                                gaps[key].add(agent);
                            }
                        }
                    }
                });

                return Object.entries(gaps)
                    .map(([question, agentSet]) => ({
                        question,
                        count: agentSet.size,
                        impact: Math.round((agentSet.size / totalAgents) * 100),
                        agents: Array.from(agentSet)
                    }))
                    .filter(g => g.impact >= (PoppyApp.config.gapImpactThreshold || 15))
                    .sort((a, b) => b.impact - a.impact)
                    .slice(0, 5);
            }, [processedData, isQCContext, metricsMapping, gapViewMode]);


            const handleDraftKB = async (gap) => {
                setKbLoading(gap.question);
                setKbDraft(null);


                // Get sample failures for context
                const contextFailures = processedData
                    .filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d)) // Apply Global Filters
                    .filter(d => {
                        const q = d['Question'] || d.calculatedTag || d.Question;
                        return q === gap.question && d.isFail;
                    })
                    .map(d => d['Remediation Feedback'] || d['TL RCA'] || d['Outcome'] || d['Feedback'])
                    .filter(Boolean)
                    .slice(0, 5);


                const prompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nDraft a Knowledge Base (KB) snippet to address a systemic gap.\nTopic/Question: "${gap.question}"\nImpact: ${gap.impact}% of the team is failing this.\nReal Failure Context: ${JSON.stringify(contextFailures)}\n\nSTRICT RULES:\n1. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.\n2. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).\n3. NO hashtags (#).\n4. Do NOT use the word "Bold", "Underline", or "B" as text.\n\nOUTPUT FORMAT:\n**Title**: [Clear Title]\n**The Rule**: [Brief explanation of the correct process]\n**Common Mistake**: [What agents are doing wrong]\n**Quick Fix**: [Simple instruction to correct it]\n**Example Script**: "[Correct phrase to use]"\n\nKeep it short, scannable, and training-ready.`;


                try {
                    const text = await GeminiAI.generate(prompt);
                    setKbDraft({ title: gap.question, content: text });
                } catch (e) {
                    setKbDraft({ title: "Error", content: "Failed to generate draft." });
                }
                setKbLoading(false);
            };

            const handleGenerateAllKB = async () => {
                if (knowledgeGaps.length === 0) {
                    showToast("No knowledge gaps to draft", 'error');
                    return;
                }
                if (!confirm(`Generate KB updates for ${knowledgeGaps.length} gaps?`)) return;
                setKbBatchLoading(true);
                showToast(`Generating ${knowledgeGaps.length} KB updates...`, 'info');
                let successCount = 0;
                for (const gap of knowledgeGaps) {
                    try {
                        await handleDraftKB(gap);
                        successCount++;
                    } catch (e) {
                        console.error("KB draft failed", e);
                    }
                }
                showToast(`Draft generation complete! ${successCount} updates created.`, 'success');
                setKbBatchLoading(false);
            };





            const handleAnalyzeAll = async () => {
                setLoading(true);
                const newRCA = { ...aiRCA };
                try {
                    const promises = sorted.slice(0, 15).map(async (item) => {
                        if (!newRCA[item.name]) {
                            try {
                                // For QC context, pass the breakdown data (agents or questions) instead of metricFails
                                let breakdownData;
                                if (isQCContext && dimension === 'Question') {
                                    breakdownData = [...new Set(processedData.filter(d => {
                                        // Apply Global Appeal Filter
                                        if (DataEngine.isAppeal(d) || DataEngine.isNpsPassAllSubmetrics(d)) return false;
                                        const qName = d['Question'] || d.calculatedTag || d.Question;
                                        return qName === item.name && d.mistakes?.Total > 0;
                                    }).map(d => DataEngine.normalizeAgent(d, 'QC')).filter(Boolean))];
                                } else if (isQCContext && dimension === 'Agent') {
                                    breakdownData = [...new Set(processedData.filter(d => {
                                        // Apply Global Appeal Filter
                                        if (DataEngine.isAppeal(d) || DataEngine.isNpsPassAllSubmetrics(d)) return false;
                                        const agentName = DataEngine.normalizeAgent(d, 'QC');
                                        return agentName === item.name && d.mistakes?.Total > 0;
                                    }).map(d => d['Question'] || d.calculatedTag || d.Question).filter(Boolean))];
                                } else {
                                    breakdownData = item.metricFails;
                                }
                                newRCA[item.name] = await generateAdvancedRCA(dimension, item.name, breakdownData, item.feedbacks, processedData, isQCContext ? 'QC' : 'NPS');
                            } catch (err) {
                                console.error(`Failed to analyze ${item.name}`, err);
                                newRCA[item.name] = [{ issue: "Analysis Failed", root_cause: "API Error", action: "Try again later" }];
                            }
                        }
                    });
                    await Promise.all(promises);
                } catch (e) {
                    console.error("Global Analysis Error", e);
                }
                setAiRCA(newRCA);
                setLoading(false);
            };





            // Fix: RCA Mistake Breakdown - For QC show Agent/Question list, for NPS show metric breakdown
            const renderMarkdownCol = (fails, dim, data, contextName) => {
                if (isQCContext && dim === 'Question') {
                    // QC Question view: Show agents who got this question wrong
                    const questionData = data
                        .filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d))
                        .filter(d => {
                        const qName = d['Question'] || d.calculatedTag || d.Question;
                        return qName === contextName && d.mistakes?.Total > 0;
                    });
                    const agents = [...new Set(questionData.map(d => DataEngine.normalizeAgent(d, 'QC')).filter(Boolean))];
                    if (agents.length === 0) return <span className="text-slate-300 italic text-sm">No agents</span>;
                    return (
                        <ul className="text-sm space-y-1 text-slate-700 pl-4 list-disc" style={{ listStyleType: 'disc', paddingLeft: '20px', margin: 0, color: '#334155' }}>
                            {agents.map((agent, idx) => (
                                <li key={idx} className="leading-relaxed" style={{ marginBottom: '4px' }}>{agent}</li>
                            ))}
                        </ul>
                    );
                } else if (isQCContext && dim === 'Agent') {
                    // QC Agent view: Show questions this agent got wrong
                    const agentData = data
                        .filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d))
                        .filter(d => {
                        const agentName = DataEngine.normalizeAgent(d, 'QC');
                        return agentName === contextName && d.mistakes?.Total > 0;
                    });
                    const questions = [...new Set(agentData.map(d => d['Question'] || d.calculatedTag || d.Question).filter(Boolean))];
                    if (questions.length === 0) return <span className="text-slate-300 italic text-sm">No questions</span>;
                    return (
                        <ul className="text-sm space-y-1 text-slate-700 pl-4 list-disc" style={{ listStyleType: 'disc', paddingLeft: '20px', margin: 0, color: '#334155' }}>
                            {questions.map((q, idx) => (
                                <li key={idx} className="leading-relaxed" style={{ marginBottom: '4px' }}>{q}</li>
                            ))}
                        </ul>
                    );
                } else {
                    // NPS view: Show metric breakdown
                    if (!fails || Object.keys(fails).length === 0) return <span className="text-slate-300 italic text-sm"> No Fails</span>;
                    return (
                        <div className="space-y-2">
                            {Object.entries(fails).map(([pillar, metrics]) => (
                                <div key={pillar} className="mb-3">
                                    <p className="font-semibold text-sm text-slate-800 mb-1">{pillar}</p>
                                    <ul className="text-sm space-y-1 text-slate-700 pl-4 list-disc" style={{ listStyleType: 'disc', paddingLeft: '20px', margin: 0, color: '#334155' }}>
                                        {Object.entries(metrics).map(([m, c]) => (
                                            <li key={m} className="leading-relaxed" style={{ marginBottom: '4px' }}>{m}: {c}</li>
                                        ))}
                                    </ul>
                                </div>
                            ))}
                        </div>
                    );
                }
            };


            const renderAnalysisRows = (item, analysisData) => {
                // Apply the same classes to ensure consistent styling
                const cellClass = "p-4 border-r border-slate-100 align-top";
                const textClass = "text-sm text-slate-700 leading-relaxed";
                const textStyle = { fontFamily: "'Inter', sans-serif", fontSize: '14px' };


                if (!analysisData) {
                    return (
                        <tr className="hover:bg-slate-50 transition-colors align-top border-b border-slate-100">
                            <td className="p-4 font-semibold text-slate-800 border-r border-slate-100 align-top">{item.name}<div className="text-[10px] text-slate-500 mt-1 font-bold uppercase">{item.count} Audits</div></td>
                            <td className={cellClass}>{renderMarkdownCol(item.metricFails, dimension, processedData, item.name)}</td>
                            <td colSpan="3" className="p-4 text-slate-500 text-xs italic align-top">Pending analysis...</td>
                        </tr>
                    );
                }
                return analysisData.map((row, i) => (
                    <tr key={`${item.name}-${i}`} className="hover:bg-slate-50 transition-colors align-top border-b border-slate-100">
                        {i === 0 && (<><td rowSpan={analysisData.length} className="p-4 font-semibold text-slate-800 border-r border-slate-100 align-top bg-white">{item.name}<div className="text-[10px] text-slate-500 mt-1 font-bold uppercase">{item.count} Audits</div></td><td rowSpan={analysisData.length} className="p-4 border-r border-slate-100 align-top bg-white">{renderMarkdownCol(item.metricFails, dimension, processedData, item.name)}</td></>)}
                        <td className={`${cellClass} ${textClass} whitespace-pre-wrap`} style={textStyle}><div className="whitespace-pre-wrap" style={textStyle}>{row.issue}</div></td>
                        <td className={`${cellClass} ${textClass} whitespace-pre-wrap`} style={textStyle}><div className="whitespace-pre-wrap" style={textStyle}>{row.root_cause}</div></td>
                        <td className={`p-4 align-top ${textClass} whitespace-pre-wrap`} style={textStyle}><div className="whitespace-pre-wrap" style={textStyle}>{row.action}</div></td>
                    </tr>
                ));
            };


            // Phase 4.4: Check context to provide correct dimension options
            // If QC metrics (Critical/Process/SoftSkills) are present, assume QC context
            const isQC = metricsMapping.Critical !== undefined;
            // Fix Issue 18: Use consistent labels for dimension options
            // NPS: User Problem / Chat Tag / Agent
            // QC: Question / Agent
            const dimensionOptions = isQC ? ['Question', 'Agent'] : ['User Problem', 'Chat Tag', 'Agent'];


            return (
                <div className="w-full space-y-8 pb-12">
                    {/* FEATURE 4: KNOWLEDGE GAP DETECTOR UI - Fix Issue 22: Added AI tabs */}
                    {knowledgeGaps.length > 0 && (
                        <Card
                            title="Systemic Knowledge Gaps"
                            icon={AlertCircle}
                            infoText={`The following questions are failing across a wide range of agents (>${15}% impact), indicating a potential gap in training materials or the Knowledge Base.`}
                            askAI={askAI}
                            dataForAI={knowledgeGaps}
                            aiType="Table"
                            type="Table"
                            chartId="knowledge-gaps-section"
                            onDownloadImage={onDownload}
                            onExpand={() => setExpandedKey('Knowledge Gaps')}
                            className="border-rose-100 shadow-sm"
                            type="Table"
                            rowCount={knowledgeGaps.length}
                            showValues={showChartValues}
                            toggleValues={() => setShowChartValues(!showChartValues)}
                            onDownloadCSV={() => ExportEngine.exportCSV(knowledgeGaps, 'systemic_knowledge_gaps')}
                            onCopyTable={() => copyTableToClipboard(null, knowledgeGaps)}
                            headerActions={(
                                <div className="flex items-center gap-2">
                                    <button
                                        onClick={handleGenerateAllKB}
                                        disabled={kbBatchLoading}
                                        className="px-3 py-1.5 bg-rose-50 text-rose-700 rounded-lg text-[10px] font-bold hover:bg-rose-100 transition-all flex items-center gap-2 shadow-sm no-export whitespace-nowrap"
                                        data-html2canvas-ignore="true"
                                        title="Generate KB updates for all visible gaps"
                                    >
                                        {kbBatchLoading ? <div className="w-3 h-3 border-2 border-rose-500 border-t-transparent rounded-full animate-spin" /> : <Sparkles size={12} />}
                                        {kbBatchLoading ? "Generating..." : "Generate All KB Updates"}
                                    </button>
                                    <div className="flex bg-slate-100 p-0.5 rounded-lg border border-slate-200">
                                        {(isQCContext ? ['Question', 'Agent'] : ['User Problem', 'Chat Tag', 'Agent']).map(m => (
                                            <button
                                                key={m}
                                                onClick={() => setGapViewMode(m)}
                                                className={`px-3 py-1 text-[10px] font-bold rounded-md transition-all ${gapViewMode === m ? 'bg-white text-indigo-600 shadow-sm' : 'text-slate-500 hover:text-slate-700'}`}
                                            >
                                                {m}
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            )}
                        >
                            <div id="knowledge-gaps-section" className="relative w-full">
                                <div className="absolute top-0 right-0 p-4 opacity-5 pointer-events-none"><BookOpen size={64} className="text-rose-500" /></div>
                                <div className="w-full">
                                    <table className="w-full text-sm text-left">
                                        <thead className="bg-slate-50 border-b border-slate-200">
                                            <tr className="text-slate-700">
                                                <th className="p-3 font-black uppercase text-[10px] tracking-wider text-left">{gapViewMode === 'Agent' ? 'Agent' : 'Question / Metric'}</th>
                                                <th className="p-3 font-black uppercase text-[10px] tracking-wider text-center">{gapViewMode === 'Agent' ? 'Failure Types' : 'Failed Count'}</th>
                                                <th className="p-3 font-black uppercase text-[10px] tracking-wider text-center">{gapViewMode === 'Agent' ? 'Impact Score' : 'Team Impact'}</th>
                                                <th className="p-3 font-black uppercase text-[10px] tracking-wider text-center">Action</th>
                                            </tr>
                                        </thead>
                                        <tbody className="divide-y divide-rose-50">
                                            {knowledgeGaps.map((gap, i) => (
                                                <tr key={i} className="hover:bg-rose-50/30 transition-colors">
                                                    <td className="p-3 font-medium text-slate-700 max-w-[400px] text-left">{gap.question}</td>
                                                    <td className="p-3 text-slate-500 text-center">{gap.count} {gapViewMode === 'Agent' ? 'Types' : 'Agents'}</td>
                                                    <td className="p-3">
                                                        <div className="flex items-center justify-center gap-3">
                                                            <div className="w-24 h-2 bg-slate-100 rounded-full overflow-hidden">
                                                                <div className="h-full bg-rose-500 rounded-full" style={{ width: `${Math.min(gap.impact, 100)}%` }} />
                                                            </div>
                                                            <span className="font-bold text-rose-600">{gap.impact}%</span>
                                                        </div>
                                                    </td>
                                                    <td className="p-3 text-center">
                                                        <button
                                                            onClick={() => handleDraftKB(gap)}
                                                            disabled={kbBatchLoading || kbLoading === gap.question}
                                                            className="inline-flex px-3 py-1.5 bg-white border border-rose-200 text-rose-700 rounded-lg text-xs font-bold hover:bg-rose-50 hover:border-rose-300 transition-all items-center gap-2 shadow-sm no-export"
                                                            data-html2canvas-ignore="true"
                                                        >
                                                            {kbLoading === gap.question ? <div className="w-3 h-3 border-2 border-rose-500 border-t-transparent rounded-full animate-spin" /> : <Sparkles size={12} />}
                                                            {kbLoading === gap.question ? "Drafting..." : "Draft KB Update"}
                                                        </button>
                                                    </td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </Card>
                    )}





                    {/* KB DRAFT MODAL */}
                    {
                        kbDraft && (
                            <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-slate-900/50 backdrop-blur-sm animate-in fade-in">
                                <div className="bg-white rounded-2xl shadow-2xl max-w-2xl w-full flex flex-col max-h-[80vh] animate-in slide-in-from-bottom-4">
                                    <div className="p-6 border-b border-slate-100 flex justify-between items-center bg-gradient-to-r from-slate-50 to-white rounded-t-2xl">
                                        <div>
                                            <h3 className="font-bold text-lg text-slate-800 flex items-center gap-2">
                                                <Sparkles size={18} className="text-violet-600" />
                                                Proposed KB Update
                                            </h3>
                                            <p className="text-xs text-slate-500 mt-1">AI-generated draft based on {knowledgeGaps.find(g => g.question === kbDraft.title)?.count} failures.</p>
                                        </div>
                                        <button onClick={() => setKbDraft(null)} className="p-2 hover:bg-slate-100 rounded-lg transition-colors"><XIcon size={20} className="text-slate-500" /></button>
                                    </div>
                                    <div className="p-6 overflow-y-auto custom-scrollbar">
                                        <div className="p-4 bg-slate-50 rounded-xl border border-slate-200 text-sm leading-relaxed text-slate-700 markdown-content prose prose-sm max-w-none" dangerouslySetInnerHTML={{ __html: safeMarked(kbDraft.content) }} />
                                    </div>
                                    <div className="p-4 border-t border-slate-100 bg-slate-50 rounded-b-2xl flex justify-end gap-3">
                                        <button onClick={() => setKbDraft(null)} className="px-4 py-2 text-slate-600 font-bold text-sm hover:bg-slate-200 rounded-xl transition-colors">Close</button>
                                        <button onClick={() => { safeCopyToClipboard(kbDraft.content); setKbDraft(null); }} className="px-4 py-2 bg-violet-600 text-white font-bold text-sm hover:bg-violet-700 rounded-xl shadow-lg shadow-violet-200 transition-all flex items-center gap-2">
                                            <Copy size={16} /> Copy to Clipboard
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )
                    }


                    {/* Queue Performance Table - Moved from Management Hub */}
                    {
                        isNPSContext && queues && queues.length > 0 && (
                            <Card
                                title="Queue Performance Monitor"
                                id="queue-performance-table"
                                type="Table"
                                onExpand={() => setExpandedKey('Queue Performance')}
                                dataForAI={queues}
                                aiType="NPS"
                                infoText="Benchmarking pass rates across different product queues. Highlights discrepancies in quality across various business lines. Pass Rate = (Clean Audits / Total Audits) * 100."
                                onDownloadImage={onDownload}
                                onDownloadCSV={() => ExportEngine.exportCSV(queues.map(q => ({
                                    'Queue Name': q.name,
                                    Audits: q.total,
                                    'Poor Count': q.poorCount,
                                    'Great/Ok Count': q.greatOkCount,
                                    'Communication Pass %': ((q.CommPass / q.total) * 100).toFixed(0) + '%',
                                    'Personalisation Pass %': ((q.PersPass / q.total) * 100).toFixed(0) + '%',
                                    'Efficiency Pass %': ((q.EffPass / q.total) * 100).toFixed(0) + '%'
                                })), "queue_performance_benchmark")}
                                onCopyTable={() => copyTableToClipboard(null, queues.map(q => ({
                                    'Queue Name': q.name,
                                    Audits: q.total,
                                    'Poor Count': q.poorCount,
                                    'Great/Ok Count': q.greatOkCount,
                                    'Communication Pass %': ((q.CommPass / q.total) * 100).toFixed(0) + '%',
                                    'Personalisation Pass %': ((q.PersPass / q.total) * 100).toFixed(0) + '%',
                                    'Efficiency Pass %': ((q.EffPass / q.total) * 100).toFixed(0) + '%'
                                })))}


                                askAI={askAI}
                                showValues={showChartValues}
                                 toggleValues={() => setShowChartValues(!showChartValues)}
                            >
                                <div id="queue-performance-table" className="w-full">
                                    <table className="w-full text-xs text-left">
                                        <thead className="bg-slate-50 sticky top-0 border-b border-slate-200">
                                            <tr className="text-slate-700">
                                                <th className="p-3 font-black uppercase text-[10px] tracking-wider text-left">Queue Name</th>
                                                <th className="p-3 font-black uppercase text-[10px] tracking-wider text-center">Audits</th>
                                                <th className="p-3 font-black uppercase text-[10px] tracking-wider text-center">Poor Count</th>
                                                <th className="p-3 font-black uppercase text-[10px] tracking-wider text-center">Great/Ok Count</th>
                                                <th className="p-3 font-black uppercase text-[10px] tracking-wider text-center">Communication Pass %</th>
                                                <th className="p-3 font-black uppercase text-[10px] tracking-wider text-center">Personalisation Pass %</th>
                                                <th className="p-3 font-black uppercase text-[10px] tracking-wider text-center">Efficiency Pass %</th>
                                            </tr>
                                        </thead>
                                        <tbody className="divide-y">{queues.sort((a, b) => {
                                            // Sort by total first, then alphabetically by queue name
                                            if (b.total !== a.total) return b.total - a.total;
                                            return a.name.localeCompare(b.name);
                                        }).map((q, i) => (<tr key={i} className="hover:bg-slate-50"><td className="p-3 font-bold text-slate-700">{q.name}</td><td className="p-3 text-center">{q.total}</td><td className="p-3 text-center font-bold text-rose-600">{q.poorCount}</td><td className="p-3 text-center font-bold text-emerald-600">{q.greatOkCount}</td><td className={`p-3 text-center font-bold ${q.CommPass / q.total < 0.85 ? 'text-red-500' : 'text-green-600'}`}>{((q.CommPass / q.total) * 100).toFixed(0)}%</td><td className={`p-3 text-center font-bold ${q.PersPass / q.total < 0.85 ? 'text-red-500' : 'text-green-600'}`}>{((q.PersPass / q.total) * 100).toFixed(0)}%</td><td className={`p-3 text-center font-bold ${q.EffPass / q.total < 0.85 ? 'text-red-500' : 'text-green-600'}`}>{((q.EffPass / q.total) * 100).toFixed(0)}%</td></tr>))}</tbody>
                                    </table>
                                </div>
                            </Card>
                        )
                    }


                    {/* Friction Hierarchy removed per Issue #5 */}
                    <Card
                        title="Strategic Root Cause Analysis"
                        id="rca-table-card"
                        type="Table"
                        rowCount={sorted.length}
                        onExpand={() => setExpandedKey('Deep Dive Analysis Table')}
                        infoText="Holistic analysis of performance failures. AI evaluates historical feedback and failure patterns to derive structural root causes and recommended coaching actions."
                        onDownloadImage={onDownload}
                        askAI={askAI}
                        onDownloadCSV={() => ExportEngine.exportCSV(sorted.flatMap(item => {
                            const analysis = aiRCA[item.name];
                            if (!analysis) return [{ Context: item.name, Count: item.count, Issue: 'Analysis pending', Root_Cause: 'N/A', Action: 'N/A' }];
                            return analysis.map(row => ({
                                Context: item.name,
                                Count: item.count,
                                Issue: row.issue,
                                Root_Cause: row.root_cause,
                                Action: row.action
                            }));
                        }), `rca_analysis_${dimension.toLowerCase()}`)}
                        onCopyTable={() => copyTableToClipboard(null, sorted.flatMap(item => {
                            const analysis = aiRCA[item.name];
                            if (!analysis) return [{ Context: item.name, Count: item.count, Issue: 'Analysis pending', Root_Cause: 'N/A', Action: 'N/A' }];
                            return analysis.map(row => ({
                                Context: item.name,
                                Count: item.count,
                                Issue: row.issue,
                                Root_Cause: row.root_cause,
                                Action: row.action
                            }));
                        }))}
                        dataForAI={sorted.slice(0, 10)}
                        askAI={askAI}
                        headerActions={(
                            <div className="flex items-center gap-2">
                                {/* Dimension Switch Buttons */}
                                <div className="flex bg-slate-100 p-0.5 rounded-lg border border-slate-200 mr-2">
                                    {(isQCContext ? ['Question', 'Agent'] : ['User Problem', 'Chat Tag', 'Agent']).map(m => (
                                        <button
                                            key={m}
                                            onClick={() => {
                                                setDimension(m);
                                                // Clear RCA cache when switching dimensions to prevent stale data
                                                setAiRCA({});
                                            }}
                                            className={`px-3 py-1 text-[10px] font-bold rounded-md transition-all ${dimension === m ? 'bg-white text-indigo-600 shadow-sm' : 'text-slate-500 hover:text-slate-700'}`}
                                        >
                                            {m}
                                        </button>
                                    ))}
                                </div>
                                <button onClick={() => { setRcaWizardOpen(true); setRcaWizardQuery(''); clearWizardSelection(); setRcaDraftVersions([]); setRcaDraftIndex(0); setRcaDraftRefine(''); }} className="px-3 py-1.5 bg-blue-600 text-white rounded-lg text-[10px] font-bold uppercase hover:bg-blue-700 transition-all shadow-sm flex items-center gap-2"><ClipboardList size={12} /> Wizard</button>
                                <button onClick={handleAnalyzeAll} disabled={loading} className="px-3 py-1.5 bg-slate-900 text-white rounded-lg text-[10px] font-bold uppercase hover:bg-black transition-all shadow-sm flex items-center gap-2">{loading ? <Loader size={12} className="animate-spin" /> : <BrainCircuit size={12} />} Analyze All</button>
                                <TableColumnMenu
                                    visibleColumns={Object.fromEntries(cols.map(c => [c, visible.includes(c)]))}
                                    toggleColumn={c => setVisible(p => p.includes(c) ? p.filter(x => x !== c) : [...p, c])}
                                    labels={Object.fromEntries(cols.map(c => [c, c]))}
                                />
                            </div>
                        )}
                    >
                        <div className="overflow-x-auto w-full max-h-[1000px] overflow-y-auto">
                            <table className="w-full text-xs text-left border-collapse" id="rca-table">
                                <thead className="bg-slate-50 sticky top-0 z-20 border-b border-slate-200">
                                    <tr className="text-slate-700">
                                        <th className="p-4 border-r border-slate-200 min-w-[200px] font-black uppercase text-[10px] tracking-wider text-left">Context</th>
                                        <th className="p-4 border-r border-slate-200 min-w-[300px] font-black uppercase text-[10px] tracking-wider text-left">{isQCContext && dimension === 'Question' ? 'Agent Emails' : (isQCContext && dimension === 'Agent' ? 'Questions' : 'Mistake Breakdown')}</th>
                                        <th className="p-4 border-r border-slate-200 min-w-[200px] font-black uppercase text-[10px] tracking-wider text-left">Issue</th>
                                        <th className="p-4 border-r border-slate-200 min-w-[200px] font-black uppercase text-[10px] tracking-wider text-left">Root Cause</th>
                                        <th className="p-4 min-w-[200px] font-black uppercase text-[10px] tracking-wider text-left">Action</th>
                                    </tr>
                                </thead>
                                <tbody className="bg-white">{sorted.map((item) => renderAnalysisRows(item, aiRCA[item.name]))}</tbody>
                            </table>
                        </div>
                    </Card>



                    <Modal isOpen={rcaWizardOpen} onClose={() => setRcaWizardOpen(false)} title="Guided RCA Wizard" onDownloadImage={onDownload}>
                        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 overflow-visible">
                            <div className="space-y-4">
                                <div className="flex items-center gap-3">
                                    <div className="flex-1">
                                        <div className="text-[10px] font-black uppercase tracking-wider text-slate-500 mb-1">Context</div>
                                        <select value={rcaWizardContext} onChange={(e) => { setRcaWizardContext(e.target.value); clearWizardSelection(); }} className="w-full px-3 py-2 text-xs border border-slate-200 rounded-xl bg-white">
                                            <option value="">Select...</option>
                                            {sorted.slice(0, 80).map(it => <option key={it.name} value={it.name}>{it.name}</option>)}
                                        </select>
                                    </div>
                                    <button onClick={() => selectTopWizard(10)} className="mt-6 px-4 py-2 bg-slate-100 text-slate-700 rounded-xl text-[10px] font-bold uppercase hover:bg-slate-200 transition-all">Top 10</button>
                                    <button onClick={clearWizardSelection} className="mt-6 px-4 py-2 bg-slate-100 text-slate-700 rounded-xl text-[10px] font-bold uppercase hover:bg-slate-200 transition-all">Clear</button>
                                </div>
                                <div className="relative">
                                    <Search className="absolute left-3 top-2.5 text-slate-500" size={14} />
                                    <input value={rcaWizardQuery} onChange={(e) => setRcaWizardQuery(e.target.value)} placeholder="Search records..." className="w-full pl-9 pr-4 py-2 text-xs bg-white border border-slate-200 rounded-xl outline-none focus:ring-2 focus:ring-blue-500" />
                                </div>
                                <div className="border border-slate-200 rounded-2xl overflow-hidden">
                                    <div className="grid grid-cols-12 bg-slate-50 border-b border-slate-200 px-4 py-3 text-[10px] font-black uppercase tracking-wider text-slate-700">
                                        <div className="col-span-1">Sel</div>
                                        <div className="col-span-8">Record</div>
                                        <div className="col-span-3 text-right">Link</div>
                                    </div>
                                    <div className="max-h-[55vh] overflow-auto custom-scrollbar bg-white">
                                        {filteredWizardRows.map(r => (
                                            <div key={r.id} className="grid grid-cols-12 px-4 py-3 border-b border-slate-100 hover:bg-slate-50 items-start gap-2">
                                                <div className="col-span-1 pt-0.5">
                                                    <input type="checkbox" checked={!!rcaWizardSelected[r.id]} onChange={() => toggleWizardRow(r.id)} />
                                                </div>
                                                <div className="col-span-8">
                                                    <div className="text-xs font-semibold text-slate-800">{r.label}</div>
                                                    {r.feedback && <div className="text-[11px] text-slate-500 mt-1 line-clamp-3">{String(r.feedback)}</div>}
                                                </div>
                                                <div className="col-span-3 flex justify-end">
                                                    {r.link ? <a href={r.link} target="_blank" rel="noreferrer" className="inline-flex items-center gap-1 text-[11px] font-semibold text-blue-600 hover:underline"><ExternalLink size={12} /> Open</a> : <span className="text-[11px] text-slate-500"></span>}
                                                </div>
                                            </div>
                                        ))}
                                        {filteredWizardRows.length === 0 && (
                                            <div className="p-10 text-center text-slate-500 text-sm">No records found for this context.</div>
                                        )}
                                    </div>
                                </div>
                            </div>


                            <div className="space-y-4">
                                <div className="flex items-center justify-end gap-2">
                                    <button onClick={generateRcaDraft} disabled={rcaDraftLoading} className="px-6 py-2.5 bg-slate-900 text-white rounded-xl text-[10px] font-bold uppercase hover:bg-black transition-all shadow-lg flex items-center gap-2 no-export" data-html2canvas-ignore="true">{rcaDraftLoading ? <Loader size={14} className="animate-spin" /> : <Sparkles size={14} />} Generate Draft</button>
                                </div>
                                {/* Fix Issue 19: Removed redundant Adjust button - using AIOutputWrapper's modify options only */}
                                {rcaDraft ? (
                                    <div className="space-y-3">
                                        <AIOutputWrapper
                                            content={rcaDraft}
                                            onEdit={(t) => {
                                                setRcaDraftVersions(prev => {
                                                    const next = [...prev];
                                                    next[rcaDraftIndex] = t;
                                                    return next;
                                                });
                                            }}
                                            onRegenerate={generateRcaDraft}
                                            onVersionChange={(i) => setRcaDraftIndex(Math.max(0, Math.min(i, rcaDraftVersions.length - 1)))}
                                            versions={rcaDraftVersions}
                                            currentVersionIndex={rcaDraftIndex}
                                            type="RCADraft"
                                            title="RCA Draft (Slack)"
                                            isRegenerating={rcaDraftLoading}
                                        />
                                    </div>
                                ) : (
                                    <div className="text-center py-12 text-slate-500 italic bg-slate-50/50 border-2 border-dashed border-slate-200 rounded-[2rem]">Select records and generate a draft</div>
                                )}
                            </div>
                        </div>
                    </Modal>


                    <Modal isOpen={!!expandedKey} onClose={() => setExpandedKey(null)} title={expandedKey || 'Analysis'} onDownloadImage={onDownload}>
                        {expandedKey === 'Queue Performance' && queues && (
                            <div className="h-[80vh] w-full p-4">
                                <ResponsiveContainer width="100%" height="100%">
                                    <BarChart data={queues} margin={{ top: 20, bottom: 20 }}>
                                        <XAxis dataKey="name" />
                                        <YAxis />
                                        <Tooltip />
                                        <Bar dataKey="total" fill="#3B82F6" name="Total Audits">
                                            {showValues && <LabelList dataKey="total" position="top" style={{ fontSize: 10, fontWeight: 700, fill: '#64748b' }} />}
                                        </Bar>
                                        <Bar dataKey="passRate" fill="#10B981" name="Pass Rate %">
                                            {showValues && <LabelList dataKey="passRate" position="top" style={{ fontSize: 10, fontWeight: 700, fill: '#64748b' }} />}
                                        </Bar>
                                    </BarChart>
                                </ResponsiveContainer>
                            </div>
                        )}
                        {/* Friction Hierarchy expanded view removed per Issue #5 */}
                        {expandedKey === 'Deep Dive Analysis Table' && (
                            <div className={`${sorted.length > 30 ? 'overflow-auto max-h-[80vh]' : 'overflow-visible h-auto'} border border-slate-200 rounded-xl custom-scrollbar`} id="rca-table-expanded">
                                <table className="w-full text-xs text-left border-collapse">
                                    <thead className="bg-slate-50 sticky top-0 z-20 border-b border-slate-200"><tr><th className="p-4 border-r border-slate-200 min-w-[200px]">Context</th><th className="p-4 border-r border-slate-200 min-w-[300px]">{isQCContext && dimension === 'Question' ? 'Agent Emails' : (isQCContext && dimension === 'Agent' ? 'Questions' : 'Mistake Breakdown')}</th><th className="p-4 border-r border-slate-200 min-w-[200px]">Issue</th><th className="p-4 border-r border-slate-200 min-w-[200px]">Root Cause</th><th className="p-4 min-w-[200px]">Action</th></tr></thead>
                                    <tbody className="bg-white">{sorted.map((item) => renderAnalysisRows(item, aiRCA[item.name]))}</tbody>
                                </table>
                            </div>
                        )}
                        {expandedKey === 'Appeal Intelligence' && (
                            <div className="p-4 space-y-6">
                                <div className="h-96"><ResponsiveContainer width="100%" height="100%"><BarChart data={rcaData} layout="vertical" margin={{ top: 5, right: 30, left: 40, bottom: 5 }}><XAxis type="number" /><YAxis dataKey="name" type="category" width={250} tick={<VerticalAxisTick />} /><Tooltip /><Legend /><Bar dataKey="Volume" fill="#3b82f6" name="Volume" /><Bar dataKey="OverturnRate" fill="#10b981" name="Overturn Rate %" /></BarChart></ResponsiveContainer></div>
                                <div className="overflow-auto border border-slate-200 rounded-xl">
                                    <table className="w-full text-xs text-left">
                                        <thead className="bg-slate-50 sticky top-0"><tr className="border-b"><th className="p-2">Context</th><th className="p-2">Volume</th><th className="p-2">Overturn %</th></tr></thead>
                                        <tbody>{rcaData.map((d, i) => (<tr key={i} className="border-b"><td className="p-2 font-bold">{d.name}</td><td className="p-2">{d.Volume}</td><td className="p-2 text-emerald-600 font-bold">{d.OverturnRate}%</td></tr>))}</tbody>
                                    </table>
                                </div>
                            </div>
                        )}
                    </Modal>
                </div >
            );
        };


        const AgMatrixWrapper = ({ stats, qcMatrixCols, qcVisible, setQcVisible, downloadAsImage, setExpandedKey: _ignore, setSpotlightAgent, setActiveTab, processedQC, slackPosts, setSlackPosts, askAI }) => {
            const [expandedKey, setExpandedKey] = useState(null); // Local Expansion
            const { data: sorted, toggleSort, sortKey, direction, setColumnFilter, filters } = useSortableTable(stats.agentList);
            return (
                <div className="space-y-6">
                    <Card
                        title="Agent Quality Matrix"
                        id="qc-matrix"
                        onDownloadImage={downloadAsImage}
                        onExpand={() => setExpandedKey('Agent Quality Matrix')}
                        onDownloadCSV={() => ExportEngine.exportCSV(sorted.map(a => ({
                            Agent: a.name,
                            Audits: a.audits,
                            'Total Score': a.totalScore,
                            High: a.scoreCounts?.high || 0,
                            Medium: a.scoreCounts?.medium || 0,
                            Low: a.scoreCounts?.low || 0
                        })), "agent_quality_matrix")}
                        onCopyTable={() => copyTableToClipboard(null, sorted.map(a => ({
                            Agent: a.name,
                            Audits: a.audits,
                            'Total Score': a.totalScore,
                            High: a.scoreCounts?.high || 0,
                            Medium: a.scoreCounts?.medium || 0,
                            Low: a.scoreCounts?.low || 0
                        })))}
                        dataForAI={stats.agentList}
                        columnFilter={
                            <TableColumnMenu
                                visibleColumns={Object.fromEntries(qcMatrixCols.map(c => [c, qcVisible.includes(c)]))}
                                toggleColumn={(col) => setQcVisible(prev => prev.includes(col) ? prev.filter(c => c !== col) : [...prev, col])}
                                labels={Object.fromEntries(qcMatrixCols.map(c => [c, c]))}
                            />
                        }
                        infoText="Aggregated view of agent performance distribution. High/Medium/Low categories are based on raw audit score thresholds. Total Score is the sum of all QC scores for the agent."
                        askAI={askAI}
                    >
                        <div id="qc-matrix-table" className={`${sorted.length > 30 ? 'overflow-x-auto max-h-[1000px] flex-1' : 'overflow-visible h-auto'} custom-scrollbar`}>
                            <table className="w-full text-xs text-left border-collapse">
                                <thead className="bg-slate-50 sticky top-0 z-20">
                                    <tr className="border-b border-slate-200 text-slate-700">
                                        {qcVisible.includes('Agent') && <SortableTableHeader column="name" label="Agent" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['name']} data={stats.agentList} className="p-4 border-r font-black uppercase text-[10px] tracking-wider text-left" />}
                                        {qcVisible.includes('Audits') && <SortableTableHeader column="audits" label="Audits" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['audits']} data={stats.agentList} className="p-4 border-r font-black uppercase text-[10px] tracking-wider text-center" />}
                                        {qcVisible.includes('Total Score') && <SortableTableHeader column="totalScore" label="Total Score" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['totalScore']} data={stats.agentList} className="p-4 border-r font-black uppercase text-[10px] tracking-wider text-center" />}
                                        {/* QC Matrix colors: High Score (1.0) is BAD (Red), Low Score (0.33) is GOOD (Emerald) */}
                                        {qcVisible.includes('High') && <th className="p-4 text-center font-black uppercase text-[10px] tracking-wider border-r text-slate-700">High (1.0)</th>}
                                        {qcVisible.includes('Medium') && <th className="p-4 text-center font-black uppercase text-[10px] tracking-wider border-r text-slate-700">Medium (0.5/0.67)</th>}
                                        {qcVisible.includes('Low') && <th className="p-4 text-center font-black uppercase text-[10px] tracking-wider text-slate-700">Low (0.33)</th>}
                                    </tr>
                                </thead>
                                <tbody className="divide-y divide-slate-100 bg-white">
                                    {sorted.map((ag, i) => (
                                        <tr key={i} className="hover:bg-slate-50 transition-colors cursor-pointer" onClick={() => { setSpotlightAgent(ag.name); if (setActiveTab) setActiveTab('Spotlight'); }}>
                                            {qcVisible.includes('Agent') && <td className="p-4 font-semibold text-slate-700 border-r border-slate-100 underline decoration-blue-200 decoration-2 underline-offset-2">{ag.name}</td>}
                                            {qcVisible.includes('Audits') && <td className="p-4 text-center border-r border-slate-100">{ag.audits}</td>}
                                            {qcVisible.includes('Total Score') && <td className="p-4 text-center font-bold border-r border-slate-100 text-slate-800">{ag.totalScore}</td>}
                                            {/* QC Matrix colors: High Score (1.0) is BAD (Red), Low Score (0.33) is GOOD (Emerald) */}
                                            {qcVisible.includes('High') && <td className="p-4 text-center font-bold border-r border-slate-100 text-rose-600 bg-rose-50/50">{ag.scoreCounts?.high || 0}</td>}
                                            {qcVisible.includes('Medium') && <td className="p-4 text-center font-bold border-r border-slate-100 text-amber-600 bg-amber-50/50">{ag.scoreCounts?.medium || 0}</td>}
                                            {qcVisible.includes('Low') && <td className="p-4 text-center font-bold border-r border-slate-100 text-emerald-600 bg-emerald-50/50">{ag.scoreCounts?.low || 0}</td>}
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </Card>


                    {/* Phase 10.3: Error Co-Occurrence Matrix */}
                    {stats.top8Q && stats.top8Q.length > 0 && stats.coOccurrenceMatrix && (
                        <Card
                            title="Error Correlation Matrix"
                            id="co-occurrence-matrix"
                            infoText="Heatmap showing the probability of error patterns. Higher percentages indicate that agents who failed the row-metric are highly likely to also fail the column-metric. Essential for identifying systemic behavior clusters."
                            onDownloadImage={downloadAsImage}
                            onExpand={() => setExpandedKey('Co-Occurrence Matrix')}
                            onDownloadCSV={() => ExportEngine.exportCSV(stats.top8Q.map((rowQ, i) => {
                                const row = { Question: rowQ };
                                stats.coOccurrenceMatrix[i].forEach((cell, j) => {
                                    row[stats.top8Q[j]] = `${cell.val}%`;
                                });
                                return row;
                            }), "error_co_occurrence_matrix")}
                            onCopyTable={() => copyTableToClipboard(null, stats.top8Q.map((rowQ, i) => {
                                const row = { Question: rowQ };
                                stats.coOccurrenceMatrix[i].forEach((cell, j) => {
                                    row[stats.top8Q[j]] = `${cell.val}%`;
                                });
                                return row;
                            }))}


                            dataForAI={stats.coOccurrenceMatrix}
                            askAI={askAI}
                        >
                            <div className="overflow-x-auto w-full">
                                <table className="w-full text-[10px]">
                                    <thead>
                                        <tr>
                                            <th className="p-2 bg-slate-50"></th>
                                            {stats.top8Q.map((q, i) => <th key={i} className="p-2 bg-slate-50 max-w-[150px] whitespace-normal break-words font-bold border text-center" title={q}><div className="break-words">{q}</div></th>)}
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {stats.top8Q.map((rowQ, i) => (
                                            <tr key={i}>
                                                <td className="p-2 font-bold bg-slate-50 max-w-[150px] whitespace-normal break-words border" title={rowQ}><div className="break-words">{rowQ}</div></td>
                                                {stats.coOccurrenceMatrix[i].map((cell, j) => {
                                                    let bg = 'bg-white';
                                                    if (cell.val > 75) bg = 'bg-red-500 text-white';
                                                    else if (cell.val > 50) bg = 'bg-pink-400 text-white';
                                                    else if (cell.val > 25) bg = 'bg-pink-200 text-pink-900';
                                                    else if (cell.val > 0) bg = 'bg-pink-50 text-pink-700';
                                                    return <td key={j} className={`p-2 text-center border font-bold ${bg}`}>{cell.val}%</td>;
                                                })}
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        </Card>
                    )}




                    <Modal isOpen={!!expandedKey} onClose={() => setExpandedKey(null)} title={expandedKey} onDownloadImage={downloadAsImage}>
                        <div className={`p-4 ${sorted.length > 30 ? 'overflow-auto max-h-[80vh]' : 'overflow-visible h-auto'}`}>
                            {expandedKey === 'Agent Quality Matrix' && (
                                <table className="w-full text-xs text-left border-collapse">
                                    <thead className="bg-slate-50 sticky top-0 z-20">
                                        <tr className="border-b border-slate-200 text-slate-500">
                                            {qcVisible.includes('Agent') && <th className="p-4 border-r font-black bg-slate-50">Agent</th>}
                                            {qcVisible.includes('Audits') && <th className="p-4 border-r text-center font-black bg-slate-50">Audits</th>}
                                            {qcVisible.includes('Total Score') && <th className="p-4 border-r text-center font-black bg-slate-50">Total Score</th>}
                                            {qcMatrixCols.filter(c => !['Agent', 'Audits', 'Total Score'].includes(c) && qcVisible.includes(c)).map(c => <th key={c} className="p-4 border-r text-center bg-slate-50 font-black">{c}</th>)}
                                        </tr>
                                    </thead>
                                    <tbody className="divide-y divide-slate-100 bg-white">
                                        {sorted.map(a => (
                                            <tr key={a.name} className="hover:bg-slate-50">
                                                {qcVisible.includes('Agent') && <td className="p-4 font-bold border-r">{a.name}</td>}
                                                {qcVisible.includes('Audits') && <td className="p-4 text-center border-r">{a.audits}</td>}
                                                {qcVisible.includes('Total Score') && <td className="p-4 text-center border-r font-bold text-slate-800">{a.totalScore}</td>}
                                                {qcMatrixCols.filter(c => !['Agent', 'Audits', 'Total Score'].includes(c) && qcVisible.includes(c)).map(c => {
                                                    let val = 0;
                                                    if (c === 'High') val = a.scoreCounts?.high || 0;
                                                    if (c === 'Medium') val = a.scoreCounts?.medium || 0;
                                                    if (c === 'Low') val = a.scoreCounts?.low || 0;
                                                    if (stats.top8Q.includes(c)) {
                                                        const qStat = processedQC.filter(r => DataEngine.normalizeAgent(r, 'QC') === a.name && r.calculatedTag === c && r.isFail).length;
                                                        val = qStat;
                                                    }
                                                    return <td key={c} className="p-4 text-center border-r bg-slate-50/50">{val > 0 ? val : '-'}</td>
                                                })}
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            )}
                            {expandedKey === 'Co-Occurrence Matrix' && (
                                <div className="overflow-x-auto w-full">
                                    <table className="w-full text-xs">
                                        <thead>
                                            <tr>
                                                <th className="p-3 bg-slate-50"></th>
                                                {stats.top8Q.map((q, i) => <th key={i} className="p-3 bg-slate-50 max-w-[150px] whitespace-normal break-words font-bold border text-center">{q}</th>)}
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {stats.top8Q.map((rowQ, i) => (
                                                <tr key={i}>
                                                    <td className="p-3 font-bold bg-slate-50 max-w-[150px] whitespace-normal break-words border">{rowQ}</td>
                                                    {stats.coOccurrenceMatrix[i].map((cell, j) => {
                                                        let bg = 'bg-white';
                                                        if (cell.val > 75) bg = 'bg-red-500 text-white';
                                                        else if (cell.val > 50) bg = 'bg-pink-400 text-white';
                                                        else if (cell.val > 25) bg = 'bg-pink-200 text-pink-900';
                                                        else if (cell.val > 0) bg = 'bg-pink-50 text-pink-700';
                                                        return <td key={j} className={`p-3 text-center border font-bold ${bg}`}>{cell.val}%</td>;
                                                    })}
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                            )}
                        </div>
                    </Modal>
                </div>
            );
        };


        // QualitySentimentMatrix removed per Issue #22



        const QCView = ({ data, onDownloadImage, activeTab, setActiveTab, selectedAgentGlobal, setSelectedAgentGlobal, askAI, filters, setFilters }) => {
            const subTab = activeTab || 'Overview';
            const spotlightAgent = selectedAgentGlobal;
            const setSpotlightAgent = setSelectedAgentGlobal;
            const [showValues, setShowValues] = useState(true);
            const [expandedData, setExpandedData] = useState(null);
            const [showAppealNumbers, setShowAppealNumbers] = useState(true);
            const [expandedKey, setExpandedKey] = useState(null);
            const [bulkModalOpen, setBulkModalOpen] = useState(false);

            // Clear selected agent when entering Agent Review to show list view
            useEffect(() => {
                if (subTab === 'Agent Review' && spotlightAgent) {
                    setSpotlightAgent(null);
                }
            }, [subTab]);

            // 1. Process QC Data & Enhance with Code B Logic
            const processedQC = useMemo(() => {
                return data.map(r => {
                    const tag = extractQCTag(r);
                    const score = parseFloat(r['QC Score']);
                    const isFail = score < 100 || r['Pass/Fail'] === 'Fail' || r['Pass/Fail'] === 'FALSE';
                    const isFatal = r['Fatal'] === 'TRUE' || r['Fatal'] === true;


                    // Appeal Logic
                    const appealStatus = String(r['Appeal Status'] || '').trim();
                    const appealStatusLower = appealStatus.toLowerCase();
                    const hasAppealStatus = appealStatus.length > 0 && appealStatusLower !== 'nan';
                    const agentRequestingAppeal = r['Appeal? 2'] === 'Yes' || r['Appeal? 2'] === true || r['Agent Dispute Request'] === 'Yes' || r['Agent Dispute Request'] === true;


                    const isAppeal = hasAppealStatus || agentRequestingAppeal;


                    let appealResult = 'none';
                    if (isAppeal) {
                        if (appealStatusLower.includes('accept') || appealStatusLower.includes('approved') || appealStatusLower.includes('overturned')) {
                            appealResult = 'approved';
                        } else if (appealStatusLower.includes('reject') || appealStatusLower.includes('rejected') || appealStatusLower.includes('denied') || appealStatusLower.includes('upheld')) {
                            appealResult = 'denied';
                        } else {
                            appealResult = 'pending';
                        }
                    }


                    const isAck = r['Agent Ack.'] === true || String(r['Agent Ack.']).toUpperCase() === 'TRUE' || String(r['Agent Ack']).toUpperCase() === 'YES';


                    let dayOfWeek = 'Unknown';
                    const dObj = DataEngine.parseDate(r.Date);
                    if (dObj) dayOfWeek = dObj.toLocaleDateString('en-US', { weekday: 'long' });


                    return { ...r, calculatedTag: tag, isFail, isFatal, numericScore: isNaN(score) ? 0 : score, isAppeal, appealResult, isAck, dayOfWeek };
                });
            }, [data]);


            // 2. Aggregate Stats
            const stats = useMemo(() => {
                if (!processedQC || processedQC.length === 0) {
                    return {
                        total: 0,
                        totalScore: 0,
                        fatals: 0,
                        appeals: { approved: 0, denied: 0, pending: 0, total: 0 },
                        topIssues: [],
                        appealData: [],
                        agentList: [],
                        appealsResolved: 0,
                        unackedList: [],
                        totalUnacked: 0,
                        top8Q: [],
                        coOccurrenceMatrix: []
                    };
                }


                const total = processedQC.length;
                const totalScore = processedQC.reduce((a, b) => a + (b.numericScore || 0), 0);
                const fatals = processedQC.filter(r => r.isFatal).length;


                const appeals = { approved: 0, denied: 0, pending: 0, total: 0, pendingToBeAppealed: 0 };
                const timeMap = {};
                const unackedList = [];
                const unackedMap = {};


                // Group by Tag (Question)
                const tagCounts = {};
                processedQC.forEach(r => {
                    if (r.isFail) {
                        tagCounts[r.calculatedTag] = (tagCounts[r.calculatedTag] || 0) + 1;
                    }


                    // Count appeals: non-empty Appeal Status column
                    const appealStatus = String(r['Appeal Status'] || '').trim();
                    const tlRCA = String(r['TL RCA'] || '').trim().toLowerCase();


                    if (appealStatus && appealStatus !== '' && appealStatus.toLowerCase() !== 'nan') {
                        appeals.total++;
                        const statusLower = appealStatus.toLowerCase();
                        if (statusLower.includes('accept') || statusLower.includes('approved') || statusLower.includes('overturned')) {
                            appeals.approved++;
                        }
                        else if (statusLower.includes('reject') || statusLower.includes('rejected') || statusLower.includes('denied') || statusLower.includes('upheld')) {
                            appeals.denied++;
                        }
                        else {
                            appeals.pending++;
                        }
                    } else if ((tlRCA.startsWith('appeal') || tlRCA.startsWith('appealed'))) {
                        // Logic: TL wants appeal but Appeal Status is empty
                        appeals.pendingToBeAppealed++;
                    }


                    // Unacked
                    if (!r.isAck) {
                        const a = DataEngine.normalizeAgent(r, 'QC') || 'Unknown';
                        unackedMap[a] = (unackedMap[a] || 0) + 1;
                    }
                });


                const topIssues = Object.entries(tagCounts).sort((a, b) => b[1] - a[1]).slice(0, 5);


                const appealData = [
                    { name: 'Approved', value: appeals.approved, fill: '#10b981' },
                    { name: 'Denied', value: appeals.denied, fill: '#ef4444' },
                    { name: 'Pending', value: appeals.pending, fill: '#f59e0b' }
                ];


                Object.entries(unackedMap).forEach(([name, count]) => unackedList.push({ name, count }));
                unackedList.sort((a, b) => b.count - a.count);


                const agents = {};
                processedQC.forEach(r => {
                    const agent = DataEngine.normalizeAgent(r, 'QC') || 'Unknown';
                    if (!agents[agent]) agents[agent] = { name: agent, audits: 0, scoreSum: 0, fails: 0, fatals: 0, failCounts: {}, scoreCounts: { low: 0, medium: 0, high: 0 } };
                    agents[agent].audits++;
                    agents[agent].scoreSum += (r.numericScore || 0);
                    const score = r.numericScore;
                    if (score === 0.33) agents[agent].scoreCounts.low++;
                    else if (score === 0.5 || score === 0.67) agents[agent].scoreCounts.medium++;
                    else if (score === 1.0) agents[agent].scoreCounts.high++;
                    if (r.isFail) {
                        agents[agent].fails++;
                        // Determine category based on QC Score, NOT question name matching
                        const score = r.numericScore;
                        let category = 'Process'; // default
                        if (score === 1.0) category = 'Critical';
                        else if (score === 0.5 || score === 0.67) category = 'Process';
                        else if (score === 0.33) category = 'Internal';
                        agents[agent].failCounts[category] = (agents[agent].failCounts[category] || 0) + 1;
                    }
                    if (r.isFatal) agents[agent].fatals++;
                });


                const agentList = Object.values(agents).map((a) => {
                    return Object.assign({}, a, {
                        totalScore: parseFloat((a.scoreSum || 0).toFixed(2)).toFixed(2),
                        scoreCounts: a.scoreCounts
                    });
                });


                const totalClosed = appeals.approved + appeals.denied;


                // Error Co-Occurrence Matrix
                const top8Q = Object.entries(tagCounts).sort((a, b) => b[1] - a[1]).slice(0, 8).map(([q]) => q);
                const agentQuestionSets = {};
                processedQC.forEach(r => {
                    if (r.isFail && top8Q.includes(r.calculatedTag)) {
                        const agent = DataEngine.normalizeAgent(r, 'QC') || 'Unknown';
                        if (!agentQuestionSets[agent]) agentQuestionSets[agent] = new Set();
                        agentQuestionSets[agent].add(r.calculatedTag);
                    }
                });
                const coOccurrenceMatrix = top8Q.map((rowQ, i) => {
                    return top8Q.map((colQ, j) => {
                        if (rowQ === colQ) return { val: 100 };
                        const agentsWithRow = Object.values(agentQuestionSets).filter(s => s.has(rowQ)).length;
                        if (agentsWithRow === 0) return { val: 0 };
                        const agentsWithBoth = Object.values(agentQuestionSets).filter(s => s.has(rowQ) && s.has(colQ)).length;
                        return { val: Math.round((agentsWithBoth / agentsWithRow) * 100) };
                    });
                });


                const dailyData = {};
                processedQC.forEach(r => {
                    const date = DataEngine.parseDate(r.Date || r['Review Date']);
                    if (date) {
                        const day = DataEngine.formatDate(date);
                        if (!dailyData[day]) dailyData[day] = { n: day, total: 0, scoreSum: 0 };
                        dailyData[day].total++;
                        dailyData[day].scoreSum += r.numericScore;
                    }
                });
                const trendData = Object.values(dailyData).sort((a, b) => {
                    const dA = DataEngine.parseDate(a.n);
                    const dB = DataEngine.parseDate(b.n);
                    return (dA || 0) - (dB || 0);
                }).map(i => ({
                    n: i.n,
                    "QC Total Score": parseFloat((i.scoreSum).toFixed(1))
                }));


                // Silent Killers: Low frequency (< 15%) but High Severity (> 50% Fatal or High Penalty)
                const questionStats = {};
                processedQC.forEach(r => {
                    if (r.isFail) {
                        const q = r.calculatedTag || 'Unknown';
                        if (!questionStats[q]) questionStats[q] = { name: q, fails: 0, fatal: 0, highPenalty: 0 };
                        questionStats[q].fails++;
                        if (r.isFatal) questionStats[q].fatal++;
                        if (r.numericScore >= 0.67) questionStats[q].highPenalty++;
                    }
                });


                // FIX: Added 'appeals', 'trendData' to the return object
                return { total, totalScore: parseFloat(totalScore.toFixed(2)).toFixed(2), fatals, topIssues, agentList, appealData, appeals, appealsResolved: totalClosed, unackedList, totalUnacked: unackedList.reduce((a, b) => a + b.count, 0), top8Q, coOccurrenceMatrix, trendData };
            }, [processedQC]);


            const downloadQCPDF = async () => {
                try {
                    await ExportEngine.exportToPDFSmart('qc-spotlight-dashboard', `${spotlightAgent || 'Spotlight'}_QC_Dashboard`, { sectionSelector: '.export-atomic' });
                } catch (e) {
                    console.error("PDF Export Failed", e);
                    // WIRING 3: Fix Export Alerts
                    showToast("PDF Export Failed", "error");
                }
            };


            // QC Spotlight Stats
            const qcSpotlightStats = useMemo(() => {
                if (!spotlightAgent) return null;
                const agentData = processedQC.filter(r => DataEngine.normalizeAgent(r, 'QC') === spotlightAgent);
                const metricScores = {};
                let auditCount = 0, appealAccepted = 0, appealRejected = 0, failCount = 0;
                agentData.forEach(r => {
                    auditCount++;
                    if (r.isFail) {
                        failCount++;
                        if (!metricScores[r.calculatedTag]) metricScores[r.calculatedTag] = { fail: 0 };
                        metricScores[r.calculatedTag].fail++;
                    }
                    if (r.isAppeal) {
                        if (r.appealResult === 'approved') appealAccepted++;
                        else if (r.appealResult === 'denied') appealRejected++;
                    }
                });


                const metricsList = Object.entries(metricScores).map(([n, s]) => ({ name: n, failRate: (s.fail / auditCount || 1) * 100 }));
                return { auditCount, appealAccepted, appealRejected, failCount, strengths: metricsList.sort((a, b) => a.failRate - b.failRate).slice(0, 3), opportunities: metricsList.sort((a, b) => b.failRate - a.failRate).slice(0, 3), metricScores };
            }, [spotlightAgent, processedQC]);


            const qcSpotlightFeedbackLoop = useMemo(() => {
                if (!spotlightAgent) return null;
                const agentData = processedQC.filter(r => DataEngine.normalizeAgent(r, 'QC') === spotlightAgent);
                return feedbackLoopCalculator(agentData, 'QC');
            }, [spotlightAgent, processedQC]);


            // Fix for Issue 5: Calculate Global QC Feedback Loop
            const qcFeedbackLoop = useMemo(() => {
                return feedbackLoopCalculator(processedQC, 'QC');
            }, [processedQC]);


            // Phase 4: QC Feedback Loop by Agent (Breakdown)
            const qcAgentFeedbackLoop = useMemo(() => {
                const agentMap = {};
                processedQC.forEach(r => {
                    const agent = DataEngine.normalizeAgent(r, 'QC');
                    if (!agent) return;
                    if (!agentMap[agent]) agentMap[agent] = [];
                    agentMap[agent].push(r);
                });


                return Object.entries(agentMap).map(([agent, rows]) => {
                    const stats = feedbackLoopCalculator(rows, 'QC');
                    return { agent, ...stats };
                }).filter(s => s.provided > 0).sort((a, b) => b.pending - a.pending); // Sort by pending desc
            }, [processedQC]);


            const [showQCDataModal, setShowQCDataModal] = useState(false);


            const qcFeedbackProvidedRows = useMemo(() => {
                if (!spotlightAgent) return [];
                const agentData = processedQC.filter(r => DataEngine.normalizeAgent(r, 'QC') === spotlightAgent);
                const normalized = agentData.map(d => normalizeCompliance(d, 'QC'));
                const rows = [];
                normalized.forEach((d, i) => {
                    if (d.isMandatory) {
                        rows.push({
                            ...agentData[i],
                            _isAck: d.isAck,
                            _hasJustification: d.hasJustification,
                            _status: d.status
                        });
                    }
                });
                return rows;
            }, [spotlightAgent, processedQC]);


            const handleExpand = (content, title) => {
                setExpandedData({ content, title });
            };


            const handleChartClick = (data) => {
                if (data && data.activePayload && data.activePayload[0] && setFilters) {
                    const name = data.activePayload[0].payload.name;
                    // Filter by Question (Tag)
                    setFilters(prev => ({ ...prev, 'Question': [name] }));
                    showToast(`Filtering by question: ${name}`);
                }
            };


            const getQuestionDistribution = () => {
                const counts = {};
                processedQC.forEach(r => {
                    if (r.isFail) {
                        counts[r.calculatedTag] = (counts[r.calculatedTag] || 0) + 1;
                    }
                });
                return Object.entries(counts).sort((a, b) => b[1] - a[1]).slice(0, 10).map(([name, value]) => ({ name, value }));
            };


            const handleAgentSelect = (e) => {
                setSpotlightAgent(e.target.value);
            };


            const qcMatrixCols = ['Agent', 'Audits', 'Total Score', 'High', 'Medium', 'Low'];
            const [qcVisible, setQcVisible] = useState(qcMatrixCols);
            const logKeys = ["Date", "Agent Email", "Dante/BO Review Link", "Question", "Answer Comment", "QC Score", "Appeal ID", "Appeal Status", "Appeal JIRA", "TL RCA"];
            const [logVisible, setLogVisible] = useState(logKeys);
            const [slackPosts, setSlackPosts] = useState({}); // Lifted state for persistence
            const reviewsTableSort = useSortableTable(processedQC);
            const appealsTableSort = useSortableTable(processedQC.filter(r => r['Appeal Status'] && r['Appeal Status'].trim() !== ''));


            const renderExpandedContent = () => {
                if (!expandedKey) return null;
                if (expandedKey === 'kpi' && expandedData) {
                    return (
                        <div className="flex flex-col items-center justify-center h-full p-10">
                            <div className="text-[120px] font-black text-slate-900">{expandedData.value}</div>
                            <div className="w-full max-w-2xl mt-8">
                                <AIOutputWrapper
                                    title="Deep Dive"
                                    content="Click Regenerate..."
                                    onRegenerate={async () => {
                                        const resp = await GeminiAI.generate(`Analyze KPI: ${expandedData.title} - ${expandedData.value}`);
                                        showToast("AI analysis updated.", "success");
                                    }}
                                />
                            </div>
                        </div>
                    );
                }
                {/* Defect Distribution removed per Issue #11 */}
                return <div className="text-center py-12 text-slate-500">No content available</div>;
            };
            const modalContent = renderExpandedContent();


            return (
                <div className="space-y-6">


                    {subTab === 'Overview' && stats && (
                        <div className="space-y-6">
                            <div className="grid grid-cols-1 md:grid-cols-4 gap-6 overflow-visible items-start">
                                <MetricCard title="Total Audits" value={stats?.total || 0} icon={FileText} color="blue" info="Total number of Quality Control audits in the uploaded dataset." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'Total Audits', value: stats?.total || 0 }} sparkleType="QC" askAI={askAI} onExpand={() => setExpandedData({ title: 'Total Audits', content: buildKPIExpand('Total Audits', stats?.total || 0) })} />


                                <MetricCard
                                    title="Total QC Score"
                                    value={typeof stats?.totalScore === 'number' ? stats.totalScore.toFixed(2) : (stats?.totalScore || '0.00')}
                                    icon={TrendingDown}
                                    color="red"
                                    info="Total QC Score (sum of all QC markdown scores). This is the sum of numeric QC scores across all audits."
                                    onDownloadImage={onDownloadImage}
                                    dataForAI={{ stat: 'Total QC Score', value: stats?.totalScore || 0 }}
                                    sparkleType="QC"
                                    askAI={askAI}
                                    onExpand={() => setExpandedData({ title: 'Total QC Score', content: buildKPIExpand('Total QC Score', typeof stats?.totalScore === 'number' ? stats.totalScore.toFixed(2) : (stats?.totalScore || '0.00')) })}
                                />


                                <MetricCard title="Total Appeals" value={stats?.appeals?.total || 0} icon={AlertCircle} color="orange" info="Total number of appeals made based on non-empty Appeal Status column." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'Total Appeals', value: stats?.appeals?.total || 0 }} sparkleType="QC" askAI={askAI} onExpand={() => setExpandedData({ title: 'Total Appeals', content: buildKPIExpand('Total Appeals', stats?.appeals?.total || 0) })} />
                                <MetricCard title="Pending Acks" value={stats?.totalUnacked || 0} icon={Clock} color="amber" info="Audits that haven't been acknowledged by the agent yet." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'Pending Acks', value: stats?.totalUnacked || 0 }} sparkleType="QC" askAI={askAI} onExpand={() => setExpandedData({ title: 'Pending Acks', content: buildKPIExpand('Pending Acks', stats?.totalUnacked || 0) })} />
                            </div>

                            


                            {/* Trend Analysis Removed per user request */}


                            <div className="grid grid-cols-1 md:grid-cols-2 gap-6 overflow-visible">
                                <Card
                                    title="Appeal Intelligence"
                                    id="appeal-intelligence"
                                    infoText="Breakdown of dispute outcomes based on the 'Appeal Status' column. Tracks the precision of the initial audit process and the effectiveness of feedback loops."
                                    onDownloadImage={onDownloadImage}
                                    onDownloadCSV={() => ExportEngine.exportCSV(stats.appealData.map(d => ({ Outcome: d.name, Volume: d.value })), "appeal_intelligence_outcomes")}
                                    onCopyTable={() => copyTableToClipboard(null, stats.appealData.map(d => ({ Outcome: d.name, Volume: d.value })))}
                                    toggleValues={() => setShowAppealNumbers(!showAppealNumbers)}
                                    showValues={showAppealNumbers}
                                    onExpand={() => handleExpand(
                                        <ExpandedChartView
                                            title="Appeal Intelligence"
                                            subtitle="Appeal outcomes by status"
                                            chartContent={
                                                <div className="h-[500px] flex items-center justify-center">
                                                    <ResponsiveContainer width="100%" height="100%">
                                                        <PieChart>
                                                            <Pie data={stats.appealData} cx="50%" cy="50%" innerRadius={100} outerRadius={140} paddingAngle={2} dataKey="value">
                                                                {stats.appealData.map((entry, index) => (<Cell key={`cell-${index}`} fill={entry.color} />))}
                                                            </Pie>
                                                            <Tooltip content={<CustomTooltip />} />
                                                            <Legend verticalAlign="bottom" height={36} />
                                                        </PieChart>
                                                    </ResponsiveContainer>
                                                </div>
                                            }
                                        />,
                                        "Appeal Intelligence"
                                    )}
                                    dataForAI={stats.appealData || []}
                                    aiType="QC"
                                    askAI={askAI}
                                >
                                    <div className="h-64 flex items-center justify-center">
                                        {stats.appealData && stats.appealData.length > 0 ? (
                                            <ResponsiveContainer width="100%" height="100%">
                                                <PieChart>
                                                    <Pie data={stats.appealData} cx="50%" cy="50%" innerRadius={50} outerRadius={70} paddingAngle={5} dataKey="value">
                                                        {stats.appealData.map((entry, index) => (<Cell key={`cell-${index}`} fill={entry.fill} />))}
                                                        {showAppealNumbers && <LabelList position="outside" dataKey="value" style={{ fontSize: '13px', fontWeight: 700 }} stroke="none" fill="#64748b" />}
                                                    </Pie>
                                                    <Tooltip />
                                                    <Legend wrapperStyle={{ fontSize: '13px', fontWeight: 700 }} />
                                                </PieChart>
                                            </ResponsiveContainer>
                                        ) : (
                                            <div className="text-slate-500 text-sm">No appeal data available</div>
                                        )}
                                    </div>
                                    <div className="text-center mt-2 text-xs font-bold text-slate-500">
                                        Win Rate: {stats.appealsResolved > 0 && stats.appealData?.[0] ? ((stats.appealData[0].value / stats.appealsResolved) * 100).toFixed(1) : 0}%
                                    </div>
                                </Card>


                                <Card
                                    title="Top 5 Critical QC Gaps"
                                    id="top-5-qc-fails"
                                    onExpand={() => handleExpand(
                                        <ExpandedListView
                                            title="Top 5 Critical QC Gaps"
                                            subtitle="Highest failure questions across all QC reviews"
                                            listContent={
                                                <div className="space-y-6 pt-4 p-8">
                                                    {(stats.topIssues || []).map((i, idx) => (
                                                        <div key={idx}>
                                                            <div className="flex justify-between mb-3">
                                                                <span className="text-sm font-bold uppercase text-slate-600 tracking-wider">{i[0]}</span>
                                                                <span className="text-sm font-black text-rose-600">{i[1]} fails</span>
                                                            </div>
                                                            <div className="w-full bg-slate-100 rounded-full h-4">
                                                                <div className="bg-rose-500 h-4 rounded-full" style={{ width: `${stats.total > 0 ? (i[1] / stats.total) * 100 : 0}%` }}></div>
                                                            </div>
                                                        </div>
                                                    ))}
                                                </div>
                                            }
                                        />,
                                        "Top 5 QC Fails"
                                    )}
                                    onDownloadImage={onDownloadImage}
                                    onDownloadCSV={() => ExportEngine.exportCSV(stats.topIssues.map(i => ({ Question: i[0], Fails: i[1] })), "top_qc_fails")}
                                    onCopyTable={() => copyTableToClipboard(null, stats.topIssues.map(i => ({ Question: i[0], Fails: i[1] })))}
                                    dataForAI={stats.topIssues || []}
                                    aiType="QC"
                                    infoText="The specific questions with the highest failure counts. These represent key coaching opportunities for quality improvement."
                                    askAI={askAI}
                                    showValues={showValues}
                                    toggleValues={() => setShowValues(!showValues)}
                                >
                                    <div className="space-y-6 pt-2 px-4">
                                        {(stats.topIssues || []).map((i, idx) => (
                                            <div key={idx} className="cursor-pointer hover:opacity-80 transition-opacity" onClick={() => {
                                                if (setFilters) {
                                                    setFilters(prev => ({ ...prev, 'Question': [i[0]] }));
                                                    showToast(`Filtering by question: ${i[0]}`);
                                                }
                                            }}>
                                                <div className="flex justify-between mb-3">
                                                    <span className="text-[11px] font-semibold uppercase text-slate-500 tracking-wider">{i[0]}</span>
                                                    <span className="text-[11px] font-bold text-rose-600">{i[1]} fails</span>
                                                </div>
                                                <div className="w-full bg-slate-100 rounded-full h-2.5">
                                                    <div className="bg-rose-500 h-2.5 rounded-full" style={{ width: `${stats.total > 0 ? (i[1] / stats.total) * 100 : 0}%` }}></div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </Card>
                            </div>


                            <WeeklySummaryGenerator
                                npsData={[]}
                                qcData={processedQC}
                                onDownloadImage={onDownloadImage}
                                askAI={askAI}
                                mode="qc"
                            />

                        </div>
                    )}


                    {/* Duplicate Appeals Log Removed */}


                    {subTab === 'Matrix' && (
                        <AgMatrixWrapper stats={stats} qcMatrixCols={qcMatrixCols} qcVisible={qcVisible} setQcVisible={setQcVisible} downloadAsImage={onDownloadImage} setExpandedKey={setExpandedKey} setSpotlightAgent={setSpotlightAgent} setActiveTab={setActiveTab} processedQC={processedQC} slackPosts={slackPosts} setSlackPosts={setSlackPosts} askAI={askAI} />
                    )}


                    {subTab === 'RCA' && (
                        <div className="space-y-6">
                            <ErrorBoundary>
                                <StrategicRCAView processedData={processedQC.map(d => ({ ...d, mistakes: { Total: d.isFail ? 1 : 0 }, metricFails: { [d.calculatedTag]: 1 }, "Question": d.calculatedTag }))} metricsMapping={QC_METRIC_MAPPING} onDownload={onDownloadImage} onExpand={handleExpand} askAI={askAI} />
                            </ErrorBoundary>
                        </div>
                    )}


                    {subTab === 'Reviews' && (
                        <Card
                            title="QC Reviews Feed"
                            chartId="qc-logs"
                            dataForAI={processedQC.slice(0, 20)}
                            aiType="QC"
                            infoText="Comprehensive audit trail of row-level data from QC evaluations. Use the search and filter tools to narrow down specific records."
                            onDownloadImage={onDownloadImage}
                            onDownloadCSV={() => ExportEngine.exportCSV(reviewsTableSort.data.map(r => {
                                const row = {};
                                logKeys.filter(k => logVisible.includes(k)).forEach(k => {
                                    if (k === 'Date') row[k] = DataEngine.formatDate(r.Date);
                                    else if (k === 'Agent Email') row[k] = DataEngine.normalizeAgent(r, 'QC');
                                    else row[k] = r[k] || '';
                                });
                                return row;
                            }), "qc_reviews_audit")}
                            onCopyTable={() => copyTableToClipboard(null, reviewsTableSort.data.map(r => {
                                const row = {};
                                logKeys.filter(k => logVisible.includes(k)).forEach(k => {
                                    if (k === 'Date') row[k] = DataEngine.formatDate(r.Date);
                                    else if (k === 'Agent Email') row[k] = DataEngine.normalizeAgent(r, 'QC');
                                    else row[k] = r[k] || '';
                                });
                                return row;
                            }))}


                            onExpand={() => setExpandedKey('QC Reviews')}
                            columnFilter={
                                <div className="flex gap-2 items-center">
                                    <TableColumnMenu
                                        visibleColumns={Object.fromEntries(logKeys.map(k => [k, logVisible.includes(k)]))}
                                        toggleColumn={c => setLogVisible(p => p.includes(c) ? p.filter(x => x !== c) : [...p, c])}
                                        labels={Object.fromEntries(logKeys.map(k => [k, k]))}
                                    />
                                    <div className="relative">
                                        <Search className="absolute left-3 top-2 text-slate-500" size={14} />
                                        <input
                                            type="text"
                                            placeholder="Quick Find..."
                                            value={reviewsTableSort.query}
                                            onChange={e => reviewsTableSort.setQuery(e.target.value)}
                                            className="pl-9 pr-4 py-1.5 bg-slate-50 border border-slate-200 rounded-xl text-[10px] w-48 focus:ring-2 ring-indigo-500 outline-none transition-all"
                                        />
                                    </div>
                                </div>
                            }
                            showValues={showValues}
                            toggleValues={() => setShowValues(!showValues)}
                        >
                            <div id="qc-logs-table" className={`border border-slate-200 rounded-2xl custom-scrollbar overflow-x-auto ${reviewsTableSort.data.length > 30 ? 'max-h-[1000px] overflow-y-auto' : 'overflow-y-visible h-auto'}`}>
                                <table className="w-full text-xs text-left">
                                    <thead className="bg-slate-50 sticky top-0 z-10"><tr className="border-b">
                                        {logKeys.filter(k => logVisible.includes(k)).map(k => (
                                            <SortableTableHeader
                                                key={k}
                                                column={k}
                                                label={k}
                                                sortKey={reviewsTableSort.sortKey}
                                                sortDirection={reviewsTableSort.direction}
                                                onSort={reviewsTableSort.toggleSort}
                                                onFilter={reviewsTableSort.setColumnFilter}
                                                filterValue={reviewsTableSort.filters[k]}
                                                data={processedQC}
                                                className="font-bold text-slate-600"
                                            />
                                        ))}
                                    </tr></thead>
                                    <tbody className="divide-y">{reviewsTableSort.data.map((r, i) => {
                                        return (<tr key={i} className="hover:bg-slate-50">
                                            {logVisible.includes("Date") && <td className="p-3">{DataEngine.formatDate(r.Date)}</td>}
                                            {logVisible.includes("Agent Email") && <td className="p-3 font-bold"><HighlightText text={DataEngine.normalizeAgent(r, 'QC')} highlight={reviewsTableSort.query} /></td>}
                                            {logVisible.includes("Dante/BO Review Link") && <td className="p-3 text-blue-600 truncate max-w-xs">{r['Dante/BO Review Link'] || r['Chat/BO Link']}</td>}
                                            {logVisible.includes("Question") && <td className="p-3 truncate max-w-xs"><HighlightText text={r['Question'] || r.calculatedTag} highlight={reviewsTableSort.query} /></td>}
                                            {logVisible.includes("Answer Comment") && <td className="p-3 text-slate-500 max-w-md whitespace-pre-wrap break-words"><HighlightText text={r['Answer Comment'] || r['Comments']} highlight={reviewsTableSort.query} /></td>}
                                            {logVisible.includes("QC Score") && <td className={`p-3 font-bold ${r.isFail ? 'text-rose-600' : 'text-emerald-600'}`}>{r['QC Score']}</td>}
                                            {logVisible.includes("Appeal ID") && <td className="p-3">{r['Appeal ID']}</td>}
                                            {logVisible.includes("Appeal Status") && <td className="p-3">{r['Appeal Status']}</td>}
                                            {logVisible.includes("Appeal JIRA") && <td className="p-3">{r['Appeal JIRA']}</td>}
                                            {logVisible.includes("TL RCA") && <td className="p-3 text-slate-500 max-w-md whitespace-pre-wrap break-words"><HighlightText text={r['TL RCA']} highlight={reviewsTableSort.query} /></td>}
                                            {logVisible.includes("Answer Comment") && <td className="p-3 text-slate-500 max-w-md whitespace-pre-wrap break-words"><HighlightText text={r['Answer Comment'] || ''} highlight={reviewsTableSort.query} /></td>}
                                        </tr>)
                                    })
                                    }</tbody>
                                </table>
                            </div>
                        </Card>
                    )}


                    {subTab === 'Appeals' && (
                        <div className="space-y-6">
                            <div className="grid grid-cols-1 md:grid-cols-6 gap-4 overflow-visible">
                                <KPICard title="Total Appeals" value={stats?.appeals?.total || 0} icon={FileText} color="blue" info="Total number of appeals made (non-empty Appeal Status)." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'Total Appeals', value: stats?.appeals?.total || 0 }} sparkleType="QC" askAI={askAI} />
                                <KPICard title="Accepted" value={stats?.appeals?.approved || 0} icon={CheckCircle} color="green" info="Appeals that were approved/accepted/overturned." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'Accepted', value: stats?.appeals?.approved || 0 }} sparkleType="QC" askAI={askAI} />
                                <KPICard title="Rejected" value={stats?.appeals?.denied || 0} icon={AlertCircle} color="red" info="Appeals that were rejected/denied/upheld." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'Rejected', value: stats?.appeals?.denied || 0 }} sparkleType="QC" askAI={askAI} />
                                <KPICard title="Pending/To Do" value={stats?.appeals?.pending || 0} icon={Clock} color="amber" info="Appeals that are still pending decision (status is To Do or similar)." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'Pending/To Do', value: stats?.appeals?.pending || 0 }} sparkleType="QC" askAI={askAI} />
                                <KPICard
                                    title="Win Rate"
                                    value={`${((stats?.appeals?.approved || 0) + (stats?.appeals?.denied || 0)) > 0 ? (((stats?.appeals?.approved || 0) / ((stats?.appeals?.approved || 0) + (stats?.appeals?.denied || 0))) * 100).toFixed(1) : 0}%`}
                                    icon={TrendingUp}
                                    color="purple"
                                    info="Win Rate = (Accepted / (Accepted + Rejected))  100. Measures success rate of closed appeals."
                                    onDownloadImage={onDownloadImage}
                                    dataForAI={{ stat: 'Win Rate', approved: stats?.appeals?.approved || 0, denied: stats?.appeals?.denied || 0 }}
                                    sparkleType="QC"
                                    askAI={askAI}
                                />
                                <KPICard title="Pending to be Appealed" value={stats?.appeals?.pendingToBeAppealed || 0} icon={Bell} color="orange" info="Rows where TL RCA starts with 'Appeal' or 'Appealed' but Appeal Status is empty. TL indicated appeal is needed but not yet raised." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'Pending to be Appealed', value: stats?.appeals?.pendingToBeAppealed || 0 }} sparkleType="QC" askAI={askAI} />
                            </div>


                            <Card
                                title="Appeals Performance Log"
                                chartId="qc-appeals-log"
                                infoText="Audit of all formal appeals including their current status and justifications. Search by Agent or Appeal ID to narrow results."
                                onDownloadImage={onDownloadImage}
                                onDownloadCSV={() => ExportEngine.exportCSV(appealsTableSort.data.map(r => {
                                    const row = {};
                                    logKeys.filter(k => logVisible.includes(k)).forEach(k => {
                                        if (k === 'Date') row[k] = DataEngine.formatDate(r.Date);
                                        else if (k === 'Agent Email') row[k] = DataEngine.normalizeAgent(r, 'QC');
                                        else row[k] = r[k] || '';
                                    });
                                    return row;
                                }), "qc_appeals_audit")}
                                onCopyTable={() => copyTableToClipboard(null, appealsTableSort.data.map(r => {
                                    const row = {};
                                    logKeys.filter(k => logVisible.includes(k)).forEach(k => {
                                        if (k === 'Date') row[k] = DataEngine.formatDate(r.Date);
                                        else if (k === 'Agent Email') row[k] = DataEngine.normalizeAgent(r, 'QC');
                                        else row[k] = r[k] || '';
                                    });
                                    return row;
                                }))}
                                onExpand={() => setExpandedKey('Appeals Log')}
                                dataForAI={appealsTableSort.data.slice(0, 10)}
                                aiType="QC"
                                askAI={askAI}
                                columnFilter={
                                    <div className="flex gap-2 items-center">
                                        <TableColumnMenu
                                            visibleColumns={Object.fromEntries(logKeys.map(k => [k, logVisible.includes(k)]))}
                                            toggleColumn={c => setLogVisible(p => p.includes(c) ? p.filter(x => x !== c) : [...p, c])}
                                            labels={Object.fromEntries(logKeys.map(k => [k, k]))}
                                        />
                                        <div className="relative">
                                            <Search className="absolute left-3 top-2 text-slate-500" size={14} />
                                            <input
                                                type="text"
                                                placeholder="Search Appeals..."
                                                value={appealsTableSort.query}
                                                onChange={e => appealsTableSort.setQuery(e.target.value)}
                                                className="pl-9 pr-4 py-1.5 bg-slate-50 border border-slate-200 rounded-xl text-[10px] w-48 focus:ring-2 ring-indigo-500 outline-none transition-all"
                                            />
                                        </div>
                                    </div>
                                }
                                showValues={showValues}
                                toggleValues={() => setShowValues(!showValues)}
                            >
                                <div id="qc-appeals-table" className={`border border-slate-200 rounded-2xl custom-scrollbar overflow-x-auto ${appealsTableSort.data.length > 30 ? 'max-h-[1000px] overflow-y-auto flex-1' : 'overflow-y-visible h-auto'}`}>
                                    <table className="w-full text-xs text-left">
                                        <thead className="bg-slate-50 sticky top-0 z-10">
                                            <tr className="border-b">
                                                {logKeys.filter(k => logVisible.includes(k)).map(k => (
                                                    <SortableTableHeader
                                                        key={k}
                                                        column={k}
                                                        label={k}
                                                        sortKey={appealsTableSort.sortKey}
                                                        sortDirection={appealsTableSort.direction}
                                                        onSort={appealsTableSort.toggleSort}
                                                        onFilter={appealsTableSort.setColumnFilter}
                                                        filterValue={appealsTableSort.filters[k]}
                                                        data={appealsTableSort.data}
                                                        className="font-bold text-slate-600"
                                                    />
                                                ))}
                                            </tr>
                                        </thead>
                                        <tbody className="divide-y">
                                            {appealsTableSort.data.map((r, i) => (
                                                <tr key={i} className="hover:bg-slate-50">
                                                    {logVisible.includes("Date") && <td className="p-3">{DataEngine.formatDate(r.Date)}</td>}
                                                    {logVisible.includes("Agent Email") && <td className="p-3 font-bold">{DataEngine.normalizeAgent(r, 'QC')}</td>}
                                                    {logVisible.includes("Dante/BO Review Link") && <td className="p-3 text-blue-600 truncate max-w-xs">{r['Dante/BO Review Link'] || r['Chat/BO Link']}</td>}
                                                    {logVisible.includes("Question") && <td className="p-3 truncate max-w-xs">{r['Question'] || r.calculatedTag}</td>}
                                                    {logVisible.includes("Answer Comment") && <td className="p-3 text-slate-500 max-w-md whitespace-pre-wrap break-words">{r['Answer Comment'] || r['Comments']}</td>}
                                                    {logVisible.includes("QC Score") && <td className={`p-3 font-bold ${r.isFail ? 'text-rose-600' : 'text-emerald-600'}`}>{r['QC Score']}</td>}
                                                    {logVisible.includes("Appeal ID") && <td className="p-3">{r['Appeal ID']}</td>}
                                                    {logVisible.includes("Appeal Status") && (
                                                        <td className="p-3">
                                                            <span className={`px-2 py-1 rounded text-xs font-bold ${String(r['Appeal Status']).toLowerCase().includes('accept') || String(r['Appeal Status']).toLowerCase().includes('approved') ? 'bg-emerald-100 text-emerald-700' :
                                                                String(r['Appeal Status']).toLowerCase().includes('reject') || String(r['Appeal Status']).toLowerCase().includes('denied') ? 'bg-rose-100 text-rose-700' :
                                                                    'bg-amber-100 text-amber-700'
                                                                }`}>
                                                                {r['Appeal Status']}
                                                            </span>
                                                        </td>
                                                    )}
                                                    {logVisible.includes("Appeal JIRA") && <td className="p-3">{r['Appeal JIRA']}</td>}
                                                    {logVisible.includes("TL RCA") && <td className="p-3 text-slate-500 max-w-md whitespace-pre-wrap break-words">{r['TL RCA']}</td>}
                                                    {logVisible.includes("Answer Comment") && <td className="p-3 text-slate-500 max-w-md whitespace-pre-wrap break-words">{r['Answer Comment'] || ''}</td>}
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                            </Card>


                        </div>
                    )}


                    {subTab === 'Agent Review' && (
                        <QCAgentReview data={processedQC} selectedAgent={spotlightAgent} askAI={askAI} onDownloadImage={onDownloadImage} onSelectAgent={setSpotlightAgent} scope="QC" />
                    )}


                    {subTab === 'Spotlight' && (
                        <>
                            <ErrorBoundary>
                                <SpotlightView
                                    spotlightAgent={spotlightAgent}
                                    filterOptions={{ agent: stats.agentList.map(a => a.name).filter(a => a && a.trim() !== '') }}
                                    setSpotlightAgent={setSpotlightAgent}
                                    processedData={processedQC}
                                    METRIC_MAPPING={QC_METRIC_MAPPING}
                                    downloadAsImage={onDownloadImage}
                                    setExpandedKey={handleExpand}
                                    type="QC"
                                    askAI={askAI}
                                    bulkAction={{
                                        onClick: () => setBulkModalOpen(true),
                                        label: 'Bulk Generate'
                                    }}
                                />
                            </ErrorBoundary>
                        </>
                    )}


                    {subTab === 'Feedback Loop' && (
                        <FeedbackLoopTabV2 data={data} type="QC" onDownloadImage={onDownloadImage} askAI={askAI} />
                    )}


                    {subTab === 'Quiz' && (
                        <QuizModule data={processedQC} type="QC" askAI={askAI} />
                    )}


                    <Modal isOpen={!!expandedData} onClose={() => setExpandedData(null)} title={expandedData?.title || 'Detail View'} content={expandedData?.content} onDownloadImage={onDownloadImage} />
                    <Modal isOpen={!!expandedKey} onClose={() => setExpandedKey(null)} title={expandedKey} onDownloadImage={onDownloadImage}>
                        {modalContent || <div className="text-center py-12 text-slate-500">Loading content...</div>}
                    </Modal>


                    <BulkGeneratorModal
                        isOpen={bulkModalOpen}
                        onClose={() => setBulkModalOpen(false)}
                        agents={stats.agentList.map(a => a.name)}
                        onGenerate={async (agent) => {
                            const agentStats = stats.agentList.find(a => a.name === agent);
                            const agentData = processedQC.filter(r => DataEngine.normalizeAgent(r, 'QC') === agent);


                            const failCounts = {};
                            agentData.forEach(r => {
                                if (r.isFail) failCounts[r.calculatedTag] = (failCounts[r.calculatedTag] || 0) + 1;
                            });
                            const topGaps = Object.entries(failCounts).sort((a, b) => b[1] - a[1]).slice(0, 3).map(x => x[0]).join(", ");


                            const prompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nCreate a coaching plan for ${agent}. \nTotal Score: ${agentStats?.totalScore || '0.00'}. \nTop Issues: ${topGaps || 'None'}. \nTotal Audits: ${agentStats?.audits || 0}.\n\nSTRICT RULES:\n1. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.\n2. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).\n3. NO hashtags (#).\n4. Use emojis sparingly (max 2 per line).\n5. Do NOT use the word "Bold", "Underline", or "B" as text.\n\nStructure:\n1. Performance Summary\n2. Key Strengths\n3. Primary Areas for Improvement (Deep dive into ${topGaps})\n4. Action Plan (SMART Goals)\n5. Roleplay Scenario`;


                            return await GeminiAI.generate(prompt);
                        }}
                        title="Bulk QC Coaching Generator"
                    />
                </div>
            );
        };


        // Phase 2: Helper function for week number
        // Fix: getWeekStartDate - Return start date of week (DD/MM/YYYY) only
        // Replaced old 'getWeekNumber' to clarify intent


        const CategorySelector = ({ id, label, color, toggles, onToggle, weeks, onWeekChange, availableWeeks, showWeeks = true }) => (
            <div className="flex flex-col gap-2">
                <button onClick={() => onToggle(id)} className={`w-full px-4 py-3 rounded-xl text-xs font-bold transition-all flex justify-between items-center ${toggles[id] ? `bg-${color}-600 text-white shadow-md` : 'bg-white border border-slate-200 text-slate-600 hover:bg-slate-50'}`}>
                    <span>{label}</span>
                    {toggles[id] && <CheckCircle size={14} />}
                </button>
                {toggles[id] && showWeeks && (
                    <div>
                        <MultiSelect label="Select Weeks" icon={Calendar} options={availableWeeks} value={weeks} onChange={(val) => onWeekChange(id, val)} />
                        <p className="text-[10px] text-slate-500 mt-1 ml-1">{weeks.length} weeks selected</p>
                    </div>
                )}
            </div>
        );


        const AgentSelectionModal = ({ isOpen, onClose, allAgents, initialSelected, initialFiles, initialUnmatched, onConfirm, agentEmails, customAgents, setCustomAgents, emailAliases, setEmailAliases }) => {
            if (!isOpen) return null;


            const [localSelected, setLocalSelected] = useState([]);
            const [localFiles, setLocalFiles] = useState({}); // Now stores { agentName: { text, fileName } }
            const [localUnmatched, setLocalUnmatched] = useState([]);
            const [searchTerm, setSearchTerm] = useState('');
            const [createAgentState, setCreateAgentState] = useState({ active: false, fileIdx: -1, name: '', email: '' });


            useEffect(() => {
                if (isOpen) {
                    setLocalSelected(initialSelected || []);
                    setLocalFiles(initialFiles || {});
                    setLocalUnmatched(initialUnmatched || []);
                }
            }, [isOpen]);


            // Fix 3: Reset functionality
            const handleReset = () => {
                setLocalSelected([]);
                setLocalFiles({});
                setLocalUnmatched([]);
                showToast("Selection and uploads reset.");
            };


            const handleFileUpload = async (e) => {
                const files = Array.from(e.target.files);
                if (files.length === 0) return;


                const newFiles = { ...localFiles };
                const newUnmatched = [...localUnmatched];
                const newSelected = new Set(localSelected);


                for (const file of files) {
                    if (!file.name.endsWith('.docx')) continue;
                    try {
                        const arrayBuffer = await file.arrayBuffer();
                        const result = await window.mammoth.extractRawText({ arrayBuffer });
                        const text = result.value;
                        const lowerText = String(text || '').toLowerCase();

                        // Fix 1: Strictly match via email only to avoid "System" or token false-positives
                        let matchedAgent = null;
                        const emails = String(text).match(/[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}/g) || [];

                        if (emails.length > 0) {
                            const primaryEmail = emails[0].toLowerCase();
                            matchedAgent = agentEmails[primaryEmail] || emailAliases[primaryEmail];
                        }


                        if (matchedAgent) {
                            // Fix 2: Store filename along with text to allow re-assignment view
                            newFiles[matchedAgent] = { text, fileName: file.name };
                            newSelected.add(matchedAgent);
                        } else {
                            if (!newUnmatched.some(u => u.name === file.name)) {
                                newUnmatched.push({ name: file.name, text });
                            }
                        }
                    } catch (err) {
                        console.error("Read Error", err);
                    }
                }
                setLocalFiles(newFiles);
                setLocalUnmatched(newUnmatched);
                setLocalSelected(Array.from(newSelected));
            };


            const assignUnmatched = (fileIndex, agentName) => {
                if (!agentName) return;
                const file = localUnmatched[fileIndex];
                const newFiles = { ...localFiles, [agentName]: { text: file.text, fileName: file.name } };
                const newUnmatched = localUnmatched.filter((_, i) => i !== fileIndex);
                const newSelected = Array.from(new Set([...localSelected, agentName]));


                setLocalFiles(newFiles);
                setLocalUnmatched(newUnmatched);
                setLocalSelected(newSelected);
            };


            const createAndAssign = () => {
                const { fileIdx, name, email } = createAgentState;
                if (!name || fileIdx === -1) return;

                const exists = allAgents.includes(name);
                if (!exists) {
                    setCustomAgents([...customAgents, { name, email }]);
                }
                if (email) {
                    setEmailAliases({ ...emailAliases, [email.toLowerCase()]: name });
                }

                assignUnmatched(fileIdx, name);
                setCreateAgentState({ active: false, fileIdx: -1, name: '', email: '' });
            };


            const toggleAgent = (agent) => {
                setLocalSelected(prev => prev.includes(agent) ? prev.filter(a => a !== agent) : [...prev, agent]);
            };


            const handleConfirm = () => {
                // Flatten files back to expected format for onConfirm
                const flattenedFiles = {};
                Object.keys(localFiles).forEach(agent => {
                    flattenedFiles[agent] = localFiles[agent].text || localFiles[agent];
                });
                onConfirm(localSelected, flattenedFiles, localUnmatched);
                onClose();
            };


            const filteredAgents = allAgents.filter(a => a.toLowerCase().includes(searchTerm.toLowerCase()));


            const extractEmails = (text) => {
                const matches = String(text).match(/[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}/g);
                return matches ? [...new Set(matches.map(e => e.toLowerCase()))] : [];
            };


            return createPortal(
                <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/50 backdrop-blur-sm p-6 animate-in fade-in duration-200">
                    <div className="bg-white w-full max-w-5xl h-[80vh] rounded-3xl shadow-2xl flex flex-col overflow-hidden animate-in zoom-in-95 duration-200 relative">

                        {createAgentState.active && (
                            <div className="absolute inset-0 z-50 bg-white/95 flex items-center justify-center p-4">
                                <div className="w-full max-w-md space-y-4">
                                    <div className="text-center">
                                        <div className="w-12 h-12 bg-indigo-100 text-indigo-600 rounded-full flex items-center justify-center mx-auto mb-3">
                                            <UserPlus size={24} />
                                        </div>
                                        <h3 className="text-xl font-black text-slate-800">Add Agent / Link Alias</h3>
                                        <p className="text-sm text-slate-500">Create a new agent or link an email to an existing one.</p>
                                    </div>

                                    <div className="space-y-3">
                                        <div>
                                            <label className="text-xs font-bold text-slate-500 uppercase ml-1">Agent Name</label>
                                            <input
                                                type="text"
                                                value={createAgentState.name}
                                                onChange={e => setCreateAgentState(prev => ({ ...prev, name: e.target.value }))}
                                                className="w-full p-3 bg-slate-50 border border-slate-200 rounded-xl font-bold text-slate-800 focus:ring-2 focus:ring-indigo-500 outline-none"
                                                placeholder="e.g. John Doe"
                                                list="agent-list"
                                            />
                                            <datalist id="agent-list">
                                                {allAgents.map(a => <option key={a} value={a} />)}
                                            </datalist>
                                        </div>
                                        <div>
                                            <label className="text-xs font-bold text-slate-500 uppercase ml-1">Email (for future auto-match)</label>
                                            <input
                                                type="email"
                                                value={createAgentState.email}
                                                onChange={e => setCreateAgentState(prev => ({ ...prev, email: e.target.value }))}
                                                className="w-full p-3 bg-slate-50 border border-slate-200 rounded-xl font-medium text-slate-800 focus:ring-2 focus:ring-indigo-500 outline-none"
                                                placeholder="john.doe@example.com"
                                            />
                                        </div>
                                    </div>


                                    <div className="grid grid-cols-2 gap-3 pt-2">
                                        <button
                                            onClick={() => setCreateAgentState({ active: false, fileIdx: -1, name: '', email: '' })}
                                            className="p-3 rounded-xl border border-slate-200 font-bold text-slate-600 hover:bg-slate-50"
                                        >
                                            Cancel
                                        </button>
                                        <button
                                            onClick={createAndAssign}
                                            className="p-3 rounded-xl bg-indigo-600 text-white font-bold hover:bg-indigo-700 shadow-lg shadow-indigo-200"
                                        >
                                            Save & Assign
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}


                        <div className="p-6 border-b border-slate-100 flex justify-between items-center bg-slate-50/50">
                            <div>
                                <h3 className="text-xl font-black text-slate-800 tracking-tight">Select Agents & Upload Notes</h3>
                                <p className="text-xs text-slate-500 font-medium">Auto-match .docx files to agents or select manually.</p>
                            </div>
                            <div className="flex gap-2">
                                {/* Fix 3: Added Reset Button */}
                                <button onClick={handleReset} className="px-4 py-2 bg-rose-50 text-rose-600 border border-rose-200 rounded-xl font-bold text-sm flex items-center gap-2 transition-all hover:bg-rose-100">
                                    <RefreshCw size={14} /> Reset All
                                </button>
                                <button onClick={onClose} className="p-2 hover:bg-slate-200 rounded-full transition-colors"><XIcon size={20} className="text-slate-500" /></button>
                            </div>
                        </div>


                        <div className="flex-1 flex overflow-hidden">
                            <div className="w-1/2 p-6 border-r border-slate-100 overflow-y-auto bg-slate-50/30">
                                <label className="flex flex-col items-center justify-center h-32 border-2 border-dashed border-indigo-200 rounded-2xl bg-indigo-50/50 text-indigo-600 hover:bg-indigo-50 hover:border-indigo-400 transition-all cursor-pointer mb-6 group">
                                    <UploadCloud size={32} className="mb-2 group-hover:scale-110 transition-transform" />
                                    <span className="text-sm font-bold">Upload 1:1 .docx Files</span>
                                    <span className="text-[10px] opacity-60">Drag & drop or click to browse</span>
                                    <input type="file" multiple accept=".docx" onChange={handleFileUpload} className="hidden" />
                                </label>


                                <div className="space-y-4">
                                    {localUnmatched.map((file, idx) => {
                                        const emails = extractEmails(file.text);
                                        return (
                                            <div key={`unmatched-${idx}`} className="p-3 bg-white rounded-xl border border-rose-200 shadow-sm">
                                                <div className="flex justify-between items-start mb-2">
                                                    <div className="flex items-center gap-2 text-rose-600 font-bold text-xs">
                                                        <AlertCircle size={14} />
                                                        <span className="truncate max-w-[200px]">{file.name}</span>
                                                    </div>
                                                </div>
                                                <select
                                                    className="w-full text-xs p-2 border border-slate-200 rounded-lg bg-slate-50 focus:ring-2 focus:ring-rose-500 outline-none"
                                                    onChange={(e) => {
                                                        if (e.target.value === '__NEW__') {
                                                            setCreateAgentState({ active: true, fileIdx: idx, name: '', email: emails[0] || '' });
                                                        } else {
                                                            assignUnmatched(idx, e.target.value);
                                                        }
                                                    }}
                                                    value=""
                                                >
                                                    <option value="" disabled>Select Agent to Assign...</option>
                                                    <option value="__NEW__" className="font-bold text-indigo-600 bg-indigo-50">+ Create New Agent / Link Alias</option>
                                                    {allAgents.map(a => <option key={a} value={a}>{a}</option>)}
                                                </select>
                                                {emails.length > 0 && (
                                                    <div className="mt-2 flex flex-wrap gap-2">
                                                        {emails.map(email => (
                                                            <button
                                                                key={email}
                                                                onClick={() => setCreateAgentState({ active: true, fileIdx: idx, name: '', email })}
                                                                className="flex items-center gap-1 text-[10px] px-2 py-1 bg-indigo-50 text-indigo-600 rounded-md hover:bg-indigo-100 transition-colors"
                                                            >
                                                                <Link size={10} /> Link {email}
                                                            </button>
                                                        ))}
                                                    </div>
                                                )}
                                            </div>
                                        );
                                    })}


                                    {/* Fix 2: Matched files view with filename and re-assignment dropdown */}
                                    {Object.entries(localFiles).map(([agent, data]) => (
                                        <div key={agent} className="p-3 bg-emerald-50/50 rounded-xl border border-emerald-100 space-y-2">
                                            <div className="flex items-center justify-between">
                                                <div className="flex items-center gap-3">
                                                    <div className="w-8 h-8 rounded-full bg-emerald-100 text-emerald-600 flex items-center justify-center font-bold text-xs">
                                                        <Check size={14} />
                                                    </div>
                                                    <div className="min-w-0">
                                                        <p className="text-[10px] font-black text-slate-500 uppercase truncate">{data.fileName || 'Matched File'}</p>
                                                        <p className="text-xs font-bold text-emerald-900 truncate">{agent}</p>
                                                    </div>
                                                </div>
                                                <button onClick={() => {
                                                    const next = { ...localFiles };
                                                    delete next[agent];
                                                    setLocalFiles(next);
                                                }} className="text-emerald-400 hover:text-emerald-700 transition-colors"><XIcon size={14} /></button>
                                            </div>
                                            <select
                                                className="w-full text-[10px] p-1.5 border border-emerald-200 rounded-lg bg-white outline-none"
                                                value={agent}
                                                onChange={(e) => {
                                                    const newAgent = e.target.value;
                                                    const fileContent = localFiles[agent];
                                                    const nextFiles = { ...localFiles };
                                                    delete nextFiles[agent];
                                                    setLocalFiles({ ...nextFiles, [newAgent]: fileContent });
                                                    if (!localSelected.includes(newAgent)) setLocalSelected([...localSelected, newAgent]);
                                                }}
                                            >
                                                {allAgents.map(a => <option key={a} value={a}>{a}</option>)}
                                            </select>
                                        </div>
                                    ))}
                                </div>
                            </div>


                            <div className="w-1/2 flex flex-col bg-white">
                                <div className="p-4 border-b border-slate-100">
                                    <div className="relative">
                                        <Search size={16} className="absolute left-3 top-1/2 -translate-y-1/2 text-slate-500" />
                                        <input
                                            type="text"
                                            placeholder="Search agents..."
                                            className="w-full pl-9 pr-4 py-2 bg-slate-100 rounded-xl text-xs font-bold focus:ring-2 focus:ring-indigo-500 outline-none transition-all"
                                            value={searchTerm}
                                            onChange={(e) => setSearchTerm(e.target.value)}
                                        />
                                    </div>
                                    <div className="flex justify-between items-center mt-3">
                                        <span className="text-[10px] font-bold text-slate-500 uppercase">{localSelected.length} Selected</span>
                                        <div className="flex gap-2">
                                            <button onClick={() => setLocalSelected(allAgents)} className="text-[10px] text-indigo-600 font-bold hover:underline">All</button>
                                            <button onClick={() => setLocalSelected([])} className="text-[10px] text-slate-500 font-bold hover:underline">None</button>
                                        </div>
                                    </div>
                                </div>
                                <div className="flex-1 overflow-y-auto p-2">
                                    {filteredAgents.map(agent => (
                                        <label key={agent} className={`flex items-center gap-3 p-3 rounded-lg cursor-pointer transition-all ${localSelected.includes(agent) ? 'bg-indigo-50 border border-indigo-100' : 'hover:bg-slate-50 border border-transparent'}`}>
                                            <div className={`w-4 h-4 rounded border flex items-center justify-center transition-all ${localSelected.includes(agent) ? 'bg-indigo-600 border-indigo-600' : 'border-slate-300 bg-white'}`}>
                                                {localSelected.includes(agent) && <Check size={10} className="text-white" />}
                                            </div>
                                            <span className={`text-xs font-bold ${localSelected.includes(agent) ? 'text-indigo-700' : 'text-slate-600'}`}>{agent}</span>
                                            {localFiles[agent] && <FileText size={12} className="ml-auto text-emerald-500" />}
                                            <input type="checkbox" className="hidden" checked={localSelected.includes(agent)} onChange={() => toggleAgent(agent)} />
                                        </label>
                                    ))}
                                </div>
                            </div>
                        </div>


                        <div className="p-6 border-t border-slate-100 bg-slate-50/50 flex justify-end gap-3">
                            <button onClick={onClose} className="px-5 py-2.5 text-slate-500 font-bold text-sm hover:bg-slate-200 rounded-xl transition-colors">Cancel</button>
                            <button onClick={handleConfirm} className="px-6 py-2.5 bg-slate-900 text-white font-bold text-sm rounded-xl shadow-lg hover:bg-black hover:-translate-y-0.5 transition-all">Done ({localSelected.length})</button>
                        </div>
                    </div>
                </div>,
                document.body
            );
        };


        const OneOnOneFeedback = ({ npsData, qcData, onDownloadImage, slackPost, onSlackPostChange, askAI, customAgents, setCustomAgents, emailAliases, setEmailAliases, agentFileMap, setAgentFileMap, unmatchedFiles, setUnmatchedFiles }) => {
            const [selectedAgents, setSelectedAgents] = useState([]);
            const [step, setStep] = useState('selection'); // selection, data, generation
            const [showModal, setShowModal] = useState(false);
            const [toggles, setToggles] = useState({ nps: false, qc: false, acks: false, just: false });
            const [sectionWeeks, setSectionWeeks] = useState({ nps: [], qc: [], acks: [], just: [] });


            const [loading, setLoading] = useState(false);
            const [progress, setProgress] = useState(0);
            const [currentProcessingAgent, setCurrentProcessingAgent] = useState('');
            const [currentPage, setCurrentPage] = useState(1);
            const [generatingPage, setGeneratingPage] = useState(1);


            const [results, setResults] = useState([]);

            const handleUpdateResult = (index, newContent) => {
                setResults(prev => {
                    const newResults = [...prev];
                    const currentItem = newResults[index];
                    const newVersionObj = { content: newContent, timestamp: new Date().toISOString() };
                    const newVersions = [...(currentItem.versions || []), newVersionObj];
                    
                    newResults[index] = {
                        ...currentItem,
                        content: newContent,
                        versions: newVersions,
                        currentVersionIndex: newVersions.length - 1,
                        timestamp: new Date().toISOString()
                    };
                    return newResults;
                });
            };

            const handleRegeneratePage = async (pageIndex) => {
                const index = pageIndex - 1;
                if (index >= 0 && index < results.length) {
                    const agent = results[index].agent;
                    try {
                        showToast(`Regenerating for ${agent}...`);
                        const newContent = await generateForAgent(agent);
                        handleUpdateResult(index, newContent);
                        showToast(`Regenerated for ${agent}!`, 'success');
                    } catch (err) {
                        showToast(`Failed to regenerate for ${agent}`, 'error');
                    }
                }
            };

            const generateOneByOne = async () => {
                if (selectedAgents.length === 0) { showToast("Please select at least one agent"); return; }
                setStep('generation');
                setLoading(true);
                setResults([]);
                setProgress(0);
                setCurrentPage(1);


                const allGenerated = [];
                let completed = 0;


                for (const agent of selectedAgents) {
                    setCurrentProcessingAgent(agent);
                    try {
                        const content = await generateForAgent(agent);
                        // Structure result with versions
                        const resultItem = { 
                            agent, 
                            content,
                            versions: [{ content, timestamp: new Date().toISOString() }],
                            currentVersionIndex: 0,
                            timestamp: new Date().toISOString()
                        };
                        allGenerated.push(resultItem);
                        // Iterative Update
                        setResults([...allGenerated]);
                    } catch (err) {
                        console.error(`Error generating for ${agent}:`, err);
                        const errContent = " AI Error.";
                        allGenerated.push({ 
                            agent, 
                            content: errContent,
                            versions: [{ content: errContent, timestamp: new Date().toISOString() }],
                            currentVersionIndex: 0,
                            timestamp: new Date().toISOString()
                        });
                        setResults([...allGenerated]);
                    }


                    completed++;
                    setProgress(Math.round((completed / selectedAgents.length) * 100));
                }


                setResults(allGenerated);
                if (allGenerated.length === 1) {
                    onSlackPostChange(allGenerated[0].content);
                } else {
                    onSlackPostChange("");
                }
                setLoading(false);
                setCurrentProcessingAgent('');
            };

            const contentId = `oneonone-${Math.random().toString(36).substr(2, 9)}`;

            const agents = useMemo(() => {
                const agentSet = new Set();
                [...npsData, ...qcData].forEach(r => {
                    const agent = DataEngine.normalizeAgent(r, npsData.includes(r) ? 'NPS' : 'QC');
                    if (agent) agentSet.add(agent);
                });
                // Merge Custom Agents
                customAgents.forEach(ca => {
                    if (ca.name) agentSet.add(ca.name);
                });
                return Array.from(agentSet).sort();
            }, [npsData, qcData, customAgents]);


            const agentEmails = useMemo(() => {
                const map = {};
                [...npsData, ...qcData].forEach(r => {
                    const email = (r['Agent Email'] || r['Email'] || '').toLowerCase();
                    const name = DataEngine.normalizeAgent(r, npsData.includes(r) ? 'NPS' : 'QC');
                    if (email && name) map[email] = name;
                });
                return map;
            }, [npsData, qcData]);


            const getAvailableWeeks = useCallback((source) => {
                const weekSet = new Set();
                if (selectedAgents.length === 0) return [];


                const addWeeksFromData = (dataset, type) => {
                    dataset.forEach(r => {
                        const agent = DataEngine.normalizeAgent(r, type);
                        if (selectedAgents.includes(agent)) {
                            const date = DataEngine.getRowDate(r);
                            if (date) weekSet.add(DataEngine.getWeekStart(date));
                        }
                    });
                };


                if (source === 'NPS' || source === 'All') addWeeksFromData(npsData, 'NPS');
                if (source === 'QC' || source === 'All') addWeeksFromData(qcData, 'QC');


                return Array.from(weekSet).sort((a, b) => {
                    const dateA = DataEngine.parseDate(a);
                    const dateB = DataEngine.parseDate(b);
                    return dateA && dateB ? dateA.getTime() - dateB.getTime() : a.localeCompare(b);
                });
            }, [selectedAgents, npsData, qcData]);


            const handleToggle = (id) => setToggles(prev => ({ ...prev, [id]: !prev[id] }));
            const handleWeekChange = (id, val) => setSectionWeeks(prev => ({ ...prev, [id]: val }));


            const handleModalConfirm = (selected, files, unmatched) => {
                setSelectedAgents(selected);
                setAgentFileMap(files);
                setUnmatchedFiles(unmatched);
                setSectionWeeks({ nps: [], qc: [], acks: [], just: [] });
                setShowModal(false);
                setStep('data');
            };


            const getFirstUrl = (value) => {
                const text = String(value || '');
                const m = text.match(/https?:\/\/[^\s)]+/i);
                return m ? m[0] : '';
            };


            const getUrlFromRow = (row, candidates) => {
                for (const k of candidates) {
                    const v = row?.[k];
                    const url = getFirstUrl(v);
                    if (url) return url;
                }
                const joined = Object.values(row || {}).map(v => String(v || '')).join(' ');
                return getFirstUrl(joined);
            };


            const getNpsMetricForRow = (row) => {
                const metrics = Object.values(NPS_METRIC_MAPPING).flat();
                const isFail = (val) => {
                    if (val === false) return true;
                    const s = String(val).trim().toUpperCase();
                    return s === 'FALSE' || s === 'NO' || s === 'FAIL' || s === '0';
                };
                for (const m of metrics) {
                    if (isFail(row?.[m])) return m;
                }
                const feedbackText = String(row?.['Remediation Feedback'] || row?.['Feedback'] || '');
                if (feedbackText) {
                    const lines = feedbackText.split('\n');
                    for (const line of lines) {
                        const cleanLine = String(line || '').trim().replace(/^[\s\d\.\-\*\u2022]+/, '');
                        const match = metrics.find(mm => cleanLine.startsWith(mm));
                        if (match) return match;
                    }
                }
                return '';
            };


            const isNpsFailRow = (row) => {
                const metrics = Object.values(NPS_METRIC_MAPPING).flat();
                return metrics.some(m => row?.[m] === false || String(row?.[m]).trim().toUpperCase() === 'FALSE');
            };


            const generateForAgent = async (agent) => {
                const filterDataByWeeks = (data, type, selectedWeeks) => {
                    // Audit Fix: Safe by Default - If no weeks selected, include all data for the agent
                    if (!selectedWeeks || selectedWeeks.length === 0) {
                        return data.filter(r => DataEngine.normalizeAgent(r, type) === agent);
                    }
                    return data.filter(r => {
                        const rAgent = DataEngine.normalizeAgent(r, type);
                        const date = DataEngine.getRowDate(r);
                        if (!date || rAgent !== agent) return false;
                        return selectedWeeks.includes(DataEngine.getWeekStart(date));
                    });
                };


                const filterDataByAgent = (data, type) => data.filter(r => DataEngine.normalizeAgent(r, type) === agent);


                // --- QC Filtering for Appeals ---
                const isAppeal = (row) => {
                    const status = String(row['Appeal Status'] || '').toLowerCase().trim();
                    const rca = String(row['TL RCA'] || '').trim();
                    // 1. Check Appeal Status column
                    if (status === 'to do' || status.includes('success')) return true;
                    // 2. Check TL RCA text for "Appeal" or "Appealed" at the start
                    if (/^appealed?/i.test(rca)) return true;
                    return false;
                };


                const filteredData = {
                    nps: toggles.nps ? filterDataByWeeks(npsData, 'NPS', sectionWeeks.nps).filter(isNpsFailRow) : [],
                    qc: toggles.qc ? filterDataByWeeks(qcData, 'QC', sectionWeeks.qc).filter(r => !isAppeal(r)) : []
                };


                const pendingItems = { npsAck: 0, npsJust: 0, qcAck: 0, qcJust: 0 };
                if (toggles.acks) {
                    const npsAll = filterDataByAgent(npsData, 'NPS');
                    const qcAll = filterDataByAgent(qcData, 'QC');
                    const npsStats = feedbackLoopCalculator(npsAll, 'NPS');
                    const qcStats = feedbackLoopCalculator(qcAll, 'QC');
                    pendingItems.npsAck = npsStats.pendingTick;
                    pendingItems.qcAck = qcStats.pendingTick;
                }


                if (toggles.just) {
                    const npsAll = filterDataByAgent(npsData, 'NPS');
                    const qcAll = filterDataByAgent(qcData, 'QC');
                    const npsStats = feedbackLoopCalculator(npsAll, 'NPS');
                    const qcStats = feedbackLoopCalculator(qcAll, 'QC');
                    pendingItems.npsJust = npsStats.pendingWritten;
                    pendingItems.qcJust = qcStats.pendingWritten;
                }


                const mText = agentFileMap[agent] || "";
                const systemPrompt = ONE_ON_ONE_SYSTEM_PROMPT;
                const promptParts = [];
                promptParts.push(`Generate a 1:1 feedback Slack post for Agent: "${agent}".\n\n`);

                const linkMap = {}; // Store links for post-processing replacement


                const contextData = filterDataByWeeks(npsData, 'NPS', sectionWeeks.nps);
                const styleObj = StyleEngine.getStyleContext(contextData.length > 0 ? contextData : filterDataByAgent(npsData, 'NPS'));
                const styleContext = `TONE: ${styleObj.tlTone}\nSAMPLE FEEDBACK: ${styleObj.sampleText}`;


                promptParts.push(`STYLE INSTRUCTIONS:\n${styleContext}\n\n`);
                promptParts.push(`STRICT WRITING RULES:\n`);
                promptParts.push(`- Use complete, professional sentences.\n`);
                promptParts.push(`- Do not include any positive points inside NPS FEEDBACK or QC FEEDBACK sections.\n`);
                promptParts.push(`- Do not paste raw URLs. Only show links using Markdown links exactly as specified.\n`);
                promptParts.push(`- Use **bold** for all important words, terms, policy names, and KPIs.\n`);
                promptParts.push(`- Every heading within the message body MUST have a relevant emoji (e.g.,  for metrics,  for goals,  for action items,  for insights,  for warnings,  for summary,  for coaching,  for feedback,  for improvements,  for trends,  for greeting).\n`);
                promptParts.push(`- Add 2 line breaks (\\n\\n) after each heading before the next heading or content block.\n`);
                promptParts.push(`- Use 5-7 emojis total in the post. Max one emoji per line.\n\n`);
                promptParts.push(`CRITICAL FORMAT (MUST FOLLOW EXACTLY):\n`);
                promptParts.push(`Structure the feedback with these exact sections in order:\n\n`);
                promptParts.push(`1. **TITLE**: "** 1:1 Meeting Summary & Action Plan **" (Title wrapped in star emojis both sides, bold)\n`);
                promptParts.push(`2. **WELCOME**: AI Generated warm personal greeting using "${agent}" - different each time\n`);
                promptParts.push(`3. **SUMMARY**: AI Generated 1-2 line overview - different each time, context-aware\n`);


                if (mText) {
                    promptParts.push(`4. **Meeting Summary** (Only if meeting notes provided)\n`);
                    promptParts.push(`   Summarize meeting notes using simple bullet points "-".\n`);
                    promptParts.push(`   Write as "We" only (NOT "I" or anything else).\n`);
                    promptParts.push(`   Maximum 7 points prioritized by relevance to goals.\n`);
                    promptParts.push(`   Prioritize critical items.\n`);
                    promptParts.push(`   MEETING NOTES:\n${mText}\n\n`);
                }


                if (toggles.nps && filteredData.nps.length > 0) {
                    promptParts.push(`5. **NPS Feedback** (Only if NPS data exists)\n`);
                    promptParts.push(`   Show up to 3 items maximum.\n`);
                    promptParts.push(`   Rewrite TL feedback - do NOT copy exact text. Read, understand, and re-write properly.\n`);
                    promptParts.push(`   Format: **Sub-metric Name** :- [Rewritten feedback] (Chat:- [actual URL])\n`);
                    promptParts.push(`   Use **bold** for Sub-metric names.\n`);
                    promptParts.push(`   NO positive points allowed.\n`);
                    promptParts.push(`   Use ONLY Sub-metric names from data.\n\n`);
                    filteredData.nps.slice(0, 3).forEach((fb, i) => {
                        const metric = getNpsMetricForRow(fb) || 'Metric';
                        const url = getUrlFromRow(fb, ['Chat Link', 'Chat URL', 'ChatLink']) || '';
                        const text = (fb['Remediation Feedback'] || fb['Feedback'] || '').replace(/\n/g, ' ').trim();
                        // Generate token
                        const token = `{{NPS_LINK_${i}}}`;
                        linkMap[token] = url || 'N/A';


                        promptParts.push(`   RAW ITEM:\n`);
                        promptParts.push(`   - Sub-metric: ${metric}\n`);
                        promptParts.push(`   - URL: ${token} (Will be formatted as "(Chat:- URL)")\n`);
                        promptParts.push(`   - Feedback: ${text} (REWRITE THIS - do not copy)\n`);
                    });
                    promptParts.push(`\n`);
                }


                if (toggles.qc && filteredData.qc.length > 0) {
                    promptParts.push(`6. **QC Feedback** (Only if QC data exists)\n`);
                    promptParts.push(`   Show up to 3 items maximum.\n`);
                    promptParts.push(`   Only specific keyword from question (NOT full question).\n`);
                    promptParts.push(`   Examples: "Didn't follow Complaints", "Didn't follow Vulnerable Customer", "In Ops Tags"\n`);
                    promptParts.push(`   Rewrite based on TL RCA AND Answer Comment combined.\n`);
                    promptParts.push(`   Format: **Question Keyword** :- [Rewritten feedback] (Review:- [actual URL])\n`);
                    promptParts.push(`   Use **bold** for question keywords.\n`);
                    promptParts.push(`   NO positive points allowed.\n`);
                    promptParts.push(`   Use ONLY Question keywords from data.\n\n`);
                    filteredData.qc.slice(0, 3).forEach((fb, i) => {
                        const question = fb['Question'] || 'QC Check';
                        const fbText = (fb['TL RCA'] || fb['Answer Comment'] || '').replace(/\n/g, ' ').trim();
                        const url = getUrlFromRow(fb, ['Dante/BO Review Link', 'Review Link']) || '';
                        // Generate token
                        const token = `{{QC_LINK_${i}}}`;
                        linkMap[token] = url || 'N/A';


                        promptParts.push(`   RAW ITEM:\n`);
                        promptParts.push(`   - Question: ${question} (Extract KEYWORD only)\n`);
                        promptParts.push(`   - URL: ${token} (Will be formatted as "(Review:- URL)")\n`);
                        promptParts.push(`   - TL RCA: ${fbText} (REWRITE combining with Answer Comment)\n`);
                    });
                    promptParts.push(`\n`);
                }


                const pendingActions = [];
                if (pendingItems.npsAck > 0) pendingActions.push(`${pendingItems.npsAck} Chat Reviews are pending to be acknowledged`);
                if (pendingItems.npsJust > 0) pendingActions.push(`${pendingItems.npsJust} Chat Reviews need written justification`);
                if (pendingItems.qcAck > 0) pendingActions.push(`${pendingItems.qcAck} Quality Markdowns are pending to be acknowledged`);
                if (pendingItems.qcJust > 0) pendingActions.push(`${pendingItems.qcJust} Quality Markdowns need written justification`);


                if (pendingActions.length > 0) {
                    promptParts.push(`7. **Pending 1:1 File Actions** (Only if pending items exist)\n`);
                    pendingActions.forEach(action => promptParts.push(`   - ${action}\n`));
                    promptParts.push(`\n`);
                }


                promptParts.push(`8. **Action Items** (Always included)\n`);
                promptParts.push(`   Combine actions from meeting, NPS, QC, and pending files.\n`);
                promptParts.push(`   Format as bullet points using "-".\n`);
                promptParts.push(`   Maximum 10 items.\n`);
                promptParts.push(`   Prioritize critical items.\n`);
                promptParts.push(`   Focus on what agent should actually do.\n\n`);

                promptParts.push(`9. Closure (NOT A HEADING - Never use ** around this)\n`);
                promptParts.push(`   Write as regular paragraph (NOT a title/header).\n`);
                promptParts.push(`   1-2 lines closing statement relevant to post and data.\n`);
                promptParts.push(`   1 line forward-looking statement.\n`);
                promptParts.push(`   Combined as one paragraph with emojis.\n`);
                promptParts.push(`   If performance low: Be supportive but firm.\n`);
                promptParts.push(`   If performance good: Be celebratory and encouraging.\n`);
                promptParts.push(`   Examples: "You've got this! Looking forward to seeing your progress next week " OR "Great work on your strengths! Let's focus on growth areas together. Excited to see your improvement "\n\n`);
                promptParts.push(`NO SIGN-OFF. This is not email. After closure, it ends.\n\n`);


                let res = await GeminiAI.generate(promptParts.join(''), systemPrompt);

                // Post-Processing: Link Injection
                // Replace the {{TOKEN}} placeholders with the actual "(Chat:- URL)" or "(Review:- URL)" format
                if (res) {
                    Object.keys(linkMap).forEach(token => {
                        const url = linkMap[token];
                        // Format as "(Chat:- URL)" for NPS or "(Review:- URL)" for QC
                        const formattedLink = token.includes('NPS') ? `(Chat:- ${url})` : `(Review:- ${url})`;
                        res = res.split(token).join(formattedLink);
                    });
                    res = formatSlackMessage(res, 'OneOnOne');
                    return res;
                }
                return " AI Error."
            };


            return (
                <div className="space-y-6">
                    <AgentSelectionModal
                        isOpen={showModal}
                        onClose={() => setShowModal(false)}
                        allAgents={agents}
                        agentEmails={agentEmails}
                        initialSelected={selectedAgents}
                        initialFiles={agentFileMap}
                        initialUnmatched={unmatchedFiles}
                        onConfirm={handleModalConfirm}
                        customAgents={customAgents}
                        setCustomAgents={setCustomAgents}
                        emailAliases={emailAliases}
                        setEmailAliases={setEmailAliases}
                    />


                    <div className="space-y-8">
                        {/* Page Header */}
                        <div className="flex items-center justify-between">
                            <div>
                                <h2 className="text-2xl font-black text-slate-900">1:1 Feedback Generator</h2>
                                <p className="text-sm text-slate-500 mt-1">Generate personalized feedback for your team members</p>
                            </div>
                            {askAI && (
                                <button onClick={() => askAI("Help me use the 1:1 Feedback Generator")} className="p-2 text-slate-400 hover:text-indigo-600 transition-colors">
                                    <HelpCircle size={20} />
                                </button>
                            )}
                        </div>

                        {/* Step 1: Selection Trigger (Only if not in data/gen step) */}
                        {step === 'selection' && (
                            <div className="flex flex-col md:flex-row items-center justify-between gap-4 p-6 bg-white rounded-2xl border border-slate-200 shadow-sm">
                                <div>
                                    <h3 className="text-lg font-bold text-slate-800 flex items-center gap-2"><Users size={20} className="text-indigo-600" /> Team Selection & Notes</h3>
                                    <p className="text-sm text-slate-500 mt-1">
                                        {selectedAgents.length === 0 ? "No agents selected." : `${selectedAgents.length} Agents Selected`}
                                    </p>
                                </div>
                                <button
                                    onClick={() => setShowModal(true)}
                                    className="px-5 py-2.5 bg-indigo-600 text-white font-bold text-sm rounded-xl shadow-sm hover:bg-indigo-700 transition-all flex items-center gap-2"
                                >
                                    {selectedAgents.length === 0 ? "Start Session" : "Edit Selection"}
                                    <ChevronRight size={16} />
                                </button>
                            </div>
                        )}


                        {/* Step 2: Data Selection (Inline) */}
                        {step === 'data' && selectedAgents.length > 0 && (
                            <div className="bg-white rounded-2xl border border-slate-200 shadow-sm p-6 animate-in fade-in slide-in-from-bottom-4">
                                <div className="flex justify-between items-center mb-4">
                                    <h4 className="text-sm font-bold text-slate-800 uppercase tracking-wider flex items-center gap-2"><ListChecks size={16} className="text-indigo-600" /> Report Data Sources</h4>
                                    <button onClick={() => { setStep('selection'); setShowModal(true); }} className="text-xs font-bold text-indigo-600 hover:text-indigo-700">
                                        Change Selection
                                    </button>
                                </div>
                                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                                    <CategorySelector id="nps" label="NPS Reviews" color="blue" toggles={toggles} onToggle={handleToggle} weeks={sectionWeeks.nps} onWeekChange={handleWeekChange} availableWeeks={getAvailableWeeks('NPS')} />
                                    <CategorySelector id="qc" label="QC Reviews" color="amber" toggles={toggles} onToggle={handleToggle} weeks={sectionWeeks.qc} onWeekChange={handleWeekChange} availableWeeks={getAvailableWeeks('QC')} />
                                    <CategorySelector id="acks" label="Pending Acks" color="rose" toggles={toggles} onToggle={handleToggle} weeks={sectionWeeks.acks} onWeekChange={handleWeekChange} availableWeeks={[]} showWeeks={false} />
                                    <CategorySelector id="just" label="Pending Just." color="orange" toggles={toggles} onToggle={handleToggle} weeks={sectionWeeks.just} onWeekChange={handleWeekChange} availableWeeks={[]} showWeeks={false} />
                                </div>


                                <div className="mt-8">
                                    <button onClick={generateOneByOne} className="w-full px-6 py-4 bg-slate-900 text-white rounded-xl text-sm font-bold uppercase hover:bg-black transition-all shadow-xl hover:shadow-2xl hover:-translate-y-0.5 flex items-center justify-center gap-3">
                                        <Zap size={18} />
                                        {selectedAgents.length > 1 ? `Generate ${selectedAgents.length} Reports` : "Generate 1:1 Report"}
                                    </button>
                                </div>
                            </div>
                        )}


                        {/* Step 3: Generation & Results */}
                        {step === 'generation' && (
                            <div className="space-y-6 animate-in fade-in slide-in-from-bottom-4">
                                {loading && (
                                    <div className="bg-white rounded-xl border border-slate-200 shadow-sm p-8">
                                        <div className="flex justify-between text-xs font-bold text-slate-500 mb-2">
                                            <span>Processing: {currentProcessingAgent}</span>
                                            <span>{progress}%</span>
                                        </div>
                                        <div className="w-full bg-slate-100 rounded-full h-2 overflow-hidden mb-4">
                                            <div className="bg-indigo-600 h-full transition-all duration-300" style={{ width: `${progress}%` }}></div>
                                        </div>
                                        <div className="flex justify-center">
                                            <Loader className="animate-spin text-indigo-600" size={24} />
                                        </div>
                                    </div>
                                )}

                                {results.length > 0 && (
                                    <>
                                        <div className="flex justify-between items-center mb-4">
                                            <div className="text-sm font-bold text-slate-500">
                                                Showing {currentPage} of {results.length} Reports
                                            </div>
                                            <PaginationControls
                                                currentPage={currentPage}
                                                totalPages={results.length}
                                                onPageChange={(p) => setCurrentPage(p)}
                                                totalItems={results.length}
                                            />
                                        </div>

                                        {results.slice(currentPage - 1, currentPage).map((item, idx) => (
                                            <BulkResultWrapper
                                                key={item.agent}
                                                result={item}
                                                isGenerating={loading && currentProcessingAgent === item.agent}
                                                onRegenerate={() => handleRegeneratePage(currentPage)}
                                            />
                                        ))}
                                    </>
                                )}
                                
                                <div className="flex justify-center">
                                    <button onClick={() => setStep('data')} className="text-xs font-bold text-slate-400 hover:text-slate-600">
                                        Back to Data Selection
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };


        // --- FEATURE: QUIZ MODULE (Fixed: No Spoilers/Emojis in Options) ---
        // --- NEW AI UI COMPONENTS ---

        const RegenerableOutput = ({
            contentId,
            initialContent,
            context,
            type = 'general',
            onUpdate
        }) => {
            const [content, setContent] = useState(initialContent);
            const [isModifying, setIsModifying] = useState(false);
            const [showModifier, setShowModifier] = useState(false);
            const [instruction, setInstruction] = useState('');
            const [history, setHistory] = useState([]);

            useEffect(() => {
                // Register content
                if (contentId && initialContent) {
                    regenController.register(contentId, initialContent, context);
                }
            }, [contentId, initialContent, context]);

            const handleModify = async () => {
                if (!instruction.trim()) return;

                setIsModifying(true);
                try {
                    const modified = await regenController.modify(contentId, instruction);
                    setContent(modified);
                    setInstruction('');
                    setHistory(regenController.getHistory(contentId));
                    if (onUpdate) onUpdate(modified);
                    showToast('Content updated!', 'success');
                } catch (error) {
                    showToast('Modification failed', 'error');
                } finally {
                    setIsModifying(false);
                }
            };

            const handleUndo = () => {
                const previous = regenController.undo(contentId);
                if (previous) {
                    setContent(previous);
                    setHistory(regenController.getHistory(contentId));
                    if (onUpdate) onUpdate(previous);
                    showToast('Undone', 'success');
                }
            };

            const handleReset = () => {
                const original = regenController.reset(contentId);
                if (original) {
                    setContent(original);
                    setHistory([]);
                    if (onUpdate) onUpdate(original);
                    showToast('Reset to original', 'success');
                }
            };

            const QuickModButton = ({ label, onClick }) => (
                <button
                    onClick={onClick}
                    className="px-3 py-1 bg-white border border-slate-300 rounded-lg text-xs font-medium text-slate-700 hover:bg-slate-50 transition-all"
                >
                    {label}
                </button>
            );

            return (
                <div className="regenerable-output relative group">
                    {/* Content Display */}
                    <div
                        className="content-area markdown-content p-6 bg-white rounded-2xl border border-slate-200 transition-all"
                        dangerouslySetInnerHTML={{ __html: typeof marked !== 'undefined' ? safeMarked(content) : sanitizeHTML(content) }}
                    />

                    {/* Action Bar (appears on hover) */}
                    <div className="absolute top-2 right-2 flex gap-2 opacity-0 group-hover:opacity-100 transition-opacity bg-white/90 p-1 rounded-lg shadow-sm">
                        <button
                            onClick={() => setShowModifier(!showModifier)}
                            className="px-3 py-1.5 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-xs font-bold flex items-center gap-1 shadow-lg transition-all"
                            title="Modify content"
                        >
                            <Edit2 size={12} />
                            Modify
                        </button>

                        {history.length > 0 && (
                            <button
                                onClick={handleUndo}
                                className="px-3 py-1.5 bg-slate-600 hover:bg-slate-700 text-white rounded-lg text-xs font-bold flex items-center gap-1 shadow-lg transition-all"
                                title="Undo last change"
                            >
                                <ArrowLeft size={12} />
                                Undo
                            </button>
                        )}

                        {history.length > 0 && (
                            <button
                                onClick={handleReset}
                                className="px-3 py-1.5 bg-amber-600 hover:bg-amber-700 text-white rounded-lg text-xs font-bold flex items-center gap-1 shadow-lg transition-all"
                                title="Reset to original"
                            >
                                <RefreshCw size={12} />
                                Reset
                            </button>
                        )}
                    </div>

                    {/* Modification Interface */}
                    {showModifier && (
                        <div className="mt-4 p-4 bg-slate-50 rounded-xl border border-slate-200 animate-in fade-in slide-in-from-top-2">
                            <div className="flex items-center gap-2 mb-3">
                                <Sparkles size={16} className="text-blue-600" />
                                <h4 className="font-bold text-sm text-slate-900">
                                    AI Modification Assistant
                                </h4>
                            </div>

                            {/* Quick Actions */}
                            <div className="flex flex-wrap gap-2 mb-3">
                                <QuickModButton label="Shorter" onClick={() => setInstruction('Make this more concise and shorter')} />
                                <QuickModButton label="Longer" onClick={() => setInstruction('Expand this with more detail')} />
                                <QuickModButton label="Formal" onClick={() => setInstruction('Make the tone more formal and professional')} />
                                <QuickModButton label="Casual" onClick={() => setInstruction('Make the tone more casual and friendly')} />
                                <QuickModButton label="Add Examples" onClick={() => setInstruction('Add specific examples')} />
                            </div>

                            {/* Custom Instruction Input */}
                            <div className="relative">
                                <textarea
                                    value={instruction}
                                    onChange={(e) => setInstruction(e.target.value)}
                                    placeholder="Tell me what to change..."
                                    className="w-full px-4 py-3 text-sm border border-slate-300 rounded-xl outline-none focus:ring-2 focus:ring-blue-500 bg-white min-h-[80px] resize-none"
                                />

                                <button
                                    onClick={handleModify}
                                    disabled={!instruction.trim() || isModifying}
                                    className="absolute bottom-3 right-3 px-4 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-slate-400 text-white rounded-lg text-xs font-bold flex items-center gap-2 transition-all shadow-lg"
                                >
                                    {isModifying ? (
                                        <>
                                            <Loader size={14} className="animate-spin" />
                                            Modifying...
                                        </>
                                    ) : (
                                        <>
                                            <Sparkles size={14} />
                                            Apply
                                        </>
                                    )}
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Step 24: New Quiz Output Wrapper
        const InteractiveQuizWrapper = ({ quiz, onRegenerate, onClose }) => {
            const [localQuiz, setLocalQuiz] = useState(quiz);
            const [isEditMode, setIsEditMode] = useState(false);

            useEffect(() => { setLocalQuiz(quiz); }, [quiz]);

            const handleUpdateQuestion = (idx, field, val) => {
                const newQuestions = [...localQuiz.questions];
                newQuestions[idx] = { ...newQuestions[idx], [field]: val };
                setLocalQuiz({ ...localQuiz, questions: newQuestions });
            };

            const copyToRTF = (text) => {
                safeCopyToClipboard(text);
                showToast('Copied to clipboard!', 'success');
            };

            return (
                <div className="space-y-6 bg-white rounded-2xl p-8 border border-slate-200 shadow-lg animate-fade-in">
                    <div className="flex justify-between items-start pb-4 border-b border-slate-200">
                        <div className="flex-1">
                            {isEditMode ? (
                                <input 
                                    value={localQuiz.title} 
                                    onChange={e => setLocalQuiz({...localQuiz, title: e.target.value})}
                                    className="text-xl font-bold text-slate-800 w-full border-b border-dashed border-slate-300 focus:border-indigo-500 outline-none"
                                />
                            ) : (
                                <h3 className="text-xl font-bold text-slate-800">{localQuiz.title}</h3>
                            )}
                            {isEditMode ? (
                                <textarea 
                                    value={localQuiz.description}
                                    onChange={e => setLocalQuiz({...localQuiz, description: e.target.value})}
                                    className="text-sm text-slate-500 mt-1 w-full border border-slate-200 rounded p-1"
                                />
                            ) : (
                                <p className="text-sm text-slate-500 mt-1">{localQuiz.description}</p>
                            )}
                        </div>
                        <div className="flex gap-2 ml-4">
                            <button onClick={() => setIsEditMode(!isEditMode)} className={`px-3 py-1.5 rounded text-xs font-bold flex items-center gap-1 ${isEditMode ? 'bg-indigo-100 text-indigo-700' : 'bg-slate-100 text-slate-600'}`}>
                                <Edit2 size={14} /> {isEditMode ? 'Done' : 'Edit'}
                            </button>
                            <button onClick={onRegenerate} className="px-3 py-1.5 bg-indigo-600 text-white rounded hover:bg-indigo-700 text-xs font-bold flex items-center gap-1">
                                <RefreshCw size={14} /> Regenerate
                            </button>
                            <button onClick={onClose} className="px-3 py-1.5 bg-slate-100 text-slate-600 rounded hover:bg-slate-200 text-xs font-bold">
                                <XIcon size={14} />
                            </button>
                        </div>
                    </div>

                    <div className="space-y-4">
                        {localQuiz.questions.map((q, idx) => (
                            <div key={q.id || idx} className="border border-slate-200 rounded-xl p-4 bg-slate-50">
                                <div className="flex justify-between items-start gap-3">
                                    <div className="w-6 h-6 rounded-full bg-indigo-600 text-white flex items-center justify-center text-xs font-bold shrink-0">
                                        {idx + 1}
                                    </div>
                                    <div className="flex-1 space-y-3">
                                        <div className="group relative">
                                            {isEditMode ? (
                                                <textarea 
                                                    value={q.question}
                                                    onChange={e => handleUpdateQuestion(idx, 'question', e.target.value)}
                                                    className="w-full p-2 border border-slate-300 rounded text-sm font-medium"
                                                />
                                            ) : (
                                                <p className="font-bold text-slate-800" dangerouslySetInnerHTML={{ __html: safeMarked(q.question) }} />
                                            )}
                                            <button onClick={() => copyToRTF(q.question)} className="absolute top-0 right-0 opacity-0 group-hover:opacity-100 p-1 text-slate-400 hover:text-indigo-600">
                                                <Copy size={14} />
                                            </button>
                                        </div>

                                        <div className="space-y-2 pl-4 border-l-2 border-slate-200">
                                            {q.options.map((opt, optIdx) => (
                                                <div key={optIdx} className="flex items-start gap-2 group relative">
                                                    <div className={`w-4 h-4 rounded-full border flex items-center justify-center mt-0.5 ${q.correctAnswers?.includes(String.fromCharCode(65+optIdx)) || q.correctAnswer === opt ? 'border-green-500 bg-green-50' : 'border-slate-300'}`}>
                                                        {(q.correctAnswers?.includes(String.fromCharCode(65+optIdx)) || q.correctAnswer === opt) && <div className="w-2 h-2 rounded-full bg-green-500" />}
                                                    </div>
                                                    {isEditMode ? (
                                                        <input 
                                                            value={opt}
                                                            onChange={e => {
                                                                const newOpts = [...q.options];
                                                                newOpts[optIdx] = e.target.value;
                                                                handleUpdateQuestion(idx, 'options', newOpts);
                                                            }}
                                                            className="flex-1 text-sm border border-slate-200 rounded px-1"
                                                        />
                                                    ) : (
                                                        <span className="text-sm text-slate-700" dangerouslySetInnerHTML={{ __html: safeMarked(opt) }} />
                                                    )}
                                                    <button onClick={() => copyToRTF(opt)} className="opacity-0 group-hover:opacity-100 p-0.5 text-slate-400 hover:text-indigo-600">
                                                        <Copy size={12} />
                                                    </button>
                                                </div>
                                            ))}
                                        </div>

                                        {/* Correct Feedback */}
                                        {q.explanationCorrect && (
                                            <div className="mt-3 p-3 bg-emerald-50 rounded-lg text-sm text-emerald-800 group relative">
                                                <span className="font-bold uppercase text-xs text-emerald-600 block mb-1">Correct Feedback:</span>
                                                {isEditMode ? (
                                                    <textarea 
                                                        value={q.explanationCorrect}
                                                        onChange={e => handleUpdateQuestion(idx, 'explanationCorrect', e.target.value)}
                                                        className="w-full p-2 border border-emerald-200 rounded bg-white"
                                                    />
                                                ) : (
                                                    <div dangerouslySetInnerHTML={{ __html: safeMarked(q.explanationCorrect) }} />
                                                )}
                                                <button onClick={() => copyToRTF(q.explanationCorrect)} className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 p-1 text-emerald-400 hover:text-emerald-700">
                                                    <Copy size={14} />
                                                </button>
                                            </div>
                                        )}
                                        
                                        {/* Incorrect Feedback */}
                                        {(q.explanationWrong || q.explanation) && (
                                            <div className="mt-3 p-3 bg-rose-50 rounded-lg text-sm text-rose-800 group relative">
                                                <span className="font-bold uppercase text-xs text-rose-600 block mb-1">Incorrect Feedback:</span>
                                                {isEditMode ? (
                                                    <textarea 
                                                        value={q.explanationWrong || q.explanation}
                                                        onChange={e => handleUpdateQuestion(idx, q.explanationWrong ? 'explanationWrong' : 'explanation', e.target.value)}
                                                        className="w-full p-2 border border-rose-200 rounded bg-white"
                                                    />
                                                ) : (
                                                    <div dangerouslySetInnerHTML={{ __html: safeMarked(q.explanationWrong || q.explanation) }} />
                                                )}
                                                <button onClick={() => copyToRTF(q.explanationWrong || q.explanation)} className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 p-1 text-rose-400 hover:text-rose-700">
                                                    <Copy size={14} />
                                                </button>
                                            </div>
                                        )}
                                        
                                        {/* Justification Links */}
                                        {q.links && q.links.length > 0 && (
                                            <div className="mt-3 p-3 bg-indigo-50 rounded-lg text-sm text-indigo-800">
                                                <span className="font-bold uppercase text-xs text-indigo-600 block mb-2">Justification Links:</span>
                                                <div className="space-y-1">
                                                    {q.links.map((link, linkIdx) => (
                                                        <a 
                                                            key={linkIdx}
                                                            href={link}
                                                            target="_blank"
                                                            rel="noopener noreferrer"
                                                            className="block text-xs text-indigo-600 hover:text-indigo-800 hover:underline truncate"
                                                        >
                                                            {link}
                                                        </a>
                                                    ))}
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const AdvancedQuizBuilder = ({ data, type = 'NPS' }) => {
            const [config, setConfig] = useState({
                topic: type,
                difficulty: 'medium',
                questionCount: 10,
                types: ['multiple-choice'],
                agentSpecific: null,
                customInstructions: ''
            });

            const [filters, setFilters] = useState({});
            const [quiz, setQuiz] = useState(null);
            const [isGenerating, setIsGenerating] = useState(false);
            const [currentPage, setCurrentPage] = useState(1);
            const [progress, setProgress] = useState({ show: false, percent: 0, text: '' });


            // Filter Options
            const filterOptions = useMemo(() => {
                if (!data) return [];
                // Apply global appeal filter
                const cleanData = data.filter(d => !DataEngine.isAppeal(d));
                const key = type === 'NPS' ? 'Sub-metric' : 'Question';
                return [...new Set(cleanData.map(d => d[key]).filter(Boolean))].sort();
            }, [data, type]);

            const toggleFilter = (val) => {
                setFilters(prev => {
                    const key = type === 'NPS' ? 'SubMetric' : 'Question';
                    const current = prev[key] || [];
                    const next = current.includes(val) ? current.filter(x => x !== val) : [...current, val];
                    return { ...prev, [key]: next };
                });
            };

            // Listen to AI progress events
            React.useEffect(() => {
                const handleProgress = (e) => {
                    const detail = e.detail || {};
                    setProgress({
                        show: detail.show !== false,
                        percent: detail.progress || 0,
                        text: detail.text || ''
                    });
                };
                window.addEventListener('ai-progress', handleProgress);
                return () => window.removeEventListener('ai-progress', handleProgress);
            }, []);

            const generateQuiz = async () => {
                setIsGenerating(true);
                setProgress({ show: true, percent: 0, text: 'Initializing...' });
                try {
                    // Filter out invalid appeals (Accepted, Pending, To Be Appealed)
                    // Rejected appeals are kept as they are valid failures
                    const cleanData = data?.filter(d => !DataEngine.isAppeal(d));
                    
                    const generated = await advancedQuizGen.generateQuiz({
                        ...config,
                        dataContext: cleanData,
                        filters: filters
                    });
                    setQuiz(generated);
                    setCurrentPage(1);
                    showToast('Advanced Quiz generated!', 'success');
                } catch (error) {
                    console.error(error);
                    showToast('Failed to generate quiz', 'error');
                } finally {
                    setIsGenerating(false);
                    setProgress({ show: false, percent: 0, text: '' });
                }
            };

            const buildCSVPreview = () => {
                if (!quiz) return '';
                let csv = `Question Number,Question Text,Option Text,Is Correct,Feedback Correct,Feedback Incorrect\n`;
                quiz.questions.forEach((q, i) => {
                    q.options.forEach(opt => {
                        const isCorrect = q.correctAnswer === opt || (q.correctAnswers && q.correctAnswers.includes(opt));
                        csv += `${i + 1},"${q.question.replace(/"/g, '""')}","${opt.replace(/"/g, '""')}",${isCorrect ? 'TRUE' : 'FALSE'},"${q.explanation.replace(/"/g, '""')}","${q.explanation.replace(/"/g, '""')}"\n`;
                    });
                });
                return csv;
            };

            if (quiz) {
                return <InteractiveQuizWrapper quiz={quiz} onRegenerate={generateQuiz} onClose={() => setQuiz(null)} />;
            }

            return (
                <div className="advanced-quiz-setup w-full p-8 bg-white rounded-2xl border border-slate-200 shadow-lg relative">
                    <div className="text-center mb-10">
                        <div className="inline-flex items-center justify-center w-20 h-20 bg-gradient-to-br from-indigo-600 to-violet-600 rounded-3xl mb-6 shadow-lg">
                            <BrainCircuit size={40} className="text-white" />
                        </div>
                        <h2 className="text-3xl font-black text-slate-800 mb-3 tracking-tight">Advanced Quiz Generator</h2>
                        <p className="text-slate-500 max-w-md mx-auto leading-relaxed">Create personalized, scenario-based training modules focusing on practical agent skills and issue resolution.</p>
                    </div>

                    <div className="w-full space-y-8">
                        <div className="grid grid-cols-2 gap-6">
                            <div>
                                <label className="block text-xs font-bold text-slate-500 uppercase mb-2 tracking-wider">Difficulty Level</label>
                                <div className="flex gap-1 bg-slate-50 p-1.5 rounded-xl border border-slate-200 shadow-inner">
                                    {['easy', 'medium', 'hard'].map(d => (
                                        <button
                                            key={d}
                                            onClick={() => setConfig(prev => ({ ...prev, difficulty: d }))}
                                            className={`flex-1 py-2 text-xs font-bold rounded-lg ${config.difficulty === d ? 'bg-white shadow-md text-indigo-600 ring-1 ring-slate-200' : 'text-slate-500 hover:bg-white hover:shadow-sm'}`}
                                        >
                                            {d.charAt(0).toUpperCase() + d.slice(1)}
                                        </button>
                                    ))}
                                </div>
                            </div>
                            <div>
                                <label className="block text-xs font-bold text-slate-500 uppercase mb-2 tracking-wider">Question Count</label>
                                <div className="flex items-center gap-4 bg-slate-50 p-3 rounded-xl border border-slate-200 shadow-inner">
                                    <input
                                        type="range" min="5" max="20" step="5"
                                        value={config.questionCount}
                                        onChange={(e) => setConfig(prev => ({ ...prev, questionCount: parseInt(e.target.value) }))}
                                        className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-indigo-600"
                                    />
                                    <div className="text-center text-xs font-bold text-slate-600 min-w-[3rem] px-2 py-1 bg-white rounded-lg shadow-sm border border-slate-200">{config.questionCount} Qs</div>
                                </div>
                            </div>
                        </div>

                        {/* Filters Section */}
                        <div className={`grid grid-cols-1 md:grid-cols-2 ${type === 'Unified' ? 'lg:grid-cols-3' : 'lg:grid-cols-2'} gap-6`}>
                            {(type === 'NPS' || type === 'Unified') && (
                                <>
                                    <div>
                                        <label className="block text-xs font-bold text-slate-500 uppercase mb-2 tracking-wider">
                                            NPS Pillars
                                        </label>
                                        <MultiSelect
                                            label="Select Pillars"
                                            icon={Target}
                                            options={Object.keys(NPS_METRIC_MAPPING)}
                                            value={filters.Pillar || []}
                                            onChange={(val) => setFilters(prev => ({ ...prev, Pillar: val }))}
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-xs font-bold text-slate-500 uppercase mb-2 tracking-wider">
                                            NPS Sub-metrics
                                        </label>
                                        <MultiSelect
                                            label="All Sub-metrics"
                                            icon={ListChecks}
                                            options={type === 'Unified' ? Object.values(NPS_METRIC_MAPPING).flat() : filterOptions}
                                            value={filters.SubMetric || []}
                                            onChange={(v) => setFilters(prev => ({ ...prev, SubMetric: v }))}
                                        />
                                    </div>
                                </>
                            )}

                            {(type === 'QC' || type === 'Unified') && (
                                <div>
                                    <label className="block text-xs font-bold text-slate-500 uppercase mb-2 tracking-wider">
                                        QC Questions
                                    </label>
                                    <MultiSelect
                                        label="All Questions"
                                        icon={ClipboardList}
                                        options={type === 'Unified' ? Object.values(QC_METRIC_MAPPING).flat() : filterOptions}
                                        value={filters.Question || []}
                                        onChange={(v) => setFilters(prev => ({ ...prev, Question: v }))}
                                    />
                                </div>
                            )}
                        </div>

                        <div>
                            <label className="block text-xs font-bold text-slate-500 uppercase mb-2">Focus Area</label>
                            <textarea
                                value={config.customInstructions}
                                onChange={(e) => setConfig(prev => ({ ...prev, customInstructions: e.target.value }))}
                                placeholder="E.g., Focus on empathy in customer interactions..."
                                className="w-full p-4 text-sm border border-slate-200 bg-white rounded-xl focus:ring-2 focus:ring-indigo-500 outline-none resize-none h-24 shadow-inner placeholder:text-slate-500"
                            />
                        </div>

                        {/* Progress Bar */}
                        {progress.show && (
                            <div className="w-full bg-slate-100 rounded-xl p-4 border border-slate-200">
                                <div className="flex justify-between items-center mb-2">
                                    <span className="text-xs font-bold text-slate-600 uppercase tracking-wider">{progress.text}</span>
                                    <span className="text-xs font-bold text-indigo-600">{progress.percent}%</span>
                                </div>
                                <div className="h-2 bg-slate-200 rounded-full overflow-hidden">
                                    <div 
                                        className="h-full bg-gradient-to-r from-indigo-600 to-violet-600 transition-all duration-300 ease-out"
                                        style={{ width: `${progress.percent}%` }}
                                    />
                                </div>
                            </div>
                        )}

                        <button
                            onClick={generateQuiz}
                            disabled={isGenerating}
                            className="w-full py-4 bg-slate-900 text-white font-bold rounded-xl shadow-lg hover:bg-black disabled:opacity-50 flex items-center justify-center gap-3"
                        >
                            {isGenerating ? <Loader size={20} className="animate-spin" /> : <Sparkles size={20} />}
                            {isGenerating ? 'Analyzing Data & Generating...' : 'Generate Advanced Quiz'}
                        </button>
                    </div>
                </div>
            );
        };

        const StandardQuizModule = ({ data, askAI, type = 'QC' }) => {
            const [selectedWeek, setSelectedWeek] = useState('');
            const [currentPage, setCurrentPage] = useState(1);
            const [quizData, setQuizData] = useState({ title: '', questions: [] });
            const QUESTIONS_PER_PAGE = 3;
            const [loading, setLoading] = useState(false);
            const [currentBatch, setCurrentBatch] = useState(0);
            const [filters, setFilters] = useState({});

            const filterOptions = useMemo(() => {
                if (!data) return [];
                // Apply global appeal filter
                const cleanData = data.filter(d => !DataEngine.isAppeal(d));
                const key = type === 'NPS' ? 'Sub-metric' : 'Question';
                return [...new Set(cleanData.map(d => d[key]).filter(Boolean))].sort();
            }, [data, type]);

            const toggleFilter = (val) => {
                setFilters(prev => {
                    const key = type === 'NPS' ? 'SubMetric' : 'Question';
                    const current = prev[key] || [];
                    const next = current.includes(val) ? current.filter(x => x !== val) : [...current, val];
                    return { ...prev, [key]: next };
                });
            };
            const buildCSVPreview = () => {
                if (!quizData.questions.length) return '';
                const cols = ['Question Number', 'Question Text', 'Option Text', 'Is Correct', 'Feedback Correct', 'Feedback Incorrect'];
                const header = cols.join(',');
                const rows = quizData.questions.flatMap((q, i) => {
                    return q.options.map(opt => {
                        const vals = [
                            i + 1,
                            String(q.text || '').replace(/<[^>]*>/g, ''),
                            String(opt.text || '').replace(/<[^>]*>/g, ''),
                            opt.isCorrect ? 'TRUE' : 'FALSE',
                            String(q.feedbackCorrect || '').replace(/<[^>]*>/g, ''),
                            String(q.feedbackIncorrect || '').replace(/<[^>]*>/g, '')
                        ];
                        return vals.map(v => `"${String(v).replace(/"/g, '""')}"`).join(',');
                    });
                }).join('\n');
                return header + '\n' + rows;
            };


            const availableWeeks = useMemo(() => {
                const weeks = new Set();
                data.filter(d => !DataEngine.isAppeal(d)).forEach(d => {
                    const date = DataEngine.getRowDate(d);
                    if (date) weeks.add(DataEngine.getWeekStart(date));
                });
                return Array.from(weeks).sort((a, b) => {
                    const dA = DataEngine.parseDate(a);
                    const dB = DataEngine.parseDate(b);
                    return dB - dA;
                });
            }, [data]);


            const [editingIndex, setEditingIndex] = useState(null);
            const [editingDraft, setEditingDraft] = useState(null);
            const [previewIndex, setPreviewIndex] = useState(null);

            const startEdit = (i) => { setEditingIndex(i); setEditingDraft(JSON.parse(JSON.stringify(quizData.questions[i]))); };
            const cancelEdit = () => { setEditingIndex(null); setEditingDraft(null); };
            const saveEdit = () => {
                if (editingIndex === null || !editingDraft) return;
                setQuizData(prev => {
                    const next = [...prev.questions];
                    next[editingIndex] = editingDraft;
                    return { ...prev, questions: next };
                });
                setEditingIndex(null);
                setEditingDraft(null);
            };

            const sanitizeAgainstQuestions = (text, forbidden) => {
                if (!text || !forbidden || forbidden.length === 0) return text;
                let out = text;
                forbidden.forEach(label => {
                    if (!label) return;
                    out = out.split(label).join('this scenario');
                });
                return out;
            };

            const parseQuizMarkdown = (text, dataSlice, sanitize, forbidden) => {
                const isQC = type === 'QC';
                const lines = String(text || '').split('\n');
                const questions = [];
                let current = null;
                
                // Enhanced Robust Parsing (Step 31-40)
                // Normalizes line input for better matching
                
                for (let i = 0; i < lines.length; i++) {
                    const rawLine = lines[i];
                    const l = rawLine.trim();
                    const lower = l.toLowerCase();
                    
                    // Fuzzy question matching
                    if (/^(\*\*|#+\s*)?question\s*\d+/i.test(l) || /^Q\.\d+/i.test(l) || /^\d+\.\s+[A-Z]/i.test(l)) {
                        if (current) questions.push(current);
                        // Clean up prefixes
                        const qText = l.replace(/^(\*\*|#+\s*)?question\s*\d+(\*\*)?\s*:?\s*/i, '')
                                       .replace(/^Q\.\d+\s*:?\s*/i, '')
                                       .replace(/^\d+\.\s*/, '');
                        current = { text: sanitize(qText, forbidden), options: [], feedbackCorrect: '', feedbackIncorrect: '' };
                    } 
                    // Robust Option Parsing: Supports - [C], - [I], - (C), - (I), - A), A., etc.
                    // FIX: Check for feedback keywords first to avoid treating feedback as options
                    else if (l.match(/^-\s*\[C\]/i) || l.match(/^-\s*\(C\)/i) || (current && l.startsWith('-') && lower.includes('correct') && !lower.includes('logic') && !lower.includes('answer'))) {
                        const opt = l.replace(/^-\s*\[C\]/i, '').replace(/^-\s*\(C\)/i, '').replace(/^-\s*/, '').trim();
                        if (current) current.options.push({ text: sanitize(opt, forbidden), isCorrect: true });
                    } 
                    else if (l.match(/^-\s*\[I\]/i) || l.match(/^-\s*\(I\)/i) || (current && l.startsWith('-') && !lower.includes('logic') && !lower.includes('answer') && !lower.includes('explanation'))) {
                        const opt = l.replace(/^-\s*\[I\]/i, '').replace(/^-\s*\(I\)/i, '').replace(/^-\s*/, '').trim();
                        if (current) current.options.push({ text: sanitize(opt, forbidden), isCorrect: false });
                    }
                    // Answer Logic
                    else if (/^[\-\*]?\s*correct logic:/i.test(l) || /^[\-\*]?\s*correct answer:/i.test(l)) {
                        if (current) current.feedbackCorrect = l.replace(/^[\-\*]?\s*correct (logic|answer):\s*/i, '').trim();
                    } else if (/^[\-\*]?\s*incorrect logic:/i.test(l) || /^[\-\*]?\s*explanation:/i.test(l)) {
                        if (current) current.feedbackIncorrect = l.replace(/^[\-\*]?\s*incorrect logic:\s*/i, '').replace(/^[\-\*]?\s*explanation:\s*/i, '').trim();
                    }
                }
                if (current) questions.push(current);
                return questions.map((q, idx) => {
                    const row = dataSlice[idx % dataSlice.length] || {};
                    const src = row.sourceUrl || "N/A";
                    const subMetric = row.subMetric || "Metric";
                    const questionText = row.originalQuestion || "Question";

                    // Strictly follow guide formatting (Issues 1G & 1H)
                    const formattedFeedback = type === 'NPS'
                        ? `**${subMetric}** :- ${q.feedbackIncorrect}`
                        : `**${questionText}** :- ${q.feedbackIncorrect} [Link: ${src}]`;

                    return {
                        ...q,
                        feedbackIncorrect: formattedFeedback,
                        src: row || null
                    };
                });
            };

            const regenerateQuestion = async (index) => {
                const qOld = quizData.questions[index];
                const rec = qOld?.src || { rca: '', answerComment: '', remediationFeedback: '', sourceUrl: '' };
                const forbidden = data.map(d => (d['Question'] || d.Question || '').trim()).filter(Boolean);
                const isQC = type === 'QC';
                const recordBullets = `- RCA: ${sanitizeAgainstQuestions(rec.rca, forbidden)}; Agent: ${sanitizeAgainstQuestions(rec.answerComment, forbidden)}; Feedback: ${sanitizeAgainstQuestions(rec.remediationFeedback, forbidden)}; ${isQC ? 'LinkToken: {{LINK_0}}' : ''}`;
                const prompt = `
                        Create 1 MCQ for a training quiz.
                        
                        Context:
                        ${recordBullets}
                        
                        Output Format (Markdown only):
                        - **Question 1**: <text>
                        - **Strictly** list 2-3 Correct options [C] and 2-3 Incorrect options [I].
                        - [C] <correct option>
                        - [I] <incorrect option>
                        - Correct Logic: <positive confirmation with emoji>
                        - Incorrect Logic: <detailed explanation> ${isQC ? '{{LINK_0}}' : ''}
                        
                        RULES:
                        - Do not use emojis in options.
                        - Do not include instructions like "(Select 2)".
                        - **CRITICAL**: Do not use the exact "Question" text from the data. Invent a scenario.
                        - ${isQC ? '**CRITICAL**: For Incorrect Logic, you MUST append the {{LINK_0}} token exactly as provided in the context.' : 'Do NOT include any links or URLs.'}
                    `;
                try {
                    let result = await GeminiAI.generate(prompt);
                    const token = `{{LINK_0}}`;
                    const url = rec.sourceUrl || "No Link Available";
                    result = result.split(token).join(`Source: ${url}`);

                    const parsed = parseQuizMarkdown(result, [rec], sanitizeAgainstQuestions, forbidden);
                    const newQ = parsed[0];
                    if (newQ && newQ.options && newQ.options.length >= 4) {
                        setQuizData(prev => {
                            const next = [...prev.questions];
                            next[index] = newQ;
                            return { ...prev, questions: next };
                        });
                        showToast("Question regenerated.");
                    } else {
                        showToast("Regeneration failed.");
                    }
                } catch (e) {
                    showToast("Regeneration failed.");
                }
            };

            const letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
            const questionMarkdown = (q, i) => {
                let md = `**Question ${i + 1}**: ${String(q.text || '').replace(/<[^>]*>/g, '')}\n`;
                (q.options || []).forEach((opt, k) => {
                    md += `- ${letters[k] || 'A'}) ${String(opt.text || '').replace(/<[^>]*>/g, '')}\n`;
                });
                const correctLetters = (q.options || []).map((o, k) => o.isCorrect ? (letters[k] || 'A') : null).filter(Boolean);
                md += `Correct Answers: ${correctLetters.join(', ') || ''}\n`;
                md += `Incorrect Feedback: ${String(q.feedbackIncorrect || '')}\n`;
                md += `Correct Feedback: ${String(q.feedbackCorrect || '')}\n`;
                return md;
            };

            const handleGenerate = async () => {
                setLoading(true);
                // Dispatch progress event
                window.dispatchEvent(new CustomEvent('ai-progress', { detail: { show: true, progress: 10, text: 'Analyzing data...' } }));
                
                // Reset data and pagination
                setCurrentPage(1);
                const quizTitle = selectedWeek ? `${type} Proficiency Quiz - ${selectedWeek}` : `${type} Proficiency Quiz - All Data`;
                setQuizData({ title: quizTitle, questions: [] });


                const relevantData = data.filter(d => {
                    // Week filter is now optional
                    if (selectedWeek) {
                        const date = DataEngine.getRowDate(d);
                        const week = date ? DataEngine.getWeekStart(date) : '';
                        if (week !== selectedWeek) return false;
                    }

                    // Pillar Filter
                    if (filters.Pillar && filters.Pillar.length > 0) {
                        const mapping = type === 'NPS' ? NPS_METRIC_MAPPING : QC_METRIC_MAPPING;
                        const subMetric = type === 'NPS' ? d['Sub-metric'] : d['Question'];
                        const pillar = Object.keys(mapping).find(p => mapping[p].includes(subMetric));
                        if (!filters.Pillar.includes(pillar)) return false;
                    }

                    // Sub-metric/Question Filter
                    const filterKey = type === 'NPS' ? 'SubMetric' : 'Question';
                    if (filters[filterKey] && filters[filterKey].length > 0) {
                        const itemVal = type === 'NPS' ? d['Sub-metric'] : d['Question'];
                        if (!filters[filterKey].includes(itemVal)) return false;
                    }

                    if (type === 'NPS') return d.Rating !== 'WOW';
                    if (type === 'QC') {
                        const score = parseFloat(d['QC Score']);
                        return (!isNaN(score) && score < 100) || d['Pass/Fail'] === 'Fail';
                    }
                    return true;
                });


                if (relevantData.length === 0) {
                    showToast("No relevant data found.");
                    setLoading(false);
                    return;
                }


                const context = relevantData.map(f => {
                    const tlRCA = f['TL RCA'] || '';
                    const answerComment = f['Answer Comment'] || '';
                    const remediationFeedback = f['Remediation Feedback'] || '';
                    const sourceUrl = f['Dante/BO Review Link'] || f['Review Link'] || 'N/A';
                    const subMetric = f['Sub-metric'] || '';
                    const originalQuestion = f['Question'] || '';

                    return {
                        rca: tlRCA,
                        answerComment: answerComment,
                        remediationFeedback: remediationFeedback,
                        sourceUrl: sourceUrl,
                        subMetric: subMetric,
                        originalQuestion: originalQuestion
                    };
                });

                const totalBatches = 4;
                const batchSize = 5;


                try {
                    const forbidden = Array.from(
                        new Set(
                            relevantData
                                .map(d => (d['Question'] || d.Question || '').trim())
                                .filter(Boolean)
                        )
                    );
                    for (let b = 0; b < totalBatches; b++) {
                        setCurrentBatch(b + 1);
                        const progressPercent = 20 + Math.round((b / totalBatches) * 70);
                        window.dispatchEvent(new CustomEvent('ai-progress', { 
                            detail: { show: true, progress: progressPercent, text: `Generating batch ${b + 1}/${totalBatches}...` } 
                        }));
                        const sliceStart = (b * batchSize) % context.length;
                        const dataSlice = context.slice(sliceStart, sliceStart + batchSize);


                        const isQC = type === 'QC';
                        const recordBullets = dataSlice.map((rec, idx) => `- RCA: ${sanitizeAgainstQuestions(rec.rca, forbidden)}; Agent: ${sanitizeAgainstQuestions(rec.answerComment, forbidden)}; Feedback: ${sanitizeAgainstQuestions(rec.remediationFeedback, forbidden)}; ${isQC ? `LinkToken: {{LINK_${idx}}}` : ''}`).join('\n');
                        const prompt = `
                                Create 5 MCQs for a training quiz.
                                
                                Context:
    ${recordBullets}
                                
                                Output Format (Markdown only):
                                - For each question, add a bold header: **Question N** followed by the question text on the same line.
                                - **Strictly** list 2-3 Correct options [C] and 2-3 Incorrect options [I].
                                - Mark correct options with "[C]" prefix.
                                - Mark incorrect options with "[I]" prefix.
                                - Correct Logic: <positive confirmation with emoji>
                                - Incorrect Logic: <detailed explanation> {{LINK_N}}
                                
                                RULE NPS:
                                - DO NOT include any links or URLs in the output.
                                - Explanation format: **<Sub-metric>** :- <explanation>

                                RULE QC:
                                - For FAILED answers, YOU MUST INCLUDE THE LINK TOKEN.
                                - Explanation format: **<Question>** :- <explanation> {{LINK_N}}

                                GUIDELINES:
                                - Do not use emojis in options.
                                - Do not include instructions like "(Select 2)".
                                - **CRITICAL**: Do not use the exact "Question" text from the data. Invent a scenario.
                                - ${isQC ? '**CRITICAL**: For Incorrect Logic, you MUST append the {{LINK_N}} token exactly as provided in the context to point to the source.' : 'Do NOT include any links or URLs.'}
                            `;



                        let result = await GeminiAI.generate(prompt);

                        // Post-Process: Inject Links back from Tokens
                        dataSlice.forEach((rec, idx) => {
                            const token = `{{LINK_${idx}}}`;
                            const url = rec.sourceUrl || "No Link Available";
                            result = result.split(token).join(`Source: ${url}`);
                        });

                        const parsed = parseQuizMarkdown(result, dataSlice, sanitizeAgainstQuestions);
                        const newBatch = parsed;


                        setQuizData(prev => ({
                            ...prev,
                            questions: [...prev.questions, ...newBatch]
                        }));
                    }
                    showToast("All 20 questions generated!", "success");
                } catch (e) {
                    console.error("Stream Error", e);
                    showToast("Partial generation complete.");
                }
                setLoading(false);
                setCurrentBatch(0);
                // Hide progress bar
                window.dispatchEvent(new CustomEvent('ai-progress', { detail: { show: false, progress: 100, text: 'Complete!' } }));
            };


            const downloadQuizCSV = () => {
                if (quizData.questions.length === 0) { showToast("No quiz to export."); return; }
                const csvData = quizData.questions.flatMap((q, i) => {
                    return q.options.map(opt => ({
                        'Question Number': i + 1,
                        'Question Text': q.text.replace(/<[^>]*>/g, ''),
                        'Option Text': opt.text.replace(/<[^>]*>/g, ''),
                        'Is Correct': opt.isCorrect ? 'TRUE' : 'FALSE',
                        'Feedback Correct': q.feedbackCorrect.replace(/<[^>]*>/g, ''),
                        'Feedback Incorrect': q.feedbackIncorrect.replace(/<[^>]*>/g, '')
                    }));
                });
                ExportEngine.exportCSV(csvData, `Quiz_${selectedWeek.replace(/\//g, '-')}`);
            };


            const copyCleanText = (html) => {
                const temp = document.createElement("div");
                temp.innerHTML = html;
                const txt = temp.textContent || temp.innerText || "";
                safeCopyToClipboard(txt, html);
            };

            // FIXED: Removed transition-all, kept basic hover styling for copy button
            const GranularCopy = ({ html, title }) => (
                <button onClick={() => { copyCleanText(html); showToast(`${title} copied!`); }} className="p-1.5 text-slate-500 hover:text-indigo-600 hover:bg-indigo-50 rounded-md shrink-0">
                    <Copy size={12} />
                </button>
            );

            // Quiz Pagination Controls - 3 Questions Per Page
            const QuizPaginationControls = ({ current, totalQuestions, onChange, className = "" }) => {
                const totalPages = Math.ceil(totalQuestions / QUESTIONS_PER_PAGE);
                if (totalPages <= 1) return null;
                
                const startQ = (current - 1) * QUESTIONS_PER_PAGE + 1;
                const endQ = Math.min(current * QUESTIONS_PER_PAGE, totalQuestions);
                
                // Generate page number buttons
                const getPageNumbers = () => {
                    const pages = [];
                    for (let i = 1; i <= totalPages; i++) {
                        pages.push(i);
                    }
                    return pages;
                };
                
                return (
                    <div className={`flex flex-col items-center gap-3 mt-6 ${className}`}>
                        {/* Question Counter */}
                        <div className="text-xs font-bold text-slate-500 uppercase tracking-wider">
                            Questions {startQ} - {endQ} of {totalQuestions}
                        </div>
                        
                        {/* Navigation Controls */}
                        <div className="flex items-center justify-center gap-2">
                            <button
                                onClick={() => onChange(Math.max(1, current - 1))}
                                disabled={current === 1}
                                className="px-3 py-2 rounded-lg hover:bg-slate-100 disabled:opacity-30 transition-all text-slate-600 font-medium text-sm flex items-center gap-1"
                                title="Previous Page"
                            >
                                <ChevronLeft size={16} />
                                <span>Prev</span>
                            </button>
                            
                            {/* Page Numbers */}
                            <div className="flex items-center gap-1 px-2">
                                {getPageNumbers().map(pageNum => (
                                    <button
                                        key={pageNum}
                                        onClick={() => onChange(pageNum)}
                                        className={`w-9 h-9 rounded-lg text-sm font-bold transition-all ${
                                            current === pageNum 
                                                ? 'bg-indigo-600 text-white shadow-md' 
                                                : 'text-slate-600 hover:bg-slate-100'
                                        }`}
                                    >
                                        {pageNum}
                                    </button>
                                ))}
                            </div>
                            
                            <button
                                onClick={() => onChange(Math.min(totalPages, current + 1))}
                                disabled={current === totalPages}
                                className="px-3 py-2 rounded-lg hover:bg-slate-100 disabled:opacity-30 transition-all text-slate-600 font-medium text-sm flex items-center gap-1"
                                title="Next Page"
                            >
                                <span>Next</span>
                                <ChevronRight size={16} />
                            </button>
                        </div>
                        
                        {/* Page X of Y */}
                        <div className="text-xs text-slate-400 font-medium">
                            Page {current} of {totalPages}
                        </div>
                    </div>
                );
            };

            return (
                <div className="space-y-6">
                    <div className="bg-white rounded-2xl p-8 border border-slate-200 shadow-lg">
                        <div className={`grid grid-cols-1 md:grid-cols-2 ${type === 'Unified' ? 'lg:grid-cols-4' : 'lg:grid-cols-3'} gap-6 mb-8`}>
                            <div className="space-y-2">
                                <label className="block text-xs font-bold text-slate-500 uppercase tracking-widest pl-1">Target Week</label>
                                <select
                                    value={selectedWeek}
                                    onChange={(e) => setSelectedWeek(e.target.value)}
                                    className="w-full p-3.5 bg-slate-50 border border-slate-200 rounded-2xl text-sm font-semibold focus:ring-2 focus:ring-violet-500 outline-none shadow-sm"
                                >
                                    <option value="">-- Choose Week --</option>
                                    {availableWeeks.map(w => <option key={w} value={w}>{w}</option>)}
                                </select>
                            </div>

                            {(type === 'NPS' || type === 'Unified') && (
                                <>
                                    <div className="space-y-2">
                                        <label className="block text-xs font-bold text-slate-500 uppercase tracking-widest pl-1">NPS Pillars</label>
                                        <MultiSelect
                                            label="Select Pillars"
                                            icon={Target}
                                            options={Object.keys(NPS_METRIC_MAPPING)}
                                            value={filters.Pillar || []}
                                            onChange={(v) => setFilters({ ...filters, Pillar: v })}
                                        />
                                    </div>
                                    <div className="space-y-2">
                                        <label className="block text-xs font-bold text-slate-500 uppercase tracking-widest pl-1">NPS Sub-metrics</label>
                                        <MultiSelect
                                            label="All Sub-metrics"
                                            icon={ListChecks}
                                            options={type === 'Unified' ? Object.values(NPS_METRIC_MAPPING).flat() : filterOptions}
                                            value={filters.SubMetric || []}
                                            onChange={(v) => setFilters({ ...filters, SubMetric: v })}
                                        />
                                    </div>
                                </>
                            )}

                            {(type === 'QC' || type === 'Unified') && (
                                <div className="space-y-2">
                                    <label className="block text-xs font-bold text-slate-500 uppercase tracking-widest pl-1">QC Questions</label>
                                    <MultiSelect
                                        label="All Questions"
                                        icon={ClipboardList}
                                        options={type === 'Unified' ? Object.values(QC_METRIC_MAPPING).flat() : filterOptions}
                                        value={filters.Question || []}
                                        onChange={(v) => setFilters({ ...filters, Question: v })}
                                    />
                                </div>
                            )}
                        </div>

                        <div className="flex gap-4">
                            <button
                                onClick={handleGenerate}
                                disabled={loading}
                                className="flex-1 py-4 bg-slate-900 text-white rounded-2xl font-black uppercase tracking-tighter flex items-center justify-center gap-3 hover:bg-black disabled:opacity-50"
                            >
                                {loading ? <Loader size={20} className="animate-spin" /> : <Sparkles size={20} />}
                                <span>{loading ? `Generating Batch ${currentBatch}/4...` : 'Generate Training Quiz'}</span>
                            </button>
                            {quizData.questions.length > 0 && (
                                <button
                                    onClick={downloadQuizCSV}
                                    className="px-6 py-4 bg-white border border-slate-200 text-slate-700 rounded-2xl font-bold flex items-center justify-center gap-2 hover:bg-slate-50"
                                    title="Export CSV"
                                >
                                    <FileSpreadsheet size={20} />
                                </button>
                            )}
                        </div>
                    </div>

                    <React.Fragment>
                    {quizData.questions.length > 0 && (
                        <div className="bg-white rounded-2xl border border-slate-200 shadow-lg p-8">
                            {/* Quiz Header */}
                            <div className="flex justify-between items-center pb-6 mb-6 border-b border-slate-200">
                                <div>
                                    <h3 className="text-xl font-bold text-slate-800">{quizData.title}</h3>
                                    <p className="text-sm text-slate-500 mt-1">Training module generated based on {selectedWeek} performance data. Focus points include areas with identified defects.</p>
                                </div>
                                <button
                                    onClick={handleGenerate}
                                    className="px-4 py-2 bg-indigo-600 text-white rounded-lg text-sm font-bold hover:bg-indigo-700 flex items-center gap-2"
                                >
                                    <RefreshCw size={16} />
                                    Regenerate
                                </button>
                            </div>
                            
                            <div className="space-y-8">
                                {/* Pagination Controls Top */}
                                <QuizPaginationControls current={currentPage} totalQuestions={quizData.questions.length} onChange={setCurrentPage} />

                                {/* Questions for Current Page - Display 3 questions per page */}
                                <div className="space-y-8">
                                    {quizData.questions
                                        .slice((currentPage - 1) * QUESTIONS_PER_PAGE, currentPage * QUESTIONS_PER_PAGE)
                                        .map((question, idx) => {
                                            const questionIndex = (currentPage - 1) * QUESTIONS_PER_PAGE + idx;
                                            const isEditing = editingIndex === questionIndex;
                                            
                                            return (
                                                <div key={questionIndex} className="bg-slate-50 p-8 rounded-xl border border-slate-200 space-y-8">
                                                    {/* Question Header */}
                                                    <div className="flex justify-between items-start gap-4">
                                                        <div className="flex gap-4 items-start">
                                                            <div className="w-12 h-12 rounded-2xl bg-gradient-to-br from-violet-600 to-indigo-600 text-white flex items-center justify-center font-black text-xl flex-shrink-0 shadow-md">
                                                                {questionIndex + 1}
                                                            </div>
                                                            <div>
                                                                <h3 className="text-xl font-black text-slate-800 leading-tight mb-2" dangerouslySetInnerHTML={{ __html: question.text }} />
                                                                <p className="text-[10px] font-bold text-slate-500 uppercase tracking-widest">Scenario-Based Challenge</p>
                                                            </div>
                                                        </div>
                                                        <div className="flex items-center gap-1.5 p-1 bg-white rounded-xl border border-slate-200">
                                                            <button onClick={() => setPreviewIndex(questionIndex)} className="p-2 text-slate-500 hover:text-indigo-600 hover:bg-slate-50 rounded-lg" title="Full Preview"><Eye size={16} /></button>
                                                            <button onClick={() => startEdit(questionIndex)} className="p-2 text-slate-500 hover:text-blue-600 hover:bg-slate-50 rounded-lg" title="Edit Content"><Edit2 size={16} /></button>
                                                            <button onClick={() => regenerateQuestion(questionIndex)} className="p-2 text-slate-500 hover:text-emerald-600 hover:bg-slate-50 rounded-lg" title="Regenerate Item"><RefreshCw size={16} /></button>
                                                            <div className="w-[1px] h-4 bg-slate-200 mx-1" />
                                                            <GranularCopy html={question.text} title="Question" />
                                                        </div>
                                                    </div>

                                                    {isEditing ? (
                                                        <div className="space-y-6 bg-white p-6 rounded-xl border border-slate-200">
                                                            <div className="space-y-2">
                                                                <label className="text-[10px] font-black text-slate-500 uppercase tracking-widest ml-1">Question Text</label>
                                                                <textarea
                                                                    value={editingDraft?.text || ''}
                                                                    onChange={(e) => setEditingDraft(prev => ({ ...prev, text: e.target.value }))}
                                                                    className="w-full p-4 bg-slate-50 border border-slate-200 rounded-2xl text-sm focus:ring-2 ring-violet-500 outline-none shadow-sm"
                                                                    rows={3}
                                                                />
                                                            </div>
                                                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                                                {(editingDraft?.options || []).map((opt, j) => (
                                                                    <div key={j} className={`p-4 rounded-2xl border flex items-center gap-3 ${opt.isCorrect ? 'border-emerald-200 bg-emerald-50' : 'bg-white border-slate-200 shadow-sm'}`}>
                                                                        <input
                                                                            type="checkbox"
                                                                            checked={!!opt.isCorrect}
                                                                            onChange={(e) => setEditingDraft(prev => {
                                                                                const next = { ...prev };
                                                                                next.options = [...(next.options || [])];
                                                                                next.options[j] = { ...next.options[j], isCorrect: e.target.checked };
                                                                                return next;
                                                                            })}
                                                                            className="w-5 h-5 rounded-lg border-slate-300 text-violet-600 focus:ring-violet-500"
                                                                        />
                                                                        <input
                                                                            value={opt.text || ''}
                                                                            onChange={(e) => setEditingDraft(prev => {
                                                                                const next = { ...prev };
                                                                                next.options = [...(next.options || [])];
                                                                                next.options[j] = { ...next.options[j], text: e.target.value };
                                                                                return next;
                                                                            })}
                                                                            className="flex-1 p-2.5 bg-transparent border-none text-xs font-medium focus:ring-0 outline-none"
                                                                            placeholder={`Option ${j + 1}...`}
                                                                        />
                                                                    </div>
                                                                ))}
                                                            </div>
                                                            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                                                <div className="space-y-2">
                                                                    <label className="text-[10px] font-black text-emerald-600 uppercase tracking-widest ml-1">Correct Logic</label>
                                                                    <textarea value={editingDraft?.feedbackCorrect || ''} onChange={(e) => setEditingDraft(prev => ({ ...prev, feedbackCorrect: e.target.value }))} className="w-full p-4 bg-emerald-50 border border-emerald-200 rounded-2xl text-xs focus:ring-2 ring-emerald-500 outline-none shadow-sm" rows={3} />
                                                                </div>
                                                                <div className="space-y-2">
                                                                    <label className="text-[10px] font-black text-rose-600 uppercase tracking-widest ml-1">Misconception Alert</label>
                                                                    <textarea value={editingDraft?.feedbackIncorrect || ''} onChange={(e) => setEditingDraft(prev => ({ ...prev, feedbackIncorrect: e.target.value }))} className="w-full p-4 bg-rose-50 border border-rose-200 rounded-2xl text-xs focus:ring-2 ring-rose-500 outline-none shadow-sm" rows={3} />
                                                                </div>
                                                            </div>
                                                            <div className="flex gap-3 justify-end pt-2">
                                                                <button onClick={saveEdit} className="px-6 py-2.5 bg-slate-900 text-white rounded-xl text-xs font-black uppercase tracking-widest shadow-lg hover:shadow-xl">Save Changes</button>
                                                                <button onClick={cancelEdit} className="px-6 py-2.5 bg-slate-100 text-slate-500 rounded-xl text-xs font-black uppercase tracking-widest hover:bg-slate-200">Discard</button>
                                                            </div>
                                                        </div>
                                                    ) : (
                                                        <div className="space-y-8">
                                                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                                                {question.options.map((opt, j) => (
                                                                    <div key={j} className={`group p-5 rounded-2xl border flex justify-between items-center ${opt.isCorrect ? 'border-emerald-200 bg-emerald-50' : 'bg-white border-slate-200 hover:border-violet-300'}`}>
                                                                        <div className="flex items-center gap-4 flex-1 min-w-0">
                                                                            <div className={`w-6 h-6 rounded-lg border-2 flex-shrink-0 flex items-center justify-center ${opt.isCorrect ? 'bg-emerald-500 border-emerald-500' : 'bg-white border-slate-300'}`}>
                                                                                {opt.isCorrect && <CheckCircle size={14} className="text-white" />}
                                                                            </div>
                                                                            <span className="text-sm font-semibold text-slate-700 leading-snug" dangerouslySetInnerHTML={{ __html: safeMarked(opt.text) }} />
                                                                        </div>
                                                                        <GranularCopy html={opt.text} title="Option" />
                                                                    </div>
                                                                ))}
                                                            </div>

                                                            <div className="grid grid-cols-1 md:grid-cols-2 gap-6 pt-6 border-t border-slate-200">
                                                                <div className="p-6 bg-emerald-50 rounded-2xl border border-emerald-200 relative">
                                                                    <div className="absolute top-4 right-4"><GranularCopy html={safeMarked(question.feedbackCorrect)} title="Correct Logic" /></div>
                                                                    <div className="flex items-center gap-2 mb-3">
                                                                        <div className="p-1 px-2 rounded-lg bg-emerald-200 text-emerald-800 text-[10px] font-black uppercase tracking-widest">Success Logic</div>
                                                                    </div>
                                                                    <div className="text-xs text-emerald-900 leading-relaxed pr-8 font-medium" dangerouslySetInnerHTML={{ __html: safeMarked(question.feedbackCorrect) }} />
                                                                </div>
                                                                <div className="p-6 bg-rose-50 rounded-2xl border border-rose-200 relative">
                                                                    <div className="absolute top-4 right-4"><GranularCopy html={safeMarked(question.feedbackIncorrect)} title="Incorrect Logic" /></div>
                                                                    <div className="flex items-center gap-2 mb-3">
                                                                        <div className="p-1 px-2 rounded-lg bg-rose-200 text-rose-800 text-[10px] font-black uppercase tracking-widest">Risk Warning</div>
                                                                    </div>
                                                                    <div className="text-xs text-rose-900 leading-relaxed pr-8 font-medium" dangerouslySetInnerHTML={{ __html: safeMarked(question.feedbackIncorrect) }} />
                                                                </div>
                                                            </div>
                                                        </div>
                                                    )}
                                                    
                                                    {/* Separator between questions (except for last) */}
                                                    {idx < Math.min(QUESTIONS_PER_PAGE, quizData.questions.length - (currentPage - 1) * QUESTIONS_PER_PAGE) - 1 && (
                                                        <div className="border-t-2 border-dashed border-slate-200 mt-8 pt-4">
                                                            <div className="text-center text-xs text-slate-400 font-medium uppercase tracking-wider">
                                                                Next Question
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>
                                            );
                                        })}
                                </div>

                                {/* Pagination Controls Bottom */}
                                <QuizPaginationControls current={currentPage} totalQuestions={quizData.questions.length} onChange={setCurrentPage} />

                            </div>
                        </div>
                    )}

                    <Modal isOpen={previewIndex !== null} onClose={() => setPreviewIndex(null)} title={`Question ${previewIndex !== null ? previewIndex + 1 : ''} Preview`}>
                        <div id="quiz-preview-content" className="bg-slate-50 rounded-xl border border-slate-200 p-6">
                            {previewIndex !== null && (
                                <div>
                                    <div className="flex justify-between items-center mb-4 pb-4 border-b border-slate-200">
                                        <h4 className="text-sm font-bold text-slate-700">Detailed Analysis</h4>
                                        <button
                                            onClick={() => regenerateQuestion(previewIndex)}
                                            className="px-3 py-1.5 bg-indigo-600 text-white rounded-lg text-xs font-bold hover:bg-indigo-700 flex items-center gap-2"
                                        >
                                            <RefreshCw size={12} />
                                            Regenerate
                                        </button>
                                    </div>
                                    <pre className="text-xs text-slate-600 bg-white p-4 rounded-lg border border-slate-200 overflow-x-auto whitespace-pre-wrap font-mono">{questionMarkdown(quizData.questions[previewIndex], previewIndex)}</pre>
                                </div>
                            )}
                        </div>
                    </Modal>
                    </React.Fragment>
                </div>
            );
        };

        // InsightReliabilityDashboard removed per Issue #22
        const _InsightReliabilityDashboard = ({ npsData, qcData, askAI, onDownloadImage }) => {
            const stats = useMemo(() => {
                const agents = {};
                npsData.forEach(r => {
                    const a = DataEngine.normalizeAgent(r, 'NPS');
                    if (a) {
                        if (!agents[a]) agents[a] = { nps: [], qc: [] };
                        // Simplified NPS Score: 100 if not Poor, 0 if Poor (approximate for row-level)
                        // Or better: use 100 for Pass, 0 for Fail based on defects?
                        // Requirement says: "NPS Score: (Clean Surveys / Total Surveys) * 100"
                        const isClean = !Object.values(NPS_METRIC_MAPPING).flat().some(m => r[m] === false || r[m] === 'FALSE');
                        agents[a].nps.push(isClean ? 100 : 0);
                    }
                });
                qcData.forEach(r => {
                    const a = DataEngine.normalizeAgent(r, 'QC');
                    if (a) {
                        if (!agents[a]) agents[a] = { nps: [], qc: [] };
                        agents[a].qc.push(parseFloat(r['QC Score']) || 0);
                    }
                });


                const agentStats = Object.entries(agents).map(([name, data]) => {
                    const npsAvg = data.nps.length ? data.nps.reduce((a, b) => a + b, 0) / data.nps.length : 0;
                    const qcAvg = data.qc.length ? data.qc.reduce((a, b) => a + b, 0) / data.qc.length : 0;
                    const holistic = (npsAvg + qcAvg) / 2;
                    return { name, nps: npsAvg, qc: qcAvg, holistic, gap: Math.abs(npsAvg - qcAvg) };
                }).filter(a => a.nps > 0 || a.qc > 0);


                const holisticScores = agentStats.map(a => a.holistic);
                const mean = holisticScores.length ? holisticScores.reduce((a, b) => a + b, 0) / holisticScores.length : 0;
                const variance = holisticScores.length ? holisticScores.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / holisticScores.length : 0;
                const stdDev = Math.sqrt(variance);


                return {
                    agentStats,
                    stdDev: stdDev.toFixed(1),
                    avgGap: agentStats.length ? (agentStats.reduce((a, b) => a + b.gap, 0) / agentStats.length).toFixed(1) : 0
                };
            }, [npsData, qcData]);


            return (
                <div className="space-y-6">
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <KPICard
                            title="Calibration Variance"
                            value={stats.stdDev}
                            subtitle="Standard Deviation of Holistic Scores"
                            icon={Activity}
                            trend="neutral"
                        />
                        <KPICard
                            title="Avg Coverage Gap"
                            value={stats.avgGap}
                            subtitle="Avg Abs Diff between NPS & QC"
                            icon={GitCompare}
                            trend="neutral"
                        />
                    </div>


                    <Card
                        title="Reliability Matrix (NPS vs QC)"
                        id="reliability-matrix"
                        infoText="Scatter plot comparing External Sentiment (NPS) vs Internal Quality (QC). Agents in the top-right are 'Stars'. Bottom-left are 'Underperformers'. Off-diagonal indicates misalignment."
                        onDownloadImage={onDownloadImage}
                        askAI={askAI}
                        dataForAI={stats.agentStats}
                    >
                        <div className="h-96 relative p-4">
                            {/* Scatter Plot Implementation */}
                            <div className="absolute bottom-8 left-8 right-8 top-8 border-l border-b border-slate-300">
                                {stats.agentStats.map((agent, i) => (
                                    <div
                                        key={i}
                                        className="absolute w-3 h-3 rounded-full bg-indigo-500/80 hover:bg-indigo-600 hover:scale-150 transition-all cursor-pointer shadow-sm group"
                                        style={{
                                            left: `${agent.nps}%`,
                                            bottom: `${agent.qc}%`,
                                            transform: 'translate(-50%, 50%)'
                                        }}
                                        title={`${agent.name}: NPS ${agent.nps.toFixed(0)}%, QC ${agent.qc.toFixed(0)}%`}
                                    >
                                        <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 px-2 py-1 bg-slate-800 text-white text-xs rounded opacity-0 group-hover:opacity-100 whitespace-nowrap z-10 pointer-events-none">
                                            {agent.name}
                                        </div>
                                    </div>
                                ))}
                                {/* Axis Labels */}
                                <div className="absolute -bottom-6 right-0 text-xs font-bold text-slate-500">NPS Score (External) ?</div>
                                <div className="absolute -left-6 top-0 text-xs font-bold text-slate-500 -rotate-90 origin-right">QC Score (Internal) ?</div>
                            </div>
                        </div>
                    </Card>


                    <Card
                        title="Misalignment Table"
                        type="Table"
                        id="misalignment-table"
                        infoText="Agents with the highest discrepancy between how customers rate them vs. how QA rates them."
                        onDownloadImage={onDownloadImage}
                    >
                        <div className="overflow-x-auto w-full">
                            <table className="w-full text-xs text-left">
                                <thead className="bg-slate-50">
                                    <tr>
                                        <th className="p-3 font-bold text-slate-600">Agent</th>
                                        <th className="p-3 font-bold text-slate-600 text-center">NPS Score</th>
                                        <th className="p-3 font-bold text-slate-600 text-center">QC Score</th>
                                        <th className="p-3 font-bold text-slate-600 text-center">Gap</th>
                                        <th className="p-3 font-bold text-slate-600">Verdict</th>
                                    </tr>
                                </thead>
                                <tbody className="divide-y divide-slate-100">
                                    {stats.agentStats.sort((a, b) => b.gap - a.gap).slice(0, 10).map((agent, i) => (
                                        <tr key={i} className="hover:bg-slate-50">
                                            <td className="p-3 font-medium text-slate-700">{agent.name}</td>
                                            <td className="p-3 text-center">{agent.nps.toFixed(0)}%</td>
                                            <td className="p-3 text-center">{agent.qc.toFixed(0)}%</td>
                                            <td className="p-3 text-center font-bold text-rose-600">{agent.gap.toFixed(0)}%</td>
                                            <td className="p-3 text-slate-500">
                                                {agent.nps > agent.qc + 10 ? "Customer Favorite (Process Weak?)" :
                                                    agent.qc > agent.nps + 10 ? "Process Expert (Robot?)" : "Aligned"}
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </Card>
                </div>
            );
        };


        /**
         * AdvancedQuizModule - Premium quiz aesthetic for agent-focused scenarios.
         * Features: Incremental generation, individual question control, and clean UI.
         */


        // --- Quiz Output Wrapper ---
        const QuizOutputWrapper = ({ data, filename = 'quiz-scenarios' }) => {
            if (!data || data.length === 0) return null;

            const handleCopy = () => {
                safeCopyToClipboard(JSON.stringify(data, null, 2));
                showToast('Quiz JSON copied to clipboard!', 'success');
            };

            const handleDownload = () => {
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${filename}.json`;
                a.click();
                URL.revokeObjectURL(url);
                showToast('Quiz JSON downloaded!', 'success');
            };

            return (
                <div className="mx-8 mb-6 p-4 bg-slate-100 rounded-xl border border-slate-200">
                    <div className="flex justify-between items-center">
                        <div className="flex items-center gap-2">
                            <div className="p-1.5 bg-slate-200 rounded-lg text-slate-600">
                                <FileCode size={14} />
                            </div>
                            <div>
                                <h4 className="text-xs font-bold text-slate-600 uppercase tracking-wider">Developer Export</h4>
                                <p className="text-[10px] text-slate-500">Access raw scenario data</p>
                            </div>
                        </div>
                        <div className="flex gap-2">
                            <button onClick={handleCopy} className="text-xs flex items-center gap-1 text-slate-600 hover:text-indigo-600 font-medium px-3 py-1.5 bg-white border border-slate-200 hover:border-indigo-300 rounded-lg transition-colors shadow-sm">
                                <Copy size={12} /> Copy JSON
                            </button>
                            <button onClick={handleDownload} className="text-xs flex items-center gap-1 text-slate-600 hover:text-indigo-600 font-medium px-3 py-1.5 bg-white border border-slate-200 hover:border-indigo-300 rounded-lg transition-colors shadow-sm">
                                <Download size={12} /> Download JSON
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const AdvancedQuizModule = ({ data, askAI, selectedAgent, title }) => {
            const [scenarios, setScenarios] = useState([]);
            const [generating, setGenerating] = useState(false);
            const [progress, setProgress] = useState(0);
            const [currentStage, setCurrentStage] = useState("");
            const scrollContainerRef = useRef(null);
            
            // Filter state variables
            const [selectedPillar, setSelectedPillar] = useState([]);
            const [selectedSubMetrics, setSelectedSubMetrics] = useState([]);
            const [selectedQuestions, setSelectedQuestions] = useState([]);
            
            // Get all available NPS sub-metrics
            const npsSubMetrics = useMemo(() => {
                return Object.values(NPS_METRIC_MAPPING).flat();
            }, []);
            
            // Get all available QC questions
            const qcQuestions = useMemo(() => {
                if (!data?.qc) return [];
                const questions = new Set();
                data.qc.forEach(row => {
                    const q = row['Question'] || row.Question;
                    if (q) questions.add(q);
                });
                return Array.from(questions).sort();
            }, [data]);

            const buildFallbackScenarios = () => {
                const fallback = [];
                const agentContext = selectedAgent && selectedAgent !== 'Team' ? ` for ${selectedAgent}` : '';
                
                // Scenario 1: NPS Low Scores
                const lowNps = data.nps?.filter(r => r.Rating === 'Poor') || [];
                if (lowNps.length > 0) {
                     fallback.push({
                        id: 1,
                        topic: "De-escalation",
                        scenario: `A customer gave a poor rating${agentContext} mentioning: "${lowNps[0]['Comment'] || 'Unresolved issue'}".`,
                        question: "What is the best immediate recovery action?",
                        options: ["Ignore and move on", "Call back immediately", "Send a generic apology email", "Analyze the root cause and send a personalized follow-up"],
                        correct: 3,
                        logic: "Personalized follow-up addresses the specific dissatisfaction and shows care."
                     });
                } else {
                    fallback.push({
                        id: 1,
                        topic: "Proactive Service",
                        scenario: "A customer seems hesitant about a product feature.",
                        question: "How should you approach this?",
                        options: ["Push for a sale", "Ask open-ended questions to understand needs", "Wait for them to ask", "Refer to FAQ"],
                        correct: 1,
                        logic: "Understanding needs builds trust and leads to better solutions."
                    });
                }

                // Scenario 2: QC Compliance
                const failedQc = data.qc?.filter(r => r.isFail || r['Pass/Fail'] === 'Fail') || [];
                if (failedQc.length > 0) {
                     fallback.push({
                        id: 2,
                        topic: "Compliance",
                        scenario: `An audit failed${agentContext} on: "${failedQc[0]['Question'] || 'Process adherence'}".`,
                        question: "How do we prevent this recurrence?",
                        options: ["Blame the system", "Review the specific procedure and role-play", "Ignore it as a one-off", "Dispute the audit"],
                        correct: 1,
                        logic: "Reviewing and practicing is the only way to ensure future compliance."
                     });
                } else {
                     fallback.push({
                        id: 2,
                        topic: "Process Adherence",
                        scenario: "You are unsure about a specific step in the verification process.",
                        question: "What is the safest action?",
                        options: ["Guess", "Ask a neighbor", "Consult the official Knowledge Base", "Skip the step"],
                        correct: 2,
                        logic: "The Knowledge Base is the single source of truth."
                     });
                }

                // Scenario 3: Soft Skills (Generic)
                fallback.push({
                    id: 3,
                    topic: "Empathy",
                    scenario: "A customer is frustrated by a long wait time.",
                    question: "Which statement demonstrates the most empathy?",
                    options: ["'It's not my fault.'", "'I know, it's busy.'", "'I sincerely apologize for the delay, let's get this sorted for you.'", "'Please hold.'"],
                    correct: 2,
                    logic: "Acknowledging the pain point and pivoting to a solution is key."
                });

                return fallback;
            };

            const generateScenarios = async () => {
                setScenarios([]);
                setScenarioPage(1); // Reset pagination
                setGenerating(true);
                setProgress(0);
                setCurrentStage("Analyzing Agent Gaps...");

                try {
                    // 1. Analyze Gaps (with filters applied)
                    let npsFail = data.nps?.filter(r => r.Rating === 'Poor') || [];
                    let qcFail = data.qc?.filter(r => r.isFail || r['Pass/Fail'] === 'Fail') || [];

                    // Apply pillar filter
                    if (selectedPillar.length > 0) {
                        npsFail = npsFail.filter(r => {
                            return selectedPillar.some(pillar => {
                                const metrics = NPS_METRIC_MAPPING[pillar] || [];
                                return metrics.some(metric => r[metric] === false || r[metric] === 'FALSE');
                            });
                        });
                    }

                    // Apply sub-metric filter
                    if (selectedSubMetrics.length > 0) {
                        npsFail = npsFail.filter(r => {
                            return selectedSubMetrics.some(metric => 
                                r[metric] === false || r[metric] === 'FALSE'
                            );
                        });
                    }

                    // Apply QC question filter
                    if (selectedQuestions.length > 0) {
                        qcFail = qcFail.filter(r => {
                            const q = r['Question'] || r.Question;
                            return selectedQuestions.includes(q);
                        });
                    }

                    const issues = {};
                    npsFail.forEach(r => {
                        Object.entries(NPS_METRIC_MAPPING).forEach(([p, ms]) => {
                            ms.forEach(m => { if (r[m] === false || r[m] === 'FALSE') issues[m] = (issues[m] || 0) + 1; });
                        });
                    });
                    qcFail.forEach(r => {
                        const tag = r.calculatedTag || r.Question || 'Unknown';
                        issues[tag] = (issues[tag] || 0) + 1;
                    });

                    const topIssues = Object.entries(issues).sort((a, b) => b[1] - a[1]).slice(0, 3).map(x => x[0]);

                    setProgress(20);
                    setCurrentStage("Synthesizing Coaching Scenarios...");

                    const agentContext = selectedAgent && selectedAgent !== 'Team' 
                        ? `for agent: "${selectedAgent}"`
                        : 'for a general team coaching session';
                    
                    const prompt = `${AI_PERSONA}
${TL_PERSONA_PROMPT}

Create 5 advanced COACHING QUIZ SCENARIOS ${agentContext}.
Top weaknesses to address: ${topIssues.join(", ")}.

Each scenario MUST be realistic, complex, and test high-level skills.
Do NOT use Markdown formatting (no \`\`\`json). Return RAW JSON only.

Return strict JSON array of objects matching this schema:
[
  {
    "id": 1,
    "topic": "Topic Name",
    "scenario": "A 2-3 sentence complex customer situation.",
    "question": "What is the best way to handle this while maintaining quality?",
    "options": ["Option A", "Option B", "Option C", "Option D"],
    "correct": 0,
    "logic": "Detailed explanation of why this choice is correct based on policy."
  }
]`;

                    const schema = {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                id: { type: "INTEGER" },
                                topic: { type: "STRING" },
                                scenario: { type: "STRING" },
                                question: { type: "STRING" },
                                options: { type: "ARRAY", items: { type: "STRING" } },
                                correct: { type: "INTEGER" },
                                logic: { type: "STRING" }
                            },
                            required: ["id", "topic", "scenario", "question", "options", "correct", "logic"]
                        }
                    };

                    const response = await GeminiAI.generateJson(prompt, schema);
                    const cleanResponse = response.replace(/```json/g, '').replace(/```/g, '').trim();
                    setScenarios(JSON.parse(cleanResponse));
                    setProgress(100);
                    setCurrentStage("Coaching Set Ready");
                } catch (e) {
                    console.error("Quiz Generation Failed, using fallback:", e);
                    setScenarios(buildFallbackScenarios());
                    showToast("AI service unavailable. Generated offline scenarios.", "warning");
                } finally {
                    setGenerating(false);
                    setCurrentStage("Coaching Set Ready");
                    setProgress(100);
                }
            };

            // Pagination state for scenarios
            const [scenarioPage, setScenarioPage] = useState(1);
            const SCENARIOS_PER_PAGE = 3;

            const ScenarioCard = ({ s }) => {
                const [selected, setSelected] = useState(null);
                const [showLogic, setShowLogic] = useState(false);
                const isCorrect = selected === s.correct;

                // Copy helper
                const copyOption = (opt, idx, e) => {
                    e.stopPropagation();
                    safeCopyToClipboard(opt);
                    showToast(`Option ${String.fromCharCode(65 + idx)} copied!`);
                };

                return (
                    <div className="bg-white border border-slate-200 rounded-2xl p-6 shadow-md mb-6">
                        <div className="flex justify-between items-start mb-4">
                            <span className="px-3 py-1 bg-blue-100 text-blue-700 text-[10px] font-black uppercase tracking-widest rounded-full border border-blue-200 select-none">
                                {s.topic}
                            </span>
                            {/* Copy buttons for question/scenario */}
                            <div className="flex gap-2">
                                <button onClick={() => askAI(`Explain the policy behind: ${s.scenario}`)} className="p-1.5 text-slate-500 hover:text-blue-600 hover:bg-blue-50 rounded transition-colors" title="Clarify Policy"><HelpCircle size={14} /></button>
                                <button onClick={() => { safeCopyToClipboard(s.scenario); showToast('Scenario copied!'); }} className="p-1.5 text-slate-500 hover:text-indigo-600 hover:bg-indigo-50 rounded transition-colors" title="Copy Scenario"><Copy size={14} /></button>
                            </div>
                        </div>

                        <div className="flex justify-between items-start gap-2 mb-4">
                            <p className="text-sm font-bold text-slate-700 leading-relaxed italic flex-1">"{s.scenario}"</p>
                        </div>
                        <div className="flex justify-between items-start gap-2 mb-4">
                            <h4 className="text-xs font-black text-slate-900 uppercase tracking-tight border-l-4 border-indigo-500 pl-3 flex-1">{s.question}</h4>
                            <button 
                                onClick={() => { safeCopyToClipboard(s.question); showToast('Question copied!'); }}
                                className="p-1.5 text-slate-400 hover:text-indigo-600 hover:bg-indigo-50 rounded transition-colors shrink-0"
                                title="Copy Question"
                            >
                                <Copy size={14} />
                            </button>
                        </div>

                        <div className="space-y-2">
                            {s.options.map((opt, i) => (
                                <button
                                    key={i}
                                    onClick={() => { if (selected === null) setSelected(i); }}
                                    disabled={selected !== null}
                                    className={`w-full text-left p-4 rounded-2xl text-[11px] font-bold border ${selected === null
                                        ? 'bg-slate-50 border-slate-200 hover:border-indigo-300 hover:bg-white'
                                        : i === s.correct
                                            ? 'bg-emerald-50 border-emerald-500 text-emerald-700'
                                            : i === selected
                                                ? 'bg-rose-50 border-rose-500 text-rose-700'
                                                : 'bg-slate-50 border-slate-200 opacity-50'
                                        }`}
                                >
                                    <div className="flex items-center gap-3">
                                        <div className={`w-6 h-6 rounded-lg flex items-center justify-center text-[10px] font-black shrink-0 ${selected === null ? 'bg-white border text-slate-500' : i === s.correct ? 'bg-emerald-500 text-white' : i === selected ? 'bg-rose-500 text-white' : 'bg-slate-200 text-slate-500'
                                            }`}>
                                            {String.fromCharCode(65 + i)}
                                        </div>
                                        <span className="flex-1">{opt}</span>
                                        <button
                                            onClick={(e) => copyOption(opt, i, e)}
                                            className="p-1 text-slate-300 hover:text-indigo-600 hover:bg-indigo-50 rounded"
                                            title={`Copy Option ${String.fromCharCode(65 + i)}`}
                                        >
                                            <Copy size={12} />
                                        </button>
                                    </div>
                                </button>
                            ))}
                        </div>

                        {selected !== null && (
                            <div className="mt-6 p-5 bg-slate-900 rounded-3xl overflow-hidden relative">
                                <div className="absolute top-0 right-0 p-4 opacity-10"><Zap size={48} className="text-indigo-400" /></div>
                                <div className="flex items-center justify-between mb-3">
                                    <div className="flex items-center gap-2">
                                        {isCorrect ? <CheckCircle size={14} className="text-emerald-400" /> : <XCircle size={14} className="text-rose-400" />}
                                        <span className={`text-[10px] font-black uppercase tracking-widest ${isCorrect ? 'text-emerald-400' : 'text-rose-400'}`}>
                                            {isCorrect ? 'Outstanding Precision' : 'Calibration Gap Detected'}
                                        </span>
                                    </div>
                                    <button
                                        onClick={() => { safeCopyToClipboard(s.logic); showToast('Explanation copied!'); }}
                                        className="p-1.5 text-slate-500 hover:text-white hover:bg-slate-800 rounded transition-colors"
                                        title="Copy Explanation"
                                    >
                                        <Copy size={14} />
                                    </button>
                                </div>
                                <p className="text-[11px] text-slate-400 leading-relaxed font-medium">
                                    <span className="text-white font-bold block mb-1">Poppy Coach Logic:</span>
                                    {s.logic}
                                </p>
                            </div>
                        )}
                    </div>
                );
            };

            return (
                <div className="flex flex-col min-h-[600px] bg-slate-50 rounded-2xl border border-slate-200 relative overflow-hidden">

                    <div className="p-8 pb-4 flex justify-between items-center z-10 shrink-0">
                        <div>
                            <h3 className="text-xl font-black text-slate-900 tracking-tighter uppercase flex items-center gap-2">
                                <Brain size={24} className="text-indigo-600" />
                                Advanced <span className="text-blue-600">Cognitive</span> Quizzes
                            </h3>
                            <p className="text-[10px] font-bold text-slate-500 uppercase tracking-[0.2em] mt-1">AI-Powered Skill Calibration</p>
                            {(selectedPillar.length > 0 || selectedSubMetrics.length > 0 || selectedQuestions.length > 0) && (
                                <p className="text-xs text-blue-600 font-bold mt-1">
                                    Filters active: {selectedPillar.length + selectedSubMetrics.length + selectedQuestions.length} selected
                                </p>
                            )}
                        </div>
                        <div className="flex gap-2">
                            {(selectedPillar.length > 0 || selectedSubMetrics.length > 0 || selectedQuestions.length > 0) && (
                                // FIXED: Removed transition-all
                                <button
                                    onClick={() => {
                                        setSelectedPillar([]);
                                        setSelectedSubMetrics([]);
                                        setSelectedQuestions([]);
                                    }}
                                    className="px-4 py-3 bg-white border border-slate-200 text-slate-600 rounded-2xl text-[10px] font-black uppercase tracking-[0.2em] hover:bg-slate-50"
                                >
                                    Clear Filters
                                </button>
                            )}
                            {/* FIXED: Removed active:scale-95 and transition-transform animations */}
                            <button
                                onClick={generateScenarios}
                                disabled={generating}
                                className="group relative px-6 py-3 bg-slate-900 hover:bg-black text-white rounded-2xl text-[10px] font-black uppercase tracking-[0.2em] shadow-2xl disabled:opacity-50"
                            >
                                <span className="relative z-10 flex items-center gap-2">
                                    {generating ? <Loader size={12} className="animate-spin" /> : <Sparkles size={12} />}
                                    {scenarios.length > 0 ? 'Regenerate Set' : 'Initialize Generator'}
                                </span>
                            </button>
                        </div>
                    </div>

                    {/* Filter Dropdowns Section */}
                    <div className="px-8 pb-4 shrink-0">
                        <div className="grid grid-cols-3 gap-4 bg-white rounded-2xl p-6 border border-slate-200">
                            {/* NPS Pillar Dropdown */}
                            <div className="space-y-2">
                                <label className="block text-xs font-bold text-slate-500 uppercase tracking-widest">
                                    NPS Pillars
                                </label>
                                <MultiSelect
                                    label="Select Pillars"
                                    icon={Target}
                                    options={Object.keys(NPS_METRIC_MAPPING)}
                                    value={selectedPillar}
                                    onChange={setSelectedPillar}
                                />
                            </div>

                            {/* NPS Sub-metrics Dropdown */}
                            <div className="space-y-2">
                                <label className="block text-xs font-bold text-slate-500 uppercase tracking-widest">
                                    NPS Sub-metrics
                                </label>
                                <MultiSelect
                                    label="All Sub-metrics"
                                    icon={ListChecks}
                                    options={npsSubMetrics}
                                    value={selectedSubMetrics}
                                    onChange={setSelectedSubMetrics}
                                />
                            </div>

                            {/* QC Questions Dropdown */}
                            <div className="space-y-2">
                                <label className="block text-xs font-bold text-slate-500 uppercase tracking-widest">
                                    QC Questions
                                </label>
                                <MultiSelect
                                    label="All Questions"
                                    icon={ClipboardList}
                                    options={qcQuestions}
                                    value={selectedQuestions}
                                    onChange={setSelectedQuestions}
                                />
                            </div>
                        </div>
                    </div>

                    {/* Quiz Output Wrapper - JSON Export */}
                    <QuizOutputWrapper data={scenarios} filename={`poppy-quiz-scenarios-${selectedAgent || 'team'}`} />

                    <div className="flex-1 px-8 pb-8" ref={scrollContainerRef}>
                        {scenarios.length === 0 && !generating && (
                            <div className="h-full flex flex-col items-center justify-center text-center p-12">
                                <div className="w-20 h-20 bg-white rounded-3xl shadow-xl border border-slate-100 inline-flex items-center justify-center mb-6 text-slate-300">
                                    <Ghost size={40} />
                                </div>
                                <h4 className="text-sm font-black text-slate-800 uppercase tracking-widest mb-2">No active scenarios</h4>
                                <p className="text-xs text-slate-500 max-w-md mx-auto leading-relaxed">
                                    {selectedAgent 
                                        ? `Click Initialize to allow Poppy to analyze ${selectedAgent}'s performance data and craft 5 high-fidelity coaching scenarios based on real gaps.`
                                        : 'Click Initialize to generate 5 high-fidelity coaching scenarios based on general performance gaps (select an agent above for personalized scenarios).'
                                    }
                                </p>
                            </div>
                        )}

                        {generating && scenarios.length === 0 && (
                            <div className="h-full flex flex-col items-center justify-center">
                                <div className="space-y-8 w-64">
                                    <div className="relative">
                                        {/* Keep animate-spin for loading indicator, remove animate-pulse */}
                                        <div className="w-16 h-16 border-4 border-slate-100 border-t-indigo-600 rounded-full animate-spin mx-auto" />
                                        <Brain size={24} className="absolute inset-0 m-auto text-indigo-600" />
                                    </div>
                                    <div className="text-center">
                                        <p className="text-[10px] font-black text-indigo-600 uppercase tracking-[0.3em] mb-2">{currentStage}</p>
                                        <div className="h-1 bg-slate-100 rounded-full overflow-hidden">
                                            {/* Keep progress bar transition */}
                                            <div className="h-full bg-gradient-to-r from-blue-600 to-indigo-600 transition-all duration-500" style={{ width: `${progress}%` }} />
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Scenarios Display */}
                        {scenarios.length > 0 && (
                            <div className="bg-white rounded-2xl border border-slate-200 p-6">
                                <div className="flex justify-between items-center mb-6 pb-4 border-b border-slate-200">
                                    <div>
                                        <h3 className="text-lg font-bold text-slate-800">Advanced Coaching Scenarios</h3>
                                        <p className="text-sm text-slate-500">{scenarios.length} AI-generated coaching scenarios{selectedAgent ? ` based on ${selectedAgent}'s performance gaps` : ' based on general performance gaps'}.</p>
                                    </div>
                                    <button
                                        onClick={generateScenarios}
                                        className="px-4 py-2 bg-indigo-600 text-white rounded-lg text-sm font-bold hover:bg-indigo-700 flex items-center gap-2"
                                    >
                                        <RefreshCw size={16} />
                                        Regenerate All
                                    </button>
                                </div>
                                
                                {/* Pagination Controls Top */}
                                <div className="mt-6">
                                    <AIWrapper
                                        data={scenarios}
                                        isPaginated={true}
                                        title="Generated Scenarios"
                                        onRegenerate={async (idx) => {
                                            const s = scenarios[idx];
                                            if (!s) return;
                                            
                                            showToast(`Regenerating scenario ${idx + 1}...`, 'info');
                                            try {
                                                const prompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nCreate 1 advanced coaching quiz scenario for agent: "${selectedAgent}".\nTopic: ${s.topic}\n\nOutput exactly in this JSON format:\n[{\n  "id": ${s.id},\n  "topic": "${s.topic}",\n  "scenario": "A 2-3 sentence complex customer situation.",\n  "question": "What is the best way to handle this?",\n  "options": ["Option A", "Option B", "Option C", "Option D"],\n  "correct": 0,\n  "logic": "Detailed explanation."\n}]`;
                                                const response = await AIRequestManager.generate(prompt);
                                                const parsed = JSON.parse(response.replace(/```json|```/g, '').trim());
                                                if (parsed && parsed[0]) {
                                                    const newScenario = parsed[0];
                                                    setScenarios(prev => prev.map((sc, i) => i === idx ? newScenario : sc));
                                                    return JSON.stringify(newScenario, null, 2);
                                                }
                                            } catch (e) {
                                                showToast('Failed to regenerate scenario', 'error');
                                            }
                                        }}
                                        renderItem={(content, item) => (
                                            <ScenarioCard s={item} />
                                        )}
                                    />
                                </div>
                            </div>
                        )}
                    </div>

                    {/* Footer Stats/Info */}
                    <div className="p-4 bg-white border-t border-slate-200 shrink-0 flex justify-between items-center">
                        <div className="flex gap-4">
                            <div className="flex items-center gap-2">
                                <div className="w-2 h-2 rounded-full bg-emerald-500" />
                                <span className="text-[9px] font-bold text-slate-500 uppercase">Live Data Match</span>
                            </div>
                            <div className="flex items-center gap-2">
                                <div className="w-2 h-2 rounded-full bg-blue-500" />
                                <span className="text-[9px] font-bold text-slate-500 uppercase">AI Synced</span>
                            </div>
                        </div>
                        <span className="text-[9px] font-black text-slate-500 italic">Advanced Mode v4.2</span>
                    </div>
                </div>
            );
        };

        const UnifiedDashboard = ({ npsData, qcData, onDownloadImage, activeTab, setActiveTab, selectedAgentGlobal, setSelectedAgentGlobal, askAI, filters, setFilters, customAgents, setCustomAgents, emailAliases, setEmailAliases, agentFileMap, setAgentFileMap, unmatchedFiles, setUnmatchedFiles }) => {
            const selectedAgent = selectedAgentGlobal;
            const setSelectedAgent = setSelectedAgentGlobal;
            const [loadingCoaching, setLoadingCoaching] = useState(false);
            const [coachingPlan, setCoachingPlan] = useState("");
            const [bulkModalOpen, setBulkModalOpen] = useState(false);
            const [showValues, setShowValues] = useState(true);




            // FEATURE 7: AUTO-ROLEPLAY SCRIPTS
            const [roleplayScript, setRoleplayScript] = useState(null);
            const [loadingRoleplay, setLoadingRoleplay] = useState(false);


            const generateRoleplayScript = async () => {
                setLoadingRoleplay(true);
                setRoleplayScript(null);

                // 1. Calculate Top Weaknesses (On-the-fly)
                const npsFailCounts = {};
                if (agentNPS) {
                    agentNPS.forEach(row => {
                        Object.entries(NPS_METRIC_MAPPING).forEach(([p, metrics]) => {
                            metrics.forEach(m => {
                                if (row[m] === false || row[m] === 'FALSE') npsFailCounts[m] = (npsFailCounts[m] || 0) + 1;
                            });
                        });
                    });
                }
                const topNPS = Object.entries(npsFailCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || "Communication";

                const qcFailCounts = {};
                if (agentQC) {
                    agentQC.forEach(row => {
                        const tag = row.calculatedTag || row['Question'] || row.Question;
                        if (row.isFail) qcFailCounts[tag] = (qcFailCounts[tag] || 0) + 1;
                    });
                }
                const topQC = Object.entries(qcFailCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || "Process Adherence";

                // 2. Get Context
                const feedbackSamples = [...agentNPS, ...agentQC]
                    .filter(r => (r['Remediation Feedback'] || r['Feedback'] || r['TL RCA']))
                    .slice(0, 3)
                    .map(r => r['Remediation Feedback'] || r['Feedback'] || r['TL RCA']);

                const prompt = `${AI_PERSONA}
${TL_PERSONA_PROMPT}

Create a 2-minute ROLEPLAY SCRIPT for coaching agent "${selectedAgent}".

FOCUS AREAS that need improvement:
1. ${topNPS} (Client Satisfaction Weakness)
2. ${topQC} (Quality/Process Weakness)

REAL FEEDBACK CONTEXT:
${JSON.stringify(feedbackSamples)}

SCENARIO:
The agent is handling a customer interaction that specifically requires them to use the skills they are weak in.

Return strict JSON:
{
  "title": "Engaging scenario title",
  "objective": "1 sentence goal",
  "characters": { "agent": "Name", "customer": "Persona details" },
  "script": [
    { "speaker": "Customer", "text": "Opening line..." },
    { "speaker": "Agent", "text": "Response..." }
  ],
  "coachNote": "1 secret tip for coach"
}`;

                const schema = {
                    type: "OBJECT",
                    properties: {
                        title: { type: "STRING" },
                        objective: { type: "STRING" },
                        characters: { 
                            type: "OBJECT", 
                            properties: { agent: { type: "STRING" }, customer: { type: "STRING" } },
                            required: ["agent", "customer"]
                        },
                        script: { 
                            type: "ARRAY", 
                            items: { 
                                type: "OBJECT", 
                                properties: { speaker: { type: "STRING" }, text: { type: "STRING" } },
                                required: ["speaker", "text"]
                            } 
                        },
                        coachNote: { type: "STRING" }
                    },
                    required: ["title", "objective", "characters", "script", "coachNote"]
                };

                try {
                    const response = await GeminiAI.generateJson(prompt, schema);
                    setRoleplayScript(response);
                } catch (e) {
                    console.error("Roleplay generation failed", e);
                    setRoleplayScript(null);
                    showToast("Failed to generate roleplay script", "error");
                } finally {
                    setLoadingRoleplay(false);
                }
            };
            const [viewMode, setViewMode] = useState('tabs');


            // Lifted State for Persistence
            const [oneOnePost, setOneOnePost] = useState("");
            const [slackPosts, setSlackPosts] = useState({});


            const contentId = `coaching-${Math.random().toString(36).substr(2, 9)}`;


            // 1. Master Data Aggregator
            const masterData = useMemo(() => {
                const map = {};
                npsData.forEach(r => {
                    const agent = DataEngine.normalizeAgent(r, 'NPS') || 'Unknown';
                    if (agent) {
                        if (!map[agent]) map[agent] = { name: agent, npsVol: 0, npsFail: 0, qcVol: 0, qcScoreSum: 0, qcScoreAvg: 0 };
                        map[agent].npsVol++;
                        if (r.Rating === 'Poor') map[agent].npsFail++;
                    }
                });


                qcData.forEach(r => {
                    const agent = DataEngine.normalizeAgent(r, 'QC') || 'Unknown';
                    if (agent) {
                        if (!map[agent]) map[agent] = { name: agent, npsVol: 0, npsFail: 0, qcVol: 0, qcScoreSum: 0, qcScoreAvg: 0 };
                        map[agent].qcVol++;
                        map[agent].qcScoreSum += parseFloat(r['QC Score']) || 0;
                    }
                });


                return Object.values(map).map(a => {
                    const npsScoreNum = a.npsVol > 0 ? (1 - (a.npsFail / a.npsVol)) * 100 : 0;
                    const qcScoreNum = a.qcVol > 0 ? (a.qcScoreSum / a.qcVol) : 0;
                    return {
                        ...a,
                        npsScore: Math.round(npsScoreNum),
                        qcScore: Math.round(qcScoreNum),
                        gap: Math.round(Math.abs(npsScoreNum - qcScoreNum)),
                        holistic: Math.round((npsScoreNum + qcScoreNum) / 2)
                    };
                }).filter(a => a.npsVol > 0 || a.qcVol > 0).sort((a, b) => {
                    // Sort by holistic score first, then alphabetically by name
                    if (b.holistic !== a.holistic) return b.holistic - a.holistic;
                    return a.name.localeCompare(b.name);
                });
            }, [npsData, qcData]);


            const agentNPS = useMemo(() => npsData.filter(r => DataEngine.normalizeAgent(r, 'NPS') === selectedAgent), [selectedAgent, npsData]);
            const agentQC = useMemo(() => qcData.filter(r => DataEngine.normalizeAgent(r, 'QC') === selectedAgent), [selectedAgent, qcData]);


            const [showUnifiedNPSDataModal, setShowUnifiedNPSDataModal] = useState(false);
            const [showUnifiedQCDataModal, setShowUnifiedQCDataModal] = useState(false);


            // Unified Feedback Loop for Spotlight
            const npsFeedbackLoop = useMemo(() => {
                if (!selectedAgent) return null;
                return feedbackLoopCalculator(agentNPS, 'NPS');
            }, [selectedAgent, agentNPS]);


            const qcFeedbackLoop = useMemo(() => {
                if (!selectedAgent) return null;
                return feedbackLoopCalculator(agentQC, 'QC');
            }, [selectedAgent, agentQC]);


            // FEATURE 11: SMART PEER MATCHING
            const recommendedMentors = useMemo(() => {
                if (!selectedAgent || !agentNPS || !agentQC || !masterData) return [];


                // 1. Identify Agent's Weaknesses (Failures > 0)
                const weaknesses = new Set();


                // Check NPS Weaknesses
                const npsFailCounts = {};
                agentNPS.forEach(row => {
                    Object.entries(NPS_METRIC_MAPPING).forEach(([p, metrics]) => {
                        metrics.forEach(m => {
                            if (row[m] === false || row[m] === 'FALSE') {
                                npsFailCounts[m] = (npsFailCounts[m] || 0) + 1;
                            }
                        });
                    });
                });
                // Add top 3 NPS weaknesses
                Object.entries(npsFailCounts)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3)
                    .forEach(([m]) => weaknesses.add(m));


                // Check QC Weaknesses
                const qcFailCounts = {};
                agentQC.forEach(row => {
                    const tag = row.calculatedTag || row['Question'] || row.Question;
                    if (row.isFail && tag) qcFailCounts[tag] = (qcFailCounts[tag] || 0) + 1;
                });
                // Add top 3 QC weaknesses
                Object.entries(qcFailCounts)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3)
                    .forEach(([tag]) => weaknesses.add(tag));


                if (weaknesses.size === 0) return [];


                // 2. Find Mentors (Top 20 Performers)
                const potentialMentors = masterData
                    .filter(a => a.name !== selectedAgent && a.holistic >= 85) // High performers only
                    .slice(0, 20);


                const mentors = potentialMentors.map(mentor => {
                    let matchScore = 0;
                    const skills = [];


                    // Calculate their performance on the specific weaknesses
                    // Need to filter data for this mentor
                    const mentorNPS = npsData.filter(r => DataEngine.normalizeAgent(r, 'NPS') === mentor.name);
                    const mentorQC = qcData.filter(r => DataEngine.normalizeAgent(r, 'QC') === mentor.name);


                    weaknesses.forEach(weakness => {
                        // Check if it's an NPS metric
                        let totalCount = 0;
                        let failCount = 0;


                        // Check NPS
                        const isNPSMetric = Object.values(NPS_METRIC_MAPPING).flat().includes(weakness);
                        if (isNPSMetric) {
                            totalCount = mentorNPS.length;
                            failCount = mentorNPS.filter(r => r[weakness] === false || r[weakness] === 'FALSE').length;
                        } else {
                            // Assume QC
                            totalCount = mentorQC.filter(r => (r.calculatedTag || r.Question) === weakness).length; // Rough volume check
                            if (totalCount === 0) totalCount = mentorQC.length; // Fallback to total volume if tag specific not found


                            failCount = mentorQC.filter(r => (r.calculatedTag || r.Question) === weakness && r.isFail).length;
                        }


                        // If they have handled it and have 0 fails (or very low)
                        if (failCount === 0) {
                            matchScore++;
                            skills.push(weakness);
                        }
                    });


                    return { ...mentor, matchScore, skills };
                })
                    .filter(m => m.matchScore > 0)
                    .sort((a, b) => b.matchScore - a.matchScore || b.holistic - a.holistic)
                    .slice(0, 3); // Top 3


                return mentors;
            }, [selectedAgent, agentNPS, agentQC, masterData, npsData, qcData]);


            // Get feedback provided rows for Unified View
            const unifiedNPSFeedbackRows = useMemo(() => {
                if (!selectedAgent) return [];
                const normalized = agentNPS.map(d => normalizeCompliance(d, 'NPS'));
                const rows = [];
                normalized.forEach((d, i) => {
                    if (d.isMandatory) {
                        rows.push({
                            ...agentNPS[i],
                            _isAck: d.isAck,
                            _hasJustification: d.hasJustification,
                            _status: d.status
                        });
                    }
                });
                return rows;
            }, [selectedAgent, agentNPS]);


            const unifiedQCFeedbackRows = useMemo(() => {
                if (!selectedAgent) return [];
                const normalized = agentQC.map(d => normalizeCompliance(d, 'QC'));
                const rows = [];
                normalized.forEach((d, i) => {
                    if (d.isMandatory) {
                        rows.push({
                            ...agentQC[i],
                            _isAck: d.isAck,
                            _hasJustification: d.hasJustification,
                            _status: d.status
                        });
                    }
                });
                return rows;
            }, [selectedAgent, agentQC]);


            const generateCoaching = async () => {
                if (!selectedAgent) {
                    showToast("Please select an agent first", "error");
                    return;
                }
                setLoadingCoaching(true);
                try {
                    const totalNPS = agentNPS.length;
                    const poorNPS = agentNPS.filter(r => r.Rating === 'Poor').length;
                    const qcScore = agentQC.length > 0 ? agentQC.reduce((a, b) => a + (parseFloat(b['QC Score']) || 0), 0).toFixed(2) : "N/A";


                    // Calculate NPS strengths and opportunities - need to process NPS data with mistakes
                    const processedAgentNPS = agentNPS.map(row => {
                        const mistakes = { Communication: 0, Personalisation: 0, Efficiency: 0, Total: 0 };
                        Object.entries(NPS_METRIC_MAPPING).forEach(([p, metrics]) => {
                            metrics.forEach(m => {
                                if (row[m] === false || row[m] === 'FALSE') {
                                    mistakes[p]++;
                                    mistakes.Total++;
                                }
                            });
                        });
                        return { ...row, mistakes };
                    });


                    const npsMetricScores = {};
                    Object.values(NPS_METRIC_MAPPING).flat().forEach(m => npsMetricScores[m] = { pass: 0, fail: 0 });
                    processedAgentNPS.forEach(row => {
                        Object.entries(NPS_METRIC_MAPPING).forEach(([p, metrics]) => {
                            metrics.forEach(m => {
                                if (row.mistakes?.Total > 0 && (row[m] === false || row[m] === 'FALSE')) {
                                    npsMetricScores[m].fail++;
                                } else {
                                    npsMetricScores[m].pass++;
                                }
                            });
                        });
                    });
                    const npsMetricsList = Object.entries(npsMetricScores).map(([n, s]) => ({ name: n, failRate: (s.fail / (s.pass + s.fail || 1)) * 100 }));
                    const npsStrengths = npsMetricsList.sort((a, b) => a.failRate - b.failRate).slice(0, 5);
                    const npsOpportunities = npsMetricsList.sort((a, b) => b.failRate - a.failRate).slice(0, 5);


                    // Calculate QC strengths and opportunities
                    const qcMetricScores = {};
                    agentQC.forEach(r => {
                        const tag = r.calculatedTag || r['Question'] || r.Question;
                        if (!qcMetricScores[tag]) qcMetricScores[tag] = { fail: 0, total: 0 };
                        qcMetricScores[tag].total++;
                        if (r.isFail) {
                            qcMetricScores[tag].fail++;
                        }
                    });
                    const qcMetricsList = Object.entries(qcMetricScores).map(([n, s]) => ({ name: n, failRate: (s.fail / (s.total || 1)) * 100 }));
                    const qcStrengths = qcMetricsList.sort((a, b) => a.failRate - b.failRate).slice(0, 5);
                    const qcOpportunities = qcMetricsList.sort((a, b) => b.failRate - a.failRate).slice(0, 5);


                    // Get feedback context - standardized "Pending 1:1 File actions" section
                    let feedbackContext = '';
                    const x = npsFeedbackLoop?.pendingTick || 0;
                    const y = npsFeedbackLoop?.pendingWritten || 0;
                    const a = qcFeedbackLoop?.pendingTick || 0;
                    const b = qcFeedbackLoop?.pendingWritten || 0;
                    if ((x + y + a + b) > 0) {
                        feedbackContext =
                            `Pending 1:1 File actions:\n` +
                            `- ${x} Chat reviews pending to be acknowledged.\n` +
                            `- ${y} Chat reviews pending to be provide written justification/acknowledgement.\n` +
                            `- ${a} Quality reviews pending to be acknowledged.\n` +
                            `- ${b} Quality reviews pending to be provide written justification/acknowledgement.\n`;
                    }


                    // Get TL feedbacks for action items
                    // Get TL feedbacks for action items
                    // Get TL feedbacks for action items
                    const npsFeedbacks = agentNPS
                        .filter(d => d["Remediation Feedback"] || d["Feedback"])
                        .map(d => {
                             const rawLink = d["Chat Link"] || "N/A";
                             const cleanLink = rawLink.startsWith('http') ? `<${rawLink}|Link>` : rawLink;
                             return `${d["Sub-metric"] || "General"} [${cleanLink}]: ${d["Remediation Feedback"] || d["Feedback"]}`;
                        }).slice(0, 5);

                    const qcFeedbacks = agentQC
                        .filter(d => (d['TL RCA'] || d['Answer Comment']) && !d['Appeal Status'] && String(d['Appeal Status']).toLowerCase() !== 'pending')
                        .map(d => {
                            const tlRCA = d['TL RCA'] || '';
                            const answerComment = d['Answer Comment'] || '';
                            const q = d['Question'] || 'General';
                            const rawLink = d["Dante/Bo Link"] || "N/A";
                            const cleanLink = rawLink.startsWith('http') ? `<${rawLink}|Link>` : rawLink;
                            return `${q} [${cleanLink}]: ${tlRCA && answerComment ? `${tlRCA} ${answerComment}` : (tlRCA || answerComment)}`;
                        }).slice(0, 5);
                    const errorsContext = `\n\nNPS Feedback List:\n${npsFeedbacks.join('\n')}\n\nQC Feedback List:\n${qcFeedbacks.join('\n')}`;


                    const combinedStrengths = [...npsStrengths, ...qcStrengths].slice(0, 7);
                    const combinedOpportunities = [...npsOpportunities, ...qcOpportunities].slice(0, 7);


                    // Extract TL style from both NPS and QC data
                    const npsStyle = extractTLStyleContext(agentNPS, 'NPS');
                    const qcStyle = extractTLStyleContext(agentQC, 'QC');
                    const combinedStyle = `${npsStyle}\n${qcStyle}`.trim();

                    const plan = await generateSmartCoachingPlan(
                        selectedAgent,
                        combinedStrengths,
                        combinedOpportunities,
                        feedbackContext,
                        errorsContext,
                        'Unified',
                        true,
                        combinedStyle
                    );
                    setCoachingPlan(plan);
                    showToast("Coaching plan generated successfully!");
                } catch (error) {
                    console.error("Error generating coaching plan:", error);
                    showToast("Failed to generate coaching plan. Please try again.", "error");
                } finally {
                    setLoadingCoaching(false);
                }
            };


            // Fix: Spotlight tab - just set active tab, no viewMode
            const handleDrillDown = (agentName) => {
                setSelectedAgent(agentName);
                if (setActiveTab) setActiveTab('Spotlight');
                setCoachingPlan("");
            };


            // Phase 2: Combined Feedback Loop for entire team
            const combinedFeedbackLoop = useMemo(() => {
                // Process NPS data - Count tick and written separately and independently
                const npsNormalized = npsData.map(d => normalizeCompliance(d, 'NPS'));
                const npsAgentMap = {};
                npsNormalized.forEach((d, i) => {
                    const agent = DataEngine.normalizeAgent(npsData[i], 'NPS') || 'Unknown';
                    if (!npsAgentMap[agent]) npsAgentMap[agent] = {
                        name: agent,
                        npsProvided: 0,
                        npsAckTick: 0,
                        npsAckWritten: 0,
                        npsPendingTick: 0,
                        npsPendingWritten: 0,
                        npsNotRequired: 0
                    };
                    if (!d.isMandatory) {
                        npsAgentMap[agent].npsNotRequired++;
                        return;
                    }
                    npsAgentMap[agent].npsProvided++;
                    // Count tick and written separately and independently using decoupled flags
                    if (d.isAck) {
                        npsAgentMap[agent].npsAckTick++;
                    } else if (d.isPendingTick) {
                        npsAgentMap[agent].npsPendingTick++;
                    }
                    if (d.hasJustification) {
                        npsAgentMap[agent].npsAckWritten++;
                    } else if (d.isPendingWritten) {
                        npsAgentMap[agent].npsPendingWritten++;
                    }
                });


                // Process QC data - Count tick and written separately and independently
                const qcNormalized = qcData.map(d => normalizeCompliance(d, 'QC'));
                const qcAgentMap = {};
                qcNormalized.forEach((d, i) => {
                    const agent = DataEngine.normalizeAgent(qcData[i], 'QC') || 'Unknown';
                    if (!qcAgentMap[agent]) qcAgentMap[agent] = {
                        name: agent,
                        qcProvided: 0,
                        qcAckTick: 0,
                        qcAckWritten: 0,
                        qcPendingTick: 0,
                        qcPendingWritten: 0,
                        qcNotRequired: 0
                    };
                    if (!d.isMandatory) {
                        qcAgentMap[agent].qcNotRequired++;
                        return;
                    }
                    qcAgentMap[agent].qcProvided++;
                    // Count tick and written separately and independently using decoupled flags
                    if (d.isAck) {
                        qcAgentMap[agent].qcAckTick++;
                    } else if (d.isPendingTick) {
                        qcAgentMap[agent].qcPendingTick++;
                    }
                    if (d.hasJustification) {
                        qcAgentMap[agent].qcAckWritten++;
                    } else if (d.isPendingWritten) {
                        qcAgentMap[agent].qcPendingWritten++;
                    }
                });


                // Combine both - merge by agent name
                const combined = {};
                [...Object.values(npsAgentMap), ...Object.values(qcAgentMap)].forEach(item => {
                    if (!combined[item.name]) {
                        combined[item.name] = {
                            name: item.name,
                            npsProvided: item.npsProvided || 0,
                            npsAckTick: item.npsAckTick || 0,
                            npsAckWritten: item.npsAckWritten || 0,
                            npsPendingTick: item.npsPendingTick || 0,
                            npsPendingWritten: item.npsPendingWritten || 0,
                            npsNotRequired: item.npsNotRequired || 0,
                            qcProvided: item.qcProvided || 0,
                            qcAckTick: item.qcAckTick || 0,
                            qcAckWritten: item.qcAckWritten || 0,
                            qcPendingTick: item.qcPendingTick || 0,
                            qcPendingWritten: item.qcPendingWritten || 0,
                            qcNotRequired: item.qcNotRequired || 0
                        };
                    } else {
                        // Merge values
                        combined[item.name].npsProvided += (item.npsProvided || 0);
                        combined[item.name].npsAckTick += (item.npsAckTick || 0);
                        combined[item.name].npsAckWritten += (item.npsAckWritten || 0);
                        combined[item.name].npsPendingTick += (item.npsPendingTick || 0);
                        combined[item.name].npsPendingWritten += (item.npsPendingWritten || 0);
                        combined[item.name].npsNotRequired += (item.npsNotRequired || 0);
                        combined[item.name].qcProvided += (item.qcProvided || 0);
                        combined[item.name].qcAckTick += (item.qcAckTick || 0);
                        combined[item.name].qcAckWritten += (item.qcAckWritten || 0);
                        combined[item.name].qcPendingTick += (item.qcPendingTick || 0);
                        combined[item.name].qcPendingWritten += (item.qcPendingWritten || 0);
                        combined[item.name].qcNotRequired += (item.qcNotRequired || 0);
                    }
                });


                // Calculate totals
                Object.values(combined).forEach(item => {
                    item.totalPending = item.npsPendingTick + item.npsPendingWritten + item.qcPendingTick + item.qcPendingWritten;
                    item.totalPendingTick = item.npsPendingTick + item.qcPendingTick;
                    item.totalPendingWritten = item.npsPendingWritten + item.qcPendingWritten;
                });


                return Object.values(combined).sort((a, b) => {
                    // Sort by total pending first, then alphabetically by name
                    if (b.totalPending !== a.totalPending) return b.totalPending - a.totalPending;
                    return a.name.localeCompare(b.name);
                });
            }, [npsData, qcData]);


            // Master Stats for Overview
            const unifiedStats = useMemo(() => {
                const totalNPS = npsData.length;
                const totalQC = qcData.length;
                const totalChats = totalNPS + totalQC;


                // NPS Pass Rate based on sub-metrics (not Rating)
                const allSubMetrics = Object.values(NPS_METRIC_MAPPING).flat();
                const npsPass = npsData.filter(r => {
                    return allSubMetrics.every(m => {
                        const val = r[m];
                        return val === true || String(val).toUpperCase() === 'TRUE' || val === 1 || val === '1';
                    });
                }).length;
                const npsScore = totalNPS > 0 ? (npsPass / totalNPS) * 100 : 0;


                // QC Pass Rate (Score 0 = Pass, any other = Fail) - NO AVERAGE
                const qcPass = qcData.filter(r => {
                    const score = parseFloat(r['QC Score']);
                    return score === 0;
                }).length;
                const qcPassRate = totalQC > 0 ? (qcPass / totalQC) * 100 : 0;


                // Unified Pass Rate (weighted average of pass rates, not scores)
                const compositeScore = totalChats > 0 ? ((npsScore * totalNPS) + (qcPassRate * totalQC)) / totalChats : 0;


                const coverageGap = Math.abs(npsScore - qcPassRate).toFixed(1);


                // Variance calculation (Simple version: standard deviation of holistic scores in masterData)
                const holisticScores = masterData.map(d => parseFloat(d.holistic));
                const mean = holisticScores.reduce((a, b) => a + b, 0) / (holisticScores.length || 1);
                const variance = holisticScores.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / (holisticScores.length || 1);
                const stdDev = Math.sqrt(variance).toFixed(1);


                return {
                    totalChats,
                    compositeScore: compositeScore.toFixed(0),
                    coverageGap,
                    calibrationVariance: stdDev
                };
            }, [npsData, qcData, masterData]);


            const downloadUnifiedPDF = async () => {
                try {
                    await ExportEngine.exportToPDFSmart('unified-spotlight-dashboard', `${selectedAgentGlobal || 'Spotlight'}_Unified_Dashboard`, { sectionSelector: '.export-atomic' });
                } catch (e) {
                    console.error("PDF Export Failed", e);
                    showToast("PDF Export Failed", 'error');
                }
            };




            if (activeTab === 'Spotlight') {
                return (
                    <div id="unified-spotlight-dashboard" className="space-y-8">
                        <AgentSelector
                            value={selectedAgent}
                            onChange={(e) => handleDrillDown(e.target.value)}
                            options={masterData.map(a => a.name)}
                            label="Unified Spotlight"
                            selectedAgent={selectedAgent}
                            action={(
                                <button
                                    onClick={() => setBulkModalOpen(true)}
                                    className="px-4 py-2 bg-violet-600 text-white rounded-xl font-bold text-xs hover:bg-violet-700 transition-all shadow-md flex items-center gap-2"
                                    data-html2canvas-ignore="true"
                                >
                                    <Users size={16} /> Bulk Generate
                                </button>
                            )}
                        />
                        <div className="flex justify-end mb-4" data-html2canvas-ignore="true">
                            <button onClick={downloadUnifiedPDF} className="px-4 py-2 bg-rose-600 text-white rounded-lg text-xs font-bold uppercase flex items-center gap-2 hover:bg-rose-700 transition-all shadow-md">
                                <FileText size={14} /> Export Dashboard PDF
                            </button>
                        </div>


                        <div className="space-y-8">
                            {/* NPS Section */}
                            <div className="space-y-6" id="unified-nps-section">
                                <h3 className="font-bold text-slate-700 border-b border-slate-200 pb-2">NPS Performance</h3>
                                {selectedAgent && agentNPS.length > 0 ? (() => {
                                    const npsSpotlightStats = {};
                                    Object.values(NPS_METRIC_MAPPING).flat().forEach(m => npsSpotlightStats[m] = { pass: 0, fail: 0 });
                                    let auditCount = 0, poorCount = 0, greatOkCount = 0, wowCount = 0, unratedCount = 0;


                                    agentNPS.forEach(row => {
                                        auditCount++;
                                        // Check sub-metrics for pass/fail (not Rating)
                                        const allSubMetrics = Object.values(NPS_METRIC_MAPPING).flat();
                                        const hasFailedMetric = allSubMetrics.some(m => {
                                            const val = row[m];
                                            return val === false || String(val).toUpperCase() === 'FALSE' || val === 0 || val === '0';
                                        });
                                        if (hasFailedMetric) poorCount++; else greatOkCount++;
                                        const allMetricsPass = allSubMetrics.every(m => {
                                            const val = row[m];
                                            return val === true || String(val).toUpperCase() === 'TRUE' || val === 1 || val === '1';
                                        });
                                        if (allMetricsPass) wowCount++;
                                        const hasAnyMetric = allSubMetrics.some(m => row[m] !== undefined && row[m] !== null && row[m] !== '');
                                        if (!hasAnyMetric) unratedCount++;


                                        Object.entries(NPS_METRIC_MAPPING).forEach(([p, metrics]) => {
                                            metrics.forEach(m => {
                                                const val = row[m];
                                                const isFail = val === false || String(val).toUpperCase() === 'FALSE' || String(val).toUpperCase() === 'NO' || String(val).toUpperCase() === 'FAIL' || val === 0 || val === '0';
                                                if (isFail) {
                                                    npsSpotlightStats[m].fail++;
                                                } else {
                                                    npsSpotlightStats[m].pass++;
                                                }
                                            });
                                        });
                                    });


                                    return (
                                        <div className="space-y-6">
                                            <div className="grid grid-cols-1 md:grid-cols-5 gap-6">
                                                <KPICard title="NPS Audits" value={auditCount} icon={FileText} color="blue" info="Total NPS audits for this agent." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'NPS Audits', value: auditCount, rows: agentNPS }} sparkleType="NPS" askAI={askAI} />
                                                <KPICard title="Poor Count" value={poorCount} icon={AlertCircle} color="red" info="NPS Poor ratings count." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'Poor Count', value: poorCount, rows: agentNPS }} sparkleType="NPS" askAI={askAI} />
                                                <KPICard title="Great/Ok Count" value={greatOkCount} icon={CheckCircle} color="green" info="NPS Great/Ok/WOW ratings count." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'Great/Ok Count', value: greatOkCount, rows: agentNPS }} sparkleType="NPS" askAI={askAI} />
                                                <KPICard title="WOW Count" value={wowCount} icon={Sparkles} color="purple" info="NPS WOW ratings count." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'WOW Count', value: wowCount, rows: agentNPS }} sparkleType="NPS" askAI={askAI} />
                                                <KPICard title="Unrated Count" value={unratedCount} icon={MessageSquare} color="slate" info="Unrated chats." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'Unrated Count', value: unratedCount, rows: agentNPS }} sparkleType="NPS" askAI={askAI} />
                                            </div>


                                            <DetailedScorecardTable
                                                title="NPS Detailed Scorecard"
                                                data={npsSpotlightStats}
                                                type="NPS"
                                                onDownloadImage={onDownloadImage}
                                                tableId="unified-nps-scorecard"
                                                infoText="Full metric breakdown showing pass/fail counts for each sub-metric."
                                                askAI={askAI}
                                                showValues={showValues}
                                                toggleValues={() => setShowValues(!showValues)}
                                            />
                                        </div>
                                    );
                                })() : <div className="text-slate-500 italic">No NPS data for this agent.</div>}
                            </div>


                            {/* QC Section */}
                            <div className="space-y-6" id="unified-qc-section">
                                <h3 className="font-bold text-slate-700 border-b border-slate-200 pb-2">QC Performance</h3>
                                {selectedAgent && agentQC.length > 0 ? (() => {
                                    const qcSpotlightStats = {};
                                    let auditCount = 0, appealAccepted = 0, appealRejected = 0, pendingAppeals = 0, pendingToBeAppealed = 0;


                                    agentQC.forEach(r => {
                                        auditCount++;
                                        // Calculate isFail if not already present
                                        const score = parseFloat(r['QC Score'] || 0);
                                        const isFail = score < 100 || r['Pass/Fail'] === 'Fail' || r['Pass/Fail'] === 'FALSE';
                                        if (isFail) {
                                            const tag = r.calculatedTag || extractQCTag(r) || r['Question'] || r.Question || 'Unknown';
                                            if (!qcSpotlightStats[tag]) qcSpotlightStats[tag] = { fail: 0 };
                                            qcSpotlightStats[tag].fail++;
                                        }


                                        // Appeal Logic
                                        const appealStatus = String(r['Appeal Status'] || '').trim();
                                        const tlRCA = String(r['TL RCA'] || '').trim().toLowerCase();
                                        const appealStatusLower = appealStatus.toLowerCase();


                                        if (appealStatus && appealStatus !== '' && appealStatusLower !== 'nan') {
                                            if (appealStatusLower.includes('accept') || appealStatusLower.includes('approved')) appealAccepted++;
                                            else if (appealStatusLower.includes('reject') || appealStatusLower.includes('denied')) appealRejected++;
                                            else pendingAppeals++;
                                        } else if ((tlRCA.startsWith('appeal') || tlRCA.startsWith('appealed'))) {
                                            pendingToBeAppealed++;
                                        }
                                    });


                                    return (
                                        <div className="space-y-6">
                                            <div className="grid grid-cols-1 md:grid-cols-5 gap-6">
                                                <KPICard title="QC Audits" value={auditCount} icon={FileText} color="blue" info="Total QC audits for this agent." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'QC Audits', value: auditCount, rows: agentQC }} sparkleType="QC" askAI={askAI} />
                                                <KPICard title="Appeal Accepted" value={appealAccepted} icon={CheckCircle} color="green" info="Approved appeals." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'Appeal Accepted', value: appealAccepted, rows: agentQC }} sparkleType="QC" askAI={askAI} />
                                                <KPICard title="Appeal Rejected" value={appealRejected} icon={AlertCircle} color="red" info="Rejected appeals." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'Appeal Rejected', value: appealRejected, rows: agentQC }} sparkleType="QC" askAI={askAI} />
                                                <KPICard title="Pending Appeals" value={pendingAppeals} icon={Clock} color="amber" info="Submitted appeals pending decision." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'Pending Appeals', value: pendingAppeals, rows: agentQC }} sparkleType="QC" askAI={askAI} />
                                                <KPICard title="To Be Appealed" value={pendingToBeAppealed} icon={Bell} color="purple" info="TL indicated appeal needed (RCA starts with 'Appeal')." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'To Be Appealed', value: pendingToBeAppealed, rows: agentQC }} sparkleType="QC" askAI={askAI} />
                                            </div>


                                            <DetailedScorecardTable
                                                title="QC Detailed Scorecard"
                                                data={qcSpotlightStats}
                                                type="QC"
                                                onDownloadImage={onDownloadImage}
                                                tableId="unified-qc-scorecard"
                                                infoText="Fail per question = Number of times each question was failed."
                                                askAI={askAI}
                                                showValues={showValues}
                                                toggleValues={() => setShowValues(!showValues)}
                                            />
                                        </div>
                                    );
                                })() : <div className="text-slate-500 italic">No QC data for this agent.</div>}
                            </div>


                            {/* Unified Feedback Loop */}
                            {(npsFeedbackLoop || qcFeedbackLoop) ? (
                                <Card
                                    title="Feedback Loop Status"
                                    id="unified-spotlight-loop"
                                    infoText="Combined feedback acknowledgement tracker for NPS and QC. Shows how many feedbacks were provided, acknowledged (tick or written), and pending."
                                    onDownloadImage={onDownloadImage}
                                    dataForAI={[npsFeedbackLoop, qcFeedbackLoop].filter(Boolean)}
                                    aiType="NPS"
                                    askAI={askAI}
                                    showValues={showValues}
                                    toggleValues={() => setShowValues(!showValues)}
                                    onDownloadCSV={() => ExportEngine.exportCSV([{ Type: 'NPS', ...npsFeedbackLoop }, { Type: 'QC', ...qcFeedbackLoop }].filter(d => d.provided > 0), "unified_spotlight_feedback_loop")}
                                    onCopyTable={() => copyTableToClipboard(null, [{ Type: 'NPS', ...npsFeedbackLoop }, { Type: 'QC', ...qcFeedbackLoop }].filter(d => d.provided > 0))}
                                    columnFilter={<div className="flex gap-2 items-center">
                                        {npsFeedbackLoop && npsFeedbackLoop.provided > 0 && (
                                            <button onClick={() => setShowUnifiedNPSDataModal(true)} className="px-3 py-1.5 bg-blue-600 text-white text-xs font-bold rounded-lg hover:bg-blue-700 transition-all flex items-center gap-1">
                                                <FileText size={14} /> Show NPS Data
                                            </button>
                                        )}
                                        {qcFeedbackLoop && qcFeedbackLoop.provided > 0 && (
                                            <button onClick={() => setShowUnifiedQCDataModal(true)} className="px-3 py-1.5 bg-blue-600 text-white text-xs font-bold rounded-lg hover:bg-blue-700 transition-all flex items-center gap-1">
                                                <FileText size={14} /> Show QC Data
                                            </button>
                                        )}
                                    </div>}>
                                    <TableContainer rowCount={[npsFeedbackLoop, qcFeedbackLoop].filter(d => d && d.provided > 0).length}>
                                        <table className="w-full text-xs text-left border-collapse">
                                            <thead className="bg-slate-50 sticky top-0"><tr className="border-b"><th className="p-3 font-bold text-slate-800">Type</th><th className="p-3 text-center font-bold text-slate-800">Provided</th><th className="p-3 text-center font-bold text-slate-800">Tick Ack</th><th className="p-3 text-center font-bold text-slate-800">Written Ack</th><th className="p-3 text-center font-bold text-slate-800">Pending Tick</th><th className="p-3 text-center font-bold text-slate-800">Pending Written</th><th className="p-3 text-center font-bold text-slate-800">Not Required</th></tr></thead>
                                            <tbody className="divide-y">
                                                {npsFeedbackLoop && npsFeedbackLoop.provided > 0 && (
                                                    <tr className="hover:bg-slate-50">
                                                        <td className="p-3 font-medium">NPS</td>
                                                        <td className="p-3 text-center">{npsFeedbackLoop.provided}</td>
                                                        <td className="p-3 text-center font-bold text-green-600">{npsFeedbackLoop.ackTick}</td>
                                                        <td className="p-3 text-center font-bold text-blue-600">{npsFeedbackLoop.ackWritten}</td>
                                                        <td className="p-3 text-center font-bold text-amber-500">{npsFeedbackLoop.pendingTick}</td>
                                                        <td className="p-3 text-center font-bold text-orange-500">{npsFeedbackLoop.pendingWritten}</td>
                                                        <td className="p-3 text-center font-bold text-slate-500">{npsFeedbackLoop.notRequired || 0}</td>
                                                    </tr>
                                                )}
                                                {qcFeedbackLoop && qcFeedbackLoop.provided > 0 && (
                                                    <tr className="hover:bg-slate-50">
                                                        <td className="p-3 font-medium">QC</td>
                                                        <td className="p-3 text-center">{qcFeedbackLoop.provided}</td>
                                                        <td className="p-3 text-center font-bold text-green-600">{qcFeedbackLoop.ackTick}</td>
                                                        <td className="p-3 text-center font-bold text-blue-600">{qcFeedbackLoop.ackWritten}</td>
                                                        <td className="p-3 text-center font-bold text-amber-500">{qcFeedbackLoop.pendingTick}</td>
                                                        <td className="p-3 text-center font-bold text-orange-500">{qcFeedbackLoop.pendingWritten}</td>
                                                        <td className="p-3 text-center font-bold text-slate-500">{qcFeedbackLoop.notRequired || 0}</td>
                                                    </tr>
                                                )}
                                            </tbody>
                                        </table>
                                    </TableContainer>
                                </Card>
                            ) : null}


                            {/* Modals for showing feedback provided rows - Unified View */}
                            <Modal isOpen={showUnifiedNPSDataModal} onClose={() => setShowUnifiedNPSDataModal(false)} title={`Feedback Provided Rows - ${selectedAgent || ''} (NPS - Unified View)`} onDownloadImage={onDownloadImage}>
                                <div className={`${unifiedNPSFeedbackRows.length > 30 ? 'overflow-auto max-h-[1000px]' : 'overflow-visible h-auto'} border border-slate-200 rounded-xl custom-scrollbar`}>
                                    <table className="w-full text-xs text-left border-collapse">
                                        <thead className="bg-slate-50 sticky top-0 z-20 border-b border-slate-200">
                                            <tr className="text-slate-700">
                                                <th className="p-4 border-r border-slate-200 min-w-[200px] font-black uppercase text-[10px] tracking-wider text-left">Context</th>
                                                <th className="p-4 border-r border-slate-200 min-w-[300px] font-black uppercase text-[10px] tracking-wider text-center">Questions</th>
                                                <th className="p-4 border-r border-slate-200 min-w-[200px] font-black uppercase text-[10px] tracking-wider text-center">Issue</th>
                                                <th className="p-4 border-r border-slate-200 min-w-[200px] font-black uppercase text-[10px] tracking-wider text-center">Root Cause</th>
                                                <th className="p-4 min-w-[200px] font-black uppercase text-[10px] tracking-wider text-center">Action</th>
                                            </tr>
                                        </thead>
                                        <tbody className="divide-y">
                                            {unifiedNPSFeedbackRows.map((row, idx) => (
                                                <tr key={idx} className="hover:bg-slate-50">
                                                    <td className="p-3">{DataEngine.formatDate(row.Date)}</td>
                                                    <td className="p-3 max-w-md">{row['Remediation Feedback'] || row['Feedback'] || ''}</td>
                                                    <td className="p-3 text-center">
                                                        <span className={`px-2 py-1 rounded text-xs font-bold ${row._isAck ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`}>
                                                            {row._isAck ? 'Yes' : 'No'}
                                                        </span>
                                                    </td>
                                                    <td className="p-3 max-w-md">{row['Agent Reply'] || <span className="text-slate-500 italic">Empty</span>}</td>
                                                    <td className="p-3 text-center">
                                                        <span className={`px-2 py-1 rounded text-xs font-bold ${row._status === 'Complete' ? 'bg-green-100 text-green-700' :
                                                            row._status === 'Pending Written' ? 'bg-amber-100 text-amber-700' :
                                                                'bg-orange-100 text-orange-700'
                                                            }`}>
                                                            {row._status}
                                                        </span>
                                                    </td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                            </Modal>


                            <Modal isOpen={showUnifiedQCDataModal} onClose={() => setShowUnifiedQCDataModal(false)} title={`Feedback Provided Rows - ${selectedAgent || ''} (QC - Unified View)`} onDownloadImage={onDownloadImage}>
                                <div className={`${unifiedQCFeedbackRows.length > 30 ? 'overflow-auto max-h-[1000px]' : 'overflow-visible h-auto'} border border-slate-200 rounded-xl custom-scrollbar`}>
                                    <table className="w-full text-xs text-left border-collapse">
                                        <thead className="bg-slate-50 sticky top-0 z-20 border-b border-slate-200">
                                            <tr className="text-slate-700">
                                                <th className="p-4 border-r border-slate-200 min-w-[200px] font-black uppercase text-[10px] tracking-wider text-left">Context</th>
                                                <th className="p-4 border-r border-slate-200 min-w-[300px] font-black uppercase text-[10px] tracking-wider text-center">Questions</th>
                                                <th className="p-4 border-r border-slate-200 min-w-[200px] font-black uppercase text-[10px] tracking-wider text-center">Issue</th>
                                                <th className="p-4 border-r border-slate-200 min-w-[200px] font-black uppercase text-[10px] tracking-wider text-center">Root Cause</th>
                                                <th className="p-4 min-w-[200px] font-black uppercase text-[10px] tracking-wider text-center">Action</th>
                                            </tr>
                                        </thead>
                                        <tbody className="divide-y">
                                            {unifiedQCFeedbackRows.map((row, idx) => (
                                                <tr key={idx} className="hover:bg-slate-50">
                                                    <td className="p-3">{DataEngine.formatDate(row.Date || row['Review Date'])}</td>
                                                    <td className="p-3 max-w-md">{row['TL RCA'] || ''}</td>
                                                    <td className="p-3 text-center">
                                                        <span className={`px-2 py-1 rounded text-xs font-bold ${row._isAck ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`}>
                                                            {row._isAck ? 'Yes' : 'No'}
                                                        </span>
                                                    </td>
                                                    <td className="p-3 max-w-md">{row['Answer Comment'] || <span className="text-slate-500 italic">Empty</span>}</td>
                                                    <td className="p-3 text-center">
                                                        <span className={`px-2 py-1 rounded text-xs font-bold ${row._status === 'Complete' ? 'bg-green-100 text-green-700' :
                                                            row._status === 'Pending Written' ? 'bg-amber-100 text-amber-700' :
                                                                'bg-orange-100 text-orange-700'
                                                            }`}>
                                                            {row._status}
                                                        </span>
                                                    </td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                            </Modal>


                            <div className="bg-white p-6 rounded-2xl border border-slate-200 shadow-sm relative overflow-hidden" id="unified-coaching-section" data-html2canvas-ignore="true">
                                <div className="flex justify-between items-center mb-6 z-10 relative">
                                    <h3 className="font-bold text-slate-700 uppercase text-sm flex items-center gap-2">
                                        <BrainCircuit size={16} className="text-slate-500" />
                                        Coaching Plan
                                    </h3>
                                    <div className="flex gap-2">
                                        <button onClick={generateRoleplayScript} disabled={loadingRoleplay} className="px-4 py-2 bg-gradient-to-r from-pink-600 to-rose-600 text-white rounded-lg text-xs font-bold uppercase flex items-center gap-2 hover:shadow-lg hover:scale-105 transition-all disabled:opacity-50 disabled:scale-100">
                                            {loadingRoleplay ? <div className="w-3 h-3 border-2 border-white border-t-transparent rounded-full animate-spin" /> : <MessageSquare size={14} />}
                                            Active Roleplay
                                        </button>
                                        <button onClick={generateCoaching} disabled={loadingCoaching} className="px-4 py-2 bg-slate-900 text-white rounded-lg text-xs font-bold uppercase flex items-center gap-2 hover:shadow-lg hover:scale-105 transition-all disabled:opacity-50 disabled:scale-100">
                                            {loadingCoaching ? <div className="w-3 h-3 border-2 border-white border-t-transparent rounded-full animate-spin" /> : <Sparkles size={14} />}
                                            Synthesize Plan
                                        </button>
                                    </div>
                                </div>

                                {/* Template Selection UI */}
                                {!coachingPlan && !loadingCoaching && (
                                    <div className="mb-8 bg-gradient-to-br from-blue-50 to-indigo-50 rounded-2xl p-6 border border-blue-100">
                                        <h3 className="text-sm font-bold text-slate-700 uppercase tracking-wider mb-4 flex items-center gap-2">
                                            <Zap size={16} className="text-blue-600" />
                                            Quick Start Templates
                                        </h3>
                                        <p className="text-xs text-slate-600 mb-4">
                                            Choose a pre-built coaching template tailored to specific performance gaps. 
                                            Each template automatically analyzes agent data and generates a customized plan.
                                        </p>
                                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                            {Object.entries(COACHING_TEMPLATES).map(([key, template]) => {
                                                const Icon = template.icon;
                                                return (
                                                    <button
                                                        key={key}
                                                        onClick={async () => {
                                                            if (!selectedAgent) {
                                                                showToast("Please select an agent first", "error");
                                                                return;
                                                            }
                                                            setLoadingCoaching(true);
                                                            try {
                                                                const plan = await generateCoachingFromTemplate(
                                                                    key,
                                                                    {
                                                                        name: selectedAgent,
                                                                        recentFeedback: agentNPS?.slice(0, 5) || [],
                                                                        topWeaknesses: calculateTopWeaknesses(agentNPS, agentQC),
                                                                        qcFails: agentQC?.filter(r => r['Pass/Fail'] === 'Fail') || [],
                                                                        currentMetrics: calculateAgentMetrics(agentNPS, agentQC),
                                                                        escalations: agentNPS?.filter(r => r.Rating === 'Poor') || [],
                                                                        customerComments: agentNPS?.map(r => r['User Problem']).filter(Boolean) || [],
                                                                        experienceLevel: 'Mid-level',
                                                                        knowledgeGaps: [],
                                                                        commonIssues: [],
                                                                        timeMetrics: {},
                                                                        policyFailures: [],
                                                                        frequentTasks: [],
                                                                        timeWasters: []
                                                                    },
                                                                    askAI
                                                                );
                                                                if (plan) {
                                                                    setCoachingPlan(plan);
                                                                    showToast(`Template "${template.name}" loaded successfully!`);
                                                                } else {
                                                                    showToast("Failed to generate plan from template", "error");
                                                                }
                                                            } catch (error) {
                                                                console.error("Template generation error:", error);
                                                                showToast("Error generating plan from template", "error");
                                                            } finally {
                                                                setLoadingCoaching(false);
                                                            }
                                                        }}
                                                        disabled={loadingCoaching || !selectedAgent}
                                                        className="group p-5 bg-white hover:bg-blue-50 border-2 border-blue-100 hover:border-blue-300 rounded-xl transition-all duration-200 text-left disabled:opacity-50 disabled:cursor-not-allowed"
                                                    >
                                                        <div className="flex items-start gap-3 mb-3">
                                                            <div className="w-10 h-10 rounded-lg bg-blue-100 group-hover:bg-blue-200 flex items-center justify-center flex-shrink-0 transition-colors">
                                                                <Icon size={20} className="text-blue-600" />
                                                            </div>
                                                            <div className="flex-1 min-w-0">
                                                                <h4 className="font-bold text-sm text-slate-800 mb-1 group-hover:text-blue-700 transition-colors">
                                                                    {template.name}
                                                                </h4>
                                                                <p className="text-xs text-slate-600 leading-relaxed">
                                                                    {template.description}
                                                                </p>
                                                            </div>
                                                        </div>
                                                        <div className="flex items-center justify-between mt-3 pt-3 border-t border-slate-100">
                                                            <span className="text-[10px] font-bold text-slate-500 uppercase tracking-wider">
                                                                {template.sections.length} sections
                                                            </span>
                                                            <ChevronRight size={14} className="text-blue-400 group-hover:translate-x-1 transition-transform" />
                                                        </div>
                                                    </button>
                                                );
                                            })}
                                        </div>
                                    </div>
                                )}

                                {coachingPlan ? (
                                    <AIOutputWrapper
                                        content={coachingPlan}
                                        title="Coaching Plan"
                                        onEdit={(newContent) => setCoachingPlan(newContent)}
                                        onRegenerate={() => generateCoaching()}
                                        enableEdit={true}
                                        enablePreview={true}
                                        enableRegenerate={true}
                                        enableVersioning={true}
                                        className="min-h-[320px]"
                                    />
                                ) : (!loadingCoaching && <div className="text-center py-12 text-slate-500 italic">Choose a template above or click Synthesize to generate a custom 360-degree coaching plan for {selectedAgent}</div>)}
                            </div>


                            {/* Roleplay Script Modal */}
                            {roleplayScript && (
                                <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-slate-900/50 backdrop-blur-sm animate-in fade-in">
                                    <div className="bg-white rounded-2xl shadow-2xl max-w-2xl w-full flex flex-col max-h-[80vh] animate-in slide-in-from-bottom-4">
                                        <div className="p-6 border-b border-slate-100 flex justify-between items-center bg-gradient-to-r from-pink-50 to-rose-50 rounded-t-2xl">
                                            <div>
                                                <h3 className="font-bold text-lg text-slate-800 flex items-center gap-2">
                                                    <MessageSquare size={18} className="text-rose-600" />
                                                    {roleplayScript.title}
                                                </h3>
                                                <p className="text-xs text-slate-500 mt-1">{roleplayScript.objective}</p>
                                            </div>
                                            <button onClick={() => setRoleplayScript(null)} className="p-2 hover:bg-slate-100 rounded-lg transition-colors"><XIcon size={20} className="text-slate-500" /></button>
                                        </div>
                                        <div className="p-6 overflow-y-auto custom-scrollbar space-y-6">
                                            <div className="bg-slate-50 p-4 rounded-xl border border-slate-100">
                                                <h4 className="text-xs font-bold text-slate-500 uppercase mb-2">Characters</h4>
                                                <div className="flex gap-4 text-sm">
                                                    <div><span className="font-bold text-indigo-600">Agent:</span> {roleplayScript.characters.agent}</div>
                                                    <div><span className="font-bold text-rose-600">Customer:</span> {roleplayScript.characters.customer}</div>
                                                </div>
                                            </div>
                                            
                                            <div className="space-y-4">
                                                {roleplayScript.script.map((line, i) => (
                                                    <div key={i} className={`flex gap-3 ${line.speaker === 'Agent' ? 'flex-row-reverse' : ''}`}>
                                                        <div className={`w-8 h-8 rounded-full flex items-center justify-center shrink-0 text-xs font-bold ${line.speaker === 'Agent' ? 'bg-indigo-100 text-indigo-700' : 'bg-rose-100 text-rose-700'}`}>
                                                            {line.speaker[0]}
                                                        </div>
                                                        <div className={`p-3 rounded-2xl text-sm max-w-[80%] ${line.speaker === 'Agent' ? 'bg-indigo-50 text-slate-700 rounded-tr-none' : 'bg-white border border-slate-200 text-slate-700 rounded-tl-none'}`}>
                                                            <p className="font-bold text-xs mb-1 opacity-50">{line.speaker}</p>
                                                            {line.text}
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>

                                            <div className="bg-yellow-50 p-4 rounded-xl border border-yellow-100">
                                                <h4 className="text-xs font-bold text-yellow-800 uppercase mb-1 flex items-center gap-2"><Zap size={12}/> Coach's Note</h4>
                                                <p className="text-sm text-yellow-900 italic">{roleplayScript.coachNote}</p>
                                            </div>
                                        </div>
                                        <div className="p-4 border-t border-slate-100 bg-slate-50 rounded-b-2xl flex justify-end gap-3">
                                            <button onClick={() => setRoleplayScript(null)} className="px-4 py-2 text-slate-600 font-bold text-sm hover:bg-slate-200 rounded-xl transition-colors">Close</button>
                                            <button onClick={() => { 
                                                const text = `${roleplayScript.title}\n${roleplayScript.objective}\n\n${roleplayScript.script.map(l => `${l.speaker}: ${l.text}`).join('\n')}`;
                                                safeCopyToClipboard(text); 
                                                showToast('Script copied!');
                                            }} className="px-4 py-2 bg-rose-600 text-white font-bold text-sm hover:bg-rose-700 rounded-xl shadow-lg shadow-rose-200 transition-all flex items-center gap-2">
                                                <Copy size={16} /> Copy Script
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            )}


                            {/* FEATURE 11: PEER MATCHING UI */}
                            {recommendedMentors.length > 0 && (
                                <div className="mt-6 pt-6 border-t border-slate-100">
                                    <h4 className="text-xs font-bold text-slate-500 uppercase tracking-wider mb-4 flex items-center gap-2">
                                        <Users size={14} /> Recommended Peer Mentors
                                    </h4>
                                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4 overflow-visible">
                                        {recommendedMentors.map((mentor, i) => (
                                            <div key={i} className="p-4 bg-indigo-50/50 rounded-xl border border-indigo-100 flex flex-col gap-2 hover:bg-white hover:shadow-md hover:border-indigo-200 transition-all cursor-pointer group" onClick={() => handleDrillDown(mentor.name)}>
                                                <div className="flex justify-between items-start">
                                                    <div className="font-bold text-slate-700 text-sm">{mentor.name}</div>
                                                    <div className="px-2 py-0.5 bg-white rounded-full text-[10px] font-bold text-indigo-600 shadow-sm border border-indigo-50">{mentor.holistic} Score</div>
                                                </div>
                                                <div className="text-[10px] text-slate-500 line-clamp-2 min-h-[30px]">
                                                    Mastery in: <span className="font-medium text-indigo-600">{mentor.skills.slice(0, 2).join(', ')}</span>
                                                </div>
                                                <div className="mt-1 flex items-center gap-1.5 text-[10px] text-indigo-400 font-bold group-hover:text-indigo-600 transition-colors">
                                                    <MessageSquare size={12} /> Ask for advice
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                );
            }


            return (
                <div id="unified-view-container" className="space-y-8">
                    {/* Phase 2: Proper tabs with active state */}


                    {/* Tab Content */}
                    {activeTab === 'Overview' && (
                        <div className="space-y-6">
                            {/* Master KPIs for Unified Overview */}
                            <div className="grid grid-cols-1 md:grid-cols-4 gap-6 overflow-visible items-start">
                                <KPICard
                                    title="Combined Volume"
                                    value={unifiedStats.totalChats}
                                    icon={FileText}
                                    color="slate"
                                    info="Total combined audits (NPS + QC) for the selected period/filter."
                                    onDownloadImage={onDownloadImage}
                                    dataForAI={{ stat: 'Total Chats', value: unifiedStats.totalChats }}
                                    askAI={askAI}
                                />
                                <KPICard
                                    title="Holistic QoS"
                                    value={`${unifiedStats.compositeScore}%`}
                                    icon={Zap}
                                    color="indigo"
                                    info="Weighted average score across both NPS and QC. (NPS Pass % + QC Avg %) / Total Chats."
                                    onDownloadImage={onDownloadImage}
                                    dataForAI={{ stat: 'Holistic score', value: unifiedStats.compositeScore }}
                                    askAI={askAI}
                                />
                                <KPICard
                                    title="Coverage Gap"
                                    value={`${unifiedStats.coverageGap}%`}
                                    icon={Users}
                                    color="amber"
                                    info="Absolute difference between NPS and QC scores. High gap suggests misalignment between internal quality and external sentiment."
                                    onDownloadImage={onDownloadImage}
                                    dataForAI={{ stat: 'Coverage Gap', value: unifiedStats.coverageGap }}
                                    askAI={askAI}
                                />
                                <KPICard
                                    title="Calibration Variance"
                                    value={unifiedStats.calibrationVariance}
                                    icon={TrendingUp}
                                    color="blue"
                                    info="Standard deviation of holistic scores across the team. Higher variance indicates inconsistent performance."
                                    onDownloadImage={onDownloadImage}
                                    dataForAI={{ stat: 'Calibration Variance', value: unifiedStats.calibrationVariance }}
                                    askAI={askAI}
                                />
                            </div>
            {/* Top 5 Impact from NPS and QC */}
                            {(() => {
                                // Calculate NPS Top 5 Friction Points
                                const npsMetricStats = {};
                                Object.values(NPS_METRIC_MAPPING).flat().forEach(m => npsMetricStats[m] = 0);
                                npsData.forEach(d => {
                                    Object.values(NPS_METRIC_MAPPING).flat().forEach(m => {
                                        if (d[m] === false || d[m] === 'FALSE') npsMetricStats[m]++;
                                    });
                                });
                                const npsTop5 = Object.entries(npsMetricStats).sort((a, b) => b[1] - a[1]).slice(0, 5);


                                // Calculate QC Top 5 Fails
                                const qcTagCounts = {};
                                qcData.forEach(d => {
                                    // Calculate isFail if not already present
                                    const score = parseFloat(d['QC Score'] || 0);
                                    const isFail = score < 100 || d['Pass/Fail'] === 'Fail' || d['Pass/Fail'] === 'FALSE';
                                    if (isFail) {
                                        const tag = d.calculatedTag || extractQCTag(d) || d['Question'] || d.Question || 'Unknown';
                                        qcTagCounts[tag] = (qcTagCounts[tag] || 0) + 1;
                                    }
                                });
                                const qcTop5 = Object.entries(qcTagCounts).sort((a, b) => b[1] - a[1]).slice(0, 5);


                                return (
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6 overflow-visible">
                                        <TopIssuesList
                                            data={npsTop5}
                                            maxItems={5}
                                            title="Top 5 NPS Friction Points"
                                            onDownloadImage={onDownloadImage}
                                            infoText="Top 5 specific NPS metrics with the highest failure counts."
                                            dataForAI={npsTop5}
                                            askAI={askAI}
                                        />
                                        <TopIssuesList
                                            data={qcTop5}
                                            maxItems={5}
                                            title="Top 5 QC Fails"
                                            onDownloadImage={onDownloadImage}
                                            infoText="Top 5 specific QC questions causing the most deductions."
                                            dataForAI={qcTop5}
                                            askAI={askAI}
                                        />
                                    </div>
                                );
                            })()}

            

                            {/* Appeals & Ratings Summary - Unified View */}
                            {(() => {
                                // 1. Calculate NPS based on sub-metrics (not Ratings)
                                const npsTotal = npsData.length;
                                const allSubMetrics = Object.values(NPS_METRIC_MAPPING).flat();
                                
                                // Promoters = All sub-metrics pass (equivalent to WOW)
                                const promoters = npsData.filter(r => {
                                    return allSubMetrics.every(m => {
                                        const val = r[m];
                                        return val === true || String(val).toUpperCase() === 'TRUE' || val === 1 || val === '1';
                                    });
                                }).length;
                                
                                // Detractors = Any sub-metric fails (equivalent to Poor)
                                const detractors = npsData.filter(r => {
                                    return allSubMetrics.some(m => {
                                        const val = r[m];
                                        return val === false || String(val).toUpperCase() === 'FALSE' || val === 0 || val === '0';
                                    });
                                }).length;
                                
                                // Passives = Not applicable in sub-metric model (all reviews either pass all or fail some)
                                const passives = 0;
                                
                                // NPS Score = % of non-detractors
                                const npsScore = npsTotal > 0 ? ((1 - (detractors / npsTotal)) * 100).toFixed(0) : 0;


                                // 2. Calculate QC Appeals
                                const qcAppealsData = qcData.filter(r => {
                                    const appealStatus = String(r['Appeal Status'] || '').trim();
                                    return appealStatus && appealStatus !== '' && appealStatus.toLowerCase() !== 'nan';
                                });
                                const qcTotalAppeals = qcAppealsData.length;
                                const qcApproved = qcAppealsData.filter(r => {
                                    const status = String(r['Appeal Status'] || '').toLowerCase();
                                    return status.includes('accept') || status.includes('approved') || status.includes('overturned');
                                }).length;
                                const qcRejected = qcAppealsData.filter(r => {
                                    const status = String(r['Appeal Status'] || '').toLowerCase();
                                    return status.includes('reject') || status.includes('rejected') || status.includes('denied') || status.includes('upheld');
                                }).length;
                                const qcPending = qcTotalAppeals - qcApproved - qcRejected;
                                const qcWinRate = (qcApproved + qcRejected) > 0 ? ((qcApproved / (qcApproved + qcRejected)) * 100).toFixed(1) : 0;


                                return (
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6 overflow-visible">
                                        {/* NPS Rating Breakdown (Replaces NPS Appeals) - MOVED TO LEFT */}
                                        <Card
                                            title="NPS Rating Breakdown"
                                            id="nps-rating-breakdown"
                                            onDownloadImage={onDownloadImage}
                                            onDownloadCSV={() => ExportEngine.exportCSV([
                                                { Category: 'Total Surveys', Value: npsTotal },
                                                { Category: 'Promoters', Value: promoters },
                                                { Category: 'Passives', Value: passives },
                                                { Category: 'Detractors', Value: detractors },
                                                { Category: 'Calculated NPS Score', Value: `${npsScore}%` }
                                            ], "nps_rating_breakdown")}
                                            onCopyTable={() => copyTableToClipboard(null, [
                                                { Category: 'Total Surveys', Value: npsTotal },
                                                { Category: 'Promoters', Value: promoters },
                                                { Category: 'Passives', Value: passives },
                                                { Category: 'Detractors', Value: detractors },
                                                { Category: 'Calculated NPS Score', Value: `${npsScore}%` }
                                            ])}
                                            infoText="Distribution of NPS ratings. Score is calculated as % of non-detractors. Promoters = WOW/5. Passives = Good/Ok/2-4. Detractors = Poor/1."
                                            showValues={showValues}
                                            toggleValues={() => setShowValues(!showValues)}
                                        >
                                            <div className="grid grid-cols-3 gap-4">
                                                <div className="p-4 bg-slate-50 rounded-xl text-center">
                                                    <div className="text-2xl font-bold text-slate-700">{npsTotal}</div>
                                                    <div className="text-xs uppercase font-bold text-slate-500 mt-1">Total Surveys</div>
                                                </div>
                                                <div className="p-4 bg-emerald-50 rounded-xl text-center">
                                                    <div className="text-2xl font-bold text-emerald-700">{promoters}</div>
                                                    <div className="text-xs uppercase font-bold text-emerald-400 mt-1">Promoters</div>
                                                </div>
                                                <div className="p-4 bg-blue-50 rounded-xl text-center">
                                                    <div className="text-2xl font-bold text-blue-700">{passives}</div>
                                                    <div className="text-xs uppercase font-bold text-blue-400 mt-1">Passives</div>
                                                </div>
                                                <div className="p-4 bg-rose-50 rounded-xl text-center">
                                                    <div className="text-2xl font-bold text-rose-700">{detractors}</div>
                                                    <div className="text-xs uppercase font-bold text-rose-400 mt-1">Detractors</div>
                                                </div>
                                                <div className="p-4 bg-slate-50 rounded-xl text-center col-span-2">
                                                    <div className="text-2xl font-bold text-slate-700">{npsScore}%</div>
                                                    <div className="text-xs uppercase font-bold text-slate-500 mt-1">Calculated NPS Score</div>
                                                </div>
                                            </div>
                                        </Card>


                                        {/* QC Appeals Summary - MOVED TO RIGHT */}
                                        <Card
                                            title="QC Appeals Summary"
                                            id="qc-appeals-summary"
                                            onDownloadImage={onDownloadImage}
                                            onDownloadCSV={() => ExportEngine.exportCSV([
                                                { Metric: 'Total Appeals', Value: qcTotalAppeals },
                                                { Metric: 'Accepted', Value: qcApproved },
                                                { Metric: 'Rejected', Value: qcRejected },
                                                { Metric: 'Pending', Value: qcPending },
                                                { Metric: 'Win Rate', Value: `${qcWinRate}%` }
                                            ], "qc_appeals_summary")}
                                            onCopyTable={() => copyTableToClipboard(null, [
                                                { Metric: 'Total Appeals', Value: qcTotalAppeals },
                                                { Metric: 'Accepted', Value: qcApproved },
                                                { Metric: 'Rejected', Value: qcRejected },
                                                { Metric: 'Pending', Value: qcPending },
                                                { Metric: 'Win Rate', Value: `${qcWinRate}%` }
                                            ])}
                                            infoText="Summary of formal disputes raised by agents. Evaluates the accuracy and consistency of the QC process."
                                            showValues={showValues}
                                            toggleValues={() => setShowValues(!showValues)}
                                        >
                                            {qcTotalAppeals > 0 ? (
                                                <div className="grid grid-cols-3 gap-4">
                                                    <div className="p-4 bg-blue-50 rounded-xl text-center">
                                                        <div className="text-2xl font-bold text-blue-700">{qcTotalAppeals}</div>
                                                        <div className="text-xs uppercase font-bold text-blue-400 mt-1">Total</div>
                                                    </div>
                                                    <div className="p-4 bg-green-50 rounded-xl text-center">
                                                        <div className="text-2xl font-bold text-green-700">{qcApproved}</div>
                                                        <div className="text-xs uppercase font-bold text-green-400 mt-1">Accepted</div>
                                                    </div>
                                                    <div className="p-4 bg-rose-50 rounded-xl text-center">
                                                        <div className="text-2xl font-bold text-rose-700">{qcRejected}</div>
                                                        <div className="text-xs uppercase font-bold text-rose-400 mt-1">Rejected</div>
                                                    </div>
                                                    <div className="p-4 bg-amber-50 rounded-xl text-center">
                                                        <div className="text-2xl font-bold text-amber-700">{qcPending}</div>
                                                        <div className="text-xs uppercase font-bold text-amber-400 mt-1">Pending</div>
                                                    </div>
                                                    <div className="p-4 bg-slate-50 rounded-xl text-center col-span-2">
                                                        <div className="text-2xl font-bold text-slate-700">{qcWinRate}%</div>
                                                        <div className="text-xs uppercase font-bold text-slate-500 mt-1">Win Rate</div>
                                                    </div>
                                                </div>
                                            ) : (
                                                <div className="flex flex-col items-center justify-center h-48 text-slate-500 italic">
                                                    <ShieldCheck size={48} className="mb-2 opacity-20" />
                                                    No QC Appeals found in current filter selection.
                                                </div>
                                            )}
                                        </Card>
                                    </div>
                                );
                            })()}



                            
                        </div>
                    )}


                    {activeTab === 'Feedback Loop' && (
                        <ErrorBoundary>
                            <UnifiedFeedbackLoopTabV2
                                combinedData={combinedFeedbackLoop}
                                npsData={npsData}
                                qcData={qcData}
                                onDownloadImage={onDownloadImage}
                                askAI={askAI}
                            />
                        </ErrorBoundary>
                    )}


                    {activeTab === '1:1 Feedback' && (
                        <div className="space-y-6">
                            <ErrorBoundary>
                                <OneOnOneFeedback
                                    npsData={npsData}
                                    qcData={qcData}
                                    onDownloadImage={onDownloadImage}
                                    askAI={askAI}
                                    slackPost={oneOnePost}
                                    onSlackPostChange={setOneOnePost}
                                    customAgents={customAgents}
                                    setCustomAgents={setCustomAgents}
                                    emailAliases={emailAliases}
                                    setEmailAliases={setEmailAliases}
                                    agentFileMap={agentFileMap}
                                    setAgentFileMap={setAgentFileMap}
                                    unmatchedFiles={unmatchedFiles}
                                    setUnmatchedFiles={setUnmatchedFiles}
                                />
                            </ErrorBoundary>
                        </div>
                    )}
                    {activeTab === 'Intelligence Hub' && (
                        <div className="space-y-6">
                            <div className="mb-6">
                                <h2 className="text-xl font-black text-slate-900 tracking-tight flex items-center gap-2">
                                    <Zap className="w-5 h-5 text-amber-500" />
                                    AI Tools Suite
                                </h2>
                                <p className="text-sm text-slate-500 mt-1">AI-powered utilities for CX intelligence and team management</p>
                            </div>
                            
                            {(() => {
                                const tools = [
                                    { id: 'policy-quiz', title: 'PDF Policy Quiz Generator', desc: 'Create interactive quizzes from policy documents to test agent knowledge.', icon: FileText, color: 'purple', grad: 'from-violet-500 to-purple-600' },
                                    { id: 'kb-writer', title: 'Knowledge Base Article Writer', desc: 'Draft polished KB articles fast with AI-powered content generation.', icon: BookOpen, color: 'blue', grad: 'from-blue-500 to-cyan-500' },
                                    { id: 'training-creator', title: 'Training Material Creator', desc: 'Build structured training modules and onboarding materials.', icon: GraduationCap, color: 'emerald', grad: 'from-emerald-500 to-teal-500' },
                                    { id: 'review-doc', title: 'Review Document Generator', desc: 'Generate professional review documents and performance reports.', icon: ClipboardList, color: 'orange', grad: 'from-orange-500 to-amber-500' },
                                    { id: 'coaching-planner', title: 'Coaching Session Planner', desc: 'Plan effective coaching sessions with structured agendas.', icon: Calendar, color: 'rose', grad: 'from-rose-500 to-pink-500' },
                                    { id: 'peer-matcher', title: 'Peer Coaching Matcher', desc: 'Pair mentors with mentees smartly based on skills and needs.', icon: Users, color: 'violet', grad: 'from-violet-500 to-fuchsia-500' },
                                    { id: 'tone-adjuster', title: 'Feedback Tone Adjuster', desc: 'Rewrite feedback with better tone for constructive conversations.', icon: MessageCircle, color: 'cyan', grad: 'from-cyan-500 to-sky-500' },
                                    { id: 'action-extractor', title: 'Feedback Action Extractor', desc: 'Turn feedback into actionable improvement plans.', icon: CheckSquare, color: 'lime', grad: 'from-lime-500 to-green-500' },
                                    { id: 'shadow-matcher', title: 'Shadow Pairing Matcher', desc: 'Create optimal shadowing assignments for skill transfer.', icon: UserPlus, color: 'indigo', grad: 'from-indigo-500 to-blue-500' },
                                    { id: 'pdf-analyzer', title: 'PDF Report Analyzer', desc: 'Analyze reports and extract key insights automatically.', icon: FileDown, color: 'red', grad: 'from-red-500 to-rose-500' },
                                    { id: 'sentiment-analyzer', title: 'Sentiment Analyzer', desc: 'Detect emotions and urgency in customer interactions.', icon: Heart, color: 'pink', grad: 'from-pink-500 to-rose-400' },
                                    { id: 'trend-forecaster', title: 'Trend Forecaster', desc: 'Forecast performance trends and predict future outcomes.', icon: TrendingUp, color: 'amber', grad: 'from-amber-500 to-orange-500' },
                                    { id: 'agent-comparator', title: 'Agent Comparator', desc: 'Compare agents side by side with detailed metrics.', icon: GitCompare, color: 'teal', grad: 'from-teal-500 to-cyan-500' },
                                    { id: 'response-optimizer', title: 'Response Optimizer', desc: 'Improve customer service responses for better satisfaction.', icon: Zap, color: 'sky', grad: 'from-sky-500 to-blue-500' },
                                    { id: 'escalation-predictor', title: 'Escalation Predictor', desc: 'Predict escalation risk before it happens.', icon: AlertTriangle, color: 'violet', grad: 'from-violet-500 to-purple-500' },
                                    { id: 'coach-script-generator', title: 'Coach Script Generator', desc: 'Generate scripts for tough coaching conversations.', icon: MessageSquare, color: 'indigo', grad: 'from-indigo-500 to-violet-500' },
                                    { id: 'performance-summarizer', title: 'Performance Summarizer', desc: 'Create concise agent performance summaries.', icon: FileText, color: 'emerald', grad: 'from-emerald-500 to-green-500' },
                                    { id: 'slack-post-generator', title: 'Slack Post Generator', desc: 'Generate TL-style Slack posts and announcements fast.', icon: MessageSquare, color: 'slate', grad: 'from-slate-700 to-slate-500' },
                                ];
                                
                                return (
                                    <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-5">
                                        {tools.map(t => {
                                            const Icon = t.icon;
                                            return (
                                                <div 
                                                    key={t.id} 
                                                    className="group relative bg-white rounded-2xl border border-slate-200 p-6 shadow-sm hover:shadow-xl hover:-translate-y-1 transition-all duration-300 overflow-hidden"
                                                >
                                                    {/* Gradient accent line at top */}
                                                    <div className={`absolute top-0 left-0 right-0 h-1 bg-gradient-to-r ${t.grad}`}></div>
                                                    
                                                    {/* Icon and Title Row */}
                                                    <div className="flex items-start gap-4 mb-4">
                                                        <div className={`w-14 h-14 rounded-2xl bg-gradient-to-br ${t.grad} text-white flex items-center justify-center shadow-lg group-hover:scale-110 transition-transform duration-300`}>
                                                            <Icon size={24} />
                                                        </div>
                                                        <div className="flex-1 min-w-0 pt-1">
                                                            <h3 className="text-base font-bold text-slate-900 leading-tight group-hover:text-slate-700 transition-colors">{t.title}</h3>
                                                        </div>
                                                    </div>
                                                    
                                                    {/* Description */}
                                                    <p className="text-sm text-slate-600 leading-relaxed mb-5 line-clamp-2">{t.desc}</p>
                                                    
                                                    {/* Action Button */}
                                                    <div className="flex items-center justify-between">
                                                        <button
                                                            onClick={() => window.dispatchEvent(new CustomEvent('poppy-set-active-tool', { detail: { id: t.id } }))}
                                                            className={`px-5 py-2.5 bg-gradient-to-r ${t.grad} text-white rounded-xl text-sm font-bold hover:opacity-90 hover:shadow-lg transition-all no-export flex items-center gap-2`}
                                                            data-html2canvas-ignore="true"
                                                        >
                                                            Launch Tool
                                                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 7l5 5m0 0l-5 5m5-5H6" />
                                                            </svg>
                                                        </button>
                                                        
                                                        {/* Quick hint icon */}
                                                        <div className="w-8 h-8 rounded-full bg-slate-100 flex items-center justify-center text-slate-400 group-hover:bg-slate-200 transition-colors">
                                                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                                            </svg>
                                                        </div>
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                );
                            })()}
                        </div>
                    )}

                    {activeTab === 'Quiz' && (
                        <div className="space-y-6">
                            {/* Agent Filter for Quiz - Compact inline filter style */}
                            <div className="flex items-center gap-3">
                                <div className="flex items-center gap-2">
                                    <Users size={14} className="text-slate-400" />
                                    <select
                                        value={selectedAgentGlobal || ''}
                                        onChange={(e) => setSelectedAgentGlobal(e.target.value || null)}
                                        className="px-3 py-1.5 bg-white border border-slate-200 rounded-lg text-xs text-slate-700 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none min-w-[180px]"
                                    >
                                        <option value="">Select Agent (Optional)</option>
                                        <option value="Team">Whole Team</option>
                                        {Array.from(new Set([...npsData.map(r => r.Agent || r['Agent Email']), ...qcData.map(r => r['Agent Email'] || r.Agent)])).filter(Boolean).sort().map(agent => (
                                            <option key={agent} value={agent}>{agent}</option>
                                        ))}
                                    </select>
                                    {selectedAgentGlobal && (
                                        <button 
                                            onClick={() => setSelectedAgentGlobal(null)}
                                            className="text-[10px] text-rose-500 hover:text-rose-700 font-medium"
                                        >
                                            Clear
                                        </button>
                                    )}
                                </div>
                                <span className="text-xs text-slate-500">
                                    {selectedAgentGlobal ? `Generating for: ${selectedAgentGlobal}` : 'No agent selected (generic quiz)'}
                                </span>
                            </div>

                            {/* AdvancedCognitive Quizzes */}
                            <div className="space-y-2">
                                <h3 className="text-lg font-bold text-slate-800">AdvancedCognitive Quizzes</h3>
                                <ErrorBoundary>
                                    <AdvancedQuizModule
                                        data={{ nps: npsData, qc: qcData }}
                                        askAI={askAI}
                                        selectedAgent={selectedAgentGlobal}
                                        title="AdvancedCognitive Quizzes"
                                    />
                                </ErrorBoundary>
                            </div>

                            {/* Merged NPS & QC Quiz */}
                            <div className="pt-8 border-t border-slate-200 space-y-2">
                                <h3 className="text-lg font-bold text-slate-800">Merged NPS & QC Quiz</h3>
                                <ErrorBoundary>
                                    <AdvancedQuizModule
                                        data={{ nps: npsData, qc: qcData }}
                                        askAI={askAI}
                                        selectedAgent={selectedAgentGlobal}
                                        title="Merged NPS & QC Quiz"
                                    />
                                </ErrorBoundary>
                            </div>
                        </div>
                    )}



                    <BulkGeneratorModal
                        isOpen={bulkModalOpen}
                        onClose={() => setBulkModalOpen(false)}
                        agents={masterData.map(a => a.name)}
                        onGenerate={async (agent) => {
                            const agentStats = masterData.find(a => a.name === agent);
                            const agentN = npsData.filter(r => DataEngine.normalizeAgent(r, 'NPS') === agent);
                            const agentQ = qcData.filter(r => DataEngine.normalizeAgent(r, 'QC') === agent);


                            // Calculate Top Issues
                            const issues = {};
                            agentN.forEach(r => {
                                Object.entries(NPS_METRIC_MAPPING).forEach(([p, ms]) => {
                                    ms.forEach(m => { if (r[m] === false) issues[m] = (issues[m] || 0) + 1; });
                                });
                            });
                            agentQ.forEach(r => {
                                if (r.isFail) {
                                    const tag = r.calculatedTag || r.Question || 'QC Fail';
                                    issues[tag] = (issues[tag] || 0) + 1;
                                }
                            });


                            const topGaps = Object.entries(issues).sort((a, b) => b[1] - a[1]).slice(0, 3).map(x => x[0]).join(", ");


                            const prompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nCreate a UNIFIED coaching plan for ${agent}. 
NPS Score: ${agentStats?.npsScore || 'N/A'}%. QC Score: ${agentStats?.qcScore || 'N/A'}%.
Top Friction Points: ${topGaps || 'None'}. 

CRITICAL FORMAT:
1. ** Unified Coaching Plan ** (Title wrapped in star emojis both sides, bold)

2. [Introduction - AI Generated based on combined NPS/QC context]

3. **Holistic Performance Re-cap**
   - Combined NPS + QC overview
   - Reference NPS Score: ${agentStats?.npsScore || 'N/A'}% and QC Score: ${agentStats?.qcScore || 'N/A'}%
   - Holistic view of agent performance

4. **Customer Sentiment Analysis (NPS)**
   - NPS-specific analysis
   - Use **Sub-metric names** from data
   - Identify sentiment trends

5. **Quality & Process Compliance (QC)**
   - QC-specific analysis
   - Use **Question keywords** from data
   - Identify compliance gaps

6. **Unified Action Plan**
   - Connecting NPS and QC findings
   - Show service-quality relationship

7. **Roleplay: Balancing Empathy with Policy**
   - Specific roleplay for this agent

8. [Closure - NOT A HEADING]
   - 1-2 lines + 1 line forward-looking
   - Combined as paragraph with emojis

NO SIGN-OFF.

STRICT RULES:
- Titles ALWAYS wrapped in star emojis () before and at end, in bold
- All headings and sub-headings in bold (**text**)
- Closure is NEVER a heading
- NO Sign-off
- Proper 1-2 line breaks between sections
- Use ONLY Pillar names, Sub-metric names, Question keywords from data
- Specific terms from raw data can be bold to highlight
- NO hashtags (#)`


                            return await GeminiAI.generate(prompt);
                        }}
                        title="Bulk Unified Coaching Generator"
                        type="Unified"
                    />
                </div >
            );
        };


        // ============================================
        // AI TOOLS SUITE - 9 NEW TOOLS
        // ============================================

        // TOOL 1: PDF Policy Quiz Generator
        const PolicyQuizGenerator = ({ isOpen, onClose, npsData, qcData }) => {
            const [policyText, setPolicyText] = useState('');
            const [policyFile, setPolicyFile] = useState(null);
            const [numQuestions, setNumQuestions] = useState(5);
            const [difficulty, setDifficulty] = useState('mixed');
            const [quiz, setQuiz] = useState(null);
            const [loading, setLoading] = useState(false);
            const [currentPage, setCurrentPage] = React.useState(1);
            const fileInputRef = useRef(null);
            
            // WIRING 1: Connect Persistence - REMOVED for Sandbox
            useEffect(() => {
                // ToolInputPersistence removed
            }, [isOpen]);

            const QUESTIONS_PER_PAGE = 3;
            const totalPages = quiz ? Math.ceil(quiz.questions.length / QUESTIONS_PER_PAGE) : 0;
            const startIdx = (currentPage - 1) * QUESTIONS_PER_PAGE;
            const currentQuestions = quiz ? quiz.questions.slice(startIdx, startIdx + QUESTIONS_PER_PAGE) : [];



            const handleFileUpload = async (e) => {
                const file = e.target.files?.[0];
                if (!file) return;
                
                setPolicyFile(file);
                const text = await file.text();
                setPolicyText(text);
            };

            const generateQuiz = async () => {
                if (!policyText.trim()) {
                    showToast('Please upload or enter policy content', 'error');
                    return;
                }
                
                setLoading(true);
                setQuiz(null);
                setCurrentPage(1);

                try {
                    const result = await AgenticEngine.execute({
                        systemInstruction: AI_PERSONA + "\nYou are an expert instructional designer creating policy quizzes.",
                        prompt: `Create a quiz based on the following policy/procedure document.
                        
                        POLICY CONTENT:
                        ${policyText.substring(0, 8000)}
                        
                        Requirements:
                        - Generate ${numQuestions} multiple-choice questions
                        - Difficulty level: ${difficulty}
                        - Each question must have 4 options
                        - Include correct/incorrect explanations`,
                        schema: {
                            type: "OBJECT",
                            properties: {
                                title: { type: "STRING" },
                                questions: {
                                    type: "ARRAY",
                                    items: {
                                        type: "OBJECT",
                                        properties: {
                                            question: { type: "STRING" },
                                            options: { type: "ARRAY", items: { type: "STRING" } },
                                            correctAnswer: { type: "INTEGER", description: "Index 0-3" },
                                            explanationCorrect: { type: "STRING" },
                                            explanationWrong: { type: "STRING" }
                                        },
                                        required: ["question", "options", "correctAnswer", "explanationCorrect", "explanationWrong"]
                                    }
                                }
                            },
                            required: ["title", "questions"]
                        }
                    });

                    setQuiz(result);
                    showToast('Quiz generated successfully!', 'success');
                    return result;
                } catch (e) {
                    console.error("Quiz generation failed", e);
                    showToast('Failed to generate quiz', 'error');
                } finally {
                    setLoading(false);
                }
            };



            if (!isOpen) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} title=" PDF Policy Quiz Generator" size="xl">
                    <div className="space-y-6" data-tool-id="policy-quiz">
                        {!quiz && !loading ? (
                            <>
                                <div className="bg-blue-50 border border-blue-200 rounded-xl p-4">
                                    <p className="text-sm text-blue-800">
                                        Upload a policy document (TXT, PDF text extract) or paste policy content to generate an interactive quiz for training purposes.
                                    </p>
                                </div>
                                
                                <div className="space-y-4">
                                    <div>
                                        <label className="block text-sm font-bold text-slate-700 mb-2">Upload Policy File</label>
                                        <input
                                            type="file"
                                            ref={fileInputRef}
                                            accept=".txt,.pdf,.doc,.docx"
                                            onChange={handleFileUpload}
                                            className="hidden"
                                        />
                                        <button
                                            onClick={() => fileInputRef.current?.click()}
                                            className="w-full px-4 py-3 border-2 border-dashed border-slate-300 rounded-xl hover:border-indigo-500 hover:bg-indigo-50 transition-all flex items-center justify-center gap-2"
                                        >
                                            <UploadCloud size={20} className="text-slate-400" />
                                            <span className="text-sm text-slate-600">
                                                {policyFile ? policyFile.name : 'Click to upload policy document'}
                                            </span>
                                        </button>
                                    </div>
                                    
                                    <div className="text-center text-sm text-slate-500"> OR </div>
                                    
                                    <div>
                                        <label className="block text-sm font-bold text-slate-700 mb-2">Paste Policy Content</label>
                                        <textarea
                                            value={policyText}
                                            onChange={(e) => setPolicyText(e.target.value)}
                                            name="policyText"
                                            placeholder="Paste policy text here..."
                                            className="w-full h-40 p-4 border border-slate-200 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-transparent text-sm"
                                        />
                                    </div>
                                    
                                    <div className="grid grid-cols-2 gap-4">
                                        <div>
                                            <label className="block text-sm font-bold text-slate-700 mb-2">Questions</label>
                                            <select
                                                value={numQuestions}
                                                onChange={(e) => setNumQuestions(Number(e.target.value))}
                                                name="numQuestions"
                                                className="w-full px-3 py-2 border border-slate-200 rounded-lg text-sm"
                                            >
                                                <option value={3}>3 Questions</option>
                                                <option value={5}>5 Questions</option>
                                                <option value={10}>10 Questions</option>
                                                <option value={15}>15 Questions</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label className="block text-sm font-bold text-slate-700 mb-2">Difficulty</label>
                                            <select
                                                value={difficulty}
                                                onChange={(e) => setDifficulty(e.target.value)}
                                                name="difficulty"
                                                className="w-full px-3 py-2 border border-slate-200 rounded-lg text-sm"
                                            >
                                                <option value="easy">Easy</option>
                                                <option value="mixed">Mixed</option>
                                                <option value="hard">Hard</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                                
                                <button
                                    onClick={generateQuiz}
                                    disabled={loading || !policyText.trim()}
                                    className="w-full px-4 py-3 bg-gradient-to-r from-purple-600 to-indigo-600 text-white rounded-xl font-bold flex items-center justify-center gap-2 disabled:opacity-50"
                                >
                                    {loading ? <Loader size={18} className="animate-spin" /> : <Sparkles size={18} />}
                                    {loading ? 'Generating Quiz...' : 'Generate Quiz'}
                                </button>
                            </>
                        ) : (
                            <AIWrapper
                                data={quiz}
                                renderItem={renderQuizContent}
                                onRegenerate={generateQuiz}
                                isLoading={loading}
                                title="Policy Quiz"
                            />
                        )}
                    </div>
                </Modal>
            );
        };

        // TOOL 2: Knowledge Base Article Writer
        const KBArticleWriter = ({ isOpen, onClose }) => {
            const [topic, setTopic] = useState('');
            const [category, setCategory] = useState('process');
            const [audience, setAudience] = useState('agents');
            const [article, setArticle] = useState(null);
            const [loading, setLoading] = useState(false);

            const generateArticle = async () => {
                if (!topic.trim()) {
                    showToast('Please enter a topic', 'error');
                    return;
                }
                
                setLoading(true);
                try {
                    const result = await AgenticEngine.execute({
                        systemInstruction: AI_PERSONA + "\nYou are an expert Knowledge Base article writer.",
                        prompt: `Write a comprehensive Knowledge Base article.
                        
                        TOPIC: ${topic}
                        CATEGORY: ${category}
                        AUDIENCE: ${audience}
                        
                        Structure:
                        - Overview/Purpose
                        - Prerequisites
                        - Step-by-Step Instructions
                        - Best Practices
                        - Common Pitfalls / Troubleshooting`,
                        schema: {
                            type: "OBJECT",
                            properties: {
                                title: { type: "STRING" },
                                content: { type: "STRING", description: "Full article content in Markdown" },
                                summary: { type: "STRING" }
                            },
                            required: ["title", "content"]
                        }
                    });

                    // Augment result with metadata
                    const fullResult = {
                        ...result,
                        category,
                        audience,
                        createdAt: new Date().toISOString()
                    };
                    
                    setArticle(fullResult);
                    showToast('Article generated!', 'success');
                    return fullResult;
                } catch (e) {
                    console.error("Article generation failed", e);
                    showToast('Failed to generate article', 'error');
                } finally {
                    setLoading(false);
                }
            };

            const renderArticleContent = (data) => {
                if (!data) return null;

                const handleExport = (format) => {
                    if (format === 'md') {
                        const content = `# ${data.title}\n\n**Category:** ${data.category}\n**Audience:** ${data.audience}\n**Created:** ${new Date(data.createdAt).toLocaleDateString()}\n\n---\n\n${data.content}`;
                        const blob = new Blob([content], { type: 'text/markdown' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `kb-article-${data.title.toLowerCase().replace(/\s+/g, '-')}.md`;
                        a.click();
                    } else if (format === 'txt') {
                        const content = `${data.title}\n\nCategory: ${data.category}\nAudience: ${data.audience}\nCreated: ${new Date(data.createdAt).toLocaleDateString()}\n\n${data.content}`;
                        const blob = new Blob([content], { type: 'text/plain' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `kb-article-${data.title.toLowerCase().replace(/\s+/g, '-')}.txt`;
                        a.click();
                    }
                };

                return (
                    <div className="space-y-4">
                        <div className="flex items-center justify-between">
                            <div>
                                <h3 className="text-lg font-bold text-slate-800">{data.title}</h3>
                                <p className="text-xs text-slate-500">{data.category}  {data.audience}</p>
                            </div>
                            <div className="flex gap-2">
                                <button onClick={() => handleExport('md')} className="px-3 py-1.5 bg-slate-100 hover:bg-slate-200 rounded-lg text-xs font-bold flex items-center gap-1">
                                    <Download size={12} /> MD
                                </button>
                                <button onClick={() => handleExport('txt')} className="px-3 py-1.5 bg-slate-100 hover:bg-slate-200 rounded-lg text-xs font-bold flex items-center gap-1">
                                    <Download size={12} /> TXT
                                </button>
                            </div>
                        </div>
                        
                        <div className="p-4 bg-slate-50 rounded-xl border border-slate-200 max-h-[500px] overflow-y-auto">
                            <div className="prose prose-sm max-w-none">
                                <div dangerouslySetInnerHTML={{ __html: safeMarked(data.content) }} />
                            </div>
                        </div>
                    </div>
                );
            };

            if (!isOpen) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} title=" Knowledge Base Article Writer" size="xl">
                    <div className="space-y-6" data-tool-id="kb-writer">
                        {!article && !loading ? (
                            <>
                                <div className="bg-blue-50 border border-blue-200 rounded-xl p-4">
                                    <p className="text-sm text-blue-800">
                                        Create comprehensive KB articles for your team's knowledge base. Perfect for documenting processes, procedures, and best practices.
                                    </p>
                                </div>
                                
                                <div className="space-y-4">
                                    <div>
                                        <label className="block text-sm font-bold text-slate-700 mb-2">Article Topic</label>
                                        <input
                                            type="text"
                                            value={topic}
                                            onChange={(e) => setTopic(e.target.value)}
                                            name="topic"
                                            placeholder="e.g., How to handle chargeback disputes"
                                            className="w-full px-4 py-3 border border-slate-200 rounded-xl focus:ring-2 focus:ring-indigo-500 text-sm"
                                        />
                                    </div>
                                    
                                    <div className="grid grid-cols-2 gap-4">
                                        <div>
                                            <label className="block text-sm font-bold text-slate-700 mb-2">Category</label>
                                            <select
                                                value={category}
                                                onChange={(e) => setCategory(e.target.value)}
                                                name="category"
                                                className="w-full px-3 py-2 border border-slate-200 rounded-lg text-sm"
                                            >
                                                <option value="process">Process</option>
                                                <option value="procedure">Procedure</option>
                                                <option value="policy">Policy</option>
                                                <option value="troubleshooting">Troubleshooting</option>
                                                <option value="faq">FAQ</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label className="block text-sm font-bold text-slate-700 mb-2">Target Audience</label>
                                            <select
                                                value={audience}
                                                onChange={(e) => setAudience(e.target.value)}
                                                name="audience"
                                                className="w-full px-3 py-2 border border-slate-200 rounded-lg text-sm"
                                            >
                                                <option value="agents">Agents</option>
                                                <option value="team-leads">Team Leads</option>
                                                <option value="managers">Managers</option>
                                                <option value="all">All Staff</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                                
                                <button
                                    onClick={generateArticle}
                                    disabled={loading || !topic.trim()}
                                    className="w-full px-4 py-3 bg-gradient-to-r from-blue-600 to-cyan-600 text-white rounded-xl font-bold flex items-center justify-center gap-2 disabled:opacity-50"
                                >
                                    {loading ? <Loader size={18} className="animate-spin" /> : <Sparkles size={18} />}
                                    {loading ? 'Writing Article...' : 'Generate Article'}
                                </button>
                            </>
                        ) : (
                            <AIWrapper
                                data={article}
                                renderItem={renderArticleContent}
                                onRegenerate={generateArticle}
                                isLoading={loading}
                                title="Knowledge Base Article"
                            />
                        )}
                    </div>
                </Modal>
            );
        };

        // TOOL 3: Training Material Creator
        const TrainingMaterialCreator = ({ isOpen, onClose }) => {
            const [topic, setTopic] = useState('');
            const [materialType, setMaterialType] = useState('module');
            const [duration, setDuration] = useState('30');
            const [material, setMaterial] = useState(null);
            const [loading, setLoading] = useState(false);

            const generateMaterial = async () => {
                if (!topic.trim()) {
                    showToast('Please enter a topic', 'error');
                    return;
                }
                
                setLoading(true);
                try {
                    const result = await AgenticEngine.execute({
                        systemInstruction: AI_PERSONA + "\nYou are an expert Training Material Developer.",
                        prompt: `Create detailed training material.
                        
                        TOPIC: ${topic}
                        TYPE: ${materialType}
                        DURATION: ${duration} minutes
                        
                        Structure the content appropriately for the chosen type (e.g., Module, Presentation, Handout).
                        Include:
                        - Learning Objectives
                        - Agenda / Structure
                        - Core Content
                        - Activity / Knowledge Check
                        - Facilitator Notes`,
                        schema: {
                            type: "OBJECT",
                            properties: {
                                title: { type: "STRING" },
                                content: { type: "STRING", description: "Full training content in Markdown" }
                            },
                            required: ["title", "content"]
                        }
                    });

                    const fullResult = {
                        ...result,
                        type: materialType,
                        duration,
                        createdAt: new Date().toISOString()
                    };
                    
                    setMaterial(fullResult);
                    showToast('Training material created!', 'success');
                    return fullResult;
                } catch (e) {
                    console.error("Material generation failed", e);
                    showToast('Failed to create material', 'error');
                } finally {
                    setLoading(false);
                }
            };

            if (!isOpen) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} title=" Training Material Creator" size="xl">
                    <div className="space-y-6" data-tool-id="training-creator">
                        {!material && !loading ? (
                            <>
                                <div className="bg-emerald-50 border border-emerald-200 rounded-xl p-4">
                                    <p className="text-sm text-emerald-800">
                                        Create comprehensive training materials for onboarding, upskilling, or refresher sessions.
                                    </p>
                                </div>
                                
                                <div className="space-y-4">
                                    <div>
                                        <label className="block text-sm font-bold text-slate-700 mb-2">Training Topic</label>
                                        <input
                                            type="text"
                                            value={topic}
                                            onChange={(e) => setTopic(e.target.value)}
                                            name="topic"
                                            placeholder="e.g., De-escalation techniques for angry customers"
                                            className="w-full px-4 py-3 border border-slate-200 rounded-xl focus:ring-2 focus:ring-emerald-500 text-sm"
                                        />
                                    </div>
                                    
                                    <div className="grid grid-cols-2 gap-4">
                                        <div>
                                            <label className="block text-sm font-bold text-slate-700 mb-2">Material Type</label>
                                            <select
                                                value={materialType}
                                                onChange={(e) => setMaterialType(e.target.value)}
                                                name="materialType"
                                                className="w-full px-3 py-2 border border-slate-200 rounded-lg text-sm"
                                            >
                                                <option value="module">Training Module</option>
                                                <option value="presentation">Presentation Outline</option>
                                                <option value="handout">Student Handout</option>
                                                <option value="elearning">E-Learning Script</option>
                                                <option value="roleplay">Role-play Scenario</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label className="block text-sm font-bold text-slate-700 mb-2">Duration (minutes)</label>
                                            <select
                                                value={duration}
                                                onChange={(e) => setDuration(e.target.value)}
                                                name="duration"
                                                className="w-full px-3 py-2 border border-slate-200 rounded-lg text-sm"
                                            >
                                                <option value="15">15 min</option>
                                                <option value="30">30 min</option>
                                                <option value="60">1 hour</option>
                                                <option value="90">1.5 hours</option>
                                                <option value="120">2 hours</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                                
                                <button
                                    onClick={generateMaterial}
                                    disabled={loading || !topic.trim()}
                                    className="w-full px-4 py-3 bg-gradient-to-r from-emerald-600 to-teal-600 text-white rounded-xl font-bold flex items-center justify-center gap-2 disabled:opacity-50"
                                >
                                    {loading ? <Loader size={18} className="animate-spin" /> : <Sparkles size={18} />}
                                    {loading ? 'Creating Material...' : 'Create Training Material'}
                                </button>
                            </>
                        ) : (
                            <AIWrapper
                                data={material}
                                renderItem={renderTrainingContent}
                                onRegenerate={generateMaterial}
                                isLoading={loading}
                                title="Training Material"
                            />
                        )}
                    </div>
                </Modal>
            );
        };

        // TOOL 4: Review Document Generator
        const ReviewDocumentGenerator = ({ isOpen, onClose, agents, npsData, qcData }) => {
            const [selectedAgent, setSelectedAgent] = useState('');
            const [reviewType, setReviewType] = useState('performance');
            const [period, setPeriod] = useState('month');
            const [document, setDocument] = useState(null);
            const [loading, setLoading] = useState(false);

            const generateDocument = async () => {
                if (!selectedAgent) {
                    showToast('Please select an agent', 'error');
                    return;
                }
                
                setLoading(true);
                try {
                    // Get agent data
                    const agentNps = npsData.filter(r => DataEngine.normalizeAgent(r, 'NPS') === selectedAgent);
                    const agentQc = qcData.filter(r => DataEngine.normalizeAgent(r, 'QC') === selectedAgent);
                    
                    const npsCount = agentNps.length;
                    // NPS Pass Rate based on sub-metrics (not average Rating)
                    const allSubMetrics = Object.values(NPS_METRIC_MAPPING).flat();
                    const npsPassCount = agentNps.filter(r => {
                        return allSubMetrics.every(m => {
                            const val = r[m];
                            return val === true || String(val).toUpperCase() === 'TRUE' || val === 1 || val === '1';
                        });
                    }).length;
                    const npsPassRate = npsCount > 0 ? ((npsPassCount / npsCount) * 100).toFixed(2) : 'N/A';
                    
                    const qcCount = agentQc.length;
                    // QC Pass Rate (Score 0 = Pass) - NO AVERAGE
                    const qcPassCount = agentQc.filter(r => parseFloat(r['QC Score']) === 0).length;
                    const qcPassRate = qcCount > 0 ? ((qcPassCount / qcCount) * 100).toFixed(2) : 'N/A';
                    
                    const result = await AgenticEngine.execute({
                        systemInstruction: AI_PERSONA + "\nYou are an expert Team Lead creating formal review documents.",
                        prompt: `Generate a formal ${reviewType} document for ${selectedAgent}.
                        
                        PERIOD: ${period}
                        
                        PERFORMANCE METRICS:
                        - NPS Audits: ${npsCount} (Pass Rate: ${npsPassRate}%)
                        - QC Audits: ${qcCount} (Pass Rate: ${qcPassRate}%)
                        
                        REQUIREMENTS:
                        - Professional tone suitable for HR records
                        - Highlight key strengths based on metrics
                        - Identify clear opportunities for improvement
                        - Include specific actionable goals
                        
                        Format as a complete, ready-to-sign document.`,
                        schema: {
                            type: "OBJECT",
                            properties: {
                                title: { type: "STRING" },
                                content: { type: "STRING", description: "Full document content in Markdown" },
                                summary: { type: "STRING", description: "Brief executive summary" }
                            },
                            required: ["title", "content", "summary"]
                        }
                    });
                    
                    const fullResult = {
                        ...result,
                        agent: selectedAgent,
                        type: reviewType,
                        period,
                        createdAt: new Date().toISOString()
                    };

                    setDocument(fullResult);
                    showToast('Review document generated!', 'success');
                    return fullResult;
                } catch (e) {
                    console.error("Document generation failed", e);
                    showToast('Failed to generate document', 'error');
                } finally {
                    setLoading(false);
                }
            };

            if (!isOpen) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} title=" Review Document Generator" size="xl">
                    <div className="space-y-6" data-tool-id="review-doc">
                        {!document && !loading ? (
                            <>
                                <div className="bg-orange-50 border border-orange-200 rounded-xl p-4">
                                    <p className="text-sm text-orange-800">
                                        Generate professional review documents for agents. Includes performance summaries, improvement plans, and recognition letters.
                                    </p>
                                </div>
                                
                                <div className="space-y-4">
                                    <div>
                                        <label className="block text-sm font-bold text-slate-700 mb-2">Select Agent</label>
                                        <select
                                            value={selectedAgent}
                                            onChange={(e) => setSelectedAgent(e.target.value)}
                                            name="selectedAgent"
                                            className="w-full px-4 py-3 border border-slate-200 rounded-xl text-sm"
                                        >
                                            <option value="">Select an agent...</option>
                                            {agents.map(agent => (
                                                <option key={agent} value={agent}>{agent}</option>
                                            ))}
                                        </select>
                                    </div>
                                    
                                    <div className="grid grid-cols-2 gap-4">
                                        <div>
                                            <label className="block text-sm font-bold text-slate-700 mb-2">Review Type</label>
                                            <select
                                                value={reviewType}
                                                onChange={(e) => setReviewType(e.target.value)}
                                                name="reviewType"
                                                className="w-full px-3 py-2 border border-slate-200 rounded-lg text-sm"
                                            >
                                                <option value="performance">Performance Review</option>
                                                <option value="monthly">Monthly Check-in</option>
                                                <option value="improvement">Performance Improvement Plan</option>
                                                <option value="recognition">Recognition Letter</option>
                                                <option value="probation">Probation Review</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label className="block text-sm font-bold text-slate-700 mb-2">Review Period</label>
                                            <select
                                                value={period}
                                                onChange={(e) => setPeriod(e.target.value)}
                                                name="period"
                                                className="w-full px-3 py-2 border border-slate-200 rounded-lg text-sm"
                                            >
                                                <option value="week">Week</option>
                                                <option value="month">Month</option>
                                                <option value="quarter">Quarter</option>
                                                <option value="6months">6 Months</option>
                                                <option value="year">Year</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                                
                                <button
                                    onClick={generateDocument}
                                    disabled={loading || !selectedAgent}
                                    className="w-full px-4 py-3 bg-gradient-to-r from-orange-600 to-amber-600 text-white rounded-xl font-bold flex items-center justify-center gap-2 disabled:opacity-50"
                                >
                                    {loading ? <Loader size={18} className="animate-spin" /> : <Sparkles size={18} />}
                                    {loading ? 'Generating Document...' : 'Generate Review Document'}
                                </button>
                            </>
                        ) : (
                            <AIWrapper
                                data={document}
                                renderItem={renderDocumentContent}
                                onRegenerate={generateDocument}
                                isLoading={loading}
                                title="Review Document"
                            />
                        )}
                    </div>
                </Modal>
            );
        };

        // TOOL 5: Coaching Session Planner
        const CoachingSessionPlanner = ({ isOpen, onClose, agents, npsData, qcData }) => {
            const [selectedAgent, setSelectedAgent] = useState('');
            const [sessionType, setSessionType] = useState('1on1');
            const [focusArea, setFocusArea] = useState('general');
            const [plan, setPlan] = useState(null);
            const [loading, setLoading] = useState(false);

            const generatePlan = async () => {
                if (!selectedAgent) {
                    showToast('Please select an agent', 'error');
                    return;
                }
                
                setLoading(true);
                try {
                    // Get agent metrics
                    const agentNps = npsData.filter(r => DataEngine.normalizeAgent(r, 'NPS') === selectedAgent);
                    const agentQc = qcData.filter(r => DataEngine.normalizeAgent(r, 'QC') === selectedAgent);
                    
                    const topIssues = {};
                    agentNps.forEach(r => {
                        Object.entries(NPS_METRIC_MAPPING).forEach(([p, ms]) => {
                            ms.forEach(m => { if (r[m] === false) topIssues[m] = (topIssues[m] || 0) + 1; });
                        });
                    });
                    agentQc.forEach(r => {
                        if (r.isFail) {
                            const tag = r.calculatedTag || r.Question || 'QC Fail';
                            topIssues[tag] = (topIssues[tag] || 0) + 1;
                        }
                    });
                    
                    const sortedIssues = Object.entries(topIssues).sort((a, b) => b[1] - a[1]).slice(0, 3);
                    
                    const result = await AgenticEngine.execute({
                        systemInstruction: AI_PERSONA + "\nYou are an expert Team Lead Coach.",
                        prompt: `Plan a coaching session for ${selectedAgent}.
                        
                        TYPE: ${sessionType}
                        FOCUS: ${focusArea}
                        TOP ISSUES: ${sortedIssues.map(([k, v]) => `${k} (${v})`).join(', ') || 'None identified'}
                        
                        Create a structured plan with:
                        - Warm opening script
                        - Key discussion points
                        - Roleplay/Practice scenario
                        - Specific action items
                        - Follow-up plan`,
                        schema: {
                            type: "OBJECT",
                            properties: {
                                opening: { type: "STRING", description: "Warm opening script" },
                                discussion: { type: "ARRAY", items: { type: "STRING" } },
                                practice: { type: "STRING", description: "Roleplay scenario" },
                                actions: { type: "ARRAY", items: { type: "STRING" } },
                                followup: { type: "STRING", description: "Follow-up plan" }
                            },
                            required: ["opening", "discussion", "practice", "actions", "followup"]
                        }
                    });
                    
                    const fullResult = {
                        agent: selectedAgent,
                        type: sessionType,
                        focus: focusArea,
                        content: result,
                        createdAt: new Date().toISOString()
                    };

                    setPlan(fullResult);
                    showToast('Coaching plan created!', 'success');
                    return fullResult;
                } catch (e) {
                    console.error("Plan generation failed:", e);
                    showToast('Failed to create plan', 'error');
                } finally {
                    setLoading(false);
                }
            };

            if (!isOpen) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} title=" Coaching Session Planner" size="xl">
                    <div className="space-y-6" data-tool-id="coaching-planner">
                        {!plan && !loading ? (
                            <>
                                <div className="bg-rose-50 border border-rose-200 rounded-xl p-4">
                                    <p className="text-sm text-rose-800">
                                        Create structured coaching session plans tailored to each agent's needs. Includes time-boxed activities and discussion guides.
                                    </p>
                                </div>
                                
                                <div className="space-y-4">
                                    <div>
                                        <label className="block text-sm font-bold text-slate-700 mb-2">Select Agent</label>
                                        <select
                                            value={selectedAgent}
                                            onChange={(e) => setSelectedAgent(e.target.value)}
                                            name="selectedAgent"
                                            className="w-full px-4 py-3 border border-slate-200 rounded-xl text-sm"
                                        >
                                            <option value="">Select an agent...</option>
                                            {agents.map(agent => (
                                                <option key={agent} value={agent}>{agent}</option>
                                            ))}
                                        </select>
                                    </div>
                                    
                                    <div className="grid grid-cols-2 gap-4">
                                        <div>
                                            <label className="block text-sm font-bold text-slate-700 mb-2">Session Type</label>
                                            <select
                                                value={sessionType}
                                                onChange={(e) => setSessionType(e.target.value)}
                                                name="sessionType"
                                                className="w-full px-3 py-2 border border-slate-200 rounded-lg text-sm"
                                            >
                                                <option value="1on1">1-on-1 Coaching</option>
                                                <option value="performance">Performance Review</option>
                                                <option value="skill">Skill Building</option>
                                                <option value="career">Career Development</option>
                                                <option value="remedial">Remedial Coaching</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label className="block text-sm font-bold text-slate-700 mb-2">Focus Area</label>
                                            <select
                                                value={focusArea}
                                                onChange={(e) => setFocusArea(e.target.value)}
                                                name="focusArea"
                                                className="w-full px-3 py-2 border border-slate-200 rounded-lg text-sm"
                                            >
                                                <option value="general">General Performance</option>
                                                <option value="nps">NPS/Customer Satisfaction</option>
                                                <option value="qc">Quality/Compliance</option>
                                                <option value="communication">Communication Skills</option>
                                                <option value="technical">Technical Skills</option>
                                                <option value="productivity">Productivity/Efficiency</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                                
                                <button
                                    onClick={generatePlan}
                                    disabled={loading || !selectedAgent}
                                    className="w-full px-4 py-3 bg-gradient-to-r from-rose-600 to-pink-600 text-white rounded-xl font-bold flex items-center justify-center gap-2 disabled:opacity-50"
                                >
                                    {loading ? <Loader size={18} className="animate-spin" /> : <Sparkles size={18} />}
                                    {loading ? 'Creating Plan...' : 'Create Coaching Plan'}
                                </button>
                            </>
                        ) : (
                            <AIWrapper
                                data={plan}
                                renderItem={renderPlanContent}
                                onRegenerate={generatePlan}
                                isLoading={loading}
                                title="Coaching Plan"
                            />
                        )}
                    </div>
                </Modal>
            );
        };

        // TOOL 6: Peer Coaching Matcher
        const PeerCoachingMatcher = ({ isOpen, onClose, agents, npsData, qcData }) => {
            const [matches, setMatches] = useState(null);
            const [loading, setLoading] = useState(false);
            const [focusArea, setFocusArea] = useState('General Performance');

            const generateMatches = async () => {
                setLoading(true);
                try {
                    // Calculate basic stats for context (Limit to save tokens if needed, but useful for context)
                    const agentStats = agents.slice(0, 30).map(agent => {
                        const agentNps = npsData.filter(r => DataEngine.normalizeAgent(r, 'NPS') === agent);
                        const agentQc = qcData.filter(r => DataEngine.normalizeAgent(r, 'QC') === agent);
                        
                        // Simple pass rate approximations for context
                        const npsScore = agentNps.length > 0 ? (agentNps.filter(r => r.Rating === 'Great' || r.Rating === 'WOW').length / agentNps.length * 100).toFixed(0) : 'N/A';
                        const qcScore = agentQc.length > 0 ? (agentQc.filter(r => parseFloat(r['QC Score']) === 0).length / agentQc.length * 100).toFixed(0) : 'N/A';
                        
                        return { name: agent, npsScore: `${npsScore}%`, qcScore: `${qcScore}%` };
                    });

                    const result = await AgenticEngine.execute({
                        systemInstruction: AI_PERSONA + "\nYou are an expert Team Manager specializing in peer mentorship matching.",
                        prompt: `Match agents for peer coaching based on performance data.
                        FOCUS AREA: ${focusArea}
                        AGENT STATS: ${JSON.stringify(agentStats.slice(0, 15))} (Sample)
                        
                        Create 3-5 optimal pairs where a stronger agent mentors a developing one.
                        Provide a clear rationale for each pair and suggested topics.`,
                        schema: {
                            type: "OBJECT",
                            properties: {
                                matches: {
                                    type: "ARRAY",
                                    items: {
                                        type: "OBJECT",
                                        properties: {
                                            mentor: { type: "STRING" },
                                            mentee: { type: "STRING" },
                                            rationale: { type: "STRING" },
                                            topics: { type: "ARRAY", items: { type: "STRING" } }
                                        },
                                        required: ["mentor", "mentee", "rationale", "topics"]
                                    }
                                }
                            },
                            required: ["matches"]
                        }
                    });
                    
                    setMatches(result);
                    showToast('Peer matches generated!', 'success');
                    return result;
                } catch (e) {
                    console.error("Match generation failed", e);
                    showToast('Failed to generate matches', 'error');
                } finally {
                    setLoading(false);
                }
            };

            if (!isOpen) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} title=" Peer Coaching Matcher" size="lg">
                    <div className="space-y-6">
                        {!matches && !loading ? (
                            <>
                                <div className="bg-violet-50 border border-violet-200 rounded-xl p-4">
                                    <p className="text-sm text-violet-800">
                                        AI-powered matching to pair agents based on complementary strengths and development needs for the chosen focus area.
                                    </p>
                                </div>
                                
                                <div>
                                    <label className="block text-sm font-bold text-slate-700 mb-2">Focus Area</label>
                                    <select 
                                        value={focusArea}
                                        onChange={(e) => setFocusArea(e.target.value)}
                                        className="w-full px-3 py-2 border border-slate-200 rounded-lg text-sm"
                                    >
                                        <option value="General Performance">General Performance</option>
                                        <option value="Customer Satisfaction (NPS)">Customer Satisfaction (NPS)</option>
                                        <option value="Quality & Compliance (QC)">Quality & Compliance (QC)</option>
                                        <option value="Soft Skills">Soft Skills/Empathy</option>
                                        <option value="Process Knowledge">Process Knowledge</option>
                                    </select>
                                </div>

                                <button
                                    onClick={generateMatches}
                                    disabled={loading || agents.length < 2}
                                    className="w-full px-4 py-3 bg-gradient-to-r from-violet-600 to-fuchsia-600 text-white rounded-xl font-bold flex items-center justify-center gap-2 disabled:opacity-50"
                                >
                                    {loading ? <Loader size={18} className="animate-spin" /> : <Sparkles size={18} />}
                                    {loading ? 'Analyzing Agents & Matching...' : 'Generate AI Matches'}
                                </button>
                            </>
                        ) : (
                            <AIWrapper
                                data={matches}
                                renderItem={renderMatchesContent}
                                onRegenerate={generateMatches}
                                isLoading={loading}
                                title="Peer Matches"
                            />
                        )}
                    </div>
                </Modal>
            );
        };

        // TOOL 7: Feedback Tone Adjuster
        const FeedbackToneAdjuster = ({ isOpen, onClose }) => {
            const [originalText, setOriginalText] = useState('');
            const [targetTone, setTargetTone] = useState('constructive');
            const [result, setResult] = useState(null);
            const [loading, setLoading] = useState(false);

            const adjustTone = async () => {
                if (!originalText.trim()) {
                    showToast('Please enter feedback text', 'error');
                    return;
                }
                
                setLoading(true);
                try {
                    const result = await AgenticEngine.execute({
                        systemInstruction: AI_PERSONA + "\nYou are an expert communications coach.",
                        prompt: `Rewrite the following feedback to have a "${targetTone}" tone.
                        ORIGINAL TEXT: "${originalText}"
                        
                        Provide the rewritten version, a list of specific changes made, and a tone match score (0-100).`,
                        schema: {
                            type: "OBJECT",
                            properties: {
                                adjusted_text: { type: "STRING" },
                                changes_made: { type: "ARRAY", items: { type: "STRING" } },
                                tone_score: { type: "INTEGER" }
                            },
                            required: ["adjusted_text", "changes_made", "tone_score"]
                        }
                    });
                    
                    const fullResult = {
                        original: originalText,
                        tone: targetTone,
                        adjusted: result.adjusted_text,
                        changes: result.changes_made,
                        score: result.tone_score,
                        createdAt: new Date().toISOString()
                    };

                    setResult(fullResult);
                    showToast('Tone adjusted!', 'success');
                    return fullResult;
                } catch (e) {
                    console.error("Tone adjustment failed", e);
                    showToast('Failed to adjust tone', 'error');
                } finally {
                    setLoading(false);
                }
            };

            if (!isOpen) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} title=" Feedback Tone Adjuster" size="xl">
                    <div className="space-y-6">
                        {!result && !loading ? (
                            <>
                                <div className="bg-cyan-50 border border-cyan-200 rounded-xl p-4">
                                    <p className="text-sm text-cyan-800">
                                        Rewrite feedback with different tones to ensure your message is received well while maintaining its core intent.
                                    </p>
                                </div>
                                
                                <div className="space-y-4">
                                    <div>
                                        <label className="block text-sm font-bold text-slate-700 mb-2">Original Feedback</label>
                                        <textarea
                                            value={originalText}
                                            onChange={(e) => setOriginalText(e.target.value)}
                                            placeholder="Paste your feedback here..."
                                            className="w-full h-32 p-4 border border-slate-200 rounded-xl focus:ring-2 focus:ring-cyan-500 text-sm"
                                        />
                                    </div>
                                    
                                    <div>
                                        <label className="block text-sm font-bold text-slate-700 mb-2">Target Tone</label>
                                        <select
                                            value={targetTone}
                                            onChange={(e) => setTargetTone(e.target.value)}
                                            className="w-full px-4 py-3 border border-slate-200 rounded-xl text-sm"
                                        >
                                            <option value="constructive">Constructive & Supportive</option>
                                            <option value="direct">Direct & Clear</option>
                                            <option value="encouraging">Encouraging & Positive</option>
                                            <option value="formal">Formal & Professional</option>
                                            <option value="empathetic">Empathetic & Understanding</option>
                                            <option value="urgent">Urgent & Action-Oriented</option>
                                        </select>
                                    </div>
                                </div>
                                
                                <button
                                    onClick={adjustTone}
                                    disabled={loading || !originalText.trim()}
                                    className="w-full px-4 py-3 bg-gradient-to-r from-cyan-600 to-sky-600 text-white rounded-xl font-bold flex items-center justify-center gap-2 disabled:opacity-50"
                                >
                                    {loading ? <Loader size={18} className="animate-spin" /> : <Sparkles size={18} />}
                                    {loading ? 'Adjusting Tone...' : 'Adjust Tone'}
                                </button>
                            </>
                        ) : (
                            <AIWrapper
                                data={result}
                                renderItem={renderToneContent}
                                onRegenerate={adjustTone}
                                isLoading={loading}
                                title="Tone Adjustment"
                            />
                        )}
                    </div>
                </Modal>
            );
        };

        // TOOL 8: Feedback Action Extractor
        const FeedbackActionExtractor = ({ isOpen, onClose }) => {
            const [feedbackText, setFeedbackText] = useState('');
            const [actions, setActions] = useState(null);
            const [loading, setLoading] = useState(false);

            const extractActions = async () => {
                if (!feedbackText.trim()) {
                    showToast('Please enter feedback text', 'error');
                    return;
                }
                
                setLoading(true);
                try {
                    const { systemPrompt, userPrompt } = PromptBuilder.build('action-extractor', {
                        feedbackText
                    });
                    
                    const response = await GeminiAI.generateJson(userPrompt, systemPrompt);
                    const parsed = JSON.parse(response.replace(/```json/g, '').replace(/```/g, '').trim());
                    setActions(parsed.actions);
                    showToast(`Extracted ${parsed.actions.length} action items!`, 'success');
                } catch (e) {
                    const sentences = String(feedbackText).split(/[\.\n]+/).map(s => s.trim()).filter(s => s.length > 10);
                    const list = sentences.slice(0, 6).map(s => {
                        const lower = s.toLowerCase();
                        const category = /today|asap|urgent/.test(lower) ? 'Immediate' : /week|soon|next/.test(lower) ? 'Short-term' : 'Long-term';
                        const priority = /critical|urgent|major|high/.test(lower) ? 'High' : /medium|moderate/.test(lower) ? 'Medium' : 'Low';
                        return { action: s, category, priority, rationale: 'Derived from feedback text' };
                    });
                    setActions(list);
                    showToast(`Extracted ${list.length} action items (offline)!`, 'success');
                }
                setLoading(false);
            };

            if (!isOpen) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} title="? Feedback Action Extractor" size="xl">
                    <div className="space-y-6">
                        {!actions ? (
                            <>
                                <div className="bg-lime-50 border border-lime-200 rounded-xl p-4">
                                    <p className="text-sm text-lime-800">
                                        Automatically extract and organize action items from feedback into a structured task list with priorities.
                                    </p>
                                </div>
                                
                                <div className="space-y-4">
                                    <div>
                                        <label className="block text-sm font-bold text-slate-700 mb-2">Feedback Text</label>
                                        <textarea
                                            value={feedbackText}
                                            onChange={(e) => setFeedbackText(e.target.value)}
                                            placeholder="Paste feedback here to extract action items..."
                                            className="w-full h-40 p-4 border border-slate-200 rounded-xl focus:ring-2 focus:ring-lime-500 text-sm"
                                        />
                                    </div>
                                </div>
                                
                                <button
                                    onClick={extractActions}
                                    disabled={loading || !feedbackText.trim()}
                                    className="w-full px-4 py-3 bg-gradient-to-r from-lime-600 to-green-600 text-white rounded-xl font-bold flex items-center justify-center gap-2 disabled:opacity-50"
                                >
                                    {loading ? <Loader size={18} className="animate-spin" /> : <Sparkles size={18} />}
                                    {loading ? 'Extracting Actions...' : 'Extract Action Items'}
                                </button>
                            </>
                        ) : (
                            <div className="space-y-4">
                                <div className="flex items-center justify-between">
                                    <h3 className="text-lg font-bold text-slate-800">Extracted Action Items ({actions.length})</h3>
                                    <button
                                        onClick={() => {
                                            const csv = actions.map(a => ({
                                                Action: a.action,
                                                Category: a.category,
                                                Priority: a.priority,
                                                Rationale: a.rationale
                                            }));
                                            ExportEngine.exportCSV(csv, 'action-items');
                                        }}
                                        className="px-3 py-1.5 bg-lime-100 hover:bg-lime-200 text-lime-700 rounded-lg text-xs font-bold"
                                    >
                                        Export CSV
                                    </button>
                                </div>
                                
                                <div className="space-y-2 max-h-[400px] overflow-y-auto">
                                    {actions.map((action, i) => (
                                        <div key={i} className="p-4 bg-white rounded-xl border border-slate-200">
                                            <div className="flex items-start justify-between gap-4">
                                                <div className="flex-1">
                                                    <p className="font-semibold text-slate-800">{action.action}</p>
                                                    <p className="text-xs text-slate-500 mt-1">{action.rationale}</p>
                                                </div>
                                                <div className="flex flex-col gap-1 items-end">
                                                    <span className={`px-2 py-1 rounded-lg text-[10px] font-bold ${
                                                        action.priority === 'High' ? 'bg-rose-100 text-rose-700' :
                                                        action.priority === 'Medium' ? 'bg-amber-100 text-amber-700' :
                                                        'bg-blue-100 text-blue-700'
                                                    }`}>
                                                        {action.priority}
                                                    </span>
                                                    <span className="px-2 py-1 bg-slate-100 rounded-lg text-[10px] text-slate-600">
                                                        {action.category}
                                                    </span>
                                                </div>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                                
                                <button
                                    onClick={() => setActions(null)}
                                    className="w-full px-4 py-3 border border-slate-200 text-slate-700 rounded-xl font-bold hover:bg-slate-50"
                                >
                                    Extract From Another Feedback
                                </button>
                            </div>
                        )}
                    </div>
                </Modal>
            );
        };

        // TOOL 9: Shadow Pairing Matcher
        const ShadowPairingMatcher = ({ isOpen, onClose, agents, npsData, qcData }) => {
            const [pairings, setPairings] = useState(null);
            const [loading, setLoading] = useState(false);
            const [focusArea, setFocusArea] = useState('Skill Transfer (General)');

            const generatePairings = async () => {
                setLoading(true);
                try {
                    // Identify potential hosts (high performers) and mentees (developing)
                    const agentStats = agents.map(agent => {
                        const agentNps = npsData.filter(r => DataEngine.normalizeAgent(r, 'NPS') === agent);
                        const agentQc = qcData.filter(r => DataEngine.normalizeAgent(r, 'QC') === agent);
                        
                        // Simple stats for context
                        const npsScore = agentNps.length > 0 ? (agentNps.filter(r => r.Rating === 'Great' || r.Rating === 'WOW').length / agentNps.length * 100).toFixed(0) : 0;
                        const qcScore = agentQc.length > 0 ? (agentQc.filter(r => parseFloat(r['QC Score']) === 0).length / agentQc.length * 100).toFixed(0) : 0;
                        
                        return { name: agent, npsScore, qcScore };
                    });

                    // Naive split for context - let AI refine
                    const topPerformers = agentStats.filter(a => a.npsScore > 80 && a.qcScore > 90).slice(0, 5);
                    const developingAgents = agentStats.filter(a => a.npsScore < 70 || a.qcScore < 80).slice(0, 10);
                    
                    if (topPerformers.length === 0 || developingAgents.length === 0) {
                         // Fallback if no clear split, just take top/bottom of sorted list
                         const sorted = [...agentStats].sort((a,b) => (Number(b.npsScore)+Number(b.qcScore)) - (Number(a.npsScore)+Number(a.qcScore)));
                         if (topPerformers.length === 0) topPerformers.push(...sorted.slice(0, 3));
                         if (developingAgents.length === 0) developingAgents.push(...sorted.slice(-5));
                    }

                    const prompt = `${AI_PERSONA}
Match developing agents with top performers for shadowing sessions.
Focus: ${focusArea}
Hosts (Top Performers): ${JSON.stringify(topPerformers)}
Mentees (Developing): ${JSON.stringify(developingAgents)}

Return strict JSON:
{
  "pairings": [
    {
      "host": "Agent Name",
      "mentee": "Agent Name",
      "focus": "Specific focus for this session",
      "duration": "e.g., 1 hour"
    }
  ]
}`;
                    
                    const response = await GeminiAI.generateJson(prompt);
                    setPairings(JSON.parse(response));
                    showToast('Shadow pairings generated!', 'success');
                } catch (e) {
                    console.error(e);
                    showToast('Failed to generate pairings', 'error');
                }
                setLoading(false);
            };

            if (!isOpen) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} title=" Shadow Pairing Matcher" size="lg">
                    <div className="space-y-6">
                        {!pairings ? (
                            <>
                                <div className="bg-indigo-50 border border-indigo-200 rounded-xl p-4">
                                    <p className="text-sm text-indigo-800">
                                        AI-driven matching of developing agents with top performers for targeted shadowing sessions.
                                    </p>
                                </div>
                                
                                <div>
                                    <label className="block text-sm font-bold text-slate-700 mb-2">Shadowing Focus</label>
                                    <select 
                                        value={focusArea}
                                        onChange={(e) => setFocusArea(e.target.value)}
                                        className="w-full px-3 py-2 border border-slate-200 rounded-lg text-sm"
                                    >
                                        <option value="Skill Transfer (General)">Skill Transfer (General)</option>
                                        <option value="De-escalation Techniques">De-escalation Techniques</option>
                                        <option value="Tool Efficiency">Tool Efficiency & Speed</option>
                                        <option value="Policy Adherence">Policy Adherence</option>
                                    </select>
                                </div>

                                <button
                                    onClick={generatePairings}
                                    disabled={loading || agents.length < 2}
                                    className="w-full px-4 py-3 bg-gradient-to-r from-indigo-600 to-blue-600 text-white rounded-xl font-bold flex items-center justify-center gap-2 disabled:opacity-50"
                                >
                                    {loading ? <Loader size={18} className="animate-spin" /> : <Sparkles size={18} />}
                                    {loading ? 'Analyzing Performance...' : 'Generate Shadow Pairings'}
                                </button>
                            </>
                        ) : (
                            <div className="space-y-4">
                                <div className="flex items-center justify-between mb-4">
                                    <h3 className="text-lg font-bold text-slate-800">Shadow Assignments</h3>
                                    <button 
                                        onClick={() => ExportEngine.exportCSV(pairings.pairings, 'shadow-pairings')}
                                        className="px-3 py-1.5 bg-indigo-100 text-indigo-700 rounded-lg text-xs font-bold"
                                    >
                                        Export CSV
                                    </button>
                                </div>

                                <div className="grid grid-cols-1 gap-4">
                                    {pairings.pairings?.map((pair, i) => (
                                        <div key={i} className="bg-white border border-slate-200 rounded-xl p-4 shadow-sm flex items-center justify-between">
                                            <div className="flex items-center gap-4">
                                                <div className="text-center">
                                                    <div className="text-[10px] text-slate-500 uppercase font-bold tracking-wider">Host</div>
                                                    <div className="font-bold text-slate-800">{pair.host}</div>
                                                </div>
                                                <div className="text-slate-300"><ArrowRight size={20} /></div>
                                                <div className="text-center">
                                                    <div className="text-[10px] text-slate-500 uppercase font-bold tracking-wider">Shadow</div>
                                                    <div className="font-bold text-slate-800">{pair.mentee}</div>
                                                </div>
                                            </div>
                                            <div className="text-right">
                                                <div className="text-xs font-bold text-indigo-600">{pair.duration}</div>
                                                <div className="text-xs text-slate-500 max-w-[150px] truncate">{pair.focus}</div>
                                            </div>
                                        </div>
                                    ))}
                                </div>

                                <button
                                    onClick={() => setPairings(null)}
                                    className="w-full px-4 py-3 border border-slate-200 text-slate-700 rounded-xl font-bold hover:bg-slate-50"
                                >
                                    Start Over
                                </button>
                            </div>
                        )}
                    </div>
                </Modal>
            );
        };

        // ============================================
        // NEW AI TOOLS (Issue #40)
        // ============================================

        // TOOL 10: PDF Report Analyzer
        const PDFReportAnalyzer = ({ isOpen, onClose, npsData, qcData }) => {
            const [reportText, setReportText] = useState('');
            const [analysis, setAnalysis] = useState(null);
            const [loading, setLoading] = useState(false);
            const fileInputRef = useRef(null);

            const handleFileUpload = async (e) => {
                const file = e.target.files?.[0];
                if (!file) return;
                const text = await file.text();
                setReportText(text);
            };

            const buildFallbackAnalysis = () => {
                const text = String(reportText || '').toLowerCase();
                
                // Simple keyword extraction for offline mode
                const metrics = [];
                const numbers = text.match(/\d+(\.\d+)?%?/g) || [];
                if (numbers.length > 0) metrics.push(`Found ${numbers.length} data points`);
                if (text.includes('nps')) metrics.push('NPS data detected');
                if (text.includes('csat')) metrics.push('CSAT data detected');
                if (text.includes('qc')) metrics.push('QC data detected');

                const issues = [];
                if (text.includes('slow')) issues.push('Speed/Efficiency concerns');
                if (text.includes('rude')) issues.push('Staff behavior/attitude');
                if (text.includes('error')) issues.push('Process/System errors');
                if (text.includes('wait')) issues.push('Wait time issues');
                if (issues.length === 0) issues.push('No specific negative keywords detected in simple scan');

                return {
                    executiveSummary: "This is an offline analysis based on keyword scanning. The document appears to contain customer service performance data.",
                    keyMetrics: metrics.length ? metrics : ["No specific metrics extracted in offline mode"],
                    topIssues: issues,
                    recommendations: ["Review the full report manually", "Check specific low-scoring areas", "Validate these automated findings"],
                    trends: ["Insufficient data for offline trend analysis"]
                };
            };

            const analyzeReport = async () => {
                if (!reportText.trim()) {
                    showToast('Please upload or paste a report', 'error');
                    return;
                }
                setLoading(true);
                setAnalysis(null);
                
                try {
                    const prompt = `${AI_PERSONA}
Analyze the following CX report and extract key insights:

REPORT CONTENT:
${reportText.substring(0, 5000)}

Return strict JSON:
{
  "executiveSummary": "2-3 sentence overview",
  "keyMetrics": ["List important numbers/stats found"],
  "topIssues": ["Main problems identified"],
  "recommendations": ["3-5 actionable suggestions"],
  "trends": ["Patterns or changes over time"]
}`;
                    
                    const schema = {
                        type: "OBJECT",
                        properties: {
                            executiveSummary: { type: "STRING" },
                            keyMetrics: { type: "ARRAY", items: { type: "STRING" } },
                            topIssues: { type: "ARRAY", items: { type: "STRING" } },
                            recommendations: { type: "ARRAY", items: { type: "STRING" } },
                            trends: { type: "ARRAY", items: { type: "STRING" } }
                        },
                        required: ["executiveSummary", "keyMetrics", "topIssues", "recommendations", "trends"]
                    };

                    const response = await GeminiAI.generateJson(prompt, schema);
                    setAnalysis(response);
                    showToast('Analysis complete!', 'success');
                } catch (e) {
                    console.error("Analysis failed", e);
                    setAnalysis(buildFallbackAnalysis());
                    showToast('Analysis generated (offline mode)', 'warning');
                } finally {
                    setLoading(false);
                }
            };

            if (!isOpen) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} title=" PDF Report Analyzer" size="xl">
                    <div className="space-y-6">
                        {!analysis ? (
                            <>
                                <div className="bg-red-50 border border-red-200 rounded-xl p-4">
                                    <p className="text-sm text-red-800">
                                        Upload a report or paste its content to get AI-powered analysis and insights.
                                    </p>
                                </div>
                                <input type="file" ref={fileInputRef} accept=".txt,.pdf,.doc,.docx" onChange={handleFileUpload} className="hidden" />
                                <button onClick={() => fileInputRef.current?.click()} className="w-full px-4 py-3 border-2 border-dashed border-slate-300 rounded-xl hover:border-red-500 hover:bg-red-50 transition-all">
                                    <UploadCloud size={20} className="mx-auto text-slate-400 mb-2" />
                                    <span className="text-sm text-slate-600">{reportText ? 'File loaded ' : 'Click to upload report'}</span>
                                </button>
                                <textarea value={reportText} onChange={(e) => setReportText(e.target.value)} placeholder="Or paste report content here..." className="w-full h-40 p-4 border border-slate-200 rounded-xl text-sm" />
                                <button onClick={analyzeReport} disabled={loading || !reportText.trim()} className="w-full px-4 py-3 bg-gradient-to-r from-red-600 to-rose-600 text-white rounded-xl font-bold flex items-center justify-center gap-2 disabled:opacity-50">
                                    {loading ? <Loader size={18} className="animate-spin" /> : <Sparkles size={18} />}
                                    {loading ? 'Analyzing...' : 'Analyze Report'}
                                </button>
                            </>
                        ) : (
                            <div className="space-y-4">
                                <div className="p-4 bg-slate-50 rounded-xl border border-slate-200 max-h-[500px] overflow-y-auto space-y-4">
                                    <div className="bg-white p-4 rounded-lg shadow-sm border border-slate-100">
                                        <h4 className="font-bold text-slate-800 mb-2">Executive Summary</h4>
                                        <p className="text-sm text-slate-600">{analysis.executiveSummary}</p>
                                    </div>
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                        <div className="bg-white p-4 rounded-lg shadow-sm border border-slate-100">
                                            <h4 className="font-bold text-slate-800 mb-2 text-indigo-600">Key Metrics</h4>
                                            <ul className="list-disc pl-4 text-sm text-slate-600 space-y-1">{analysis.keyMetrics.map((m, i) => <li key={i}>{m}</li>)}</ul>
                                        </div>
                                        <div className="bg-white p-4 rounded-lg shadow-sm border border-slate-100">
                                            <h4 className="font-bold text-slate-800 mb-2 text-rose-600">Top Issues</h4>
                                            <ul className="list-disc pl-4 text-sm text-slate-600 space-y-1">{analysis.topIssues.map((m, i) => <li key={i}>{m}</li>)}</ul>
                                        </div>
                                    </div>
                                    <div className="bg-white p-4 rounded-lg shadow-sm border border-slate-100">
                                        <h4 className="font-bold text-slate-800 mb-2 text-emerald-600">Recommendations</h4>
                                        <ul className="list-disc pl-4 text-sm text-slate-600 space-y-1">{analysis.recommendations.map((m, i) => <li key={i}>{m}</li>)}</ul>
                                    </div>
                                    {analysis.trends && analysis.trends.length > 0 && (
                                         <div className="bg-white p-4 rounded-lg shadow-sm border border-slate-100">
                                            <h4 className="font-bold text-slate-800 mb-2 text-amber-600">Trends</h4>
                                            <ul className="list-disc pl-4 text-sm text-slate-600 space-y-1">{analysis.trends.map((m, i) => <li key={i}>{m}</li>)}</ul>
                                        </div>
                                    )}
                                </div>
                                <button onClick={() => setAnalysis(null)} className="w-full px-4 py-3 border border-slate-200 text-slate-700 rounded-xl font-bold hover:bg-slate-50">Analyze Another Report</button>
                            </div>
                        )}
                    </div>
                </Modal>
            );
        };

        // TOOL 11: Sentiment Analyzer
        const SentimentAnalyzer = ({ isOpen, onClose, npsData }) => {
            const [inputText, setInputText] = useState('');
            const [sentiment, setSentiment] = useState(null);
            const [loading, setLoading] = useState(false);

            const analyzeSentiment = async () => {
                if (!inputText.trim()) {
                    showToast('Please enter text to analyze', 'error');
                    return;
                }
                setLoading(true);
                setSentiment(null);

                try {
                    const result = await AgenticEngine.execute({
                        systemInstruction: AI_PERSONA + "\nYou are an expert Sentiment Analyst.",
                        prompt: `Analyze the sentiment of the following customer feedback:\n\nTEXT: "${inputText}"`,
                        schema: {
                            type: "OBJECT",
                            properties: {
                                sentiment: { type: "STRING", enum: ["Positive", "Negative", "Neutral"] },
                                score: { type: "INTEGER", description: "Score from -100 to 100" },
                                emotions: { type: "ARRAY", items: { type: "STRING" } },
                                urgency: { type: "STRING", enum: ["High", "Medium", "Low"] },
                                tone: { type: "STRING" }
                            },
                            required: ["sentiment", "score", "emotions", "urgency", "tone"]
                        }
                    });
                    
                    setSentiment(result);
                    showToast('Sentiment analyzed!', 'success');
                } catch (e) {
                    console.error("Sentiment analysis failed", e);
                    showToast('Sentiment analysis failed', 'error');
                } finally {
                    setLoading(false);
                }
            };

            const renderContent = (data) => {
                if (!data) return null;
                const { sentiment, score, emotions, urgency, tone } = data;
                
                const scoreColor = score > 0 ? 'text-emerald-600' : score < 0 ? 'text-rose-600' : 'text-slate-600';
                const bgClass = score > 0 ? 'bg-emerald-50 border-emerald-200' : score < 0 ? 'bg-rose-50 border-rose-200' : 'bg-slate-50 border-slate-200';
                
                return (
                    <div className="space-y-4 p-2">
                        <div className={`p-6 rounded-2xl border ${bgClass}`}>
                            <div className="flex items-center justify-between mb-4">
                                <div>
                                    <h3 className={`font-bold text-lg ${scoreColor}`}>{sentiment} Sentiment</h3>
                                    <p className="text-slate-500 text-xs uppercase tracking-wider font-bold">Confidence Score</p>
                                </div>
                                <div className={`text-4xl font-black ${scoreColor}`}>
                                    {score > 0 ? '+' : ''}{score}
                                </div>
                            </div>
                            
                            <div className="space-y-3">
                                <div className="flex items-start gap-2">
                                    <span className="font-bold text-slate-700 min-w-[80px]">Emotions:</span>
                                    <div className="flex flex-wrap gap-1">
                                        {emotions.map((e, i) => (
                                            <span key={i} className="px-2 py-0.5 bg-white border border-slate-200 rounded text-xs font-bold text-slate-600">
                                                {e}
                                            </span>
                                        ))}
                                    </div>
                                </div>
                                
                                <div className="flex items-center gap-2">
                                    <span className="font-bold text-slate-700 min-w-[80px]">Urgency:</span>
                                    <span className={`px-2 py-1 rounded text-xs font-bold ${urgency === 'High' ? 'bg-red-100 text-red-800' : urgency === 'Medium' ? 'bg-amber-100 text-amber-800' : 'bg-blue-100 text-blue-800'}`}>
                                        {urgency} Priority
                                    </span>
                                </div>
                                
                                <div>
                                    <span className="font-bold text-slate-700 block mb-1">Suggested Tone:</span>
                                    <p className="text-sm text-slate-600 italic bg-white/50 p-2 rounded border border-slate-200/50">
                                        "{tone}"
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };

            if (!isOpen) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} title=" Sentiment Analyzer" size="lg">
                    <div className="space-y-6">
                        {!sentiment && !loading && (
                            <>
                                <div className="bg-pink-50 border border-pink-200 rounded-xl p-4">
                                    <p className="text-sm text-pink-800">Analyze customer feedback sentiment to understand emotions and urgency.</p>
                                </div>
                                <textarea 
                                    value={inputText} 
                                    onChange={(e) => setInputText(e.target.value)} 
                                    placeholder="Paste customer feedback here..." 
                                    className="w-full h-32 p-4 border border-slate-200 rounded-xl text-sm focus:ring-2 focus:ring-pink-500 focus:border-transparent outline-none transition-all" 
                                />
                                <button 
                                    onClick={analyzeSentiment} 
                                    disabled={!inputText.trim()} 
                                    className="w-full px-4 py-3 bg-gradient-to-r from-pink-500 to-rose-500 text-white rounded-xl font-bold flex items-center justify-center gap-2 disabled:opacity-50 hover:shadow-lg hover:shadow-pink-200 transition-all"
                                >
                                    <Heart size={18} />
                                    Analyze Sentiment
                                </button>
                            </>
                        )}
                        
                        {(sentiment || loading) && (
                            <AIWrapper
                                data={sentiment}
                                renderItem={renderContent}
                                onRegenerate={analyzeSentiment}
                                isLoading={loading}
                                title="Sentiment Analysis"
                            />
                        )}
                        
                        {sentiment && !loading && (
                            <button onClick={() => setSentiment(null)} className="w-full px-4 py-3 border border-slate-200 text-slate-700 rounded-xl font-bold hover:bg-slate-50 transition-colors">
                                Analyze Another
                            </button>
                        )}
                    </div>
                </Modal>
            );
        };

        // TOOL 12: Trend Forecaster
        const TrendForecaster = ({ isOpen, onClose, npsData, qcData }) => {
            const [forecast, setForecast] = useState(null);
            const [loading, setLoading] = useState(false);

            const generateForecast = async () => {
                setLoading(true);
                setForecast(null);
                
                // Calculate pass/fail based on sub-metrics (not Rating)
                const allSubMetrics = Object.values(NPS_METRIC_MAPPING).flat();
                const recentNps = npsData.slice(0, 50); // Increased from 20 to 50 for better context
                const npsPassFail = recentNps.map(r => {
                    const hasFail = allSubMetrics.some(m => {
                        const val = r[m];
                        return val === false || String(val).toUpperCase() === 'FALSE' || val === 0 || val === '0';
                    });
                    return hasFail ? 'Fail' : 'Pass';
                });

                try {
                    const result = await AgenticEngine.execute({
                        systemInstruction: AI_PERSONA + "\nYou are an expert Data Analyst and Trend Forecaster.",
                        prompt: `Based on the following data patterns, forecast next month's trends:
                        
                        NPS Data Points: ${npsData.length}
                        QC Data Points: ${qcData.length}
                        Recent NPS Pass/Fail Pattern (Last 50 interactions): ${JSON.stringify(npsPassFail)}
                        
                        Analyze the pass/fail ratio and predict the trend direction.`,
                        schema: {
                            type: "OBJECT",
                            properties: {
                                projectedTrend: { 
                                    type: "OBJECT", 
                                    properties: { direction: { type: "STRING", enum: ["Upward", "Downward", "Stable"] }, description: { type: "STRING" } },
                                    required: ["direction", "description"]
                                },
                                qualityForecast: {
                                    type: "OBJECT",
                                    properties: { score: { type: "STRING" }, description: { type: "STRING" } },
                                    required: ["score", "description"]
                                },
                                emergingIssues: { type: "ARRAY", items: { type: "STRING" } },
                                recommendedActions: { type: "ARRAY", items: { type: "STRING" } },
                                confidenceLevel: { type: "STRING", enum: ["High", "Medium", "Low"] }
                            },
                            required: ["projectedTrend", "qualityForecast", "emergingIssues", "recommendedActions", "confidenceLevel"]
                        }
                    });
                    
                    setForecast(result);
                    showToast('Forecast generated!', 'success');
                } catch (e) {
                    console.error("Forecast failed", e);
                    showToast('Forecast failed', 'error');
                } finally {
                    setLoading(false);
                }
            };

            const renderContent = (data) => {
                if (!data) return null;
                const { projectedTrend, qualityForecast, emergingIssues, recommendedActions, confidenceLevel } = data;
                
                return (
                    <div className="space-y-4 p-2">
                        <div className="flex items-center justify-between mb-4">
                            <h3 className="font-bold text-slate-800">Performance Forecast</h3>
                            <span className={`px-2 py-1 rounded text-xs font-bold ${confidenceLevel === 'High' ? 'bg-emerald-100 text-emerald-800' : confidenceLevel === 'Medium' ? 'bg-amber-100 text-amber-800' : 'bg-slate-100 text-slate-800'}`}>
                                {confidenceLevel} Confidence
                            </span>
                        </div>

                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div className="bg-slate-50 p-4 rounded-xl border border-slate-200">
                                <h4 className="font-bold text-slate-800 mb-2 flex items-center gap-2">
                                    <TrendingUp size={16} className={projectedTrend.direction === 'Upward' ? 'text-emerald-500' : projectedTrend.direction === 'Downward' ? 'text-rose-500' : 'text-slate-500'} />
                                    NPS Trend: {projectedTrend.direction}
                                </h4>
                                <p className="text-sm text-slate-600 leading-relaxed">{projectedTrend.description}</p>
                            </div>
                            <div className="bg-slate-50 p-4 rounded-xl border border-slate-200">
                                <h4 className="font-bold text-slate-800 mb-2 flex items-center gap-2">
                                    <CheckCircle size={16} className="text-blue-500" />
                                    QC Forecast: {forecast.qualityForecast.score}
                                </h4>
                                <p className="text-sm text-slate-600 leading-relaxed">{qualityForecast.description}</p>
                            </div>
                        </div>

                        <div className="space-y-4">
                            <div>
                                <h4 className="font-bold text-slate-800 mb-2 flex items-center gap-2 text-sm uppercase tracking-wide">
                                    <AlertTriangle size={14} className="text-amber-500" /> Emerging Issues
                                </h4>
                                <ul className="space-y-2">
                                    {emergingIssues.map((m, i) => (
                                        <li key={i} className="flex items-start gap-2 text-sm text-slate-700 bg-amber-50 p-2 rounded border border-amber-100">
                                            <span className="text-amber-500 mt-0.5"></span> {m}
                                        </li>
                                    ))}
                                </ul>
                            </div>

                            <div>
                                <h4 className="font-bold text-slate-800 mb-2 flex items-center gap-2 text-sm uppercase tracking-wide">
                                    <Zap size={14} className="text-emerald-500" /> Recommended Actions
                                </h4>
                                <ul className="space-y-2">
                                    {recommendedActions.map((m, i) => (
                                        <li key={i} className="flex items-start gap-2 text-sm text-slate-700 bg-emerald-50 p-2 rounded border border-emerald-100">
                                            <span className="text-emerald-500 mt-0.5"></span> {m}
                                        </li>
                                    ))}
                                </ul>
                            </div>
                        </div>
                    </div>
                );
            };

            if (!isOpen) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} title=" Trend Forecaster" size="lg">
                    <div className="space-y-6">
                        {!forecast && !loading && (
                            <>
                                <div className="bg-amber-50 border border-amber-200 rounded-xl p-4">
                                    <p className="text-sm text-amber-800">AI-powered trend forecasting based on your current data patterns.</p>
                                </div>
                                <button 
                                    onClick={generateForecast} 
                                    disabled={loading} 
                                    className="w-full px-4 py-3 bg-gradient-to-r from-amber-500 to-orange-500 text-white rounded-xl font-bold flex items-center justify-center gap-2 disabled:opacity-50 hover:shadow-lg hover:shadow-amber-200 transition-all"
                                >
                                    <TrendingUp size={18} />
                                    Generate Forecast
                                </button>
                            </>
                        )}
                        
                        {(forecast || loading) && (
                            <AIWrapper
                                data={forecast}
                                renderItem={renderContent}
                                onRegenerate={generateForecast}
                                isLoading={loading}
                                title="Trend Forecast"
                            />
                        )}
                        
                        {forecast && !loading && (
                            <button onClick={() => setForecast(null)} className="w-full px-4 py-3 border border-slate-200 text-slate-700 rounded-xl font-bold hover:bg-slate-50 transition-colors">
                                Forecast Again
                            </button>
                        )}
                    </div>
                </Modal>
            );
        };

        // TOOL 13: Agent Comparator
        // Mission 2: AI Toolkit - Component Encapsulation & Custom Dashboard
        const AgentComparator = ({ isOpen, onClose, npsData, qcData }) => {
            const [agent1, setAgent1] = useState('');
            const [agent2, setAgent2] = useState('');
            const [comparison, setComparison] = useState(null);
            const [loading, setLoading] = useState(false);

            const allAgents = [...new Set([...npsData.map(r => DataEngine.normalizeAgent(r, 'NPS')), ...qcData.map(r => DataEngine.normalizeAgent(r, 'QC'))])].filter(Boolean).sort();

            const compareAgents = async () => {
                if (!agent1 || !agent2) {
                    showToast('Please select both agents', 'error');
                    return;
                }
                setLoading(true);
                setComparison(null);

                try {
                    const getAgentStats = (agent) => {
                        const nps = npsData.filter(r => DataEngine.normalizeAgent(r, 'NPS') === agent);
                        const qc = qcData.filter(r => DataEngine.normalizeAgent(r, 'QC') === agent);
                        const npsPass = nps.filter(r => r.Rating >= 9 || r['Promoter'] === true).length;
                        const qcScores = qc.map(r => parseFloat(r['QC Score'] || 0));
                        const avgQc = qcScores.length ? (qcScores.reduce((a, b) => a + b, 0) / qcScores.length).toFixed(1) : 'N/A';
                        const npsScore = nps.length ? ((npsPass / nps.length) * 100).toFixed(1) : 'N/A';
                        
                        return {
                            agent,
                            npsCount: nps.length,
                            qcCount: qc.length,
                            npsScore,
                            qcScore: avgQc,
                            recentFeedback: nps.slice(0, 5).map(r => r.Comment || r.Feedback || '').filter(Boolean).join(' | ')
                        };
                    };

                    const stats1 = getAgentStats(agent1);
                    const stats2 = getAgentStats(agent2);

                    const result = await AgenticEngine.execute({
                        systemInstruction: AI_PERSONA + "\nYou are an expert Performance Analyst comparing two agents.",
                        prompt: `Compare these two agents based on their performance data:
                        
                        AGENT 1: ${agent1}
                        - NPS Score: ${stats1.npsScore}% (${stats1.npsCount} reviews)
                        - QC Score: ${stats1.qcScore}% (${stats1.qcCount} audits)
                        - Recent Feedback Snippets: ${stats1.recentFeedback}
                        
                        AGENT 2: ${agent2}
                        - NPS Score: ${stats2.npsScore}% (${stats2.npsCount} reviews)
                        - QC Score: ${stats2.qcScore}% (${stats2.qcCount} audits)
                        - Recent Feedback Snippets: ${stats2.recentFeedback}
                        
                        Provide a detailed comparison identifying the winner for each metric, their key strengths/weaknesses, and a final recommendation.`,
                        schema: {
                            type: "OBJECT",
                            properties: {
                                metrics: { 
                                    type: "ARRAY", 
                                    items: { 
                                        type: "OBJECT",
                                        properties: { 
                                            name: { type: "STRING" }, 
                                            agent1Value: { type: "STRING" }, 
                                            agent2Value: { type: "STRING" }, 
                                            winner: { type: "STRING", description: "Name of the winning agent or 'Tie'" } 
                                        },
                                        required: ["name", "agent1Value", "agent2Value", "winner"]
                                    } 
                                },
                                strengths: { 
                                    type: "OBJECT",
                                    properties: {
                                        agent1: { type: "ARRAY", items: { type: "STRING" } },
                                        agent2: { type: "ARRAY", items: { type: "STRING" } }
                                    },
                                    required: ["agent1", "agent2"]
                                },
                                weaknesses: { 
                                    type: "OBJECT",
                                    properties: {
                                        agent1: { type: "ARRAY", items: { type: "STRING" } },
                                        agent2: { type: "ARRAY", items: { type: "STRING" } }
                                    },
                                    required: ["agent1", "agent2"]
                                },
                                recommendation: { type: "STRING" }
                            },
                            required: ["metrics", "strengths", "weaknesses", "recommendation"]
                        }
                    });
                    
                    setComparison(result);
                    showToast('Comparison complete!', 'success');
                } catch (e) {
                    console.error("Agent comparison failed", e);
                    showToast('Comparison failed', 'error');
                } finally {
                    setLoading(false);
                }
            };

            const renderContent = (data) => {
                if (!data) return null;
                const { metrics, strengths, weaknesses, recommendation } = data;
                
                return (
                    <div className="space-y-6 p-2">
                        <div className="grid grid-cols-1 gap-3">
                            {metrics.map((m, i) => (
                                <div key={i} className="bg-slate-50 p-4 rounded-xl border border-slate-200 flex flex-col md:flex-row justify-between items-center gap-2">
                                    <span className="font-bold text-slate-700 w-full md:w-1/3">{m.name}</span>
                                    <div className="flex justify-between w-full md:w-2/3 gap-4 text-sm bg-white p-2 rounded-lg border border-slate-100">
                                        <div className={`flex-1 text-center ${m.winner === agent1 ? "text-green-600 font-black" : "text-slate-500"}`}>
                                            <div className="text-xs uppercase text-slate-400 mb-1">{agent1}</div>
                                            {m.agent1Value}
                                        </div>
                                        <div className="w-px bg-slate-200"></div>
                                        <div className={`flex-1 text-center ${m.winner === agent2 ? "text-blue-600 font-black" : "text-slate-500"}`}>
                                            <div className="text-xs uppercase text-slate-400 mb-1">{agent2}</div>
                                            {m.agent2Value}
                                        </div>
                                    </div>
                                </div>
                            ))}
                        </div>

                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div className="p-5 bg-green-50 rounded-xl border border-green-100 relative overflow-hidden">
                                <div className="absolute top-0 right-0 p-4 opacity-10">
                                    <User size={64} className="text-green-600" />
                                </div>
                                <h4 className="font-bold text-green-800 mb-4 text-lg border-b border-green-200 pb-2">{agent1}</h4>
                                
                                <div className="mb-4">
                                    <h5 className="text-xs font-bold text-green-600 uppercase tracking-wide mb-2 flex items-center gap-1"><ThumbsUp size={12}/> Strengths</h5>
                                    <ul className="space-y-1">
                                        {strengths.agent1.map((s, i) => (
                                            <li key={i} className="text-sm text-green-800 flex items-start gap-2">
                                                <span className="mt-1 w-1.5 h-1.5 rounded-full bg-green-500 shrink-0"></span>
                                                {s}
                                            </li>
                                        ))}
                                    </ul>
                                </div>
                                
                                <div>
                                    <h5 className="text-xs font-bold text-green-600 uppercase tracking-wide mb-2 flex items-center gap-1"><AlertCircle size={12}/> Areas to Watch</h5>
                                    <ul className="space-y-1">
                                        {weaknesses.agent1.map((s, i) => (
                                            <li key={i} className="text-sm text-green-700/80 flex items-start gap-2">
                                                <span className="mt-1 w-1.5 h-1.5 rounded-full bg-green-300 shrink-0"></span>
                                                {s}
                                            </li>
                                        ))}
                                    </ul>
                                </div>
                            </div>

                            <div className="p-5 bg-blue-50 rounded-xl border border-blue-100 relative overflow-hidden">
                                <div className="absolute top-0 right-0 p-4 opacity-10">
                                    <User size={64} className="text-blue-600" />
                                </div>
                                <h4 className="font-bold text-blue-800 mb-4 text-lg border-b border-blue-200 pb-2">{agent2}</h4>
                                
                                <div className="mb-4">
                                    <h5 className="text-xs font-bold text-blue-600 uppercase tracking-wide mb-2 flex items-center gap-1"><ThumbsUp size={12}/> Strengths</h5>
                                    <ul className="space-y-1">
                                        {strengths.agent2.map((s, i) => (
                                            <li key={i} className="text-sm text-blue-800 flex items-start gap-2">
                                                <span className="mt-1 w-1.5 h-1.5 rounded-full bg-blue-500 shrink-0"></span>
                                                {s}
                                            </li>
                                        ))}
                                    </ul>
                                </div>
                                
                                <div>
                                    <h5 className="text-xs font-bold text-blue-600 uppercase tracking-wide mb-2 flex items-center gap-1"><AlertCircle size={12}/> Areas to Watch</h5>
                                    <ul className="space-y-1">
                                        {weaknesses.agent2.map((s, i) => (
                                            <li key={i} className="text-sm text-blue-700/80 flex items-start gap-2">
                                                <span className="mt-1 w-1.5 h-1.5 rounded-full bg-blue-300 shrink-0"></span>
                                                {s}
                                            </li>
                                        ))}
                                    </ul>
                                </div>
                            </div>
                        </div>

                        <div className="bg-gradient-to-r from-slate-800 to-slate-900 text-white p-6 rounded-xl shadow-lg">
                            <h4 className="font-bold text-amber-400 mb-2 flex items-center gap-2">
                                <Star size={18} className="fill-amber-400" /> Final Recommendation
                            </h4>
                            <p className="text-slate-200 leading-relaxed italic">"{recommendation}"</p>
                        </div>
                    </div>
                );
            };

            if (!isOpen) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} title=" Agent Comparator" size="xl">
                    <div className="space-y-6">
                        {!comparison && !loading && (
                            <>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div className="space-y-2">
                                        <label className="text-xs font-bold text-slate-500 uppercase">Agent A</label>
                                        <select value={agent1} onChange={(e) => setAgent1(e.target.value)} className="w-full px-4 py-3 border border-slate-200 rounded-xl text-sm focus:ring-2 focus:ring-teal-500 outline-none"><option value="">Select Agent...</option>{allAgents.map(a => <option key={a} value={a}>{a}</option>)}</select>
                                    </div>
                                    <div className="space-y-2">
                                        <label className="text-xs font-bold text-slate-500 uppercase">Agent B</label>
                                        <select value={agent2} onChange={(e) => setAgent2(e.target.value)} className="w-full px-4 py-3 border border-slate-200 rounded-xl text-sm focus:ring-2 focus:ring-cyan-500 outline-none"><option value="">Select Agent...</option>{allAgents.filter(a => a !== agent1).map(a => <option key={a} value={a}>{a}</option>)}</select>
                                    </div>
                                </div>
                                <button 
                                    onClick={compareAgents} 
                                    disabled={!agent1 || !agent2} 
                                    className="w-full px-4 py-4 bg-gradient-to-r from-teal-500 to-cyan-500 text-white rounded-xl font-bold flex items-center justify-center gap-2 disabled:opacity-50 hover:shadow-lg hover:shadow-cyan-200 transition-all"
                                >
                                    <GitCompare size={20} />
                                    Compare Performance
                                </button>
                            </>
                        )}
                        
                        {(comparison || loading) && (
                            <AIWrapper
                                data={comparison}
                                renderItem={renderContent}
                                onRegenerate={compareAgents}
                                isLoading={loading}
                                title={`Comparison: ${agent1} vs ${agent2}`}
                            />
                        )}
                        
                        {comparison && !loading && (
                            <button onClick={() => setComparison(null)} className="w-full px-4 py-3 border border-slate-200 text-slate-700 rounded-xl font-bold hover:bg-slate-50 transition-colors">
                                New Comparison
                            </button>
                        )}
                    </div>
                </Modal>
            );
        };

        // TOOL 14: Response Optimizer
        // Mission 2: Stateful Mini-App with JSON Output
        const ResponseOptimizer = ({ isOpen, onClose }) => {
            const [originalText, setOriginalText] = useState('');
            const [context, setContext] = useState('customer-complaint');
            const [optimized, setOptimized] = useState(null);
            const [loading, setLoading] = useState(false);

            const optimizeResponse = async () => {
                if (!originalText.trim()) {
                    showToast('Please enter a response to optimize', 'error');
                    return;
                }
                setLoading(true);
                setOptimized(null);
                
                try {
                    const result = await AgenticEngine.execute({
                        systemInstruction: AI_PERSONA + "\nYou are an expert Customer Service Communication Specialist.",
                        prompt: `Optimize the following customer service response for the given context:
                        CONTEXT: ${context}
                        ORIGINAL RESPONSE: "${originalText}"
                        
                        Ensure the tone is empathetic, professional, and clear.`,
                        schema: {
                            type: "OBJECT",
                            properties: {
                                optimized: { type: "STRING", description: "The improved response text" },
                                improvements: { type: "ARRAY", items: { type: "STRING" } },
                                tone: { type: "STRING" },
                                alternative: { type: "STRING", description: "A shorter, more concise alternative" }
                            },
                            required: ["optimized", "improvements", "tone", "alternative"]
                        }
                    });
                    
                    setOptimized(result);
                    showToast('Response optimized!', 'success');
                } catch (e) {
                    console.error("Optimization failed", e);
                    showToast('Optimization failed', 'error');
                } finally {
                    setLoading(false);
                }
            };

            const renderContent = (data) => {
                if (!data) return null;
                const { optimized, improvements, tone, alternative } = data;
                
                return (
                    <div className="space-y-6 p-2">
                        <div className="bg-emerald-50 p-6 rounded-2xl border border-emerald-100 relative">
                            <div className="absolute top-4 right-4">
                                <button 
                                    onClick={() => {
                                        ClipboardUtils.copy(optimized);
                                        showToast('Copied to clipboard', 'success');
                                    }}
                                    className="p-2 bg-white text-emerald-600 rounded-lg shadow-sm hover:bg-emerald-100 transition-colors"
                                    title="Copy Optimized Response"
                                >
                                    <Copy size={16} />
                                </button>
                            </div>
                            <h4 className="font-bold text-emerald-800 mb-3 flex items-center gap-2">
                                <Sparkles size={18} /> Optimized Response
                            </h4>
                            <p className="text-emerald-900 text-base leading-relaxed whitespace-pre-wrap font-medium">{optimized}</p>
                            <div className="mt-4 flex items-center gap-2">
                                <span className="text-xs font-bold text-emerald-600 uppercase tracking-wide">Tone:</span>
                                <span className="px-2 py-1 bg-white/50 rounded text-xs text-emerald-700 font-bold border border-emerald-100">{tone}</span>
                            </div>
                        </div>

                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div className="p-4 bg-white rounded-xl border border-slate-200">
                                <h4 className="font-bold text-slate-800 mb-3 flex items-center gap-2 text-sm uppercase tracking-wide">
                                    <ThumbsUp size={14} className="text-blue-500" /> Key Improvements
                                </h4>
                                <ul className="space-y-2">
                                    {improvements.map((imp, i) => (
                                        <li key={i} className="flex items-start gap-2 text-sm text-slate-600">
                                            <span className="text-blue-500 mt-0.5"></span> {imp}
                                        </li>
                                    ))}
                                </ul>
                            </div>

                            <div className="p-4 bg-slate-50 rounded-xl border border-slate-200 relative group">
                                <div className="absolute top-4 right-4 opacity-0 group-hover:opacity-100 transition-opacity">
                                    <button 
                                        onClick={() => {
                                            ClipboardUtils.copy(alternative);
                                            showToast('Copied to clipboard', 'success');
                                        }}
                                        className="p-1.5 bg-white text-slate-600 rounded shadow-sm hover:text-blue-600"
                                        title="Copy Alternative"
                                    >
                                        <Copy size={14} />
                                    </button>
                                </div>
                                <h4 className="font-bold text-slate-800 mb-3 flex items-center gap-2 text-sm uppercase tracking-wide">
                                    <Zap size={14} className="text-amber-500" /> Concise Alternative
                                </h4>
                                <p className="text-sm text-slate-600 italic leading-relaxed">"{alternative}"</p>
                            </div>
                        </div>
                    </div>
                );
            };

            if (!isOpen) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} title=" Response Optimizer" size="xl">
                    <div className="space-y-6">
                        {!optimized && !loading && (
                            <>
                                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                    <div className="md:col-span-2">
                                        <label className="text-xs font-bold text-slate-500 uppercase mb-2 block">Your Draft Response</label>
                                        <textarea 
                                            value={originalText} 
                                            onChange={(e) => setOriginalText(e.target.value)} 
                                            placeholder="Paste your draft response here..." 
                                            className="w-full h-40 p-4 border border-slate-200 rounded-xl text-sm focus:ring-2 focus:ring-indigo-500 outline-none resize-none"
                                        />
                                    </div>
                                    <div className="space-y-4">
                                        <div>
                                            <label className="text-xs font-bold text-slate-500 uppercase mb-2 block">Context</label>
                                            <select 
                                                value={context} 
                                                onChange={(e) => setContext(e.target.value)} 
                                                className="w-full p-3 border border-slate-200 rounded-xl text-sm outline-none focus:border-indigo-500 bg-white"
                                            >
                                                <option value="customer-complaint">Complaint Handling</option>
                                                <option value="feature-request">Feature Request</option>
                                                <option value="refund-denial">Refund Denial</option>
                                                <option value="general-inquiry">General Inquiry</option>
                                                <option value="escalation">Escalation Handover</option>
                                            </select>
                                        </div>
                                        <div className="bg-indigo-50 p-4 rounded-xl border border-indigo-100">
                                            <p className="text-xs text-indigo-800 leading-relaxed">
                                                <strong>Tip:</strong> Select the correct context to ensure the AI adjusts empathy and policy adherence correctly.
                                            </p>
                                        </div>
                                    </div>
                                </div>
                                <button 
                                    onClick={optimizeResponse} 
                                    disabled={!originalText.trim()} 
                                    className="w-full px-4 py-4 bg-gradient-to-r from-indigo-500 to-violet-500 text-white rounded-xl font-bold flex items-center justify-center gap-2 disabled:opacity-50 hover:shadow-lg hover:shadow-indigo-200 transition-all"
                                >
                                    <Zap size={20} />
                                    Optimize Response
                                </button>
                            </>
                        )}
                        
                        {(optimized || loading) && (
                            <AIWrapper
                                data={optimized}
                                renderItem={renderContent}
                                onRegenerate={optimizeResponse}
                                isLoading={loading}
                                title="Response Optimization"
                            />
                        )}
                        
                        {optimized && !loading && (
                            <button onClick={() => setOptimized(null)} className="w-full px-4 py-3 border border-slate-200 text-slate-700 rounded-xl font-bold hover:bg-slate-50 transition-colors">
                                Optimize Another
                            </button>
                        )}
                    </div>
                </Modal>
            );
        };

        // TOOL 16: Coach Script Generator
        // Mission 2: Stateful Mini-App with JSON Output
        const CoachScriptGenerator = ({ isOpen, onClose }) => {
            const [topic, setTopic] = useState('');
            const [difficulty, setDifficulty] = useState('sensitive');
            const [script, setScript] = useState(null);
            const [loading, setLoading] = useState(false);

            const generateScript = async () => {
                if (!topic.trim()) {
                    showToast('Please enter a topic', 'error');
                    return;
                }
                setLoading(true);
                setScript(null);
                
                try {
                    const result = await AgenticEngine.execute({
                        systemInstruction: AI_PERSONA + "\nYou are an expert Team Lead Coach.",
                        prompt: `Generate a coaching conversation script for:
                        TOPIC: ${topic}
                        DIFFICULTY: ${difficulty}
                        
                        Structure the conversation into clear phases with actionable tips.`,
                        schema: {
                            type: "OBJECT",
                            properties: {
                                phases: {
                                    type: "ARRAY",
                                    items: {
                                        type: "OBJECT",
                                        properties: {
                                            title: { type: "STRING" },
                                            content: { type: "STRING" }
                                        },
                                        required: ["title", "content"]
                                    }
                                },
                                tips: {
                                    type: "ARRAY",
                                    items: { type: "STRING" }
                                }
                            },
                            required: ["phases", "tips"]
                        }
                    });
                    
                    setScript(result);
                    showToast('Script generated!', 'success');
                } catch (e) {
                    console.error("Script generation failed", e);
                    showToast('Script generation failed', 'error');
                } finally {
                    setLoading(false);
                }
            };

            const renderContent = (data) => {
                if (!data) return null;
                const { phases, tips } = data;
                
                return (
                    <div className="space-y-6 p-2">
                        <div className="space-y-4">
                            {phases.map((phase, i) => (
                                <div key={i} className="flex gap-4">
                                    <div className="flex flex-col items-center">
                                        <div className="w-8 h-8 rounded-full bg-violet-100 text-violet-600 flex items-center justify-center font-bold text-sm border border-violet-200">
                                            {i + 1}
                                        </div>
                                        {i < phases.length - 1 && <div className="w-0.5 h-full bg-slate-100 my-2"></div>}
                                    </div>
                                    <div className="flex-1 pb-4">
                                        <h4 className="font-bold text-slate-800 text-lg mb-2">{phase.title}</h4>
                                        <div className="bg-white p-4 rounded-xl border border-slate-200 shadow-sm relative">
                                            <div className="absolute top-4 left-0 w-1 h-8 bg-violet-500 rounded-r"></div>
                                            <p className="text-slate-600 italic leading-relaxed">"{phase.content}"</p>
                                        </div>
                                    </div>
                                </div>
                            ))}
                        </div>

                        <div className="bg-amber-50 p-5 rounded-xl border border-amber-100">
                            <h4 className="font-bold text-amber-800 mb-3 flex items-center gap-2">
                                <Lightbulb size={18} /> Coaching Tips
                            </h4>
                            <ul className="space-y-2">
                                {tips.map((tip, i) => (
                                    <li key={i} className="flex items-start gap-2 text-sm text-amber-900">
                                        <span className="text-amber-500 mt-0.5"></span> {tip}
                                    </li>
                                ))}
                            </ul>
                        </div>
                    </div>
                );
            };

            if (!isOpen) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} title=" Coach Script Generator" size="xl">
                    <div className="space-y-6">
                        {!script && !loading && (
                            <>
                                <div className="bg-violet-50 border border-violet-200 rounded-xl p-4">
                                    <p className="text-sm text-violet-800">Generate structured coaching scripts for difficult conversations.</p>
                                </div>
                                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                    <div className="md:col-span-2">
                                        <label className="text-xs font-bold text-slate-500 uppercase mb-2 block">Coaching Topic</label>
                                        <input 
                                            type="text" 
                                            value={topic} 
                                            onChange={(e) => setTopic(e.target.value)} 
                                            placeholder="e.g., Low QA scores on empathy..." 
                                            className="w-full p-3 border border-slate-200 rounded-xl text-sm outline-none focus:border-violet-500"
                                        />
                                    </div>
                                    <div>
                                        <label className="text-xs font-bold text-slate-500 uppercase mb-2 block">Difficulty</label>
                                        <select 
                                            value={difficulty} 
                                            onChange={(e) => setDifficulty(e.target.value)} 
                                            className="w-full p-3 border border-slate-200 rounded-xl text-sm outline-none focus:border-violet-500 bg-white"
                                        >
                                            <option value="low">Low (Routine)</option>
                                            <option value="medium">Medium (Correction)</option>
                                            <option value="high">High (Performance Plan)</option>
                                            <option value="sensitive">Sensitive (Behavior)</option>
                                        </select>
                                    </div>
                                </div>
                                <button 
                                    onClick={generateScript} 
                                    disabled={!topic.trim()} 
                                    className="w-full px-4 py-4 bg-gradient-to-r from-violet-500 to-purple-500 text-white rounded-xl font-bold flex items-center justify-center gap-2 disabled:opacity-50 hover:shadow-lg hover:shadow-violet-200 transition-all"
                                >
                                    <Mic size={20} />
                                    Generate Script
                                </button>
                            </>
                        )}
                        
                        {(script || loading) && (
                            <AIWrapper
                                data={script}
                                renderItem={renderContent}
                                onRegenerate={generateScript}
                                isLoading={loading}
                                title="Coaching Script"
                            />
                        )}
                        
                        {script && !loading && (
                            <button onClick={() => setScript(null)} className="w-full px-4 py-3 border border-slate-200 text-slate-700 rounded-xl font-bold hover:bg-slate-50 transition-colors">
                                New Script
                            </button>
                        )}
                    </div>
                </Modal>
            );
        };

        // TOOL 17: Performance Summarizer
        const PerformanceSummarizer = ({ isOpen, onClose, npsData, qcData }) => {
            const [agentName, setAgentName] = useState('');
            const [summary, setSummary] = useState(null);
            const [loading, setLoading] = useState(false);

            const allAgents = [...new Set([...npsData.map(r => DataEngine.normalizeAgent(r, 'NPS')), ...qcData.map(r => DataEngine.normalizeAgent(r, 'QC'))])].filter(Boolean).sort();

            const generateSummary = async () => {
                if (!agentName) {
                    showToast('Please select an agent', 'error');
                    return;
                }
                setLoading(true);
                setSummary(null);
                
                try {
                    const agentNPS = npsData.filter(r => DataEngine.normalizeAgent(r, 'NPS') === agentName);
                    const agentQC = qcData.filter(r => DataEngine.normalizeAgent(r, 'QC') === agentName);

                    // Calculate NPS Pass Rate based on sub-metrics (not Rating)
                    const allSubMetrics = Object.values(NPS_METRIC_MAPPING).flat();
                    const npsPassCount = agentNPS.filter(r => allSubMetrics.every(m => {
                        const val = r[m];
                        return val === true || String(val).toUpperCase() === 'TRUE' || val === 1 || val === '1';
                    })).length;
                    const npsPassRate = agentNPS.length ? ((npsPassCount / agentNPS.length) * 100).toFixed(2) : 'N/A';

                    // Calculate QC Pass Rate (Score 0 = Pass)
                    const qcPassCount = agentQC.filter(r => parseFloat(r['QC Score']) === 0).length;
                    const qcPassRate = agentQC.length ? ((qcPassCount / agentQC.length) * 100).toFixed(2) : 'N/A';

                    const result = await AgenticEngine.execute({
                        systemInstruction: AI_PERSONA + "\nYou are an expert Team Lead analyzing performance data.",
                        prompt: `Generate a concise performance summary for:
                        
                        AGENT: ${agentName}
                        NPS Reviews: ${agentNPS.length}
                        NPS Pass Rate: ${npsPassRate}%
                        QC Audits: ${agentQC.length}
                        QC Pass Rate: ${qcPassRate}%
                        
                        Focus on actionable insights and clear achievements.`,
                        schema: {
                            type: "OBJECT",
                            properties: {
                                oneLineSummary: { type: "STRING" },
                                keyAchievements: { type: "ARRAY", items: { type: "STRING" } },
                                developmentAreas: { type: "ARRAY", items: { type: "STRING" } },
                                monthOverMonth: { type: "STRING" },
                                recommendation: { type: "STRING" }
                            },
                            required: ["oneLineSummary", "keyAchievements", "developmentAreas", "monthOverMonth", "recommendation"]
                        }
                    });

                    setSummary(result);
                    showToast('Summary generated!', 'success');
                } catch (e) {
                    console.error("Summary failed", e);
                    showToast('Failed to generate summary', 'error');
                } finally {
                    setLoading(false);
                }
            };

            const renderContent = (data) => {
                if (!data) return null;
                return (
                    <div className="space-y-4">
                        <div className="bg-white p-4 rounded-xl border border-slate-200 shadow-sm">
                            <h4 className="font-bold text-slate-800 mb-2">Summary</h4>
                            <p className="text-sm text-slate-600 italic">"{data.oneLineSummary}"</p>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div className="bg-emerald-50 p-4 rounded-xl border border-emerald-100">
                                <h4 className="font-bold text-emerald-800 mb-2 flex items-center gap-2">
                                    <Award size={16} /> Key Achievements
                                </h4>
                                <ul className="list-disc pl-4 text-sm text-emerald-700 space-y-1">
                                    {data.keyAchievements.map((m, i) => <li key={i}>{m}</li>)}
                                </ul>
                            </div>
                            <div className="bg-rose-50 p-4 rounded-xl border border-rose-100">
                                <h4 className="font-bold text-rose-800 mb-2 flex items-center gap-2">
                                    <Target size={16} /> Development Areas
                                </h4>
                                <ul className="list-disc pl-4 text-sm text-rose-700 space-y-1">
                                    {data.developmentAreas.map((m, i) => <li key={i}>{m}</li>)}
                                </ul>
                            </div>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div className="bg-blue-50 p-4 rounded-xl border border-blue-100">
                                <h4 className="font-bold text-blue-800 mb-2 flex items-center gap-2">
                                    <TrendingUp size={16} /> Month-over-Month
                                </h4>
                                <p className="text-sm text-blue-700">{data.monthOverMonth}</p>
                            </div>
                            <div className="bg-violet-50 p-4 rounded-xl border border-violet-100">
                                <h4 className="font-bold text-violet-800 mb-2 flex items-center gap-2">
                                    <Lightbulb size={16} /> Recommendation
                                </h4>
                                <p className="text-sm text-violet-700">{data.recommendation}</p>
                            </div>
                        </div>
                    </div>
                );
            };

            if (!isOpen) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} title=" Performance Summarizer" size="lg">
                    <div className="space-y-6">
                        <div className="bg-slate-50 border border-slate-200 rounded-xl p-4">
                            <p className="text-sm text-slate-600">Generate concise performance summaries based on NPS and QC data.</p>
                        </div>

                        <div className="space-y-4">
                            <div>
                                <label className="block text-xs font-bold text-slate-500 uppercase tracking-wider mb-1">Select Agent</label>
                                <select 
                                    value={agentName} 
                                    onChange={(e) => setAgentName(e.target.value)} 
                                    className="w-full px-4 py-3 bg-white border border-slate-200 rounded-xl text-sm focus:outline-none focus:ring-2 focus:ring-violet-500/20 focus:border-violet-500 transition-all"
                                >
                                    <option value="">Select Agent...</option>
                                    {allAgents.map(a => <option key={a} value={a}>{a}</option>)}
                                </select>
                            </div>

                            <button 
                                onClick={generateSummary} 
                                disabled={loading || !agentName} 
                                className="w-full px-6 py-3 bg-violet-600 hover:bg-violet-700 text-white rounded-xl font-bold transition-all shadow-sm hover:shadow-md disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2"
                            >
                                {loading ? <Loader size={18} className="animate-spin" /> : <FileText size={18} />}
                                {loading ? 'Analyzing Performance...' : 'Generate Summary'}
                            </button>
                        </div>

                        {(summary || loading) && (
                            <AIWrapper
                                data={summary}
                                renderItem={renderContent}
                                onRegenerate={generateSummary}
                                isLoading={loading}
                                title="Performance Summary"
                            />
                        )}
                    </div>
                </Modal>
            );
        };

        const SlackPostGenerator = ({ isOpen, onClose }) => {
            const scenarios = useMemo(() => ([
                {
                    id: 'achievement',
                    label: 'Achievement',
                    fields: [
                        { key: 'name', label: 'Name', placeholder: 'e.g., Alex', required: true },
                        { key: 'achievement', label: 'Achievement', placeholder: 'e.g., Closed 20 complex cases this week', required: true, textarea: true },
                        { key: 'impact', label: 'Impact', placeholder: 'e.g., Improved response times / reduced backlog', textarea: true },
                        { key: 'shoutouts', label: 'Shoutouts (optional)', placeholder: 'e.g., Thanks to Sam and Priya for support', textarea: true }
                    ]
                },
                {
                    id: 'promotion',
                    label: 'Promotion',
                    fields: [
                        { key: 'name', label: 'Name', placeholder: 'e.g., Alex', required: true },
                        { key: 'newRole', label: 'New role', placeholder: 'e.g., Senior Specialist', required: true },
                        { key: 'effectiveDate', label: 'Effective date', placeholder: 'e.g., 15 Feb', required: false },
                        { key: 'highlights', label: 'Highlights', placeholder: 'What did they do exceptionally well?', textarea: true },
                        { key: 'nextSteps', label: 'Next steps (optional)', placeholder: 'e.g., They will support X and mentor Y', textarea: true }
                    ]
                },
                {
                    id: 'moving-out',
                    label: 'Promotion / Moving out of team',
                    fields: [
                        { key: 'name', label: 'Name', placeholder: 'e.g., Alex', required: true },
                        { key: 'newTeamOrRole', label: 'New team or role', placeholder: 'e.g., Payments Ops - Team Lead', required: true },
                        { key: 'lastDay', label: 'Last day (optional)', placeholder: 'e.g., 28 Feb', required: false },
                        { key: 'appreciation', label: 'Appreciation', placeholder: 'What will we miss / key contributions?', required: true, textarea: true }
                    ]
                },
                {
                    id: 'birthday',
                    label: 'Birthday',
                    fields: [
                        { key: 'name', label: 'Name', placeholder: 'e.g., Alex', required: true },
                        { key: 'message', label: 'Message (optional)', placeholder: 'Any personal note you want included?', textarea: true }
                    ]
                },
                {
                    id: 'work-anniversary',
                    label: 'Work anniversary',
                    fields: [
                        { key: 'name', label: 'Name', placeholder: 'e.g., Alex', required: true },
                        { key: 'years', label: 'Years', placeholder: 'e.g., 2', required: true },
                        { key: 'contributions', label: 'Key contributions', placeholder: 'e.g., Mentoring, process improvements, ownership', textarea: true }
                    ]
                },
                {
                    id: 'welcome',
                    label: 'Welcoming a new joiner',
                    fields: [
                        { key: 'name', label: 'Name', placeholder: 'e.g., Alex', required: true },
                        { key: 'role', label: 'Role', placeholder: 'e.g., CX Associate', required: true },
                        { key: 'startDate', label: 'Start date (optional)', placeholder: 'e.g., 12 Feb', required: false },
                        { key: 'background', label: 'Background (optional)', placeholder: 'Anything you want to share about them', textarea: true },
                        { key: 'howToHelp', label: 'How to help them ramp (optional)', placeholder: 'e.g., Please say hi and offer support on X', textarea: true }
                    ]
                },
                {
                    id: 'farewell',
                    label: 'Someone leaving the company',
                    fields: [
                        { key: 'name', label: 'Name', placeholder: 'e.g., Alex', required: true },
                        { key: 'lastDay', label: 'Last day (optional)', placeholder: 'e.g., 28 Feb', required: false },
                        { key: 'nextChapter', label: 'Next chapter (optional)', placeholder: 'Where are they going / whats next?', textarea: true },
                        { key: 'thankYou', label: 'Thank you note', placeholder: 'Key contributions and appreciation', required: true, textarea: true }
                    ]
                },
                {
                    id: 'buddy-session',
                    label: 'Buddy Session Invite',
                    fields: [
                        { key: 'invitee', label: 'Invitee name', placeholder: 'e.g., Alex', required: true },
                        { key: 'topic', label: 'Session topic', placeholder: 'e.g., De-escalation techniques', required: true },
                        { key: 'date', label: 'Date', placeholder: 'e.g., 15 Feb', required: true },
                        { key: 'time', label: 'Time', placeholder: 'e.g., 2:00 PM', required: true },
                        { key: 'duration', label: 'Duration', placeholder: 'e.g., 30 minutes', required: true },
                        { key: 'meetingLink', label: 'Meeting link (optional)', placeholder: 'e.g., Zoom / Meet link', textarea: true },
                        { key: 'notes', label: 'Additional notes (optional)', placeholder: 'e.g., Bring your latest feedback / cases', textarea: true }
                    ]
                },
                {
                    id: 'team-update',
                    label: 'Team update / announcement',
                    fields: [
                        { key: 'headline', label: 'Headline', placeholder: 'e.g., This weeks focus + priorities', required: true },
                        { key: 'context', label: 'Context (optional)', placeholder: 'Whats driving this update?', textarea: true },
                        { key: 'keyPoints', label: 'Key points', placeholder: 'Use bullets or short sentences', required: true, textarea: true },
                        { key: 'actions', label: 'Call to action', placeholder: 'e.g., Please do X by EOD Friday', textarea: true },
                        { key: 'deadline', label: 'Deadline (optional)', placeholder: 'e.g., Friday 5pm', required: false }
                    ]
                },
                {
                    id: 'event-invite',
                    label: 'Team event invite',
                    fields: [
                        { key: 'eventName', label: 'Event name', placeholder: 'e.g., Team huddle / retro / workshop', required: true },
                        { key: 'date', label: 'Date', placeholder: 'e.g., 15 Feb', required: true },
                        { key: 'time', label: 'Time', placeholder: 'e.g., 2:00 PM', required: true },
                        { key: 'duration', label: 'Duration (optional)', placeholder: 'e.g., 45 minutes', required: false },
                        { key: 'agenda', label: 'Agenda (optional)', placeholder: 'What will we cover?', textarea: true },
                        { key: 'meetingLink', label: 'Meeting link (optional)', placeholder: 'e.g., Zoom / Meet link', textarea: true }
                    ]
                },
                {
                    id: 'help-request',
                    label: 'Request help / cover',
                    fields: [
                        { key: 'ask', label: 'What do you need help with?', placeholder: 'e.g., Covering queue X / reviewing docs', required: true, textarea: true },
                        { key: 'when', label: 'When?', placeholder: 'e.g., Today 46pm / This week', required: true },
                        { key: 'why', label: 'Why (optional)', placeholder: 'Short context', textarea: true },
                        { key: 'howToRespond', label: 'How to respond (optional)', placeholder: 'e.g., React with  or DM me', required: false }
                    ]
                }
            ]), []);

            const [scenarioId, setScenarioId] = useState(scenarios[0]?.id || '');
            const [details, setDetails] = useState({});
            const [output, setOutput] = useState(null);
            const [loading, setLoading] = useState(false);

            const scenario = useMemo(() => scenarios.find(s => s.id === scenarioId) || scenarios[0], [scenarioId, scenarios]);

            useEffect(() => {
                if (isOpen) {
                    setDetails({});
                    setOutput(null);
                }
            }, [scenarioId, isOpen]);

            const setField = (key, value) => setDetails(prev => ({ ...prev, [key]: value }));

            const buildDetailsText = () => {
                const lines = (scenario?.fields || []).map(f => {
                    const v = String(details?.[f.key] || '').trim();
                    return v ? `- ${f.label}: ${v}` : null;
                }).filter(Boolean);
                return lines.length ? lines.join('\n') : '- (No details provided)';
            };

            const generate = async () => {
                const required = (scenario?.fields || []).filter(f => f.required);
                const missing = required.filter(f => !String(details?.[f.key] || '').trim());
                if (missing.length) {
                    showToast(`Missing: ${missing.map(m => m.label).join(', ')}`, 'error');
                    return;
                }

                setLoading(true);
                setOutput(null);
                
                try {
                    const result = await AgenticEngine.execute({
                        systemInstruction: AI_PERSONA + "\nYou are an expert Team Lead crafting engaging Slack announcements.",
                        prompt: `Generate a Slack announcement for:
                        SCENARIO: ${scenario?.label || scenarioId}
                        DETAILS:
                        ${buildDetailsText()}
                        
                        Return strict JSON with a catchy headline, markdown body (with emojis), optional call to action, and hashtags.`,
                        schema: {
                            type: "OBJECT",
                            properties: {
                                headline: { type: "STRING" },
                                body: { type: "STRING" },
                                callToAction: { type: "STRING" },
                                hashtags: { type: "ARRAY", items: { type: "STRING" } }
                            },
                            required: ["headline", "body", "hashtags"]
                        }
                    });

                    setOutput(result);
                    showToast('Post generated!', 'success');
                } catch (e) {
                    console.error("Slack Post failed", e);
                    showToast('Failed to generate post', 'error');
                } finally {
                    setLoading(false);
                }
            };

            const renderContent = (data) => {
                if (!data) return null;
                return (
                    <div className="h-full bg-white rounded-xl border border-slate-200 p-6 flex flex-col shadow-sm">
                        <div className="flex justify-between items-start mb-4">
                            <h3 className="font-bold text-slate-900 text-lg">{data.headline}</h3>
                            <button 
                                onClick={() => {
                                    const fullText = `${data.headline}\n\n${data.body}${data.callToAction ? `\n\n ${data.callToAction}` : ''}\n\n${data.hashtags?.join(' ') || ''}`;
                                    safeCopyToClipboard(fullText);
                                    showToast('Post copied to clipboard!');
                                }}
                                className="p-2 text-slate-400 hover:text-indigo-600 hover:bg-indigo-50 rounded-lg transition-colors"
                                title="Copy full post"
                            >
                                <Copy size={18} />
                            </button>
                        </div>
                        <div className="prose prose-sm max-w-none text-slate-600 flex-1 overflow-y-auto mb-4" dangerouslySetInnerHTML={{ __html: safeMarked(data.body) }} />
                        {data.callToAction && (
                            <div className="bg-indigo-50 border border-indigo-100 rounded-lg p-3 mb-4 flex items-center gap-3">
                                <Megaphone size={16} className="text-indigo-600 shrink-0" />
                                <p className="text-sm font-bold text-indigo-900">{data.callToAction}</p>
                            </div>
                        )}
                        {data.hashtags && data.hashtags.length > 0 && (
                            <div className="flex flex-wrap gap-2 pt-4 border-t border-slate-100">
                                {data.hashtags.map((tag, i) => (
                                    <span key={i} className="px-2 py-1 bg-slate-100 text-slate-500 rounded text-xs font-medium">
                                        {tag}
                                    </span>
                                ))}
                            </div>
                        )}
                    </div>
                );
            };

            if (!isOpen) return null;

            return (
                <Modal isOpen={isOpen} onClose={onClose} title=" Slack Post Generator" size="xl">
                    <div className="space-y-6">
                        <div className="bg-slate-50 border border-slate-200 rounded-xl p-4">
                            <p className="text-sm text-slate-700">Pick a scenario, fill required details, then generate a TL-style Slack post.</p>
                        </div>

                        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                            <div className="space-y-4">
                                <div>
                                    <label className="block text-sm font-bold text-slate-700 mb-2">Scenario</label>
                                    <select
                                        value={scenarioId}
                                        onChange={(e) => setScenarioId(e.target.value)}
                                        className="w-full px-4 py-3 border border-slate-200 rounded-xl text-sm bg-white focus:outline-none focus:ring-2 focus:ring-indigo-500/20 focus:border-indigo-500 transition-all"
                                    >
                                        {scenarios.map(s => (
                                            <option key={s.id} value={s.id}>{s.label}</option>
                                        ))}
                                    </select>
                                </div>

                                <div className="space-y-4 max-h-[400px] overflow-y-auto pr-2 custom-scrollbar">
                                    {(scenario?.fields || []).map(f => (
                                        <div key={f.key}>
                                            <label className="block text-sm font-bold text-slate-700 mb-2">
                                                {f.label}{f.required ? ' *' : ''}
                                            </label>
                                            {f.textarea ? (
                                                <textarea
                                                    value={details?.[f.key] || ''}
                                                    onChange={(e) => setField(f.key, e.target.value)}
                                                    placeholder={f.placeholder || ''}
                                                    rows={3}
                                                    className="w-full px-4 py-3 border border-slate-200 rounded-xl text-sm bg-white resize-none focus:outline-none focus:ring-2 focus:ring-indigo-500/20 focus:border-indigo-500 transition-all"
                                                />
                                            ) : (
                                                <input
                                                    type="text"
                                                    value={details?.[f.key] || ''}
                                                    onChange={(e) => setField(f.key, e.target.value)}
                                                    placeholder={f.placeholder || ''}
                                                    className="w-full px-4 py-3 border border-slate-200 rounded-xl text-sm bg-white focus:outline-none focus:ring-2 focus:ring-indigo-500/20 focus:border-indigo-500 transition-all"
                                                />
                                            )}
                                        </div>
                                    ))}
                                </div>

                                <button
                                    onClick={generate}
                                    disabled={loading}
                                    className="w-full px-4 py-3 bg-gradient-to-r from-slate-900 to-slate-700 text-white rounded-xl font-bold flex items-center justify-center gap-2 disabled:opacity-50 hover:shadow-lg transition-all"
                                >
                                    {loading ? <Loader size={18} className="animate-spin" /> : <Sparkles size={18} />}
                                    {loading ? 'Generating...' : (output ? 'Regenerate Post' : 'Generate Post')}
                                </button>
                            </div>

                            <div className="min-h-[420px]">
                                {(output || loading) ? (
                                    <AIWrapper
                                        data={output}
                                        renderItem={renderContent}
                                        onRegenerate={generate}
                                        isLoading={loading}
                                        title="Slack Post Preview"
                                        className="h-full"
                                    />
                                ) : (
                                    <div className="h-full min-h-[420px] border border-dashed border-slate-300 rounded-xl bg-slate-50 flex flex-col items-center justify-center text-sm text-slate-500 gap-3">
                                        <div className="w-12 h-12 rounded-full bg-white border border-slate-200 flex items-center justify-center text-slate-400">
                                            <MessageSquare size={24} />
                                        </div>
                                        <p>Generated post will appear here</p>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                </Modal>
            );
        };

        const NarrativeLogsTable = ({ items, visibleColumns, title, safeCopyToClipboard }) => {
            // Include setQuery and query from hook
            const { data: sorted, toggleSort, setQuery, query, sortKey, direction, setColumnFilter, filters } = useSortableTable(items);

            const hasBulletPoints = (value) => {
                if (!value) return false;
                const text = String(value);
                return /(^|\n)\s*[\u2022]/.test(text) || /(^|\n)\s*-\s+/.test(text) || /(^|\n)\s*\d+\.\s+/.test(text);
            };


            // Fix: Define isVisible helper
            const isVisible = (col) => visibleColumns.includes(col);


            return (
                <div className="flex flex-col gap-4">
                    {/* INTEGRATED SEARCH BAR */}
                    <div className="flex justify-end">
                        <div className="relative">
                            <Search className="absolute left-3 top-2.5 text-slate-500" size={14} />
                            <input
                                type="text"
                                placeholder="Search logs..."
                                onChange={e => setQuery(e.target.value)}
                                className="pl-9 pr-4 py-2 text-xs bg-white border border-slate-200 rounded-lg w-64 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none transition-all shadow-sm"
                            />
                        </div>
                    </div>


                    <div className={`${sorted.length > 30 ? 'overflow-auto max-h-[80vh]' : 'overflow-visible h-auto'} custom-scrollbar`}>
                        <table className="w-full text-xs text-left whitespace-nowrap">
                            <thead className="bg-slate-50 sticky top-0 z-10">
                                <tr className="border-b">
                                    {isVisible('Date') && <th className="p-3 font-bold text-slate-600">Date</th>}
                                    {isVisible('Agent') && <th className="p-3 font-bold text-slate-600">Agent</th>}
                                    {isVisible('UserProblem') && <th className="p-3 font-bold text-slate-600">User Problem</th>}
                                    {isVisible('ChatTag') && <th className="p-3 font-bold text-slate-600">Chat Tag</th>}
                                    {isVisible('LastQueue') && <th className="p-3 font-bold text-slate-600">Last Queue</th>}
                                    {isVisible('Rating') && <th className="p-3 font-bold text-slate-600">Rating</th>}
                                    {isVisible('Country') && <th className="p-3 font-bold text-slate-600">Country</th>}
                                    {isVisible('SubMetric') && <th className="p-3 font-bold text-slate-600">Sub-Metric</th>}
                                    {isVisible('Feedback') && <th className="p-3 font-bold text-slate-600">Feedback</th>}
                                    {title.includes('Incorrect') && isVisible('Reason') && <th className="p-3 font-bold text-slate-600">Reason</th>}
                                </tr>
                            </thead>
                            <tbody className="divide-y divide-slate-100">
                                {sorted.map((r, i) => (
                                    <tr key={i} className="hover:bg-slate-50/80 transition-colors">
                                        {isVisible('Date') && <td className="p-3 text-slate-500 text-center"><HighlightText text={DataEngine.formatDate(r._date)} highlight={query} /></td>}
                                        {isVisible('Agent') && <td className="p-3 font-medium text-slate-700 text-center"><HighlightText text={r._agent} highlight={query} /></td>}
                                        {isVisible('UserProblem') && <td className={`p-3 text-slate-600 max-w-[150px] truncate ${hasBulletPoints(r['User Problem']) ? 'text-left' : 'text-center'}`} title={String(r['User Problem'] || '')}><HighlightText text={String(r['User Problem'] || '')} highlight={query} /></td>}
                                        {isVisible('ChatTag') && <td className={`p-3 text-slate-600 max-w-[150px] truncate ${hasBulletPoints(r['Chat Tag']) ? 'text-left' : 'text-center'}`} title={String(r['Chat Tag'] || '')}><HighlightText text={String(r['Chat Tag'] || '')} highlight={query} /></td>}
                                        {isVisible('LastQueue') && <td className={`p-3 text-slate-600 max-w-[150px] truncate ${hasBulletPoints(r['Last Queue']) ? 'text-left' : 'text-center'}`} title={String(r['Last Queue'] || '')}><HighlightText text={String(r['Last Queue'] || '')} highlight={query} /></td>}
                                        {isVisible('Rating') && <td className="p-3 text-slate-500 text-center"><HighlightText text={String(r.Rating || '')} highlight={query} /></td>}
                                        {isVisible('Country') && <td className="p-3 text-slate-500 text-center"><HighlightText text={String(r.Country || '')} highlight={query} /></td>}
                                        {isVisible('SubMetric') && <td className="p-3 font-bold text-slate-600 text-center"><HighlightText text={r._subMetric} highlight={query} /></td>}
                                        {isVisible('Feedback') && <td className={`p-3 min-w-[200px] text-slate-600 leading-relaxed max-w-[400px] truncate hover:whitespace-normal transition-all ${hasBulletPoints(r.specificFeedback || r._feedback || '') ? 'text-left' : 'text-center'}`}><HighlightText text={String(r.specificFeedback || r._feedback || '')} highlight={query} /></td>}
                                        {title.includes('Incorrect') && isVisible('Reason') && <td className="p-3 text-center"><span className={`px-2 py-1 rounded bg-green-100 text-green-700 font-bold border border-green-200 ${hasBulletPoints(r._reason || '') ? 'text-left' : 'text-center'}`}><HighlightText text={String(r._reason || '')} highlight={query} /></span></td>}
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                </div>
            );
        };


        const PendingTrackerTable = ({ pendingSummary }) => {
            return (
                <div id="pending-tracker-table" className={`${pendingSummary.length > 30 ? 'overflow-auto max-h-[1000px]' : 'overflow-visible h-auto'} custom-scrollbar`}>
                    <table className="w-full text-xs text-left border-collapse">
                        <thead className="bg-slate-50 sticky top-0 z-10">
                            <tr className="border-b border-slate-200">
                                <th className="p-2 font-black text-slate-500 uppercase tracking-widest">Agent</th>
                                <th className="p-2 text-center font-black text-slate-500 uppercase tracking-widest">NPS Tick</th>
                                <th className="p-2 text-center font-black text-slate-500 uppercase tracking-widest">NPS Written</th>
                                <th className="p-2 text-center font-black text-slate-500 uppercase tracking-widest">QC Tick</th>
                                <th className="p-2 text-center font-black text-slate-500 uppercase tracking-widest">QC Written</th>
                                <th className="p-2 text-center font-black text-slate-500 uppercase tracking-widest">Total</th>
                            </tr>
                        </thead>
                        <tbody className="divide-y divide-slate-100 bg-white">
                            {pendingSummary.map((a, i) => (
                                <tr key={i} className="hover:bg-slate-50 transition-colors">
                                    <td className="p-2 font-bold text-slate-700">{a.agent}</td>
                                    <td className="p-2 text-center text-slate-600 font-medium">{a.npsPendingTick}</td>
                                    <td className="p-2 text-center text-slate-600 font-medium">{a.npsPendingWritten}</td>
                                    <td className="p-2 text-center text-slate-600 font-medium">{a.qcPendingTick}</td>
                                    <td className="p-2 text-center text-slate-600 font-medium">{a.qcPendingWritten}</td>
                                    <td className="p-2 text-center">
                                        <span className={`px-3 py-1 rounded-full font-black ${a.totalPending > 0 ? 'bg-rose-100 text-rose-700' : 'bg-green-100 text-green-700'}`}>
                                            {a.totalPending}
                                        </span>
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            );
        };


        const UnifiedRankTable = ({ masterData, handleDrillDown }) => (
            <div id="unified-rank-table" className={`${masterData.length > 30 ? 'overflow-auto max-h-[1000px]' : 'overflow-visible h-auto'} custom-scrollbar w-full`}>
                <table className="w-full min-w-full text-xs text-left border-collapse">
                    <thead className="bg-slate-50 sticky top-0 z-20">
                        <tr className="border-b border-slate-200 text-slate-500">
                            <th className="p-4 border-r border-slate-200 font-black text-slate-500 uppercase tracking-widest">Agent</th>
                            <th className="p-4 border-r border-slate-200 text-center font-black text-slate-500 uppercase tracking-widest">NPS Score</th>
                            <th className="p-4 border-r border-slate-200 text-center font-black text-slate-500 uppercase tracking-widest">QC Score</th>
                            <th className="p-4 border-r border-slate-200 text-center font-black text-slate-500 uppercase tracking-widest">Gap</th>
                            <th className="p-2 text-center font-black text-slate-500 uppercase tracking-widest">Holistic Rank</th>
                        </tr>
                    </thead>
                    <tbody className="divide-y divide-slate-100 bg-white">
                        {masterData.map((ag, i) => (
                            <tr key={i} className="hover:bg-slate-50 transition-colors cursor-pointer" onClick={() => handleDrillDown && handleDrillDown(ag.name)}>
                                <td className="p-4 font-bold text-slate-700 border-r border-slate-100 underline decoration-blue-200 decoration-2 underline-offset-2 hover:text-blue-600 transition-colors">{ag.name}</td>
                                <td className="p-4 text-center font-bold text-slate-700 border-r border-slate-100">{ag.npsScore}% <span className="text-[9px] text-slate-500 font-normal">({ag.npsVol})</span></td>
                                <td className="p-4 text-center font-bold text-slate-700 border-r border-slate-100">{ag.qcScore}% <span className="text-[9px] text-slate-500 font-normal">({ag.qcVol})</span></td>
                                <td className="p-4 text-center font-medium border-r border-slate-100">
                                    <span className={`px-2 py-1 rounded text-[10px] font-black ${ag.gap > 15 ? 'bg-rose-100 text-rose-700' : 'bg-slate-100 text-slate-500'}`}>{ag.gap}% Diff</span>
                                </td>
                                <td className="p-2 text-center">
                                    <div className="flex items-center gap-3">
                                        <div className="flex-1 bg-slate-100 rounded-full h-2 relative overflow-hidden">
                                            <div className="bg-gradient-to-r from-indigo-500 to-indigo-600 h-full rounded-full transition-all duration-1000" style={{ width: `${(typeof ag.holistic === 'number' ? ag.holistic : parseFloat(ag.holistic) || 0)}%` }}></div>
                                        </div>
                                        <span className="text-[10px] font-black text-slate-700 w-8">
                                            {Math.round(typeof ag.holistic === 'number' ? ag.holistic : parseFloat(ag.holistic) || 0)}%
                                        </span>
                                    </div>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        );


        const NPSView = ({ data, onDownloadImage, onAgentSelect, activeTab, setActiveTab, selectedAgentGlobal, setSelectedAgentGlobal, askAI, filters, setFilters }) => {
            const subTab = activeTab || 'Overview';
            const [slackPosts, setSlackPosts] = useState({}); // Lifted state for persistence


            return (
                <div id="nps-view-container" className="space-y-6">


                    {/* Render Content */}
                    <NPSViewContent
                        data={data}
                        onDownloadImage={onDownloadImage}
                        onAgentSelect={onAgentSelect}
                        subTab={subTab}
                        setActiveTab={setActiveTab}
                        slackPosts={slackPosts}
                        setSlackPosts={setSlackPosts}
                        selectedAgentGlobal={selectedAgentGlobal}
                        setSelectedAgentGlobal={setSelectedAgentGlobal}
                        askAI={askAI}
                        filters={filters}
                        setFilters={setFilters}
                    />
                </div>
            );
        };


        // Split content to separate component to keep hooks valid
        const NPSViewContent = ({ data, onDownloadImage, onAgentSelect, subTab, setActiveTab, slackPosts, setSlackPosts, selectedAgentGlobal, setSelectedAgentGlobal, askAI, filters, setFilters }) => {
            const [showValues, setShowValues] = useState(true);
            const [expandedData, setExpandedData] = useState(null);
            const [expandedKey, setExpandedKey] = useState(null);
            const [bulkModalOpen, setBulkModalOpen] = useState(false);


            const spotlightAgent = selectedAgentGlobal;
            const setSpotlightAgent = setSelectedAgentGlobal;

            // Clear selected agent when entering Agent Review to show list view
            useEffect(() => {
                if (subTab === 'Agent Review' && spotlightAgent) {
                    setSpotlightAgent(null);
                }
            }, [subTab]);

            const processedNPS = useMemo(() => {
                return data.map(row => {
                    const mistakes = { Communication: 0, Personalisation: 0, Efficiency: 0, Total: 0 };
                    const failedMetrics = [];


                    Object.entries(NPS_METRIC_MAPPING).forEach(([p, metrics]) => {
                        metrics.forEach(m => {
                            const val = row[m];
                            const isFail = val === false || String(val).toUpperCase() === 'FALSE' || String(val).toUpperCase() === 'NO' || String(val).toUpperCase() === 'FAIL' || val === 0 || val === '0';
                            if (isFail) {
                                mistakes[p]++;
                                mistakes.Total++;
                                failedMetrics.push(m);
                            }
                        });
                    });
                    return { ...row, mistakes, failedMetrics };
                });
            }, [data]);


            const stats = useMemo(() => {
                const total = processedNPS.length;
                if (!total) return { total: 0, passRate: 0, avg: 0, top: [], queues: [], anomalies: [], trendData: [], mistakesCount: 0 };


                const mistakesCount = processedNPS.reduce((acc, curr) => acc + (curr.mistakes?.Total || 0), 0);


                const pass = processedNPS.filter(d => (d.mistakes?.Total || 0) === 0).length;
                const pillarStats = { Communication: 0, Personalisation: 0, Efficiency: 0 };
                const metricStats = {}; Object.values(NPS_METRIC_MAPPING).flat().forEach(m => metricStats[m] = 0);


                processedNPS.forEach(d => {
                    if ((d.mistakes?.Communication || 0) > 0) pillarStats.Communication++;
                    if ((d.mistakes?.Personalisation || 0) > 0) pillarStats.Personalisation++;
                    if ((d.mistakes?.Efficiency || 0) > 0) pillarStats.Efficiency++;
                    d.failedMetrics.forEach(m => metricStats[m]++);
                });


                const queues = {};
                processedNPS.forEach(d => {
                    const q = d['Last Queue'] || 'Untagged';
                    if (!queues[q]) queues[q] = { name: q, total: 0, CommPass: 0, PersPass: 0, EffPass: 0, poorCount: 0, greatOkCount: 0 };
                    queues[q].total++;
                    if ((d.mistakes?.Communication || 0) === 0) queues[q].CommPass++;
                    if ((d.mistakes?.Personalisation || 0) === 0) queues[q].PersPass++;
                    if ((d.mistakes?.Efficiency || 0) === 0) queues[q].EffPass++;
                    if (d.Rating === 'Poor') queues[q].poorCount++;
                    if (d.Rating === 'Ok' || d.Rating === 'Great') queues[q].greatOkCount++; // Combined Great/Ok as requested
                });


                const anomalies = processedNPS.filter(d => {
                    const fails = d.mistakes?.Total || 0;
                    return ((d.Rating === 'Excellent' || d.Rating === '5' || d.Rating === 'WOW') && fails > 2) ||
                        ((d.Rating === 'Poor' || d.Rating === '1') && fails === 0);
                }).slice(0, 8);


                const weekData = {};
                processedNPS.forEach(d => {
                    const date = DataEngine.getRowDate(d);
                    if (date) {
                        const week = DataEngine.getWeekStart(date);
                        if (!weekData[week]) weekData[week] = { n: week, vol: 0, pass: 0 };
                        weekData[week].vol++;
                        if ((d.mistakes?.Total || 0) === 0) weekData[week].pass++;
                    }
                });


                return {
                    total,
                    passRate: ((pass / total) * 100).toFixed(0),
                    avg: (mistakesCount / total).toFixed(1),
                    mistakesCount,
                    pillarStats,
                    metricStats,
                    top: Object.entries(metricStats).sort((a, b) => b[1] - a[1]).slice(0, 5),
                    queues: Object.values(queues),
                    anomalies,


                    ackRate: 85, recoveryRate: 12
                };
            }, [processedNPS]);


            const handleExpand = (content, title) => { setExpandedData({ content, title }); };
            const handleAgentSelection = (agent) => { setSpotlightAgent(agent); if (setActiveTab) setActiveTab('Spotlight'); };


            // CLICK-TO-FILTER HANDLER
            const handleQuickFilter = (data, explicitName = null) => {
                if (!setFilters) return;
                let name = explicitName;


                if (!name && data && data.activePayload && data.activePayload[0]) {
                    name = data.activePayload[0].payload.n;
                }


                if (name) {
                    setFilters(prev => ({ ...prev, 'User Problem': [name] }));
                    showToast(`Filtered by issue: ${name}`, 'success');
                }
            };


            const renderExpandedContent = () => {
                if (!expandedKey || !stats) return null;
                if (expandedKey === 'kpi' && expandedData) {
                    return (
                        <div className="flex flex-col items-center justify-center h-full p-10">
                            <div className="text-[120px] font-black text-slate-900">{expandedData.value}</div>
                            <div className="w-full max-w-2xl mt-8">
                                <AIOutputWrapper
                                    title="Deep Dive"
                                    content="Click Regenerate..."
                                    onRegenerate={async () => {
                                        const resp = await GeminiAI.generate(`Analyze KPI: ${expandedData.title} - ${expandedData.value}`);
                                        showToast("AI analysis updated.", "success");
                                    }}
                                />
                            </div>
                        </div>
                    );
                }
                const handleChartClick = (data) => {
                    if (data && data.activePayload && data.activePayload[0] && setFilters) {
                        const name = data.activePayload[0].payload.n;
                        // Click on Metric -> Filter by 'User Problem'
                        if (expandedKey === 'Top Issues' || NPS_METRIC_MAPPING[expandedKey]) {
                            setFilters(prev => ({ ...prev, 'User Problem': [name] }));
                            showToast(`Filtering by issue: ${name}`);
                        }
                    }
                };


                if (expandedKey === 'Main Impact' && stats.pillarStats) {
                    return (<div className="h-[500px] w-full"><ResponsiveContainer width="100%" height="100%"><BarChart data={Object.entries(stats.pillarStats).map(([n, v]) => ({ n, v, fill: PILLAR_COLORS[n] }))} margin={{ top: 50, bottom: 40, left: 10, right: 10 }}><XAxis dataKey="n" tick={<CustomizedAxisTick />} interval={0} /><YAxis /><Tooltip cursor={{ fill: 'transparent' }} /><Bar dataKey="v" radius={[12, 12, 0, 0]}>{Object.entries(stats.pillarStats).map((e, idx) => (<Cell key={idx} fill={PILLAR_COLORS[e[0]]} />))}{showValues && <LabelList dataKey="v" position="top" style={{ fontSize: 14, fontWeight: 700 }} formatter={(value) => String(value)} offset={5} />}</Bar></BarChart></ResponsiveContainer></div>);
                }
                if (expandedKey === 'Top Issues' && stats.top) {
                    return (<div className="space-y-8 pt-4 p-8">{stats.top.map((i, idx) => (<div key={idx} className="cursor-pointer hover:opacity-80 transition-opacity" onClick={() => handleChartClick({ activePayload: [{ payload: { n: i[0] } }] })}><div className="flex justify-between mb-3"><span className="text-sm font-bold uppercase text-slate-600 tracking-wider">{i[0]}</span><span className="text-sm font-black text-rose-600">{i[1]}</span></div><div className="w-full bg-slate-100 rounded-full h-4"><div className="bg-rose-500 h-4 rounded-full" style={{ width: `${(i[1] / stats.total) * 100}%` }}></div></div></div>))}</div>);
                }
                if (NPS_METRIC_MAPPING[expandedKey] && stats.metricStats) {
                    return (<div className="h-[500px] w-full"><ResponsiveContainer width="100%" height="100%"><BarChart onClick={handleChartClick} data={NPS_METRIC_MAPPING[expandedKey].map(m => ({ n: m, v: stats.metricStats[m] || 0 })).sort((a, b) => b.v - a.v)} margin={{ top: 50, bottom: 150, left: 10, right: 10 }}><XAxis dataKey="n" angle={0} tick={<CustomizedAxisTick />} interval={0} /><YAxis /><Tooltip /><Bar dataKey="v" fill={PILLAR_COLORS[expandedKey]} radius={[8, 8, 0, 0]} className="cursor-pointer hover:opacity-80">{showValues && <LabelList dataKey="v" position="top" style={{ fontSize: 14, fontWeight: 700 }} offset={5} />}</Bar></BarChart></ResponsiveContainer></div>);
                }
                return <div className="text-center py-12 text-slate-500">No content available</div>;
            };
            const modalContent = renderExpandedContent();


            return (
                <div className="space-y-6">
                    {subTab === 'Overview' && stats && (
                        <div className="space-y-8">
                            <div className="grid grid-cols-1 md:grid-cols-4 gap-6 overflow-visible items-start">
                                <MetricCard title="Total Chats" value={stats.total} icon={FileText} color="blue" info="Total number of NPS survey responses processed from the uploaded file." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'Total Chats', value: stats.total, rows: processedNPS }} sparkleType="NPS" askAI={askAI} onExpand={() => setExpandedData({ title: 'Total Chats', content: buildKPIExpand('Total Chats', stats.total) })} />
                                <MetricCard title="Pass Rate" value={`${stats.passRate}%`} icon={CheckCircle} color={stats.passRate < 85 ? 'red' : 'green'} info="Percentage of surveys with ZERO defects across all pillars." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'Pass Rate', value: stats.passRate, rows: processedNPS }} sparkleType="NPS" askAI={askAI} onExpand={() => setExpandedData({ title: 'Pass Rate', content: buildKPIExpand('Pass Rate', stats.passRate) })} />
                                <MetricCard title="Total Failed Sub-metrics" value={stats.mistakesCount} icon={AlertCircle} color="red" info="Total number of failed sub-metrics across all reviews." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'Total Failed Sub-metrics', value: stats.mistakesCount, rows: processedNPS }} sparkleType="NPS" askAI={askAI} onExpand={() => setExpandedData({ title: 'Total Failed Sub-metrics', content: buildKPIExpand('Total Failed Sub-metrics', stats.mistakesCount) })} />
                                <MetricCard title="Average Mistakes" value={stats.avg} icon={TrendingDown} color="amber" info="Average number of mistakes per survey. Calculated as: Total failed sub-metrics / Total surveys. This shows on average how many metrics fail per survey. A value of 0 means perfect surveys, while higher values indicate more issues per survey on average." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'Average Mistakes', value: stats.avg, rows: processedNPS }} sparkleType="NPS" askAI={askAI} onExpand={() => setExpandedData({ title: 'Average Mistakes', content: buildKPIExpand('Average Mistakes', stats.avg) })} />
                            </div>

                            


                            {/* Trend Analysis Removed per user request */}
                            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                                <Card
                                    className="lg:col-span-2"
                                    title="Pillar Impact Analysis"
                                    chartId="pillar-impact"
                                    onExpand={() => setExpandedKey('Main Impact')}
                                    onDownloadImage={onDownloadImage}
                                    infoText="Detailed distribution of defects categorized by the three main pillars: Communication, Personalisation, and Efficiency. Reflects high-level skill gaps."
                                    dataForAI={stats.pillarStats}
                                    askAI={askAI}
                                    showValues={showValues}
                                    toggleValues={() => setShowValues(!showValues)}
                                >
                                    <div className="h-80">
                                        <ResponsiveContainer width="100%" height="100%">
                                            <BarChart data={Object.entries(stats.pillarStats).map(([n, v]) => ({ n, v, fill: PILLAR_COLORS[n] }))} margin={{ top: 20, bottom: 20 }}>
                                                <XAxis dataKey="n" tick={<CustomizedAxisTick />} interval={0} axisLine={false} tickLine={false} />
                                                <YAxis tick={{ fontSize: 12, fontWeight: 700, fill: '#64748b' }} axisLine={false} tickLine={false} />
                                                <Tooltip cursor={{ fill: 'rgba(241, 245, 249, 0.4)' }} contentStyle={{ borderRadius: '12px', border: 'none', boxShadow: '0 10px 15px -3px rgb(0 0 0 / 0.1)' }} />
                                                <Bar dataKey="v" radius={[10, 10, 0, 0]} animationDuration={1500}>
                                                    {Object.entries(stats.pillarStats).map((e, idx) => (<Cell key={idx} fill={PILLAR_COLORS[e[0]]} />))}
                                                    {showValues && <LabelList dataKey="v" position="top" style={{ fontSize: 11, fontWeight: 800, fill: '#475569' }} />}
                                                </Bar>
                                            </BarChart>
                                        </ResponsiveContainer>
                                    </div>
                                </Card>


                                <Card
                                    title="Top 5 Friction Points"
                                    chartId="top-friction"
                                    onExpand={() => setExpandedKey('Top Issues')}
                                    onDownloadImage={onDownloadImage}
                                    onDownloadCSV={() => ExportEngine.exportCSV(stats.top.map(i => ({ Metric: i[0], Count: i[1] })), "top_friction_points")}
                                    onCopyTable={() => copyTableToClipboard(null, stats.top.map(i => ({ Metric: i[0], Count: i[1] })))}
                                    infoText="The specific metrics with the highest failure counts. Use this to focus coaching on high-impact areas."
                                    dataForAI={stats.top}
                                    askAI={askAI}
                                    showValues={showValues}
                                    toggleValues={() => setShowValues(!showValues)}
                                >
                                    <div className="space-y-4 pt-2 px-4">
                                        {stats.top.map((i, idx) => (
                                            <div key={idx} className="group/item">
                                                <div className="flex justify-between mb-1.5">
                                                    <span className="text-[10px] font-black uppercase text-slate-500 tracking-widest">{i[0]}</span>
                                                    <span className="text-[11px] font-black text-rose-600">{i[1]}</span>
                                                </div>
                                                <div className="w-full bg-slate-100 rounded-full h-2 relative overflow-hidden">
                                                    <div
                                                        className="bg-gradient-to-r from-rose-400 to-rose-600 h-full rounded-full transition-all duration-1000"
                                                        style={{ width: `${(i[1] / stats.total) * 100}%` }}
                                                    ></div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </Card>
                            </div>


                            <div className="space-y-10">
                                <Card
                                    title="Communication Pillar Deep Dive"
                                    className="w-full"
                                    chartId="chart-Communication"
                                    onExpand={() => setExpandedKey('Communication')}
                                    onDownloadImage={onDownloadImage}
                                    onDownloadCSV={() => ExportEngine.exportCSV(NPS_METRIC_MAPPING.Communication.map(m => ({ Metric: m, Count: stats.metricStats[m] || 0 })), "nps_communication_stats")}
                                    onCopyTable={() => copyTableToClipboard(null, NPS_METRIC_MAPPING.Communication.map(m => ({ Metric: m, Count: stats.metricStats[m] || 0 })))}
                                    infoText="Detailed breakdown of failures within the Communication pillar. Essential for identifying soft-skill gaps."
                                    dataForAI={stats.metricStats}
                                    askAI={askAI}
                                    showValues={showValues}
                                    toggleValues={() => setShowValues(!showValues)}
                                >
                                    <div className="h-72">
                                        <ResponsiveContainer width="100%" height="100%">
                                            <BarChart onClick={handleQuickFilter} data={NPS_METRIC_MAPPING.Communication.map(m => ({ n: m, v: stats.metricStats[m] || 0 })).sort((a, b) => b.v - a.v)} margin={{ top: 20, bottom: 80, left: 10, right: 10 }}>
                                                <XAxis dataKey="n" interval={0} tick={<CustomizedAxisTick />} axisLine={false} tickLine={false} />
                                                <YAxis tick={{ fontSize: 11, fontWeight: 700, fill: '#94a3b8' }} axisLine={false} tickLine={false} />
                                                <Tooltip cursor={{ fill: 'rgba(241, 245, 249, 0.4)' }} contentStyle={{ borderRadius: '12px', border: 'none', boxShadow: '0 10px 15px -3px rgb(0 0 0 / 0.1)' }} />
                                                <Bar dataKey="v" fill={PILLAR_COLORS.Communication} radius={[8, 8, 0, 0]} className="cursor-pointer" animationDuration={1000}>
                                                    {showValues && <LabelList dataKey="v" position="top" style={{ fontSize: 11, fontWeight: 800, fill: PILLAR_COLORS.Communication }} offset={5} />}
                                                </Bar>
                                            </BarChart>
                                        </ResponsiveContainer>
                                    </div>
                                </Card>


                                <div className="grid grid-cols-1 md:grid-cols-2 gap-8 overflow-visible">
                                    {['Personalisation', 'Efficiency'].map(pillar => (
                                        <Card
                                            key={pillar}
                                            title={`${pillar} Analysis`}
                                            chartId={`chart-${pillar}`}
                                            onExpand={() => setExpandedKey(pillar)}
                                            onDownloadImage={onDownloadImage}
                                            onDownloadCSV={() => ExportEngine.exportCSV(NPS_METRIC_MAPPING[pillar].map(m => ({ Metric: m, Count: stats.metricStats[m] || 0 })), `nps_${pillar.toLowerCase()}_stats`)}
                                            onCopyTable={() => copyTableToClipboard(null, NPS_METRIC_MAPPING[pillar].map(m => ({ Metric: m, Count: stats.metricStats[m] || 0 })))}
                                            infoText={`Specific failures relating to the ${pillar} pillar.`}
                                            dataForAI={NPS_METRIC_MAPPING[pillar]}
                                            askAI={askAI}
                                            showValues={showValues}
                                            toggleValues={() => setShowValues(!showValues)}
                                        >
                                            <div className="h-64">
                                                <ResponsiveContainer width="100%" height="100%">
                                                    <BarChart onClick={handleQuickFilter} data={NPS_METRIC_MAPPING[pillar].map(m => ({ n: m, v: stats.metricStats[m] || 0 })).sort((a, b) => b.v - a.v)} margin={{ top: 20, bottom: 80, left: 10, right: 10 }}>
                                                        <XAxis dataKey="n" interval={0} tick={<CustomizedAxisTick />} axisLine={false} tickLine={false} />
                                                        <YAxis tick={{ fontSize: 11, fontWeight: 700, fill: '#94a3b8' }} axisLine={false} tickLine={false} />
                                                        <Tooltip cursor={{ fill: 'rgba(241, 245, 249, 0.4)' }} />
                                                        <Bar dataKey="v" fill={PILLAR_COLORS[pillar]} radius={[6, 6, 0, 0]} className="cursor-pointer" animationDuration={1000}>
                                                            {showValues && <LabelList dataKey="v" position="top" style={{ fontSize: 11, fontWeight: 800, fill: PILLAR_COLORS[pillar] }} offset={5} />}
                                                        </Bar>
                                                    </BarChart>
                                                </ResponsiveContainer>
                                            </div>
                                        </Card>
                                    ))}
                                </div>
                            </div>

                            <WeeklySummaryGenerator
                                npsData={processedNPS}
                                qcData={[]}
                                onDownloadImage={onDownloadImage}
                                askAI={askAI}
                                mode="nps"
                            />
                        </div>
                    )}


                    {subTab === 'Quiz' && (
                        <QuizModule data={processedNPS} type="NPS" askAI={askAI} />
                    )}


                    {subTab === 'Matrix' && (
                        <>
                            <ErrorBoundary>
                                <MatrixView data={processedNPS} metricsMapping={NPS_METRIC_MAPPING} onDownload={onDownloadImage} onExpand={handleExpand} onAgentSelect={handleAgentSelection} askAI={askAI} />
                            </ErrorBoundary>
                        </>
                    )}


                    {subTab === 'RCA' && (
                        <>
                            <ErrorBoundary>
                                <StrategicRCAView processedData={processedNPS} metricsMapping={NPS_METRIC_MAPPING} onDownload={onDownloadImage} onExpand={handleExpand} queues={stats?.queues} askAI={askAI} />
                            </ErrorBoundary>
                        </>
                    )}


                    {subTab === 'Chats' && (
                        <>
                            <ChatView data={processedNPS} onDownloadImage={onDownloadImage} onExpand={handleExpand} askAI={askAI} />
                        </>
                    )}


                    {subTab === 'Agent Review' && (
                        <>
                            <AgentReviewView data={processedNPS} metricsMapping={NPS_METRIC_MAPPING} onDownload={onDownloadImage} onExpand={handleExpand} askAI={askAI} selectedAgent={selectedAgentGlobal} onSelectAgent={setSelectedAgentGlobal} scope="NPS" />
                        </>
                    )}


                    {subTab === 'Spotlight' && (
                        <>
                            <ErrorBoundary>
                                <SpotlightView
                                    spotlightAgent={spotlightAgent}
                                    filterOptions={{ agent: [...new Set(processedNPS.map(d => d.Agent))].filter(a => a && a.trim() !== '') }}
                                    setSpotlightAgent={setSpotlightAgent}
                                    processedData={processedNPS}
                                    METRIC_MAPPING={NPS_METRIC_MAPPING}
                                    downloadAsImage={onDownloadImage}
                                    setExpandedKey={handleExpand}
                                    type="NPS"
                                    askAI={askAI}
                                    bulkAction={{
                                        onClick: () => setBulkModalOpen(true),
                                        label: 'Bulk Generate'
                                    }}
                                />
                            </ErrorBoundary>
                        </>
                    )}


                    {subTab === 'Feedback Loop' && (
                        <FeedbackLoopTabV2 data={data} type="NPS" onDownloadImage={onDownloadImage} askAI={askAI} />
                    )}


                    <Modal isOpen={!!expandedData} onClose={() => setExpandedData(null)} title={expandedData?.title || 'Detail View'} content={expandedData?.content} onDownloadImage={onDownloadImage} />
                    <Modal isOpen={!!expandedKey} onClose={() => setExpandedKey(null)} title={expandedKey === 'Main Impact' ? 'Pillar Impact Analysis' : (expandedKey === 'Top Issues' ? 'Top 5 Friction Points' : expandedKey)} onDownloadImage={onDownloadImage}>
                        {modalContent || <div className="text-center py-12 text-slate-500">Loading content...</div>}
                    </Modal>


                    <BulkGeneratorModal
                        isOpen={bulkModalOpen}
                        onClose={() => setBulkModalOpen(false)}
                        agents={[...new Set(processedNPS.map(d => d.Agent))].filter(a => a && a.trim() !== '')}
                        onGenerate={async (agent) => {
                            const agentData = processedNPS.filter(r => DataEngine.normalizeAgent(r, 'NPS') === agent);
                            const last3 = agentData.slice(0, 3).map(r => r['Remediation Feedback'] || r['Feedback']).join('\n');


                            const prompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nCreate an NPS COACHING PLAN for agent ${agent}.\nContext:\n${last3}\n\nSTRICT RULES:\n1. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.\n2. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).\n3. NO hashtags (#).\n4. Use emojis sparingly (max 2 per line).\n5. Do NOT use the word "Bold", "Underline", or "B" as text.\n\nStructure:\n1. Empathy Analysis\n2. Communication Style Review\n3. Actionable Coaching Steps\n4. Roleplay Script`;


                            return await GeminiAI.generate(prompt);
                        }}
                        title="Bulk NPS Coaching Generator"
                        type="NPS"
                    />
                </div>
            );
        };


        const FeedbackLoopTabV2 = ({ data, type, onDownloadImage, askAI }) => {
            const [showDataModal, setShowDataModal] = useState(false);
            const [selectedAgentForData, setSelectedAgentForData] = useState(null);
            const [expandedChart, setExpandedChart] = useState(null);
            const [showValues, setShowValues] = useState(true);


            const { LoopData, TeamStats, FeedbackRows } = useMemo(() => {
                const normalized = data.map(d => normalizeCompliance(d, type));
                const agentMap = {};
                const rows = [];


                normalized.forEach((d, i) => {
                    const agent = DataEngine.normalizeAgent(data[i], type) || 'Unknown';
                    // Create rows for Modal
                    if (d.isMandatory) {
                        rows.push({
                            ...data[i],
                            _agent: agent,
                            _isAck: d.isAck,
                            _hasJustification: d.hasJustification,
                            _status: d.status
                        });
                    }


                    if (!agentMap[agent]) agentMap[agent] = { agent: agent, provided: 0, ackTick: 0, ackWritten: 0, pendingTick: 0, pendingWritten: 0, pending: 0, notRequired: 0 };


                    if (!d.isMandatory) {
                        agentMap[agent].notRequired++;
                        return;
                    }


                    agentMap[agent].provided++;
                    if (d.isAck) agentMap[agent].ackTick++; else agentMap[agent].pendingTick++;
                    if (d.hasJustification) agentMap[agent].ackWritten++; else agentMap[agent].pendingWritten++;
                });


                Object.values(agentMap).forEach(a => {
                    a.pending = a.pendingTick + a.pendingWritten;
                });


                const loop = Object.values(agentMap).sort((a, b) => b.pending - a.pending);


                const stats = {
                    provided: loop.reduce((acc, a) => acc + a.provided, 0),
                    ackTick: loop.reduce((acc, a) => acc + a.ackTick, 0),
                    ackWritten: loop.reduce((acc, a) => acc + a.ackWritten, 0),
                    pendingTick: loop.reduce((acc, a) => acc + a.pendingTick, 0),
                    pendingWritten: loop.reduce((acc, a) => acc + a.pendingWritten, 0),
                    pending: loop.reduce((acc, a) => acc + a.pending, 0),
                    notRequired: loop.reduce((acc, a) => acc + a.notRequired, 0)
                };


                const sortedRows = [...rows].sort((a, b) => {
                    const dA = DataEngine.parseDate(a.Date || a['Review Date']);
                    const dB = DataEngine.parseDate(b.Date || b['Review Date']);
                    return (dB || 0) - (dA || 0);
                });


                return { LoopData: loop, TeamStats: stats, FeedbackRows: sortedRows };
            }, [data, type]);


            const generateTeamSlackPost = async () => {
                const prompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nYou are a Team Lead writing an encouraging Slack post for your entire team about feedback acknowledgement.

CRITICAL FORMAT:
1. ** Feedback Acknowledgement Update ** (Title wrapped in star emojis both sides, bold)

2. [Summary - AI Generated encouraging message]
   - "Provided: [X], Pending: [Y]"
   - ENCOURAGING, MOTIVATING tone

3. [Call to Action - AI Generated]
   - Request to complete pending
   - Motivational, team-focused, positive framing
   - Include emoji

STRICT RULES:
- Titles ALWAYS wrapped in star emojis () before and at end, in bold
- ENCOURAGING, MOTIVATING tone throughout
- NO hashtags (#)
- Return ONLY raw text.`;


                try {
                    const result = await GeminiAI.generate(prompt);
                    return result || "No content generated";
                } catch (e) { return "Failed to generate post."; }
            };

            const generateSlackCongratulations = async (query, allData) => {
                const prompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nYou are a Team Lead writing a congratulatory Slack post for a teammate.\n\nUser request: "${query}"\n\nCRITICAL FORMAT:\n1. ** Celebration Time! ** (Title wrapped in star emojis both sides, bold)\n\n2. [Message - AI Generated 3-4 sentences max]\n   - Short and celebratory\n   - Mention specific achievements with **Sub-metric names**\n   - Casual, friendly tone\n   - Include emojis\n\n3. [Closure - NOT a heading]\n   - One line forward-looking with emoji\n\nSTRICT RULES:\n- Titles ALWAYS wrapped in star emojis () before and at end, in bold\n- 3-4 sentences maximum for main message\n- Casual, friendly tone\n- NO hashtags (#)`;

                try {
                    const result = await GeminiAI.generate(prompt);
                    return result || " Congratulations! Amazing work! ";
                } catch (e) { 
                    return " Congratulations! Amazing work! ";
                }
            };


            const filteredRows = useMemo(() => {
                if (!selectedAgentForData) return FeedbackRows;
                return FeedbackRows.filter(r => r._agent === selectedAgentForData);
            }, [FeedbackRows, selectedAgentForData]);


            return (
                <div className="space-y-8">
                    <div className="grid grid-cols-1 md:grid-cols-4 gap-6 overflow-visible items-start">
                        <KPICard title="Mandatory Feedbacks" value={TeamStats.provided} icon={FileText} color="blue" info="Total mandatory feedbacks provided that require acknowledgement." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'Provided', value: TeamStats.provided, rows: filteredRows }} sparkleType={type} askAI={askAI} />
                        <KPICard title="Total Pending (Both)" value={TeamStats.pending} icon={AlertCircle} color="red" info="Sum of feedbacks pending either a tick or written justification." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'Pending', value: TeamStats.pending, rows: filteredRows }} sparkleType={type} askAI={askAI} />
                        <KPICard title="Pending Tick" value={TeamStats.pendingTick} icon={Clock} color="amber" info="Feedbacks where the agent hasn't clicked acknowledge yet." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'Pending Tick', value: TeamStats.pendingTick, rows: filteredRows }} sparkleType={type} askAI={askAI} />
                        <KPICard title="Pending Written" value={TeamStats.pendingWritten} icon={AlertTriangle} color="rose" info="Feedbacks where the agent hasn't provided the required written justification/remediation." onDownloadImage={onDownloadImage} dataForAI={{ stat: 'Pending Written', value: TeamStats.pendingWritten, rows: filteredRows }} sparkleType={type} askAI={askAI} />
                    </div>


                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                        <Card
                            title="Acknowledgement Status"
                            chartId="loop-status-chart"
                            onExpand={() => setExpandedChart('Status')}
                            onDownloadImage={onDownloadImage}
                            onDownloadCSV={() => ExportEngine.exportCSV([
                                { name: 'Complete', value: TeamStats.ackWritten },
                                { name: 'Pending Written', value: TeamStats.pendingWritten },
                                { name: 'Pending Tick', value: TeamStats.pendingTick }
                            ], `${type}_ack_status`)}
                            onCopyTable={() => copyTableToClipboard(null, [
                                { name: 'Complete', value: TeamStats.ackWritten },
                                { name: 'Pending Written', value: TeamStats.pendingWritten },
                                { name: 'Pending Tick', value: TeamStats.pendingTick }
                            ])}
                            infoText="Visual breakdown of the feedback acknowledgement lifecycle. Tracks cases from provided to fully remediated."
                            dataForAI={TeamStats}
                            askAI={askAI}
                            showValues={showValues}
                            toggleValues={() => setShowValues(!showValues)}
                        >
                            <div className="h-72">
                                <ResponsiveContainer width="100%" height="100%">
                                    <PieChart>
                                        <Pie
                                            data={[
                                                { name: 'Complete', value: TeamStats.ackWritten, fill: '#10b981' },
                                                { name: 'Pending Written', value: TeamStats.pendingWritten, fill: '#f59e0b' },
                                                { name: 'Pending Tick', value: TeamStats.pendingTick, fill: '#ef4444' }
                                            ]}
                                            dataKey="value"
                                            cx="50%"
                                            cy="45%"
                                            innerRadius={50}
                                            outerRadius={75}
                                            paddingAngle={8}
                                            stroke="none"
                                            label={({ name, value }) => value > 0 ? value : ''}
                                            labelLine={true}
                                        >
                                            <Cell fill="#10b981" />
                                            <Cell fill="#f59e0b" />
                                            <Cell fill="#ef4444" />
                                        </Pie>
                                        <Tooltip contentStyle={{ borderRadius: '12px', border: 'none', boxShadow: '0 10px 15px -3px rgb(0 0 0 / 0.1)' }} />
                                        <Legend 
                                            verticalAlign="bottom" 
                                            iconType="circle" 
                                            wrapperStyle={{ 
                                                paddingTop: '20px', 
                                                fontSize: '11px', 
                                                fontWeight: 700, 
                                                textTransform: 'uppercase',
                                                whiteSpace: 'normal',
                                                wordBreak: 'break-word'
                                            }} 
                                        />
                                    </PieChart>
                                </ResponsiveContainer>
                            </div>
                        </Card>


                        <Card
                            title="Agent Backlog & Completion"
                            chartId="loop-volume-chart"
                            onExpand={() => setExpandedChart('Volume')}
                            onDownloadImage={onDownloadImage}
                            onDownloadCSV={() => ExportEngine.exportCSV(LoopData.map(a => ({ Agent: a.agent, Complete: a.ackWritten, Pending: a.pending })), `${type}_agent_backlog`)}
                            onCopyTable={() => copyTableToClipboard(null, LoopData.map(a => ({ Agent: a.agent, Complete: a.ackWritten, Pending: a.pending })))}
                            infoText="Workload and compliance volume per agent. Identify agents with high pending counts."
                            dataForAI={LoopData}
                            askAI={askAI}
                            showValues={showValues}
                            toggleValues={() => setShowValues(!showValues)}
                        >
                            <div className="h-64">
                                <ResponsiveContainer width="100%" height="100%">
                                    <BarChart data={LoopData.slice(0, 10)} layout="vertical" margin={{ left: 40, right: 20 }}>
                                        <XAxis type="number" axisLine={false} tickLine={false} tick={{ fontSize: 10, fontWeight: 700, fill: '#94a3b8' }} />
                                        <YAxis 
                                            dataKey="agent" 
                                            type="category" 
                                            axisLine={false} 
                                            tickLine={false} 
                                            tick={(props) => {
                                                const { x, y, payload } = props;
                                                const text = payload.value;
                                                const maxChars = 24;
                                                const words = text.split(' ');
                                                const lines = [];
                                                let currentLine = '';
                                                words.forEach(word => {
                                                    if ((currentLine + word).length <= maxChars) {
                                                        currentLine += (currentLine ? ' ' : '') + word;
                                                    } else {
                                                        if (currentLine) lines.push(currentLine);
                                                        currentLine = word.length > maxChars ? word.substring(0, maxChars) + '...' : word;
                                                    }
                                                });
                                                if (currentLine) lines.push(currentLine);
                                                if (lines.length === 0) lines.push(text);
                                                return (
                                                    <g transform={`translate(${x},${y})`}>
                                                        <title>{text}</title>
                                                        {lines.map((line, i) => (
                                                            <text 
                                                                key={i}
                                                                x={0} 
                                                                y={(i - (lines.length - 1) / 2) * 12} 
                                                                dy={3}
                                                                textAnchor="end" 
                                                                fill="#64748b" 
                                                                fontSize={10} 
                                                                fontWeight={700}
                                                            >
                                                                {line}
                                                            </text>
                                                        ))}
                                                    </g>
                                                );
                                            }}
                                            width={160}
                                        />
                                        <Tooltip 
                                            cursor={{ fill: 'rgba(241, 245, 249, 0.4)' }} 
                                            content={({ active, payload, label }) => {
                                                if (active && payload && payload.length) {
                                                    return (
                                                        <div style={{ 
                                                            backgroundColor: 'white', 
                                                            borderRadius: '12px', 
                                                            border: 'none', 
                                                            boxShadow: '0 10px 15px -3px rgb(0 0 0 / 0.1)',
                                                            padding: '12px',
                                                            maxWidth: '300px',
                                                            wordBreak: 'break-word'
                                                        }}>
                                                            <div style={{ fontWeight: 700, fontSize: '13px', color: '#1e293b', marginBottom: '8px' }}>
                                                                {label}
                                                            </div>
                                                            {payload.map((entry, index) => (
                                                                <div key={index} style={{ 
                                                                    display: 'flex', 
                                                                    alignItems: 'center', 
                                                                    gap: '8px',
                                                                    marginTop: index > 0 ? '6px' : '0'
                                                                }}>
                                                                    <div style={{ 
                                                                        width: '10px', 
                                                                        height: '10px', 
                                                                        borderRadius: '50%', 
                                                                        backgroundColor: entry.color 
                                                                    }} />
                                                                    <span style={{ fontSize: '12px', color: '#64748b' }}>
                                                                        {entry.name}:
                                                                    </span>
                                                                    <span style={{ fontSize: '12px', fontWeight: 700, color: '#1e293b' }}>
                                                                        {entry.value}
                                                                    </span>
                                                                </div>
                                                            ))}
                                                        </div>
                                                    );
                                                }
                                                return null;
                                            }}
                                        />
                                        <Legend 
                                            verticalAlign="top" 
                                            align="right" 
                                            iconType="circle" 
                                            wrapperStyle={{ 
                                                paddingBottom: '20px', 
                                                fontSize: '10px', 
                                                fontWeight: 700,
                                                whiteSpace: 'normal',
                                                wordBreak: 'break-word'
                                            }} 
                                        />
                                        <Bar dataKey="ackWritten" name="Complete" stackId="a" fill="#10b981" radius={[0, 0, 0, 0]} barSize={20}>
                                            <LabelList dataKey="ackWritten" position="inside" fill="white" fontSize={10} fontWeight={700} formatter={(val) => val > 0 ? val : ''} />
                                        </Bar>
                                        <Bar dataKey="pending" name="Total Pending" stackId="a" fill="#ef4444" radius={[0, 4, 4, 0]} barSize={20}>
                                            <LabelList dataKey="pending" position="inside" fill="white" fontSize={10} fontWeight={700} formatter={(val) => val > 0 ? val : ''} />
                                        </Bar>
                                    </BarChart>
                                </ResponsiveContainer>
                            </div>
                        </Card>
                    </div>


                    <AgentFeedbackLoopTable 
                        data={LoopData} 
                        type={type} 
                        onDownloadImage={onDownloadImage}
                        onAgentClick={(agent) => { setSelectedAgentForData(agent); setShowDataModal(true); }}
                        askAI={askAI}
                    />

                    <FeedbackLoopTable data={TeamStats} type={type} onShowData={() => { setSelectedAgentForData(null); setShowDataModal(true); }} showDataButton={true} tableId="feedback-loop-main-table" onDownloadImage={onDownloadImage} dataForAI={TeamStats} aiType={type} infoText="Team-wide feedback compliance summary." askAI={askAI} />




                    <FeedbackDataModal isOpen={showDataModal} onClose={() => { setShowDataModal(false); setSelectedAgentForData(null); }} title={`Feedback Provided Rows${selectedAgentForData ? ` - ${selectedAgentForData}` : ' - All Agents'} (${type})`} rows={filteredRows} type={type} onDownloadImage={onDownloadImage} />
                </div>
            );
        };


        const UnifiedFeedbackLoopTabV2 = ({ combinedData, npsData, qcData, onDownloadImage, askAI }) => {
            const [showDataModal, setShowDataModal] = useState(false);
            const [selectedAgentForData, setSelectedAgentForData] = useState(null);
            const [expandedChart, setExpandedChart] = useState(null);
            const [showValues, setShowValues] = useState(true);
            const [visibleColumns, setVisibleColumns] = useState({
                agent: true,
                nps: true, qc: true, total: true, // Group toggles? No, stick to columns.
                npsProvided: true, npsAckTick: true, npsAckWritten: true, npsPendingTick: true, npsPendingWritten: true,
                qcProvided: true, qcAckTick: true, qcAckWritten: true, qcPendingTick: true, qcPendingWritten: true,
                totalPendingTick: true, totalPendingWritten: true
            });
            const toggleColumn = (key) => setVisibleColumns(prev => ({ ...prev, [key]: !prev[key] }));


            const { npsTotals, qcTotals, combinedTotals } = useMemo(() => {
                const npsT = combinedData.reduce((acc, d) => ({
                    provided: acc.provided + d.npsProvided,
                    ackTick: acc.ackTick + d.npsAckTick,
                    ackWritten: acc.ackWritten + d.npsAckWritten,
                    pendingTick: acc.pendingTick + d.npsPendingTick,
                    pendingWritten: acc.pendingWritten + d.npsPendingWritten,
                    pending: acc.pending + (d.npsPendingTick + d.npsPendingWritten)
                }), { provided: 0, ackTick: 0, ackWritten: 0, pendingTick: 0, pendingWritten: 0, pending: 0 });


                const qcT = combinedData.reduce((acc, d) => ({
                    provided: acc.provided + d.qcProvided,
                    ackTick: acc.ackTick + d.qcAckTick,
                    ackWritten: acc.ackWritten + d.qcAckWritten,
                    pendingTick: acc.pendingTick + d.qcPendingTick,
                    pendingWritten: acc.pendingWritten + d.qcPendingWritten,
                    pending: acc.pending + (d.qcPendingTick + d.qcPendingWritten)
                }), { provided: 0, ackTick: 0, ackWritten: 0, pendingTick: 0, pendingWritten: 0, pending: 0 });


                const combT = {
                    provided: npsT.provided + qcT.provided,
                    ackTick: npsT.ackTick + qcT.ackTick,
                    ackWritten: npsT.ackWritten + qcT.ackWritten,
                    pendingTick: npsT.pendingTick + qcT.pendingTick,
                    pendingWritten: npsT.pendingWritten + qcT.pendingWritten,
                    pending: npsT.pending + qcT.pending
                };
                return { npsTotals: npsT, qcTotals: qcT, combinedTotals: combT };
            }, [combinedData]);


            // Feedback Provided Rows (Detailed Log for Modal)
            const feedbackRows = useMemo(() => {
                let rows = [];
                // Process NPS
                npsData.forEach(d => {
                    const agent = DataEngine.normalizeAgent(d, 'NPS');
                    if (selectedAgentForData && agent !== selectedAgentForData) return;
                    const norm = normalizeCompliance(d, 'NPS');
                    if (norm.isMandatory) {
                        rows.push({
                            ...d,
                            _id: Math.random(),
                            _type: 'NPS',
                            _agent: agent,
                            _dateArg: d.Date || d['Review Date'],
                            _feedback: d['Remediation Feedback'] || d['Feedback'] || d['Comment'] || d['Notes'] || d['Verbatim'] || '',
                            _isAck: norm.isAck,
                            _justification: norm.hasJustification ? (d['Agent Reply'] || '') : '',
                            _status: norm.status
                        });
                    }
                });


                // Process QC
                qcData.forEach(d => {
                    const agent = DataEngine.normalizeAgent(d, 'QC');
                    if (selectedAgentForData && agent !== selectedAgentForData) return;
                    const norm = normalizeCompliance(d, 'QC');
                    if (norm.isMandatory) {
                        rows.push({
                            ...d,
                            _id: Math.random(),
                            _type: 'QC',
                            _agent: agent,
                            _dateArg: d.Date || d['Review Date'],
                            _feedback: d['TL RCA'] || d['Feedback'] || d['Comment'] || d['Notes'] || d['Verbatim'] || '',
                            _isAck: norm.isAck,
                            _justification: norm.hasJustification ? (d['Answer Comment'] || '') : '',
                            _status: norm.status
                        });
                    }
                });


                return [...rows].sort((a, b) => {
                    const dA = DataEngine.parseDate(a._dateArg);
                    const dB = DataEngine.parseDate(b._dateArg);
                    return (dB || 0) - (dA || 0);
                });
            }, [npsData, qcData, selectedAgentForData]);


            return (
                <div className="space-y-6">
                    <FeedbackLoopTable
                        data={combinedTotals}
                        type="Unified"
                        infoText="Total aggregated feedback loop status (NPS + QC). Shows combined counts of provided, acknowledged, and pending feedbacks across all agents."
                        onDownloadImage={onDownloadImage}
                        onShowData={() => { setSelectedAgentForData(null); setShowDataModal(true); }}
                        showDataButton={true}
                        onExpand={() => setExpandedChart('unified-loop-summary')}
                        askAI={askAI}
                    />


                    <Card
                        title="Agent Feedback Breakdown (Combined)"
                        id="unified-loop-table"
                        infoText="Holistic view of feedback acknowledgement status across both NPS and QC domains. Use column filters to toggle visibility."
                        onDownloadImage={onDownloadImage}
                        onDownloadCSV={() => ExportEngine.exportCSV(combinedData.map(d => ({
                            Agent: d.name,
                            NPS_Provided: d.npsProvided, NPS_Tick: d.npsAckTick, NPS_Written: d.npsAckWritten, NPS_Pend: d.npsPendingTick + d.npsPendingWritten,
                            QC_Provided: d.qcProvided, QC_Tick: d.qcAckTick, QC_Written: d.qcAckWritten, QC_Pend: d.qcPendingTick + d.qcPendingWritten,
                            Total_Pending: d.totalPendingTick + d.totalPendingWritten
                        })), "unified_feedback_audit")}
                        onCopyTable={() => copyTableToClipboard("unified-loop-table")}
                        onExpand={() => setExpandedChart('unified-agent-loop')}
                        askAI={askAI}
                        showValues={showValues}
                        toggleValues={() => setShowValues(!showValues)}
                        onColumns={() => { }} // Signals we want the column tool
                        columnFilter={
                            <div className="flex gap-2 items-center">
                                <TableColumnMenu visibleColumns={visibleColumns} toggleColumn={toggleColumn} labels={{
                                    agent: 'Agent',
                                    npsProvided: 'NPS Provided', npsAckTick: 'NPS Tick', npsAckWritten: 'NPS Written', npsPendingTick: 'NPS Pend Tick', npsPendingWritten: 'NPS Pend Written',
                                    qcProvided: 'QC Provided', qcAckTick: 'QC Tick', qcAckWritten: 'QC Written', qcPendingTick: 'QC Pend Tick', qcPendingWritten: 'QC Pend Written',
                                    totalPendingTick: 'Total Pend Tick', totalPendingWritten: 'Total Pend Written'
                                }} />
                                {combinedData.some(d => d.npsProvided > 0 || d.qcProvided > 0) && (
                                    <button onClick={() => { setSelectedAgentForData(null); setShowDataModal(true); }} className="px-3 py-1.5 bg-indigo-600 text-white text-[10px] font-black uppercase tracking-widest rounded-xl hover:bg-indigo-500 transition-all flex items-center gap-2 shadow-lg">
                                        <FileText size={14} /> Full Log
                                    </button>
                                )}
                            </div>
                        }
                        type="Table"
                        rowCount={combinedData.length}
                    >
                        <div className="w-full">
                            <table className="w-full text-xs text-left border-collapse" id="unified-loop-table">
                                <thead className="bg-slate-50 sticky top-0">
                                    <tr className="border-b">
                                        {visibleColumns.agent && <th rowSpan="2" className="p-3 font-bold border-r border-slate-200">Agent</th>}
                                        <th colSpan="5" className="p-3 text-center font-bold text-slate-800 border-r border-slate-200">NPS</th>
                                        <th colSpan="5" className="p-3 text-center font-bold text-slate-800 border-r border-slate-200">QC</th>
                                        <th colSpan="2" className="p-3 text-center font-bold text-slate-800">Total</th>
                                    </tr>
                                    <tr className="border-b">
                                        {visibleColumns.npsProvided && <th className="p-2 text-center font-semibold text-slate-800">Provided</th>}
                                        {visibleColumns.npsAckTick && <th className="p-2 text-center font-semibold text-slate-800">Tick Ack</th>}
                                        {visibleColumns.npsAckWritten && <th className="p-2 text-center font-semibold text-slate-800">Written Ack</th>}
                                        {visibleColumns.npsPendingTick && <th className="p-2 text-center font-semibold text-slate-800">Pending Tick</th>}
                                        {visibleColumns.npsPendingWritten && <th className="p-2 text-center font-semibold text-slate-800 border-r border-slate-200">Pending Written</th>}
                                        {visibleColumns.qcProvided && <th className="p-2 text-center font-semibold text-slate-800">Provided</th>}
                                        {visibleColumns.qcAckTick && <th className="p-2 text-center font-semibold text-slate-800">Tick Ack</th>}
                                        {visibleColumns.qcAckWritten && <th className="p-2 text-center font-semibold text-slate-800">Written Ack</th>}
                                        {visibleColumns.qcPendingTick && <th className="p-2 text-center font-semibold text-slate-800">Pending Tick</th>}
                                        {visibleColumns.qcPendingWritten && <th className="p-2 text-center font-semibold text-slate-800 border-r border-slate-200">Pending Written</th>}
                                        {visibleColumns.totalPendingTick && <th className="p-2 text-center font-semibold text-slate-800">Pending Tick</th>}
                                        {visibleColumns.totalPendingWritten && <th className="p-2 text-center font-semibold text-slate-800">Pending Written</th>}
                                    </tr>
                                </thead>
                                <tbody className="divide-y">
                                    {combinedData.map((d, i) => (<tr key={i} className="hover:bg-slate-50 cursor-pointer transition-colors" onClick={() => { setSelectedAgentForData(d.name); setShowDataModal(true); }}>
                                        {visibleColumns.agent && <td className="p-3 font-medium border-r border-slate-100 text-blue-600 underline decoration-blue-200 decoration-2 underline-offset-2">{d.name}</td>}
                                        {visibleColumns.npsProvided && <td className="p-3 text-center">{d.npsProvided}</td>}
                                        {visibleColumns.npsAckTick && <td className="p-3 text-center font-bold text-green-600">{d.npsAckTick}</td>}
                                        {visibleColumns.npsAckWritten && <td className="p-3 text-center font-bold text-blue-600">{d.npsAckWritten}</td>}
                                        {visibleColumns.npsPendingTick && <td className="p-3 text-center font-bold text-amber-500">{d.npsPendingTick}</td>}
                                        {visibleColumns.npsPendingWritten && <td className="p-3 text-center font-bold text-orange-500 border-r border-slate-100">{d.npsPendingWritten}</td>}
                                        {visibleColumns.qcProvided && <td className="p-3 text-center">{d.qcProvided}</td>}
                                        {visibleColumns.qcAckTick && <td className="p-3 text-center font-bold text-green-600">{d.qcAckTick}</td>}
                                        {visibleColumns.qcAckWritten && <td className="p-3 text-center font-bold text-blue-600">{d.qcAckWritten}</td>}
                                        {visibleColumns.qcPendingTick && <td className="p-3 text-center font-bold text-amber-500">{d.qcPendingTick}</td>}
                                        {visibleColumns.qcPendingWritten && <td className="p-3 text-center font-bold text-orange-500 border-r border-slate-100">{d.qcPendingWritten}</td>}
                                        {visibleColumns.totalPendingTick && <td className={`p-3 text-center font-bold ${d.totalPendingTick > 0 ? 'text-rose-600' : 'text-slate-300'}`}>{d.totalPendingTick}</td>}
                                        {visibleColumns.totalPendingWritten && <td className={`p-3 text-center font-bold ${d.totalPendingWritten > 0 ? 'text-rose-600' : 'text-slate-300'}`}>{d.totalPendingWritten}</td>}
                                    </tr>))}
                                </tbody>
                            </table>
                        </div>
                    </Card>


                    {/* Local Expansion Modal */}
                    <Modal isOpen={!!expandedChart} onClose={() => setExpandedChart(null)} title={expandedChart === 'unified-loop-summary' ? 'Feedback Loop Status' : 'Agent Feedback Breakdown (Combined)'} onDownloadImage={onDownloadImage}>
                        <div className="p-4">
                            {expandedChart === 'unified-loop-summary' && (
                                <FeedbackLoopTable
                                    data={combinedTotals}
                                    type="Unified"
                                    onShowData={() => { setSelectedAgentForData(null); setShowDataModal(true); }}
                                    showDataButton={true}
                                    onDownloadImage={onDownloadImage}
                                    tableId="unified-loop-summary-expanded"
                                />
                            )}
                            {expandedChart === 'unified-agent-loop' && (
                                <div className={`${combinedData.length > 30 ? 'overflow-auto max-h-[1000px]' : 'overflow-visible h-auto'} border border-slate-200 rounded-xl custom-scrollbar`}>
                                    <table className="w-full text-xs text-left border-collapse">
                                        <thead className="bg-slate-50 sticky top-0">
                                            <tr className="border-b">
                                                <th rowSpan="2" className="p-3 font-bold border-r border-slate-200">Agent</th>
                                                <th colSpan="5" className="p-3 text-center font-bold text-slate-800 border-r border-slate-200">NPS</th>
                                                <th colSpan="5" className="p-3 text-center font-bold text-slate-800 border-r border-slate-200">QC</th>
                                                <th colSpan="2" className="p-3 text-center font-bold text-slate-800">Total</th>
                                            </tr>
                                            <tr className="border-b">
                                                <th className="p-2 text-center font-semibold text-slate-800">Provided</th>
                                                <th className="p-2 text-center font-semibold text-slate-800">Tick Ack</th>
                                                <th className="p-2 text-center font-semibold text-slate-800">Written Ack</th>
                                                <th className="p-2 text-center font-semibold text-slate-800">Pending Tick</th>
                                                <th className="p-2 text-center font-semibold text-slate-800 border-r border-slate-200">Pending Written</th>
                                                <th className="p-2 text-center font-semibold text-slate-800">Provided</th>
                                                <th className="p-2 text-center font-semibold text-slate-800">Tick Ack</th>
                                                <th className="p-2 text-center font-semibold text-slate-800">Written Ack</th>
                                                <th className="p-2 text-center font-semibold text-slate-800">Pending Tick</th>
                                                <th className="p-2 text-center font-semibold text-slate-800 border-r border-slate-200">Pending Written</th>
                                                <th className="p-2 text-center font-semibold text-slate-800">Pending Tick</th>
                                                <th className="p-2 text-center font-semibold text-slate-800">Pending Written</th>
                                            </tr>
                                        </thead>
                                        <tbody className="divide-y">
                                            {combinedData.map((d, i) => (<tr key={i} className="hover:bg-slate-50">
                                                <td className="p-3 font-medium border-r border-slate-100 text-slate-700">{d.name}</td>
                                                <td className="p-3 text-center">{d.npsProvided}</td>
                                                <td className="p-3 text-center font-bold text-green-600">{d.npsAckTick}</td>
                                                <td className="p-3 text-center font-bold text-blue-600">{d.npsAckWritten}</td>
                                                <td className="p-3 text-center font-bold text-amber-500">{d.npsPendingTick}</td>
                                                <td className="p-3 text-center font-bold text-orange-500 border-r border-slate-100">{d.npsPendingWritten}</td>
                                                <td className="p-3 text-center">{d.qcProvided}</td>
                                                <td className="p-3 text-center font-bold text-green-600">{d.qcAckTick}</td>
                                                <td className="p-3 text-center font-bold text-blue-600">{d.qcAckWritten}</td>
                                                <td className="p-3 text-center font-bold text-amber-500">{d.qcPendingTick}</td>
                                                <td className="p-3 text-center font-bold text-orange-500 border-r border-slate-100">{d.qcPendingWritten}</td>
                                                <td className={`p-3 text-center font-bold ${d.totalPendingTick > 0 ? 'text-rose-600' : 'text-slate-300'}`}>{d.totalPendingTick}</td>
                                                <td className={`p-3 text-center font-bold ${d.totalPendingWritten > 0 ? 'text-rose-600' : 'text-slate-300'}`}>{d.totalPendingWritten}</td>
                                            </tr>))}
                                        </tbody>
                                    </table>
                                </div>
                            )}
                        </div>
                    </Modal>


                    <Modal isOpen={showDataModal} onClose={() => { setShowDataModal(false); setSelectedAgentForData(null); }} title={`Combined Feedback Rows${selectedAgentForData ? ` - ${selectedAgentForData}` : ' - All Agents'} (Unified)`} onDownloadImage={onDownloadImage}>
                        <div className={`${feedbackRows.length > 30 ? 'overflow-auto max-h-[1000px]' : 'overflow-visible h-auto'} border border-slate-200 rounded-xl custom-scrollbar`}>
                            <table className="w-full text-xs text-left border-collapse">
                                <thead className="bg-slate-50 sticky top-0">
                                    <tr className="border-b">
                                        <th className="p-3 font-bold text-slate-800">Date</th>
                                        {!selectedAgentForData && <th className="p-3 font-bold text-slate-800">Agent</th>}
                                        <th className="p-3 font-bold text-slate-800">Type</th>
                                        <th className="p-3 font-bold text-slate-800">Feedback</th>
                                        <th className="p-3 font-bold text-center text-slate-800">Ack (Tick)</th>
                                        <th className="p-3 font-bold text-slate-800">Written Justification</th>
                                        <th className="p-3 font-bold text-center text-slate-800">Status</th>
                                    </tr>
                                </thead>
                                <tbody className="divide-y">
                                    {feedbackRows.map((row, idx) => (
                                        <tr key={idx} className="hover:bg-slate-50">
                                            <td className="p-3 whitespace-nowrap">{DataEngine.formatDate(row.Date || row['Review Date'])}</td>
                                            {!selectedAgentForData && <td className="p-3 font-medium">{row._agent}</td>}
                                            <td className="p-3"><span className={`px-2 py-0.5 rounded text-[10px] font-bold ${row._type === 'NPS' ? 'bg-blue-100 text-blue-700' : 'bg-amber-100 text-amber-700'}`}>{row._type}</span></td>
                                            <td className="p-3 max-w-xs">{row._feedback}</td>
                                            <td className="p-3 text-center"><StatusBadge status={row._isAck ? 'Yes' : 'No'} /></td>
                                            <td className="p-3 max-w-xs">{row._justification || '-'}</td>
                                            <td className="p-3 text-center"><StatusBadge status={row._status} /></td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </Modal>


                </div>
            );
        };


        // --- HEADLESS REPORT GENERATOR ENGINE (Robust & Context-Aware) ---
        const generateHeadlessReport = async (config, allData, onProgress) => {
            const { agentName, startDate, endDate, context } = config; // context = 'NPS' | 'QC' | 'Unified'


            const updateProgress = (stage, percent) => {
                if (onProgress) onProgress({ stage, percent });
            };


            updateProgress(" Filtering Data...", 10);
            await new Promise(r => setTimeout(r, 300));


            // 1. STRICT DATA FILTERING
            const isDateInRange = (d) => {
                const date = DataEngine.parseDate(d.Date || d['Review Date']);
                if (!date) return false;
                // Normalize to start of day for comparison
                const dTime = new Date(date.setHours(0, 0, 0, 0)).getTime();
                const startTime = startDate ? new Date(startDate.setHours(0, 0, 0, 0)).getTime() : 0;
                const endTime = endDate ? new Date(endDate.setHours(23, 59, 59, 999)).getTime() : Infinity;


                return dTime >= startTime && dTime <= endTime;
            };


            const nps = allData.npsData
                .filter(d => !DataEngine.isAppeal(d) && !DataEngine.isNpsPassAllSubmetrics(d))
                .filter(d =>
                DataEngine.normalizeAgent(d, 'NPS').toLowerCase() === agentName.toLowerCase() && isDateInRange(d)
            );


            const qc = allData.qcData
                .filter(d => !DataEngine.isAppeal(d)) // QC doesn't have NPS submetrics
                .filter(d =>
                DataEngine.normalizeAgent(d, 'QC').toLowerCase() === agentName.toLowerCase() && isDateInRange(d)
            );


            if (context === 'NPS' && nps.length === 0) throw new Error(`No NPS data found for ${agentName} in this period.`);
            if (context === 'QC' && qc.length === 0) throw new Error(`No QC data found for ${agentName} in this period.`);
            if (context === 'Unified' && nps.length === 0 && qc.length === 0) throw new Error(`No data found for ${agentName} in this period.`);


            updateProgress(" Calculating Metrics...", 30);


            // --- METRIC CALCULATORS ---
            const calculateNPSStats = (data) => {
                const total = data.length;
                const mistakes = {};
                data.forEach(r => {
                    Object.values(NPS_METRIC_MAPPING).flat().forEach(m => {
                        if (r[m] === false || String(r[m]).toUpperCase() === 'FALSE') mistakes[m] = (mistakes[m] || 0) + 1;
                    });
                });
                const topFriction = Object.entries(mistakes).sort((a, b) => b[1] - a[1]).slice(0, 5);


                // Weekly History for Anomaly detection
                const weeklyMap = {};
                data.forEach(d => {
                    const week = DataEngine.getWeekStart(d);
                    if (week) weeklyMap[week] = (weeklyMap[week] || 0) + 1;
                });
                const history = Object.entries(weeklyMap).sort((a, b) => a[0].localeCompare(b[0])).map(e => e[1]).slice(-4);


                // Critical Feedbacks (TL Feedbacks)
                const criticalFeedbacks = data
                    .filter(d => d['Remediation Feedback'] || d['Feedback'] || d['Comment'] || d['Notes'] || d['Verbatim'])
                    .map(d => ({ date: d.Date, metric: d._subMetric || 'General', feedback: d['Remediation Feedback'] || d['Feedback'] || d['Comment'] || d['Notes'] || d['Verbatim'] || '' }))
                    .slice(0, 5);


                // Feedback Loop
                const loop = feedbackLoopCalculator(data, 'NPS');


                return { total, mistakes, topFriction, criticalFeedbacks, loop, history };
            };


            const calculateQCStats = (data) => {
                const total = data.length;
                const scoreSum = data.reduce((a, b) => a + (parseFloat(b['QC Score']) || 0), 0);
                const totalScore = scoreSum.toFixed(2);


                // Weekly History for Anomaly detection
                const weeklyMap = {};
                data.forEach(d => {
                    const week = DataEngine.getWeekStart(d);
                    if (week) {
                        if (!weeklyMap[week]) weeklyMap[week] = { sum: 0 };
                        weeklyMap[week].sum += (parseFloat(d['QC Score']) || 0);
                    }
                });
                const history = Object.entries(weeklyMap).sort((a, b) => a[0].localeCompare(b[0])).map(e => e[1].sum).slice(-4);


                // Appeals Logic (Currently, To be, Accepted, Rejected, Pending)
                const appealsData = data.filter(r => {
                    const status = String(r['Appeal Status'] || '').trim();
                    const tlAppeal = r['TL Appeal'] === true || r['TL Appeal'] === 'TRUE';
                    const tlRca = String(r['TL RCA'] || '').trim();
                    const qcScore = parseFloat(r['QC Score']);
                    const isScoreZero = !isNaN(qcScore) && qcScore === 0;
                    
                    if (status) return true; // Has status (To Do, Accept, Reject, Accepted)
                    if (isScoreZero) return true; // Implicit Accepted Appeal
                    if (tlAppeal && (tlRca.startsWith('Appeal') || tlRca.startsWith('Appealed')) && !status) return true; // Pending to be appealed
                    return false;
                });
                const appeals = appealsData.length;
                
                const approved = appealsData.filter(r => {
                    const status = String(r['Appeal Status'] || '').trim();
                    const qcScore = parseFloat(r['QC Score']);
                    const isScoreZero = !isNaN(qcScore) && qcScore === 0;
                    
                    return status === 'Accept Appeal' || status === 'Accepted' || isScoreZero;
                }).length;
                
                const winRate = appeals ? ((approved / appeals) * 100).toFixed(1) : 0;


                // Friction Points
                const mistakes = {};
                data.forEach(r => {
                    const score = parseFloat(r['QC Score']);
                    // Fail if score > 0 (Only 0 is good)
                    const isFail = score > 0 || r['Pass/Fail'] === 'Fail';
                    if (isFail) {
                        const tag = r.calculatedTag || r.Question || 'Unknown';
                        mistakes[tag] = (mistakes[tag] || 0) + 1;
                    }
                });
                const topFriction = Object.entries(mistakes).sort((a, b) => b[1] - a[1]).slice(0, 5);


                // Merged Feedbacks
                const feedbacks = data
                    .filter(d => d['TL RCA'] || d['Answer Comment'])
                    .map(d => ({
                        date: d.Date,
                        question: d.calculatedTag || d.Question,
                        text: `<b>TL:</b> ${d['TL RCA'] || ''}<br/><b>Agent:</b> ${d['Answer Comment'] || ''}`
                    }))
                    .slice(0, 5);


                // Feedback Loop
                const loop = feedbackLoopCalculator(data, 'QC');


                return { total, totalScore, appeals, winRate, topFriction, feedbacks, loop, history };
            };


            // --- HTML TEMPLATES ---
            const generateNPSHTML = (stats, aiSummary = '') => `
            <div class="section-title">NPS Performance Summary</div>
            ${aiSummary ? `<div class="slack-message" style="margin-bottom: 20px; background: #f8fafc; border-left: 4px solid #3b82f6;"><strong>? AI Executive Summary:</strong><br/>${aiSummary}</div>` : ''}
            <div class="kpi-row">
                <div class="kpi-card blue"><div class="label">Audit Count</div><div class="value">${stats.total}</div></div>
                <div class="kpi-card red"><div class="label">Total Failures</div><div class="value">${Object.values(stats.mistakes).reduce((a, b) => a + b, 0)}</div></div>
                <div class="kpi-card green"><div class="label">Ack Rate</div><div class="value">${((stats.loop.ackTick / (stats.loop.provided || 1)) * 100).toFixed(0)}%</div></div>
            </div>


            <div class="section-header"> Top 5 Friction Points</div>
            <table class="data-table">
                <tr><th>Metric</th><th width="20%">Fail Count</th></tr>
                ${stats.topFriction.map(f => `<tr><td>${f[0]}</td><td class="center">${f[1]}</td></tr>`).join('')}
            </table>


            <div class="section-header"> Critical TL Feedbacks</div>
            <div class="feedback-list">
                ${stats.criticalFeedbacks.map(f => `<div class="feedback-item"><div class="meta">${DataEngine.formatDate(f.date)} - ${f.metric}</div><div class="text">${f.feedback}</div></div>`).join('')}
            </div>
            
            <div class="section-header"> Feedback Loop Tracker</div>
            <div class="loop-tracker">
                <div>Provided: <b>${stats.loop.provided}</b></div>
                <div>Acknowledged: <b style="color:green">${stats.loop.ackTick}</b></div>
                <div>Pending: <b style="color:orange">${stats.loop.pending}</b></div>
            </div>


            <div class="section-header"> Detailed NPS Logs</div>
            <table class="data-table">
                <tr><th>Date</th><th>Metric</th><th>Feedback</th></tr>
                ${nps.slice(0, 15).map(d => {
                    const fb = d['Remediation Feedback'] || d['Feedback'] || d['Comment'] || d['Notes'] || d['Verbatim'] || '';
                    return `<tr><td>${DataEngine.formatDate(d.Date)}</td><td>${d._subMetric || '-'}</td><td>${fb.substring(0, 100)}</td></tr>`;
                }).join('')}
            </table>
        `;


            const generateQCHTML = (stats, aiSummary = '') => `
            <div class="section-title">Quality Control (QC) Summary</div>
            ${aiSummary ? `<div class="slack-message" style="margin-bottom: 20px; background: #f8fafc; border-left: 4px solid #8b5cf6;"><strong>? AI Executive Summary:</strong><br/>${aiSummary}</div>` : ''}
            <div class="kpi-row">
                <div class="kpi-card purple"><div class="label">Total Reviews</div><div class="value">${stats.total}</div></div>
                <div class="kpi-card orange"><div class="label">Total Appeals</div><div class="value">${stats.appeals}</div></div>
                <div class="kpi-card green"><div class="label">Win Rate</div><div class="value">${stats.winRate}%</div></div>
            </div>


            <div class="section-header"> Top 5 QC Failures</div>
            <table class="data-table">
                <tr><th>Question</th><th width="20%">Fail Count</th></tr>
                ${stats.topFriction.map(f => `<tr><td>${f[0]}</td><td class="center">${f[1]}</td></tr>`).join('')}
            </table>


            <div class="section-header"> Critical Feedbacks (Merged)</div>
            <div class="feedback-list">
                ${stats.feedbacks.map(f => `<div class="feedback-item"><div class="meta">${DataEngine.formatDate(f.date)} - ${f.question}</div><div class="text">${f.text}</div></div>`).join('')}
            </div>


            <div class="section-header"> Feedback Loop Tracker</div>
            <div class="loop-tracker">
                <div>Provided: <b>${stats.loop.provided}</b></div>
                <div>Acknowledged: <b style="color:green">${stats.loop.ackTick}</b></div>
                <div>Pending: <b style="color:orange">${stats.loop.pending}</b></div>
            </div>


            <div class="section-header"> Detailed QC Logs</div>
            <table class="data-table">
                <tr><th>Date</th><th>Question</th><th>Score</th></tr>
                ${qc.slice(0, 15).map(d => `<tr><td>${DataEngine.formatDate(d.Date)}</td><td>${d.calculatedTag || d.Question || '-'}</td><td class="center">${d['QC Score']}</td></tr>`).join('')}
            </table>
        `;


            // --- MAIN RENDER LOGIC ---
            updateProgress(" Generating Visuals...", 50);


            const reportContainer = document.createElement('div');
            reportContainer.id = 'agent-report-export';
            Object.assign(reportContainer.style, {
                position: 'absolute', top: '-10000px', left: '0', width: '1000px',
                backgroundColor: '#ffffff', fontFamily: 'Inter, sans-serif', padding: '40px', color: '#1e293b'
            });


            const styles = `
            <style>
                .section-title { font-size: 20px; font-weight: 900; color: #0f172a; margin-bottom: 15px; border-bottom: 2px solid #e2e8f0; padding-bottom: 5px; text-transform: uppercase; }
                .section-header { font-size: 14px; font-weight: 700; color: #334155; margin-top: 25px; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px; }
                .kpi-row { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 20px; }
                .kpi-card { padding: 15px; border-radius: 10px; text-align: center; border: 1px solid #e2e8f0; }
                .kpi-card.blue { background: #eff6ff; color: #1d4ed8; }
                .kpi-card.red { background: #fef2f2; color: #b91c1c; }
                .kpi-card.green { background: #f0fdf4; color: #15803d; }
                .kpi-card.purple { background: #faf5ff; color: #7e22ce; }
                .kpi-card.orange { background: #fff7ed; color: #c2410c; }
                .kpi-card .label { font-size: 10px; font-weight: 700; text-transform: uppercase; margin-bottom: 5px; opacity: 0.8; }
                .kpi-card .value { font-size: 24px; font-weight: 900; }
                .data-table { width: 100%; border-collapse: collapse; font-size: 10px; }
                .data-table th { background: #f8fafc; text-align: left; padding: 8px; border-bottom: 2px solid #e2e8f0; font-weight: 700; color: #475569; }
                .data-table td { padding: 8px; border-bottom: 1px solid #f1f5f9; color: #334155; }
                .data-table td.center { text-align: center; font-weight: 700; }
                .feedback-list { display: flex; flex-direction: column; gap: 10px; }
                .feedback-item { background: #f8fafc; border-left: 3px solid #3b82f6; padding: 10px; border-radius: 0 6px 6px 0; }
                .feedback-item .meta { font-size: 9px; font-weight: 700; color: #64748b; margin-bottom: 4px; text-transform: uppercase; }
                .feedback-item .text { font-size: 11px; line-height: 1.4; color: #334155; }
                .loop-tracker { display: flex; gap: 20px; background: #f1f5f9; padding: 10px; border-radius: 6px; font-size: 12px; }
                .slack-message { background: white; border: 1px solid #cbd5e1; border-radius: 10px; padding: 15px; font-family: sans-serif; font-size: 11px; }
                .header-info { display: flex; justify-content: space-between; margin-bottom: 30px; font-size: 11px; font-weight: 600; color: #64748b; border-bottom: 1px solid #e2e8f0; padding-bottom: 10px;}
            </style>
        `;


            // NEW: AI Executive Summary Generation
            updateProgress(" Generating AI Insights...", 45);
            let aiSummary = "";
            const npsStats = (context === 'NPS' || context === 'Unified') ? calculateNPSStats(nps) : null;
            const qcStats = (context === 'QC' || context === 'Unified') ? calculateQCStats(qc) : null;

            try {
                const summaryPrompt = `
                    Analyze these performance metrics for ${agentName} (${context}):
                    ${npsStats ? 'NPS Stats: ' + JSON.stringify({ total: npsStats.total, mistakes: npsStats.mistakes }) : ''}
                    ${qcStats ? 'QC Stats: ' + JSON.stringify({ total: qcStats.total, score: qcStats.totalScore, winRate: qcStats.winRate }) : ''}
                    
                    Write a 3-4 sentence Executive Summary. Highlights key strengths and 1 major focus area.
                    Format: HTML paragraph <p>...</p>. No Markdown.
                `;
                aiSummary = await AIRequestManager.generate(summaryPrompt, "Output HTML only. No Markdown.", { temperature: 0.5 });
            } catch (e) { aiSummary = ""; }

            let contentHTML = '';
            if (context === 'NPS') contentHTML = generateNPSHTML(npsStats, aiSummary);
            else if (context === 'QC') contentHTML = generateQCHTML(qcStats, aiSummary);
            else contentHTML = generateNPSHTML(npsStats, aiSummary) + '<div style="height: 30px;"></div>' + generateQCHTML(qcStats, aiSummary);


            reportContainer.innerHTML = `
            ${styles}
            <div class="header-info">
                <div>REPORT FOR: ${agentName}</div>
                <div>PERIOD: ${startDate ? startDate.toLocaleDateString() : 'ALL TIME'} - ${endDate ? endDate.toLocaleDateString() : 'NOW'}</div>
            </div>
            ${contentHTML}
            
            <div class="section-header"> Generated Slack Message</div>
            <div class="slack-message" id="ai-slack-msg">Generating message...</div>
        `;


            document.body.appendChild(reportContainer);


            updateProgress(" Drafting Slack Message...", 70);


            // 4. GENERATE RICH TEXT SLACK MESSAGE
            try {
                const prompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nWrite a specific, data-backed Slack message for ${agentName} based on this report (${context}).\nPeriod: ${startDate ? startDate.toLocaleDateString() : 'All Time'}.\n\nSTRICT RULES:\n1. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.\n2. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).\n3. NO hashtags (#).\n4. Use emojis sparingly (max 2 per line).\n5. Do NOT use the word "Bold", "Underline", or "B" as text.\n6. Tone: Professional, Coaching, Direct.\n7. Include specific numbers from the report.`;


                const slackMsg = await AIRequestManager.generate(prompt);
                const box = reportContainer.querySelector('#ai-slack-msg');
                if (box) box.innerHTML = safeMarked(slackMsg);
            } catch (e) {
                const box = reportContainer.querySelector('#ai-slack-msg');
                if (box) box.innerText = "Message generation failed.";
            }


            updateProgress(" Capturing PDF...", 90);
            await new Promise(r => setTimeout(r, 500));


            // 5. CAPTURE & DOWNLOAD
            try {
                await ExportEngine.exportToPDFSmart('agent-report-export', `${agentName}_${context}_Report`, { sectionSelector: '.section-title, .section-header, .kpi-row, .feedback-list, .loop-tracker, table' });
            } catch (err) {
                console.error(err);
                throw new Error("PDF Generation Failed");
            } finally {
                document.body.removeChild(reportContainer);
            }


            updateProgress("? Done!", 100);
            return true;
        };


        // --- UTILS: FUZZY MATCHING & ENTITY RESOLUTION ---
        const levenshteinDistance = (a, b) => {
            if (!a || !b) return (a || '').length + (b || '').length;
            const matrix = [];
            for (let i = 0; i <= b.length; i++) matrix[i] = [i];
            for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) matrix[i][j] = matrix[i - 1][j - 1];
                    else matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));
                }
            }
            return matrix[b.length][a.length];
        };


        const findClosestMatch = (query, choices) => {
            if (!choices || choices.length === 0 || !query) return [];
            // 1. Exact/Substring match (High Priority)
            const direct = choices.filter(c => c.toLowerCase().includes(query.toLowerCase()));
            if (direct.length > 0) return direct.slice(0, 5); // Return top 5 substring matches


            // 2. Levenshtein Distance (Fuzzy Fallback)
            const rated = choices.map(c => ({
                value: c,
                score: levenshteinDistance(query.toLowerCase(), c.toLowerCase())
            }));
            // Sort by lowest distance (closest match) and take top 5
            return rated.sort((a, b) => a.score - b.score).slice(0, 5).map(r => r.value);
        };


        // --- NEW UTILS FOR ISSUE #4 ---


        // 1. Smart Search Highlighter (Robust Version)
        const HighlightText = ({ text, highlight }) => {
            if (!highlight || !String(text).trim()) return <span>{text}</span>;


            // Escape regex characters to prevent crashes with symbols like ?, *, (
            const escapeRegExp = (string) => string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');


            try {
                const pattern = new RegExp(`(${escapeRegExp(highlight)})`, 'gi');
                const parts = String(text).split(pattern);


                return (
                    <span>
                        {parts.map((part, i) =>
                            part.toLowerCase() === highlight.toLowerCase() ?
                                <span key={i} className="bg-yellow-300 text-slate-900 font-bold px-0.5 rounded-sm shadow-sm border border-yellow-400/30">{part}</span> :
                                part
                        )}
                    </span>
                );
            } catch (e) {
                return <span>{text}</span>;
            }
        };




        // 3. Data Health Logic
        const calculateDataHealth = (data, type) => {
            try {
                if (!data || data.length === 0) return { state: 'loading', msg: 'Waiting for data...', score: 0, issues: [] };
                let issues = [];
                let critical = false;
                let score = 100;
                const sample = data[0];
                const keys = Object.keys(sample);
                const isNps = String(type).toUpperCase() === 'NPS';
                const requiredAliases = isNps ? [['Date', 'Review Date'], ['Agent', 'Agent Email'], ['Rating']] : [['Date', 'Review Date'], ['Agent Email', 'Agent'], ['QC Score', 'numericScore']];
                requiredAliases.forEach((aliases) => {
                    const present = keys.some(k => aliases.some(a => k.trim().toLowerCase() === a.toLowerCase() || k.includes(a)));
                    if (!present) {
                        issues.push(`Missing '${aliases[0]}' column.`);
                        critical = true;
                        score -= 20;
                    }
                });
                const invalidDates = data.filter(r => !DataEngine.parseDate(r.Date || r['Review Date'])).length;
                if (invalidDates > 0) {
                    const pct = (invalidDates / data.length) * 100;
                    score -= pct;
                    if (pct > 10) {
                        issues.push(`Critical: ${invalidDates} rows have invalid dates.`);
                        critical = true;
                    } else {
                        issues.push(`Warning: ${invalidDates} rows have invalid dates.`);
                    }
                }
                if (!isNps) {
                    let invalidScores = 0;
                    data.forEach(r => {
                        const raw = r['QC Score'] ?? r.numericScore;
                        const val = parseFloat(raw);
                        if (isNaN(val)) invalidScores++;
                        else if (val < 0) invalidScores++;
                        else if (val > 100) invalidScores++;
                    });
                    if (invalidScores > 0) {
                        issues.push(`Warning: ${invalidScores} rows have invalid QC Scores.`);
                        score -= (invalidScores / data.length) * 50;
                    }
                } else {
                    let invalidRatings = 0;
                    data.forEach(r => {
                        const rating = r.Rating;
                        const cat = DataEngine.getRatingCat(rating);
                        if (cat === 'Unknown') invalidRatings++;
                    });
                    if (invalidRatings > 0) {
                        issues.push(`Warning: ${invalidRatings} rows have invalid ratings.`);
                        score -= (invalidRatings / data.length) * 30;
                    }
                }
                const missingAgents = data.filter(r => !DataEngine.normalizeAgent(r, isNps ? 'NPS' : 'QC')).length;
                if (missingAgents > 0) {
                    issues.push(`Warning: ${missingAgents} rows missing agent identifiers.`);
                    score -= Math.min(20, (missingAgents / data.length) * 40);
                }
                let commentCount = 0;
                if (isNps) {
                    commentCount = data.filter(r => 
                        (r['Remediation Feedback'] && String(r['Remediation Feedback']).trim()) || 
                        (r['Feedback'] && String(r['Feedback']).trim()) ||
                        (r['Comment'] && String(r['Comment']).trim()) ||
                        (r['Notes'] && String(r['Notes']).trim()) ||
                        (r['Verbatim'] && String(r['Verbatim']).trim())
                    ).length;
                } else {
                    commentCount = data.filter(r => (r['TL RCA'] && String(r['TL RCA']).trim()) || (r['Answer Comment'] && String(r['Answer Comment']).trim())).length;
                }
                const commentRatio = commentCount / data.length;
                if (commentRatio < 0.3) {
                    issues.push(`Warning: Low comment density (${Math.round(commentRatio * 100)}%).`);
                    score -= (0.3 - commentRatio) * 50;
                }
                score = Math.max(0, Math.round(score));
                let state = 'green';
                let msg = `All ${isNps ? 'NPS' : 'QC'} data columns and formats look healthy.`;
                if (critical || score < 60) { state = 'red'; msg = `Critical Data Issues: ${issues.join(' ')}`; }
                else if (issues.length > 0 || score < 90) { state = 'yellow'; msg = `Data Warnings: ${issues.join(' ')}`; }
                return { state, msg, score, issues };
            } catch (error) {
                console.error(`[DataEngine] Data Health calculation failed for ${type}:`, error);
                return { state: 'red', msg: 'Data health calculation failed due to an internal error.', score: 0, issues: ['Internal Error'] };
            }
        };


        const DataHealthIndicator = ({ npsHealth, qcHealth }) => {
            const [show, setShow] = useState(false);
            const score = Math.round(((npsHealth?.score || 100) + (qcHealth?.score || 100)) / 2);
            const state = score >= 90 ? 'green' : (score >= 60 ? 'yellow' : 'red');
            const Icon = state === 'green' ? CheckCircle : (state === 'yellow' ? AlertTriangle : AlertCircle);
            const color = state === 'green' ? 'text-emerald-600' : (state === 'yellow' ? 'text-amber-600' : 'text-rose-600');
            const bg = state === 'green' ? 'bg-emerald-50' : (state === 'yellow' ? 'bg-amber-50' : 'bg-rose-50');


            return (
                <div className="relative" onMouseEnter={() => setShow(true)} onMouseLeave={() => setShow(false)}>
                    <button className={`p-2.5 ${bg} ${color} rounded-lg transition-all active:scale-95 flex items-center gap-2 group border border-transparent hover:border-current/10`}>
                        <Icon size={18} className="group-hover:scale-110 transition-transform" />
                        <span className="text-[10px] font-black uppercase tracking-wider">{score}% Health</span>
                    </button>
                    {show && (
                        <div className="absolute right-0 top-full mt-2 w-64 bg-white border border-slate-200 shadow-2xl rounded-xl p-3 z-[100] origin-top-right">
                            <h4 className="text-[9px] font-black uppercase text-slate-500 mb-3 tracking-widest border-b border-slate-50 pb-1.5">Technical Health Status</h4>
                            <div className="space-y-4">
                                <HealthDetailRow label="NPS Feedback" health={npsHealth} />
                                <HealthDetailRow label="Quality Control" health={qcHealth} />
                            </div>
                            <div className="mt-4 pt-3 border-t border-slate-50 text-[8px] text-slate-300 leading-tight italic">
                                * Reliability is calculated based on schema compliance, comment density, and rating consistency.
                            </div>
                        </div>
                    )}
                </div>
            );
        };


        const HealthDetailRow = ({ label, health }) => {
            if (!health) return null;
            const state = health.state || (health.score >= 90 ? 'green' : (health.score >= 60 ? 'yellow' : 'red'));
            const colors = { green: 'text-emerald-600', yellow: 'text-amber-600', red: 'text-rose-600' };
            const bars = { green: 'bg-emerald-500', yellow: 'bg-amber-500', red: 'bg-rose-500' };
            const Icon = state === 'green' ? CheckCircle : (state === 'yellow' ? AlertTriangle : AlertCircle);
            return (
                <div className="space-y-1.5">
                    <div className="flex justify-between items-center text-[9px] font-black">
                        <span className="text-slate-800 flex items-center gap-1.5"><Icon size={10} className={colors[state]} /> {label}</span>
                        <span className={colors[state]}>{health.score}%</span>
                    </div>
                    <p className="text-[8px] text-slate-500 leading-tight">{health.msg}</p>
                    <div className="w-full bg-slate-100 h-1.5 rounded-full overflow-hidden">
                        <div className={`h-full ${bars[state]} transition-all duration-700`} style={{ width: `${health.score}%` }}></div>
                    </div>
                </div>
            );
        };


        // --- REPEAT OFFENDER DEEP DIVE (Analytical View #5) ---


        // --- PEER MATCHING ENGINE (New Feature) ---



        // --- REPEAT OFFENDER DEEPER DIVE (Analytical View #5 - REDESIGNED) ---



        // ExportPreviewView Removed


        // --- INSIGHT RELIABILITY DASHBOARD (Analytical View #9) ---


        // --- GOD-TIER AI WRAPPER (Universal State Container) ---
        const BulkResultWrapper = ({ result, isGenerating, onUpdate, onRegenerate }) => {
            const [versions, setVersions] = React.useState(result?.versions || []);
            const [activeVersionIndex, setActiveVersionIndex] = React.useState(result?.currentVersionIndex || 0);

            React.useEffect(() => {
                if (result) {
                    setVersions(result.versions || []);
                    setActiveVersionIndex(result.currentVersionIndex || 0);
                }
            }, [result]);

            const currentContent = versions[activeVersionIndex]?.content;

            const handleRegenerate = async () => {
                if (onRegenerate) {
                    await onRegenerate();
                }
            };

            if (!result) return null;

            return (
                <div className="bg-white rounded-xl border border-slate-200 shadow-sm overflow-hidden mb-6">
                    <div className="bg-slate-50 border-b border-slate-200 p-3 flex justify-between items-center">
                        <div className="flex items-center gap-2">
                             <span className="bg-violet-100 text-violet-700 p-1.5 rounded-lg"><Sparkles size={14}/></span>
                             <span className="font-bold text-slate-700 text-sm">{result.agent}</span>
                        </div>
                        <div className="flex items-center gap-2">
                             {versions.length > 1 && (
                                <div className="flex items-center gap-1 mr-2 text-xs text-slate-500">
                                    <button disabled={activeVersionIndex===0} onClick={() => setActiveVersionIndex(v=>Math.max(0, v-1))} className="hover:text-violet-600"><ChevronLeft size={14}/></button>
                                    <span>v{activeVersionIndex+1}/{versions.length}</span>
                                    <button disabled={activeVersionIndex===versions.length-1} onClick={() => setActiveVersionIndex(v=>Math.min(versions.length-1, v+1))} className="hover:text-violet-600"><ChevronRight size={14}/></button>
                                </div>
                             )}
                             <button onClick={() => safeCopyToClipboard(currentContent)} className="text-xs flex items-center gap-1 bg-white border border-slate-200 px-2 py-1 rounded hover:bg-slate-50 transition-all active:scale-95"><Copy size={12}/> Copy</button>
                             {onRegenerate && <button onClick={handleRegenerate} className="text-xs flex items-center gap-1 bg-violet-50 text-violet-700 border border-violet-200 px-2 py-1 rounded hover:bg-violet-100 transition-all active:scale-95"><RefreshCw size={12}/> Regenerate</button>}
                        </div>
                    </div>
                    <div className="p-4 prose prose-sm max-w-none relative">
                        {isGenerating ? (
                             <div className="animate-pulse flex flex-col items-center justify-center py-8">
                                <Loader2 className="animate-spin text-violet-600 mb-2" size={24}/>
                                <span className="text-xs text-slate-500 font-bold">Generating Report...</span>
                             </div>
                        ) : (
                            <div dangerouslySetInnerHTML={{ __html: MarkdownRenderer.render(currentContent || '') }} />
                        )}
                    </div>
                </div>
            );
        };

        const AIWrapper = ({ 
            data, 
            isPaginated = false, 
            renderItem, 
            onRegenerate, 
            isLoading = false, 
            title = "AI Analysis" 
        }) => {
            const [currentIndex, setCurrentIndex] = useState(0);
            const [versions, setVersions] = useState([]);
            const [activeVersionIndex, setActiveVersionIndex] = useState(0);
            const [isRegenerating, setIsRegenerating] = useState(false);
            const [localLoading, setLocalLoading] = useState(false);
            const contentRef = React.useRef(null);

            // Normalize data to array for consistency
            const dataArray = useMemo(() => {
                if (!data) return [];
                return Array.isArray(data) ? data : [data];
            }, [data]);

            // When data changes, push it as a new version
            useEffect(() => {
                if (data) {
                    setVersions(prev => {
                        if (prev.length === 0) return [data];
                        // Avoid duplicates if same reference
                        if (prev[prev.length - 1] === data) return prev;
                        return [...prev, data];
                    });
                }
            }, [data]);

            // Sync active version index
            useEffect(() => {
                if (versions.length > 0) {
                    setActiveVersionIndex(versions.length - 1);
                }
            }, [versions.length]);

            const handleRegenerate = async () => {
                if (!onRegenerate) return;
                setIsRegenerating(true);
                setLocalLoading(true);
                try {
                    const newData = await onRegenerate(isPaginated ? currentIndex : undefined);
                    if (newData) {
                        setVersions(prev => [...prev, newData]);
                        showToast('Regenerated successfully!', 'success');
                    }
                } catch (e) {
                    console.error("Regeneration failed", e);
                    showToast('Regeneration failed', 'error');
                } finally {
                    setIsRegenerating(false);
                    setLocalLoading(false);
                }
            };
            
            const handleCopy = () => {
                if (contentRef.current) {
                    const text = contentRef.current.innerText;
                    const html = contentRef.current.innerHTML;
                    safeCopyToClipboard(text, html);
                    return;
                }

                const currentData = versions[activeVersionIndex];
                if (!currentData) return;
                
                const contentToCopy = isPaginated 
                    ? (Array.isArray(currentData) ? currentData[currentIndex] : currentData)
                    : currentData;
                
                const text = typeof contentToCopy === 'string' 
                    ? contentToCopy 
                    : JSON.stringify(contentToCopy, null, 2);
                
                ClipboardUtils.copy(text);
                showToast('Copied raw data to clipboard', 'info');
            };

            const currentData = versions[activeVersionIndex];
            const displayData = isPaginated && Array.isArray(currentData) 
                ? currentData[currentIndex] 
                : currentData;

            if (isLoading || localLoading || isRegenerating) {
                return (
                    <div className="bg-white rounded-xl border border-slate-200 shadow-sm p-8 animate-pulse">
                        <div className="flex flex-col items-center justify-center py-12 gap-4">
                            <Loader2 className="animate-spin text-violet-600" size={32} />
                            <p className="text-sm font-bold text-slate-600">Generating Intelligence...</p>
                        </div>
                    </div>
                );
            }

            if (!versions.length && !data) return null;

            return (
                <div className="ai-wrapper bg-white rounded-xl border border-slate-200 shadow-sm overflow-hidden mb-6 transition-all">
                    {/* UNIVERSAL HEADER */}
                    <div className="bg-slate-50 border-b border-slate-200 p-4 flex justify-between items-center">
                        <div className="flex items-center gap-3">
                            <Sparkles size={16} className="text-violet-600" />
                            <span className="font-bold text-slate-700 text-sm">{title}</span>
                            {versions.length > 1 && (
                                <div className="flex items-center gap-1 bg-white border border-slate-200 rounded-lg px-2 py-1 ml-2">
                                    <button 
                                        onClick={() => setActiveVersionIndex(Math.max(0, activeVersionIndex - 1))}
                                        disabled={activeVersionIndex === 0}
                                        className="p-1 hover:bg-slate-100 rounded disabled:opacity-30"
                                    >
                                        <ChevronLeft size={12} />
                                    </button>
                                    <span className="text-[10px] font-bold text-slate-500 uppercase">
                                        v{activeVersionIndex + 1} of {versions.length}
                                    </span>
                                    <button 
                                        onClick={() => setActiveVersionIndex(Math.min(versions.length - 1, activeVersionIndex + 1))}
                                        disabled={activeVersionIndex === versions.length - 1}
                                        className="p-1 hover:bg-slate-100 rounded disabled:opacity-30"
                                    >
                                        <ChevronRight size={12} />
                                    </button>
                                </div>
                            )}
                        </div>
                        <div className="flex items-center gap-2">
                            <button 
                                onClick={handleCopy}
                                className="p-2 text-slate-400 hover:text-indigo-600 hover:bg-indigo-50 rounded-lg transition-colors"
                                title="Copy to Clipboard"
                            >
                                <Copy size={16} />
                            </button>
                            {onRegenerate && (
                                <button 
                                    onClick={handleRegenerate}
                                    className="p-2 text-slate-400 hover:text-violet-600 hover:bg-violet-50 rounded-lg transition-colors"
                                    title="Regenerate Analysis"
                                >
                                    <RefreshCw size={16} className={isRegenerating ? "animate-spin" : ""} />
                                </button>
                            )}
                        </div>
                    </div>

                    {/* BODY */}
                    <div className="p-0" ref={contentRef}>
                        {renderItem ? renderItem(displayData) : (
                            <div className="markdown-content p-6 text-sm text-slate-700">
                                <div dangerouslySetInnerHTML={{ __html: MarkdownRenderer.render(typeof displayData === 'string' ? displayData : JSON.stringify(displayData)) }} />
                            </div>
                        )}
                    </div>

                    {/* FOOTER (Pagination) */}
                    {isPaginated && Array.isArray(currentData) && currentData.length > 1 && (
                        <div className="bg-slate-50 border-t border-slate-200 p-3 flex justify-between items-center">
                            <button 
                                onClick={() => setCurrentIndex(Math.max(0, currentIndex - 1))}
                                disabled={currentIndex === 0}
                                className="px-3 py-1.5 text-xs font-bold text-slate-600 bg-white border border-slate-200 rounded-lg hover:bg-slate-100 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-1"
                            >
                                <ChevronLeft size={12} /> Previous
                            </button>
                            
                            <span className="text-xs font-bold text-slate-500">
                                Item {currentIndex + 1} of {currentData.length}
                            </span>
                            
                            <button 
                                onClick={() => setCurrentIndex(Math.min(currentData.length - 1, currentIndex + 1))}
                                disabled={currentIndex === currentData.length - 1}
                                className="px-3 py-1.5 text-xs font-bold text-slate-600 bg-white border border-slate-200 rounded-lg hover:bg-slate-100 disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-1"
                            >
                                Next <ChevronRight size={12} />
                            </button>
                        </div>
                    )}
                </div>
            );
        };

        // --- Pagination Controls Component ---
        const PaginationControls = ({ currentPage, totalPages, onPageChange, generatingPage }) => {
            const getPageNumbers = () => {
                const pages = [];
                const maxVisible = 5;
                
                if (totalPages <= maxVisible) {
                    for (let i = 0; i < totalPages; i++) pages.push(i);
                } else {
                    if (currentPage < 3) {
                        for (let i = 0; i < 4; i++) pages.push(i);
                        pages.push('ellipsis');
                        pages.push(totalPages - 1);
                    } else if (currentPage > totalPages - 4) {
                        pages.push(0);
                        pages.push('ellipsis');
                        for (let i = totalPages - 4; i < totalPages; i++) pages.push(i);
                    } else {
                        pages.push(0);
                        pages.push('ellipsis');
                        for (let i = currentPage - 1; i <= currentPage + 1; i++) pages.push(i);
                        pages.push('ellipsis');
                        pages.push(totalPages - 1);
                    }
                }
                return pages;
            };

            return (
                <div className="flex items-center justify-end w-fit shrink-0 ml-auto gap-2">
                    <div className="flex items-center gap-1">
                        <button 
                            onClick={() => onPageChange(currentPage - 1)} 
                            disabled={currentPage === 0}
                            className="px-3 py-1.5 rounded-lg text-xs font-bold bg-white border border-slate-200 text-slate-600 hover:bg-slate-50 disabled:opacity-40 disabled:cursor-not-allowed flex items-center gap-1 transition-all"
                        >
                            <ChevronLeft size={14} /> Prev
                        </button>
                        
                        {getPageNumbers().map((page, idx) => (
                            page === 'ellipsis' ? (
                                <span key={`ellipsis-${idx}`} className="px-2 text-slate-400">...</span>
                            ) : (
                                <button
                                    key={page}
                                    onClick={() => onPageChange(page)}
                                    className={`w-8 h-8 rounded-lg text-xs font-bold transition-all flex items-center justify-center ${
                                        currentPage === page 
                                            ? 'bg-violet-600 text-white shadow-md' 
                                            : 'bg-white border border-slate-200 text-slate-600 hover:bg-slate-50'
                                    }`}
                                >
                                    {page + 1}
                                </button>
                            )
                        ))}
                        
                        <button 
                            onClick={() => onPageChange(currentPage + 1)} 
                            disabled={currentPage === totalPages - 1}
                            className="px-3 py-1.5 rounded-lg text-xs font-bold bg-white border border-slate-200 text-slate-600 hover:bg-slate-50 disabled:opacity-40 disabled:cursor-not-allowed flex items-center gap-1 transition-all"
                        >
                            Next <ChevronRight size={14} />
                        </button>
                    </div>
                    
                    <div className="text-xs text-slate-500 font-medium">
                        Page {currentPage + 1} of {totalPages}
                        {generatingPage !== null && generatingPage < totalPages && (
                            <span className="ml-2 text-violet-600 animate-pulse">
                                 Generating page {generatingPage + 1}...
                            </span>
                        )}
                    </div>
                </div>
            );
        };

        const BulkGeneratorModal = ({ isOpen, onClose, agents, onGenerate, title = "Bulk Generation", type = "Coaching" }) => {
            const [selectedAgents, setSelectedAgents] = useState(new Set());
            const [step, setStep] = useState('selection'); // selection, config, generating, results
            const [config, setConfig] = useState({ includeNPS: true, includeQC: true, includeCompliance: true });
            const [progress, setProgress] = useState(0);
            const [results, setResults] = useState([]);
            const [currentPage, setCurrentPage] = useState(0);
            const [generatingPage, setGeneratingPage] = useState(null);
            const [isStreamMode, setIsStreamMode] = useState(true);

            useEffect(() => { 
                if (isOpen) { 
                    setStep('selection'); 
                    setSelectedAgents(new Set()); 
                    setResults([]); 
                    setProgress(0);
                    setCurrentPage(0);
                    setGeneratingPage(null);
                } 
            }, [isOpen]);

            const toggleAgent = (agent) => { const newSet = new Set(selectedAgents); if (newSet.has(agent)) newSet.delete(agent); else newSet.add(agent); setSelectedAgents(newSet); };
            const toggleAll = () => { if (selectedAgents.size === agents.length) setSelectedAgents(new Set()); else setSelectedAgents(new Set(agents)); };

            const handleGenerate = async () => {
                setStep('generating');
                setProgress(0);
                const agentList = Array.from(selectedAgents);
                
                // Start with empty results for incremental display
                setResults([]);

                // Stream generation - append results as they complete
                for (let i = 0; i < agentList.length; i++) {
                    const agent = agentList[i];
                    setGeneratingPage(i);
                    
                    try {
                        const result = await onGenerate(agent, config);
                        const version = { content: result, timestamp: Date.now() };
                        
                        setResults(prev => [
                            ...prev,
                            {
                                agent,
                                content: result,
                                versions: [version],
                                currentVersionIndex: 0,
                                isGenerating: false
                            }
                        ]);
                    } catch (e) {
                        setResults(prev => [
                            ...prev,
                            {
                                agent,
                                content: "Error generating report.",
                                versions: [{ content: "Error generating report.", timestamp: Date.now() }],
                                currentVersionIndex: 0,
                                isGenerating: false
                            }
                        ]);
                    }
                    
                    setProgress(Math.round(((i + 1) / agentList.length) * 100));
                    // No auto-advance: new items are added to pagination automatically
                }
                
                setGeneratingPage(null);
                setStep('results');
            };

            const handleUpdateResult = (pageIndex, content, versions, versionIndex) => {
                setResults(prev => {
                    const newResults = [...prev];
                    newResults[pageIndex] = {
                        ...newResults[pageIndex],
                        content,
                        versions,
                        currentVersionIndex: versionIndex
                    };
                    return newResults;
                });
            };

            const handleRegeneratePage = async (pageIndex) => {
                const agent = results[pageIndex]?.agent;
                if (!agent) return;
                
                try {
                    const newContent = await onGenerate(agent, config);
                    const newVersion = { content: newContent, timestamp: Date.now() };
                    
                    setResults(prev => {
                        const newResults = [...prev];
                        const existingVersions = newResults[pageIndex].versions || [];
                        newResults[pageIndex] = {
                            ...newResults[pageIndex],
                            content: newContent,
                            versions: [...existingVersions, newVersion],
                            currentVersionIndex: existingVersions.length
                        };
                        return newResults;
                    });
                    
                    return newContent;
                } catch (e) {
                    showToast('Regeneration failed', 'error');
                    throw e;
                }
            };

            const copyContent = (text) => { safeCopyToClipboard(text); };

            const copyAllContent = () => {
                const allContent = results.map(r => `## ${r.agent}\n\n${r.content}`).join('\n\n---\n\n');
                safeCopyToClipboard(allContent);
            };

            if (!isOpen) return null;

            const completedResults = results.filter(r => !r.isGenerating).length;
            const totalResults = results.length;

            return (
                <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/50 backdrop-blur-sm p-6 animate-in fade-in duration-200">
                    <div className="bg-white w-full max-w-5xl h-[85vh] rounded-3xl shadow-2xl flex flex-col overflow-hidden animate-in zoom-in-95 duration-200 relative">
                        {/* Header */}
                        <div className="p-6 border-b border-slate-100 flex justify-between items-center bg-white z-10">
                            <div className="flex items-center gap-4">
                                <div className="p-3 bg-violet-50 rounded-xl">
                                    <Sparkles size={24} className="text-violet-600" />
                                </div>
                                <div>
                                    <h3 className="text-xl font-black text-slate-900 tracking-tight">{title}</h3>
                                    <p className="text-sm font-medium text-slate-500">
                                        {step === 'results' || step === 'generating' 
                                            ? `${completedResults} of ${totalResults} pages generated` 
                                            : 'AI-Powered Bulk Processing Engine'}
                                    </p>
                                </div>
                            </div>
                            <div className="flex items-center gap-2">
                                {(step === 'results' || (step === 'generating' && completedResults > 0)) && (
                                    <button 
                                        onClick={copyAllContent}
                                        className="px-3 py-2 bg-slate-100 hover:bg-slate-200 text-slate-600 text-xs font-bold rounded-lg transition-colors flex items-center gap-1"
                                    >
                                        <Copy size={14} /> Copy All
                                    </button>
                                )}
                                <button onClick={onClose} className="p-2 hover:bg-slate-100 rounded-full transition-colors text-slate-500 hover:text-slate-600">
                                    <XIcon size={20} />
                                </button>
                            </div>
                        </div>

                        {/* Content */}
                        <div className="flex-1 overflow-y-auto p-6 custom-scrollbar relative">
                            {step === 'selection' && (
                                <div className="space-y-4">
                                    <div className="flex justify-between items-center mb-2">
                                        <span className="text-sm font-bold text-slate-600">{selectedAgents.size} Selected</span>
                                        <button onClick={toggleAll} className="text-xs font-bold text-blue-600 hover:underline">
                                            {selectedAgents.size === agents.length ? 'Deselect All' : 'Select All'}
                                        </button>
                                    </div>
                                    <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3">
                                        {agents.map(agent => (
                                            <div key={agent} onClick={() => toggleAgent(agent)} className={`p-3 rounded-lg border cursor-pointer transition-all flex items-center gap-3 ${selectedAgents.has(agent) ? 'bg-violet-50 border-violet-200 shadow-sm ring-1 ring-violet-200' : 'bg-white border-slate-200 hover:border-violet-200'}`}>
                                                <div className={`w-5 h-5 rounded border flex items-center justify-center ${selectedAgents.has(agent) ? 'bg-violet-600 border-violet-600' : 'border-slate-300 bg-white'}`}>
                                                    {selectedAgents.has(agent) && <Check size={12} className="text-white" />}
                                                </div>
                                                <span className={`text-xs font-bold truncate ${selectedAgents.has(agent) ? 'text-violet-700' : 'text-slate-600'}`}>{agent}</span>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}


                            {step === 'config' && (
                                <div className="space-y-8 max-w-2xl mx-auto">
                                    <div className="space-y-4">
                                        <h4 className="font-bold text-slate-700 flex items-center gap-2"><LayoutGrid size={16} /> Data Scope</h4>
                                        <div className="flex gap-4">
                                            <label className={`flex-1 p-4 rounded-xl border cursor-pointer transition-all ${config.includeNPS ? 'bg-blue-50 border-blue-200 ring-1 ring-blue-200' : 'bg-white border-slate-200 hover:border-slate-300'}`}>
                                                <div className="flex items-center gap-3">
                                                    <input type="checkbox" checked={config.includeNPS} onChange={(e) => setConfig({ ...config, includeNPS: e.target.checked })} className="w-4 h-4 text-blue-600 rounded" />
                                                    <div>
                                                        <div className="font-bold text-sm text-slate-700">NPS Reviews</div>
                                                        <div className="text-xs text-slate-500">Include customer sentiment data</div>
                                                    </div>
                                                </div>
                                            </label>
                                            <label className={`flex-1 p-4 rounded-xl border cursor-pointer transition-all ${config.includeQC ? 'bg-amber-50 border-amber-200 ring-1 ring-amber-200' : 'bg-white border-slate-200 hover:border-slate-300'}`}>
                                                <div className="flex items-center gap-3">
                                                    <input type="checkbox" checked={config.includeQC} onChange={(e) => setConfig({ ...config, includeQC: e.target.checked })} className="w-4 h-4 text-amber-600 rounded" />
                                                    <div>
                                                        <div className="font-bold text-sm text-slate-700">QC Audits</div>
                                                        <div className="text-xs text-slate-500">Include internal quality scores</div>
                                                    </div>
                                                </div>
                                            </label>
                                        </div>
                                    </div>


                                    <div className="space-y-4">
                                        <h4 className="font-bold text-slate-700 flex items-center gap-2"><Calendar size={16} /> Timeframe (Optional)</h4>
                                        <div className="p-4 bg-slate-50 rounded-xl border border-slate-200">
                                            <p className="text-xs text-slate-500 mb-2">Select specific weeks to analyze. Leave empty to use all available data.</p>
                                            <div className="text-xs italic text-slate-500">Week selection logic uses global context.</div>
                                        </div>
                                    </div>


                                    <div className="space-y-4">
                                        <h4 className="font-bold text-slate-700 flex items-center gap-2"><ShieldCheck size={16} /> Compliance</h4>
                                        <label className={`block p-4 rounded-xl border cursor-pointer transition-all ${config.includeCompliance ? 'bg-emerald-50 border-emerald-200 ring-1 ring-emerald-200' : 'bg-white border-slate-200 hover:border-slate-300'}`}>
                                            <div className="flex items-center gap-3">
                                                <input type="checkbox" checked={config.includeCompliance} onChange={(e) => setConfig({ ...config, includeCompliance: e.target.checked })} className="w-4 h-4 text-emerald-600 rounded" />
                                                <div>
                                                    <div className="font-bold text-sm text-slate-700">Include Pending Actions</div>
                                                    <div className="text-xs text-slate-500">Flag pending acknowledgements and justifications</div>
                                                </div>
                                            </div>
                                        </label>
                                    </div>
                                </div>
                            )}


                            {step === 'generating' && (
                                <div className="space-y-6">
                                    {/* Progress Indicator */}
                                    <div className="bg-white rounded-xl border border-slate-200 p-4">
                                        <div className="flex justify-between text-sm font-bold text-slate-700 mb-2">
                                            <span>Generating Reports...</span>
                                            <span className="text-violet-600">{progress}%</span>
                                        </div>
                                        <div className="w-full bg-slate-100 rounded-full h-2 overflow-hidden">
                                            <div 
                                                className="bg-violet-600 h-full transition-all duration-500 ease-out"
                                                style={{ width: `${progress}%` }}
                                            ></div>
                                        </div>
                                    </div>

                                    {/* Current Page Display with AI Wrapper */}
                                    {results.length > 0 && currentPage < results.length && (
                                        <div className="space-y-4">
                                            <div className="flex items-center gap-2">
                                                <span className="px-3 py-1 bg-violet-100 text-violet-700 text-xs font-black uppercase rounded-full tracking-wider">
                                                    {results[currentPage]?.agent}
                                                </span>
                                                {results[currentPage]?.isGenerating && (
                                                    <span className="text-xs text-violet-600 animate-pulse flex items-center gap-1">
                                                        <Loader2 size={12} className="animate-spin" /> Generating...
                                                    </span>
                                                )}
                                            </div>
                                            
                                            <BulkResultWrapper 
                                                result={results[currentPage]}
                                                isGenerating={results[currentPage]?.isGenerating}
                                                onUpdate={(content, versions, versionIndex) => handleUpdateResult(currentPage, content, versions, versionIndex)}
                                                onRegenerate={() => handleRegeneratePage(currentPage)}
                                            />
                                        </div>
                                    )}

                                    {/* Pagination Controls */}
                                    {results.length > 1 && (
                                        <div className="pt-4 border-t border-slate-100">
                                            <PaginationControls 
                                                currentPage={currentPage}
                                                totalPages={results.length}
                                                onPageChange={setCurrentPage}
                                                generatingPage={generatingPage}
                                            />
                                        </div>
                                    )}
                                </div>
                            )}


                            {step === 'results' && results.length > 0 && (
                                <div className="space-y-6">
                                    {/* Current Page with AI Wrapper */}
                                    <div className="space-y-4">
                                        <div className="flex items-center gap-2">
                                            <span className="px-3 py-1 bg-violet-100 text-violet-700 text-xs font-black uppercase rounded-full tracking-wider">
                                                {results[currentPage]?.agent}
                                            </span>
                                        </div>
                                        
                                        <BulkResultWrapper 
                                            result={results[currentPage]}
                                            isGenerating={false}
                                            onUpdate={(content, versions, versionIndex) => handleUpdateResult(currentPage, content, versions, versionIndex)}
                                            onRegenerate={() => handleRegeneratePage(currentPage)}
                                        />
                                    </div>

                                    {/* Pagination Controls */}
                                    {results.length > 1 && (
                                        <div className="pt-4 border-t border-slate-100">
                                            <PaginationControls 
                                                currentPage={currentPage}
                                                totalPages={results.length}
                                                onPageChange={setCurrentPage}
                                                generatingPage={null}
                                            />
                                        </div>
                                    )}
                                </div>
                            )}
                        </div>


                        {/* Footer */}
                        <div className="p-4 border-t border-slate-100 bg-white flex justify-between items-center">
                            {step === 'selection' && (
                                <>
                                    <div className="text-xs text-slate-500 font-medium">Select multiple agents to proceed</div>
                                    <button onClick={() => setStep('config')} disabled={selectedAgents.size === 0} className="px-6 py-2.5 bg-violet-600 text-white rounded-xl font-bold text-sm shadow-lg shadow-violet-200 hover:bg-violet-700 disabled:opacity-50 disabled:shadow-none transition-all flex items-center gap-2">
                                        Next: Configure <ArrowRight size={16} />
                                    </button>
                                </>
                            )}
                            {step === 'config' && (
                                <>
                                    <button onClick={() => setStep('selection')} className="px-4 py-2 border border-slate-200 rounded-lg text-slate-600 text-sm font-bold hover:bg-slate-50 flex items-center gap-2">
                                        <ArrowLeft size={16} /> Back
                                    </button>
                                    <button onClick={handleGenerate} className="px-6 py-2.5 bg-violet-600 text-white rounded-xl font-bold text-sm shadow-lg shadow-violet-200 hover:bg-violet-700 transition-all flex items-center gap-2">
                                        <Zap size={16} /> Generate Reports
                                    </button>
                                </>
                            )}
                            {(step === 'generating' || step === 'results') && (
                                <>
                                    <div className="flex items-center gap-4">
                                        {step === 'generating' ? (
                                            <span className="text-xs text-slate-500">
                                                Generating page {Math.min(currentPage + 1, results.length)} of {results.length || selectedAgents.size}...
                                            </span>
                                        ) : (
                                            <PaginationControls 
                                                currentPage={currentPage}
                                                totalPages={results.length}
                                                onPageChange={setCurrentPage}
                                                generatingPage={null}
                                            />
                                        )}
                                    </div>
                                    <button onClick={onClose} className="px-6 py-2.5 bg-slate-900 text-white rounded-xl font-bold text-sm hover:bg-black transition-all">
                                        {step === 'generating' ? 'Close' : 'Done'}
                                    </button>
                                </>
                            )}
                        </div>
                    </div>
                </div>
            );
        };






        // --- PHASE 2: LAYOUT COMPONENTS ---


        const Sidebar = ({ view, setView, activeTab, setActiveTab, tabs, health, className }) => {
            const views = [
                { id: 'nps', label: 'NPS Reviews', icon: MessageSquare },
                { id: 'qc', label: 'Quality Control', icon: ShieldCheck },
                { id: 'unified', label: 'Intelligence Hub', icon: LayoutGrid }
            ];


            return (
                <div className={`fixed inset-y-0 left-0 w-64 bg-slate-900 text-slate-300 flex flex-col transition-transform z-50 ${className}`}>
                    {/* Brand */}
                    <div className="p-6 flex items-center gap-3 border-b border-gray-200">
                        <div className="relative p-2 bg-indigo-600 rounded-lg shadow-lg shadow-indigo-500/30">
                            <LayoutDashboard size={20} className="text-white" />
                            <div className={`absolute -top-1 -right-1 w-2.5 h-2.5 rounded-full border-2 border-slate-900 ${health >= 90 ? 'bg-emerald-400' : health >= 60 ? 'bg-amber-400' : 'bg-rose-500'}`}></div>
                        </div>
                        <div>
                            <h1 className="text-lg font-black text-white tracking-tight leading-none">POPPY</h1>
                            <p className="text-[10px] font-bold text-slate-500 uppercase tracking-widest">Suite v2.0</p>
                        </div>
                    </div>


                    {/* Primary Navigation (Views) */}
                    <div className="p-4 space-y-1">
                        <div className="text-[10px] font-black uppercase text-slate-500 tracking-wider mb-2 px-2">Workspaces</div>
                        {views.map(v => (
                            <button
                                key={v.id}
                                onClick={() => { setView(v.id); setActiveTab('Overview'); }}
                                className={`w-full flex items-center gap-3 px-3 py-2.5 rounded-xl text-sm font-semibold transition-all group ${view === v.id ? 'bg-indigo-600 text-white shadow-lg shadow-indigo-900/50' : 'hover:bg-white/5 hover:text-white'}`}
                            >
                                <v.icon size={18} className={view === v.id ? 'text-white' : 'text-slate-500 group-hover:text-white'} />
                                {v.label}
                            </button>
                        ))}
                    </div>


                    {/* Secondary Navigation (Tabs) */}
                    <div className="flex-1 overflow-y-auto px-4 py-2 custom-scrollbar">
                        <div className="text-[10px] font-black uppercase text-slate-500 tracking-wider mb-2 px-2">Current View</div>
                        <div className="space-y-0.5">
                            {tabs.map(tab => (
                                <button
                                    key={tab}
                                    onClick={() => setActiveTab(tab)}
                                    className={`w-full text-left px-3 py-2 rounded-lg text-xs font-medium border-l-2 transition-all ${activeTab === tab ? 'border-indigo-500 bg-white/5 text-white' : 'border-transparent text-slate-500 hover:text-slate-200 hover:bg-white/5'}`}
                                >
                                    {tab}
                                </button>
                            ))}
                        </div>
                    </div>


                    {/* User Profile / Footer */}
                    <div className="p-4 border-t border-gray-200 bg-black/20">
                        <div className="flex items-center gap-3">
                            <div className="w-8 h-8 rounded-full bg-indigo-500/20 flex items-center justify-center text-indigo-400 font-bold text-xs ring-1 ring-white/10">JD</div>
                            <div className="flex-1 min-w-0">
                                <p className="text-xs font-bold text-white truncate">John Doe</p>
                                <p className="text-[10px] text-slate-500 truncate">Team Lead</p>
                            </div>
                            <button className="text-slate-500 hover:text-white transition-colors"><Settings size={14} /></button>
                        </div>
                    </div>
                </div>
            );
        };


        // --- GLOBAL SEARCH COMPONENT (Fix for User Issue) ---
        const GlobalSearch = ({ isOpen, onClose, npsData, qcData, onSelectAgent, setAiTrigger, setView, setFilters, setActiveTab }) => {
            const [query, setQuery] = useState('');
            const [results, setResults] = useState([]);
            const inputRef = useRef(null);


            useEffect(() => {
                if (isOpen) {
                    setTimeout(() => inputRef.current?.focus(), 100);
                    document.body.style.overflow = 'hidden';
                } else {
                    document.body.style.overflow = 'unset';
                }
                return () => { document.body.style.overflow = 'unset'; };
            }, [isOpen]);


            // Handle Escape Key
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.key === 'Escape') onClose();
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [onClose]);


            useEffect(() => {
                if (!query.trim()) {
                    setResults([]);
                    return;
                }


                const q = query.toLowerCase();
                const allAgents = new Set();
                const matches = [];


                // 0. Navigation Commands (Sherlock Mode)
                if (q.includes('nps') || q.includes('net promoter')) {
                    matches.push({ type: 'nav', value: 'nps', label: 'Go to NPS View', icon: LayoutDashboard });
                }
                if (q.includes('qc') || q.includes('quality')) {
                    matches.push({ type: 'nav', value: 'qc', label: 'Go to QC View', icon: ShieldAlert });
                }
                if (q.includes('unified') || q.includes('home')) {
                    matches.push({ type: 'nav', value: 'unified', label: 'Go to Unified View', icon: LayoutDashboard });
                }


                if (q.includes('upload') || q.includes('import')) {
                    matches.push({ type: 'nav', value: 'upload', label: 'Go to Data Upload', icon: Upload });
                }


                // 1. Search Agents
                [...npsData, ...qcData].forEach(row => {
                    const agent = DataEngine.normalizeAgent(row, row['Source'] === 'QC' ? 'QC' : 'NPS');
                    if (agent && agent.toLowerCase().includes(q) && !allAgents.has(agent)) {
                        allAgents.add(agent);
                        matches.push({ type: 'agent', value: agent, label: agent });
                    }
                });


                // 2. Search Comments (Limit to 5)
                let commentCount = 0;
                [...npsData].forEach(row => {
                    if (commentCount >= 5) return;
                    const comment = row['Remediation Feedback'] || row['Review'];
                    if (comment && comment.toLowerCase().includes(q)) {
                        matches.push({ type: 'comment', value: comment, label: `NPS: ${comment.substring(0, 60)}...`, date: row['Date'] });
                        commentCount++;
                    }
                });


                // Removed Ask AI fallback to comply with restricted trigger policy


                setResults(matches.slice(0, 20)); // Limit total results
            }, [query, npsData, qcData]);


            if (!isOpen) return null;


            return (
                <div className="fixed inset-0 z-[100] flex items-start justify-center pt-24 px-4 bg-slate-900/60 backdrop-blur-sm" onClick={onClose}>
                    <div className="w-full max-w-2xl bg-white rounded-2xl shadow-2xl overflow-hidden border border-slate-200" onClick={e => e.stopPropagation()}>
                        {/* Header / Input */}
                        <div className="flex items-center gap-4 px-6 py-4 border-b border-slate-100">
                            <Search size={20} className="text-slate-500" />
                            <input
                                ref={inputRef}
                                type="text"
                                className="flex-1 text-lg font-medium text-slate-800 placeholder-slate-400 outline-none bg-transparent"
                                placeholder="Search agents or commands..."
                                value={query}
                                onChange={e => setQuery(e.target.value)}
                                onKeyDown={e => {
                                    if (e.key === 'Enter' && results.length > 0) {
                                        // Default to first result
                                        const r = results[0];
                                        if (r.type === 'agent') { onSelectAgent(r.value); onClose(); }
                                        else if (r.type === 'nav') { setView(r.value); onClose(); }


                                    }
                                }}
                            />
                            <div className="px-2 py-1 bg-slate-100 rounded text-xs font-bold text-slate-500">ESC to close</div>
                        </div>


                        {/* Results Body */}
                        <div className="max-h-[60vh] overflow-y-auto bg-slate-50/50">
                            {results.length === 0 && query.trim() && (
                                <div className="p-8 text-center text-slate-500">
                                    <p>No results found for "{query}"</p>
                                </div>
                            )}


                            {results.length === 0 && !query.trim() && (
                                <div className="p-8 text-center text-slate-500">
                                    <p className="text-sm font-medium">Type to search across {npsData.length + qcData.length} records</p>
                                </div>
                            )}


                            {results.length > 0 && (
                                <div className="py-2">
                                    {results.map((r, i) => (
                                        <button
                                            key={i}
                                            onClick={() => {
                                                if (r.type === 'agent') {
                                                    onSelectAgent(r.value);
                                                    onClose();
                                                } else if (r.type === 'nav') {
                                                    setView(r.value);
                                                    onClose();
                                                }
                                            }}
                                            className="w-full flex items-center gap-4 px-6 py-3 hover:bg-indigo-50 transition-colors text-left group border-b border-transparent hover:border-indigo-100 last:border-0"
                                        >
                                            <div className={`w-8 h-8 rounded-lg flex items-center justify-center flex-shrink-0 ${r.type === 'agent' ? 'bg-indigo-100 text-indigo-600' :
                                                r.type === 'nav' ? 'bg-blue-100 text-blue-600' :
                                                    r.type === 'ai' ? 'bg-violet-100 text-violet-600' :
                                                        'bg-emerald-100 text-emerald-600'
                                                }`}>
                                                {r.icon ? <r.icon size={16} /> : (r.type === 'agent' ? <Users size={16} /> : <MessageSquare size={16} />)}
                                            </div>
                                            <div className="flex-1 min-w-0">
                                                <div className="font-semibold text-slate-700 group-hover:text-indigo-700 truncate">{r.label}</div>
                                                {r.date && <div className="text-xs text-slate-500">{r.date}</div>}
                                            </div>
                                            <ChevronRight size={14} className="text-slate-300 group-hover:text-indigo-400 opacity-0 group-hover:opacity-100 transition-all" />
                                        </button>
                                    ))}
                                </div>
                            )}
                        </div>


                        {/* Footer */}
                        <div className="px-6 py-2 bg-slate-50 border-t border-slate-100 text-[10px] font-bold text-slate-500 flex justify-between uppercase tracking-wider">
                            <span>POPPY SUITE GLOBAL SEARCH</span>
                            <span>{results.length} Matches</span>
                        </div>
                    </div>
                </div>
            );
        };












        // Global Pagination Controls
        const SimplePaginationControls = ({ current, total, onChange, className = "" }) => {
            if (total <= 1) return null;
            return (
                <div className={`flex items-center justify-center gap-4 mt-6 ${className}`}>
                    <button
                        onClick={() => onChange(Math.max(1, current - 1))}
                        disabled={current === 1}
                        className="p-2 rounded-full hover:bg-slate-100 disabled:opacity-30 transition-all text-slate-600"
                        title="Previous"
                    >
                        <ChevronLeft size={20} />
                    </button>
                    <div className="flex items-center gap-2">
                        <span className="font-black text-slate-700 text-sm">
                            Page {current}
                        </span>
                        <span className="text-slate-500 text-xs font-bold uppercase tracking-wider">
                            of {total}
                        </span>
                    </div>
                    <button
                        onClick={() => onChange(Math.min(total, current + 1))}
                        disabled={current === total}
                        className="p-2 rounded-full hover:bg-slate-100 disabled:opacity-30 transition-all text-slate-600"
                        title="Next"
                    >
                        <ChevronRight size={20} />
                    </button>
                </div>
            );
        };

        // Global AI Progress Bar Component
        const AIProgressBar = () => {
            const [state, setState] = React.useState({ show: false, progress: 0, text: '' });

            React.useEffect(() => {
                const handleProgress = (e) => setState(prev => ({ ...prev, ...e.detail }));
                window.addEventListener('ai-progress', handleProgress);
                return () => window.removeEventListener('ai-progress', handleProgress);
            }, []);

            if (!state.show) return null;

            return (
                <div className="fixed top-0 left-0 right-0 z-[99999] pointer-events-none">
                    <div className="h-1 w-full bg-slate-100/20">
                        <div
                            className="h-full bg-gradient-to-r from-blue-500 via-indigo-500 to-purple-500 transition-all duration-300 ease-out shadow-[0_0_10px_rgba(99,102,241,0.5)]"
                            style={{ width: `${Math.min(100, Math.max(0, state.progress))}%` }}
                        />
                    </div>
                    <div className="absolute top-2 right-4 bg-slate-900/90 text-white text-xs font-bold px-3 py-1.5 rounded-full shadow-lg backdrop-blur flex items-center gap-2 animate-in slide-in-from-top-2 border border-slate-700/50">
                        <Loader2 className="animate-spin text-indigo-400" size={12} />
                        <span className="tabular-enums">{Math.round(state.progress)}%</span>
                        <span className="text-slate-500 border-l border-slate-700 pl-2 ml-1">{state.text}</span>
                    </div>
                </div>
            );
        };


        const QuizModule = (props) => {
            const [mode, setMode] = useState('standard'); // 'standard' | 'advanced'

            return (
                <div className="quiz-wrapper space-y-4">
                    {/* Mode Toggle */}
                    <div className="flex justify-center mb-6">
                        <div className="bg-slate-100 p-1.5 rounded-xl flex gap-2 shadow-inner">
                            <button
                                onClick={() => setMode('standard')}
                                className={`px-6 py-2.5 rounded-lg text-sm font-bold flex items-center gap-2 ${mode === 'standard' ? 'bg-white shadow-sm text-slate-900 ring-1 ring-slate-200' : 'text-slate-500 hover:text-slate-700 hover:bg-slate-200/50'}`}
                            >
                                <ListChecks size={16} />
                                Standard Quiz
                            </button>
                            <button
                                onClick={() => setMode('advanced')}
                                className={`px-6 py-2.5 rounded-lg text-sm font-bold flex items-center gap-2 ${mode === 'advanced' ? 'bg-white shadow-sm text-indigo-600 ring-1 ring-indigo-100' : 'text-slate-500 hover:text-slate-700 hover:bg-slate-200/50'}`}
                            >
                                <Sparkles size={16} />
                                Advanced AI Quiz
                            </button>
                        </div>
                    </div>

                    {/* FIXED: Removed fade-in animation that was causing rendering issues */}
                    <div>
                        {mode === 'standard' ? (
                            <StandardQuizModule {...props} />
                        ) : (
                            <AdvancedQuizBuilder data={props.data} type={props.type || 'NPS'} />
                        )}
                    </div>
                </div>
            );
        };

        // ExportReminderModal removed per Issue 14 (Feature Cleanup)

        // --- COACHING TEMPLATES (Issue 12) ---
        const COACHING_TEMPLATES = {
            communication_issues: {
                name: 'Communication Skills Improvement',
                icon: MessageSquare,
                description: 'Addresses clarity, tone, and customer understanding issues',
                sections: [
                    {
                        title: 'Current State Assessment',
                        prompt: `Based on this agent's feedback data: {{feedback_samples}}
                
Analyze the agent's communication weaknesses. Be specific about:
- What communication patterns are failing
- Examples from actual customer interactions
- Impact on customer satisfaction

Output format: 2-3 clear bullet points with examples.`
                    },
                    {
                        title: 'Root Cause Analysis',
                        prompt: `Given these communication failures: {{failure_patterns}}
                
Identify the ROOT CAUSES of these issues:
- Is it lack of empathy?
- Technical jargon overuse?
- Not listening to customer needs?
- Rushing to solutions?

Be specific and actionable. Output: 3-4 root causes.`
                    },
                    {
                        title: 'Action Plan',
                        prompt: `Create a 5-step action plan to improve communication for this agent.

Context: {{context}}
Current performance: {{baseline_metrics}}

Each step should:
1. Be specific and measurable
2. Include a timeline (Week 1, Week 2, etc.)
3. Have a clear success criterion

Format:
**Week X: [Action]**
- What to do
- How to measure success
- Resources needed`
                    },
                    {
                        title: 'Success Metrics',
                        prompt: `Define clear, measurable goals for communication improvement.

Current baseline: {{baseline_metrics}}

Create SMART goals:
- Specific metric to track
- Target improvement percentage
- Timeline to achieve
- How to measure

Output: 4-5 specific metrics with targets.`
                    },
                    {
                        title: 'Practice Scenarios',
                        prompt: `Create 3 realistic practice scenarios to help this agent improve communication.

Based on actual failures: {{failure_patterns}}

Each scenario:
1. Customer situation (2-3 sentences)
2. What went wrong before
3. Correct approach with exact script
4. Why this approach works

Make scenarios realistic and based on actual data.`
                    }
                ]
            },
            quality_compliance: {
                name: 'Quality & Compliance Training',
                icon: CheckSquare,
                description: 'Addresses QC failures and policy adherence gaps',
                sections: [
                    {
                        title: 'Failed Criteria Summary',
                        prompt: `List all QC criteria that this agent failed, with frequency.

QC failure data: {{qc_failures}}

For each failed criterion:
- Criterion name
- Number of failures
- % of total audits
- Severity (Low/Medium/High)

Sort by frequency (highest first). Output as table.`
                    },
                    {
                        title: 'Policy Knowledge Gaps',
                        prompt: `Identify which policies need reinforcement based on QC data.

Failed criteria: {{qc_failures}}
Policy context: {{policy_context}}

For each policy gap:
- Policy name/number
- What the agent is doing wrong
- What they should be doing
- Why it matters

Output: 3-5 most critical policy gaps.`
                    },
                    {
                        title: 'Week-by-Week Training Plan',
                        prompt: `Design a 4-week training program to address these QC gaps.

Agent level: {{agent_level}}
Failed criteria: {{qc_failures}}

For each week:
**Week X: Focus Area**
- Key learning objectives
- Training activities (review, practice, shadow)
- Self-study materials
- Practice exercises
- Success checkpoint

Make it progressive - start simple, build complexity.`
                    },
                    {
                        title: 'Compliance Checklist',
                        prompt: `Create a daily/weekly compliance checklist for this agent.

Based on their failure patterns: {{failure_patterns}}

Checklist should include:
- Pre-interaction checks (what to verify before starting)
- During interaction (what to ensure while helping customer)
- Post-interaction (what to document/verify after)

Make it printable and easy to follow. Max 15 items.`
                    }
                ]
            },
            customer_escalations: {
                name: 'De-escalation & Empathy Training',
                icon: Heart,
                description: 'Handles customer anger, frustration, and difficult situations',
                sections: [
                    {
                        title: 'Escalation Pattern Analysis',
                        prompt: `Analyze when and why customers escalate with this agent.

Escalation data: {{escalation_data}}
Customer feedback: {{customer_feedback}}

Identify patterns:
- What triggers escalations?
- What phrases/actions make it worse?
- At what point do customers get frustrated?
- Common themes in negative feedback

Output: 4-5 key patterns with examples.`
                    },
                    {
                        title: 'Empathy Gap Assessment',
                        prompt: `Assess where this agent is missing empathy opportunities.

Customer feedback samples: {{customer_feedback}}
Failed interactions: {{failure_patterns}}

Identify:
- Where agent should have acknowledged feelings but didn't
- Where apologies were needed but absent
- Where personalization was missing
- Where agent seemed robotic or scripted

Give specific examples from actual interactions.`
                    },
                    {
                        title: 'Empathy Framework Training',
                        prompt: `Teach this agent the "AER" empathy framework:
- Acknowledge (feelings)
- Empathize (show understanding)
- Resolve (take action)

Create 5 examples showing:
1. Customer statement (angry/frustrated)
2. BAD response (what NOT to say)
3. GOOD response using AER
4. Why the good response works

Base examples on this agent's actual customer interactions: {{common_issues}}`
                    },
                    {
                        title: 'De-escalation Roleplay Scenarios',
                        prompt: `Create 3 realistic roleplay scenarios for de-escalation practice.

Based on this agent's actual escalations: {{escalation_data}}

Each scenario:
1. **Setup**: Customer's emotional state and complaint (3-4 sentences)
2. **Customer opening statement** (what they say to agent)
3. **Escalation triggers**: What NOT to say
4. **Correct approach**: Step-by-step de-escalation
5. **Success outcome**: What successful resolution looks like

Make scenarios progressively harder. Start with mildly upset, end with very angry.`
                    }
                ]
            },
            product_knowledge: {
                name: 'Product Knowledge Enhancement',
                icon: BookOpen,
                description: 'Improves understanding of products, features, and technical details',
                sections: [
                    {
                        title: 'Knowledge Gap Identification',
                        prompt: `Identify product knowledge gaps from agent's failures.

QC failures: {{qc_failures}}
Customer escalations: {{escalation_data}}

List:
- Which products/features are problematic
- What specific knowledge is missing
- How many times each gap appeared
- Impact on customer experience

Output: Table with gaps sorted by frequency.`
                    },
                    {
                        title: 'Study Plan',
                        prompt: `Create a focused study plan for product knowledge.

Identified gaps: {{knowledge_gaps}}
Agent's current level: {{agent_level}}

For each product/feature gap:
- Study materials to review
- Key facts to memorize
- Practice questions
- When to test knowledge (timeline)

Prioritize by impact and frequency.`
                    },
                    {
                        title: 'Quick Reference Guide',
                        prompt: `Create a quick reference guide for this agent.

Most common customer questions: {{common_issues}}
Products with knowledge gaps: {{knowledge_gaps}}

Format:
**Product/Feature Name**
- Key details agent must know
- Common customer questions
- Quick answer template
- Where to find more info

Keep it concise - max 2-3 bullets per item.`
                    }
                ]
            },
            time_management: {
                name: 'Efficiency & Time Management',
                icon: Clock,
                description: 'Addresses slow handling times and efficiency issues',
                sections: [
                    {
                        title: 'Time Waste Analysis',
                        prompt: `Analyze where this agent is losing time.

Performance data: {{time_metrics}}
QC feedback: {{qc_failures}}

Identify:
- Which interactions take longest
- What causes delays
- Unnecessary steps taken
- Where agent gets stuck

Output: 4-5 specific time-wasters with average time lost.`
                    },
                    {
                        title: 'Efficiency Improvement Plan',
                        prompt: `Create plan to reduce handling time by 20%.

Current metrics: {{baseline_metrics}}
Time-wasters: {{time_wasters}}

For each time-waster, provide:
1. Current inefficient process
2. Optimized process
3. Time saved
4. How to implement

Make it specific and actionable.`
                    },
                    {
                        title: 'Workflow Optimization',
                        prompt: `Design optimized workflow for this agent's common tasks.

Most frequent tasks: {{common_tasks}}
Current bottlenecks: {{time_wasters}}

Create step-by-step workflows showing:
- Task trigger
- Steps in order
- Time per step
- Shortcuts/tools to use
- Quality checkpoints

Output: 3-4 workflows for most common scenarios.`
                    }
                ]
            },
            active_listening: {
                name: 'Active Listening Skills',
                icon: Headphones,
                description: 'Improves ability to understand customer needs and concerns',
                sections: [
                    {
                        title: 'Listening Failure Patterns',
                        prompt: `Identify where this agent fails to listen effectively.

Customer feedback: {{customer_feedback}}
Escalation data: {{escalation_data}}

Look for:
- Interrupting customers
- Missing key details
- Making assumptions
- Not confirming understanding
- Rushing to solutions

Output: 4-5 specific patterns with examples.`
                    },
                    {
                        title: 'Active Listening Framework',
                        prompt: `Teach the "HEAR" framework:
- Halt: Stop talking, focus completely
- Empathize: Acknowledge emotions
- Ask: Clarifying questions
- Reflect: Summarize understanding

Create 4 examples showing:
1. Customer concern
2. POOR response (not listening)
3. GOOD response using HEAR
4. Why it works better

Base on this agent's actual interactions.`
                    },
                    {
                        title: 'Questioning Techniques',
                        prompt: `Improve this agent's questioning skills.

Common customer issues: {{common_issues}}
Communication failures: {{failure_patterns}}

Teach:
- Open vs closed questions
- Probing for details
- Confirming understanding
- Avoiding leading questions

Provide 5 question templates for common situations.`
                    },
                    {
                        title: 'Practice Exercises',
                        prompt: `Create listening practice exercises.

Based on this agent's failures: {{failure_patterns}}

Exercises:
1. **Paraphrasing practice** - Customer says X, agent summarizes Y
2. **Detail extraction** - Find the 3 key pieces of info
3. **Emotion recognition** - Identify how customer feels
4. **Solution matching** - Match concern to right solution

Make exercises progressively challenging.`
                    }
                ]
            },
            problem_solving: {
                name: 'Problem-Solving & Critical Thinking',
                icon: Brain,
                description: 'Develops analytical skills and solution-finding abilities',
                sections: [
                    {
                        title: 'Problem-Solving Gaps',
                        prompt: `Identify where this agent struggles with problem-solving.

QC failures: {{qc_failures}}
Customer escalations: {{escalation_data}}

Look for:
- Jumping to conclusions
- Missing root causes
- Incomplete solutions
- Over-complicating simple issues
- Giving up too easily

Output: Specific gaps with examples.`
                    },
                    {
                        title: 'Systematic Approach Training',
                        prompt: `Teach the "SOLVE" method:
- State the problem clearly
- Observe all symptoms/details
- List possible causes
- Verify the real cause
- Execute the best solution

Create 3 examples showing progression from confusion to clear solution.
Use this agent's actual problem scenarios.`
                    },
                    {
                        title: 'Decision-Making Framework',
                        prompt: `Improve this agent's decision-making process.

Common scenarios: {{common_issues}}
Failed decisions: {{failure_patterns}}

Teach:
- When to escalate vs resolve
- Risk assessment
- Solution prioritization
- Customer impact evaluation
- Follow-up requirements

Provide decision trees for common situations.`
                    },
                    {
                        title: 'Creative Solution Finding',
                        prompt: `Develop creative problem-solving skills.

Customer issues: {{common_issues}}
Constraints: {{policy_context}}

Exercises:
1. **Multiple solutions** - List 3 ways to solve each problem
2. **Constraint navigation** - Work within policy limits
3. **Customer-focused solutions** - Put customer first
4. **Win-win scenarios** - Satisfy both customer and company

Make it practical and actionable.`
                    }
                ]
            },
            stress_management: {
                name: 'Stress Management & Resilience',
                icon: Shield,
                description: 'Helps agents handle pressure and maintain performance under stress',
                sections: [
                    {
                        title: 'Stress Trigger Identification',
                        prompt: `Identify what causes stress for this agent.

Performance data: {{baseline_metrics}}
Escalation patterns: {{escalation_data}}
QC failures: {{qc_failures}}

Look for:
- High-pressure situations
- Difficult customer types
- Time constraints
- Complex problems
- Volume spikes

Output: Stress triggers ranked by frequency and impact.`
                    },
                    {
                        title: 'In-The-Moment Techniques',
                        prompt: `Teach stress management techniques for live interactions.

Common stressors: {{stress_triggers}}
Agent personality: {{agent_level}}

Techniques:
- Breathing exercises (10-second reset)
- Positive self-talk scripts
- Perspective reframing
- Customer empathy (reduces personal stress)
- Escalation protocols (when to hand off)

Provide specific scripts and timing.`
                    },
                    {
                        title: 'Recovery Strategies',
                        prompt: `Create post-interaction recovery protocols.

Stress patterns: {{stress_triggers}}
Agent preferences: {{agent_preferences}}

Strategies:
- Quick reset techniques (30-60 seconds)
- Between-call routines
- End-of-shift wind-down
- Building resilience over time
- When to seek support

Make it practical for busy environment.`
                    },
                    {
                        title: 'Prevention Planning',
                        prompt: `Develop proactive stress prevention strategies.

Known stressors: {{stress_triggers}}
Performance patterns: {{baseline_metrics}}

Prevention plan:
- Early warning signs to watch for
- Proactive breaks and scheduling
- Skill building to reduce stress
- Support system utilization
- Long-term resilience building

Focus on preventing stress before it happens.`
                    }
                ]
            },
            team_collaboration: {
                name: 'Team Collaboration & Knowledge Sharing',
                icon: Users,
                description: 'Improves ability to work with team members and share knowledge effectively',
                sections: [
                    {
                        title: 'Collaboration Assessment',
                        prompt: `Assess this agent's collaboration patterns.

Team feedback: {{team_feedback}}
Escalation data: {{escalation_data}}

Evaluate:
- How often they ask for help
- Quality of handoffs to other teams
- Knowledge sharing with peers
- Response to team feedback
- Mentoring opportunities

Identify specific collaboration gaps.`
                    },
                    {
                        title: 'Knowledge Sharing Skills',
                        prompt: `Improve this agent's knowledge sharing abilities.

Product knowledge: {{knowledge_gaps}}
Common issues: {{common_issues}}

Teach:
- Documenting solutions for team
- Creating helpful resources
- Training new team members
- Contributing to team knowledge base
- Leading team discussions

Provide templates and examples.`
                    },
                    {
                        title: 'Cross-Team Communication',
                        prompt: `Enhance cross-team collaboration skills.

Handoff patterns: {{escalation_data}}
Team interactions: {{team_interactions}}

Improve:
- Clear escalation documentation
- Effective handoff communication
- Following up on escalated issues
- Building relationships with other teams
- Understanding team capabilities

Create communication templates.`
                    },
                    {
                        title: 'Peer Support Development',
                        prompt: `Develop peer support and mentoring skills.

Agent strengths: {{agent_strengths}}
Team needs: {{team_needs}}

Skills:
- Recognizing when peers need help
- Offering support appropriately
- Sharing best practices
- Creating team resources
- Building team cohesion

Focus on becoming a team asset.`
                    }
                ]
            },
            technical_skills: {
                name: 'Technical Skills Development',
                icon: Wrench,
                description: 'Builds technical competency for complex product support',
                sections: [
                    {
                        title: 'Technical Gap Analysis',
                        prompt: `Identify technical knowledge gaps.

QC failures: {{qc_failures}}
Customer issues: {{common_issues}}
Escalation data: {{escalation_data}}

Look for:
- Product technical details
- System troubleshooting
- Integration issues
- Advanced features
- Technical terminology

Rank gaps by frequency and complexity.`
                    },
                    {
                        title: 'Technical Foundation Building',
                        prompt: `Create technical foundation training plan.

Identified gaps: {{technical_gaps}}
Agent level: {{agent_level}}

Foundation topics:
- Core product architecture
- Common technical issues
- Basic troubleshooting steps
- Integration points
- Technical documentation

Create progressive learning path from basic to advanced.`
                    },
                    {
                        title: 'Hands-On Practice Labs',
                        prompt: `Design practical technical exercises.

Technical gaps: {{technical_gaps}}
Common scenarios: {{common_issues}}

Lab exercises:
1. **Basic troubleshooting** - Step-by-step problem solving
2. **System integration** - How different parts work together
3. **Advanced features** - Complex functionality deep dives
4. **Error resolution** - Common error messages and fixes

Make it hands-on and practical.`
                    },
                    {
                        title: 'Technical Communication',
                        prompt: `Improve ability to explain technical concepts simply.

Technical issues: {{technical_gaps}}
Communication failures: {{failure_patterns}}

Skills:
- Translating technical jargon
- Using analogies and examples
- Step-by-step explanations
- Visual explanations
- Confirming understanding

Practice explaining complex topics simply.`
                    }
                ]
            },
            sales_techniques: {
                name: 'Sales & Upselling Techniques',
                icon: TrendingUp,
                description: 'Develops skills for identifying and acting on sales opportunities',
                sections: [
                    {
                        title: 'Opportunity Recognition',
                        prompt: `Train agent to spot sales opportunities.

Customer interactions: {{common_issues}}
Product knowledge: {{knowledge_gaps}}

Teach to recognize:
- Customer needs that match products
- Upgrade opportunities
- Cross-sell moments
- Timing for offers
- Customer readiness signals

Provide specific examples and patterns.`
                    },
                    {
                        title: 'Consultative Selling Approach',
                        prompt: `Develop consultative selling skills.

Customer issues: {{common_issues}}
Product features: {{product_features}}

Approach:
- Ask discovery questions
- Identify real needs
- Match solutions to needs
- Present benefits, not features
- Handle objections naturally

Create natural conversation flows.`
                    },
                    {
                        title: 'Objection Handling',
                        prompt: `Improve objection handling skills.

Common objections: {{common_objections}}
Customer concerns: {{customer_feedback}}

Techniques:
- Acknowledge concerns
- Ask clarifying questions
- Provide relevant information
- Offer alternatives
- Know when to back off

Create response templates for common objections.`
                    },
                    {
                        title: 'Closing Techniques',
                        prompt: `Develop natural closing skills.

Sales opportunities: {{sales_opportunities}}
Customer patterns: {{customer_behavior}}

Closing approaches:
- Assumptive close
- Alternative close
- Urgency creation
- Benefit summary
- Next step setting

Make it feel natural, not pushy.`
                    }
                ]
            },
            cultural_sensitivity: {
                name: 'Cultural Sensitivity & Inclusion',
                icon: Globe,
                description: 'Builds awareness and skills for serving diverse customer base',
                sections: [
                    {
                        title: 'Cultural Awareness Assessment',
                        prompt: `Assess cultural sensitivity in customer interactions.

Customer feedback: {{customer_feedback}}
Escalation data: {{escalation_data}}

Look for:
- Cultural misunderstandings
- Inappropriate assumptions
- Communication style issues
- Holiday/cultural references
- Language barriers

Identify specific cultural competency gaps.`
                    },
                    {
                        title: 'Inclusive Communication Training',
                        prompt: `Develop inclusive communication skills.

Cultural gaps: {{cultural_gaps}}
Customer diversity: {{customer_demographics}}

Skills:
- Avoiding cultural assumptions
- Inclusive language use
- Respecting cultural differences
- Adapting communication style
- Handling cultural references

Provide specific examples and alternatives.`
                    },
                    {
                        title: 'Global Customer Service',
                        prompt: `Build skills for international customer support.

Customer base: {{customer_demographics}}
Common issues: {{common_issues}}

Topics:
- Time zone awareness
- Holiday recognition
- Cultural business practices
- Communication preferences
- Regional product differences

Create region-specific guidance.`
                    },
                    {
                        title: 'Bias Recognition & Mitigation',
                        prompt: `Help agent recognize and mitigate unconscious bias.

Interaction patterns: {{interaction_patterns}}
Customer feedback: {{customer_feedback}}

Focus on:
- Identifying personal biases
- Checking assumptions
- Fair treatment verification
- Objective decision-making
- Continuous self-assessment

Provide practical bias-checking tools.`
                    }
                ]
            },
            follow_up_excellence: {
                name: 'Follow-Up & Relationship Building',
                icon: Mail,
                description: 'Develops skills for effective follow-up and long-term customer relationship management',
                sections: [
                    {
                        title: 'Follow-Up Gap Analysis',
                        prompt: `Identify follow-up improvement opportunities.

Customer feedback: {{customer_feedback}}
QC failures: {{qc_failures}}

Look for:
- Missed follow-up promises
- Incomplete issue resolution
- Poor closure techniques
- Lack of next steps
- No relationship building

Quantify follow-up failures.`
                    },
                    {
                        title: 'Proactive Follow-Up Strategies',
                        prompt: `Develop proactive follow-up skills.

Common scenarios: {{common_issues}}
Customer expectations: {{customer_expectations}}

Strategies:
- Setting clear expectations
- Timeline communication
- Status updates
- Escalation prevention
- Relationship maintenance

Create follow-up templates and timelines.`
                    },
                    {
                        title: 'Relationship Building Techniques',
                        prompt: `Build long-term customer relationship skills.

Customer interactions: {{customer_feedback}}
Success patterns: {{success_patterns}}

Techniques:
- Personal connection building
- Remembering customer details
- Anticipating future needs
- Adding value beyond solving problems
- Creating memorable experiences

Focus on genuine relationship building.`
                    },
                    {
                        title: 'Customer Retention Strategies',
                        prompt: `Develop customer retention focused follow-up.

Customer issues: {{common_issues}}
Retention data: {{retention_metrics}}

Strategies:
- Identifying at-risk customers
- Recovery techniques
- Loyalty building
- Upsell opportunities
- Referral generation

Make every follow-up count toward retention.`
                    }
                ]
            },
            adaptability_flexibility: {
                name: 'Adaptability & Flexibility',
                icon: Shuffle,
                description: 'Builds ability to adapt to changing situations and customer needs',
                sections: [
                    {
                        title: 'Rigidity Assessment',
                        prompt: `Identify where this agent shows inflexibility.

Customer feedback: {{customer_feedback}}
Escalation data: {{escalation_data}}
QC failures: {{qc_failures}}

Look for:
- Scripted responses in wrong contexts
- Inability to customize solutions
- Policy interpretation rigidity
- Resistance to new approaches
- One-size-fits-all mentality

Provide specific examples.`
                    },
                    {
                        title: 'Situational Adaptation Training',
                        prompt: `Develop ability to adapt approach based on situation.

Common scenarios: {{common_issues}}
Customer types: {{customer_demographics}}

Teach:
- Reading customer cues
- Adjusting communication style
- Customizing solutions
- Policy flexibility within guidelines
- Creative problem-solving

Provide adaptation frameworks.`
                    },
                    {
                        title: 'Change Management Skills',
                        prompt: `Build comfort with change and new processes.

Process changes: {{process_changes}}
Agent resistance: {{resistance_patterns}}

Skills:
- Embracing new procedures
- Learning agility
- Process improvement suggestions
- Helping others adapt
- Maintaining performance during transitions

Focus on positive change adoption.`
                    },
                    {
                        title: 'Creative Problem-Solving',
                        prompt: `Develop creative approach to unique situations.

Unusual scenarios: {{unique_scenarios}}
Policy constraints: {{policy_context}}

Techniques:
- Thinking outside standard procedures
- Finding win-win solutions
- Working within constraints creatively
- Knowing when to escalate vs innovate
- Building solution repertoire

Encourage creative thinking within guidelines.`
                    }
                ]
            },
            leadership_development: {
                name: 'Leadership & Mentoring Skills',
                icon: Award,
                description: 'Prepares high-performing agents for leadership and mentoring roles',
                sections: [
                    {
                        title: 'Leadership Potential Assessment',
                        prompt: `Assess this agent's leadership potential.

Performance metrics: {{baseline_metrics}}
Peer feedback: {{peer_feedback}}
Team interactions: {{team_interactions}}

Evaluate:
- Natural leadership behaviors
- Peer influence and respect
- Problem-solving capabilities
- Communication skills
- Mentoring aptitude

Identify specific leadership strengths.`
                    },
                    {
                        title: 'Mentoring Skills Development',
                        prompt: `Develop mentoring and coaching abilities.

Agent strengths: {{agent_strengths}}
Team needs: {{team_needs}}

Skills:
- Identifying mentee needs
- Providing constructive feedback
- Sharing knowledge effectively
- Building confidence in others
- Tracking mentee progress

Create mentoring framework and tools.`
                    },
                    {
                        title: 'Team Leadership Training',
                        prompt: `Build team leadership capabilities.

Leadership opportunities: {{leadership_opportunities}}
Team dynamics: {{team_dynamics}}

Capabilities:
- Leading team meetings
- Facilitating discussions
- Driving team initiatives
- Managing conflicts
- Representing team needs

Provide leadership practice opportunities.`
                    },
                    {
                        title: 'Continuous Leadership Growth',
                        prompt: `Create long-term leadership development plan.

Current capabilities: {{leadership_assessment}}
Career goals: {{career_aspirations}}

Growth plan:
- Skill building priorities
- Experience opportunities
- Learning resources
- Mentorship for the mentor
- Progress measurement

Focus on sustained leadership development.`
                    }
                ]
            },
            empathy_customer_connection: {
                name: 'Empathy and Customer Connection',
                icon: Smile,
                description: 'Builds genuine emotional connections and demonstrates authentic empathy with customers',
                sections: [
                    {
                        title: 'Empathy Strength Assessment',
                        prompt: `Analyze this agent's empathy expression in customer interactions.

Customer feedback: {{customer_feedback}}
Escalation data: {{escalation_data}}

Evaluate:
- How often emotions are acknowledged
- Quality of empathetic statements
- Personalization in responses
- Emotional connection depth
- Customer feeling heard

Identify 3-5 specific empathy gaps with examples.`
                    },
                    {
                        title: 'Emotional Intelligence Training',
                        prompt: `Teach emotional intelligence principles for customer service.

Common scenarios: {{common_issues}}
Agent weaknesses: {{failure_patterns}}

Framework:
- Recognizing customer emotions
- Validating feelings appropriately
- Matching emotional tone
- Building rapport quickly
- Creating personal connections

Provide 5 empathetic response templates.`
                    },
                    {
                        title: 'Connection Building Techniques',
                        prompt: `Develop skills to build genuine customer connections.

Customer types: {{customer_demographics}}
Successful interactions: {{success_patterns}}

Techniques:
- Using customer names naturally
- Referencing previous interactions
- Showing genuine interest
- Personalized problem-solving
- Creating memorable moments

Create 4 real-world connection scenarios.`
                    },
                    {
                        title: 'Empathy Practice Scenarios',
                        prompt: `Create empathy-building practice exercises.

Agent weaknesses: {{failure_patterns}}
Common complaints: {{common_issues}}

Exercises:
1. **Emotion recognition** - Identify customer feelings from statements
2. **Response crafting** - Write empathetic responses to complaints
3. **Tone adjustment** - Adapt tone to customer emotions
4. **Follow-up empathy** - Show care after resolution

Make scenarios based on actual agent interactions.`
                    }
                ]
            },
            call_handling_efficiency: {
                name: 'Call Handling Efficiency',
                icon: Phone,
                description: 'Optimizes call flow, reduces handling time while maintaining quality',
                sections: [
                    {
                        title: 'Call Flow Analysis',
                        prompt: `Analyze this agent's call handling patterns.

Time metrics: {{time_metrics}}
QC feedback: {{qc_failures}}

Identify:
- Where calls get delayed
- Unnecessary hold times
- Repetitive questions
- Inefficient processes
- Dead air moments

Quantify time impact for each issue.`
                    },
                    {
                        title: 'Opening & Closing Optimization',
                        prompt: `Improve call opening and closing efficiency.

Current patterns: {{baseline_metrics}}
Best practices: {{success_patterns}}

Optimize:
- Greeting brevity and warmth
- Verification efficiency
- Expectation setting
- Call control techniques
- Clean closing sequences

Provide exact scripts for openings and closings.`
                    },
                    {
                        title: 'Navigation & System Efficiency',
                        prompt: `Improve system navigation speed during calls.

Common tasks: {{common_tasks}}
Time wasters: {{time_wasters}}

Techniques:
- Keyboard shortcuts mastery
- Pre-call preparation
- Concurrent documentation
- Quick information retrieval
- System transition smoothness

Create workflow optimization plan.`
                    },
                    {
                        title: 'Call Control Techniques',
                        prompt: `Develop better call control skills.

Escalation patterns: {{escalation_data}}
Long call causes: {{time_wasters}}

Skills:
- Redirecting off-topic conversations
- Managing talkative customers
- Efficient questioning
- Keeping calls on track
- Balancing efficiency and service

Provide scripts for common control situations.`
                    }
                ]
            },
            first_contact_resolution: {
                name: 'First Contact Resolution',
                icon: CheckCircle,
                description: 'Increases FCR rate by improving issue understanding and resolution skills',
                sections: [
                    {
                        title: 'FCR Gap Analysis',
                        prompt: `Analyze why issues require multiple contacts.

Escalation data: {{escalation_data}}
QC failures: {{qc_failures}}
Customer feedback: {{customer_feedback}}

Identify:
- Common repeat contact reasons
- Incomplete solutions provided
- Knowledge gaps causing callbacks
- Process issues leading to recontacts
- Authorization/timeline problems

Quantify FCR impact areas.`
                    },
                    {
                        title: 'Complete Diagnosis Training',
                        prompt: `Improve issue diagnosis thoroughness.

Common issues: {{common_issues}}
Failure patterns: {{failure_patterns}}

Training:
- Asking comprehensive questions
- Probing for root causes
- Identifying related issues
- Checking for underlying problems
- Confirming full scope

Provide diagnostic question frameworks.`
                    },
                    {
                        title: 'Solution Verification',
                        prompt: `Ensure solutions are complete and verified.

Past callbacks: {{escalation_data}}
QC feedback: {{qc_failures}}

Process:
- Testing solutions before presenting
- Setting clear expectations
- Providing next steps
- Confirming customer understanding
- Offering proactive follow-up

Create solution checklist.`
                    },
                    {
                        title: 'FCR Improvement Action Plan',
                        prompt: `Create plan to improve FCR by 15%.

Current FCR rate: {{baseline_metrics}}
Top repeat reasons: {{common_issues}}

Plan includes:
- Knowledge gap remediation
- Process improvement steps
- Authorization empowerment
- Documentation enhancements
- Follow-up protocols

Set weekly targets and measurement.`
                    }
                ]
            },
            process_adherence: {
                name: 'Process Adherence',
                icon: ClipboardList,
                description: 'Ensures consistent following of procedures, protocols, and compliance requirements',
                sections: [
                    {
                        title: 'Process Deviation Analysis',
                        prompt: `Identify where agent deviates from standard processes.

QC failures: {{qc_failures}}
Policy violations: {{policy_context}}

Find:
- Skipped mandatory steps
- Incorrect procedures followed
- Missing documentation
- Approval bypasses
- Compliance gaps

Quantify deviation frequency and impact.`
                    },
                    {
                        title: 'Critical Process Training',
                        prompt: `Reinforce essential processes and procedures.

Process gaps: {{policy_context}}
Common mistakes: {{failure_patterns}}

Focus areas:
- Mandatory verification steps
- Required documentation
- Approval workflows
- Compliance checkpoints
- Quality gates

Create process checklists for common scenarios.`
                    },
                    {
                        title: 'Process Understanding Assessment',
                        prompt: `Assess agent's understanding of why processes exist.

Process knowledge gaps: {{knowledge_gaps}}
Policy context: {{policy_context}}

Evaluate:
- Understanding of process purposes
- Knowledge of compliance requirements
- Awareness of risk implications
- Recognition of exceptions
- Escalation triggers

Address knowledge deficiencies.`
                    },
                    {
                        title: 'Process Compliance Monitoring',
                        prompt: `Create self-monitoring system for process adherence.

Critical processes: {{policy_context}}
Common deviations: {{failure_patterns}}

System includes:
- Daily process checklist
- Self-audit procedures
- Peer verification steps
- Manager check-ins
- Progress tracking

Make adherence measurable and trackable.`
                    }
                ]
            },
            multitasking_skills: {
                name: 'Multi-tasking Skills',
                icon: Layers,
                description: 'Develops ability to handle multiple systems, tasks, and priorities simultaneously',
                sections: [
                    {
                        title: 'Multi-tasking Assessment',
                        prompt: `Evaluate agent's current multi-tasking capabilities.

Time metrics: {{time_metrics}}
QC feedback: {{qc_failures}}

Assess:
- System navigation speed
- Data entry accuracy while talking
- Hold time management
- Documentation efficiency
- Task prioritization

Identify specific multi-tasking weaknesses.`
                    },
                    {
                        title: 'System Navigation Mastery',
                        prompt: `Improve simultaneous system and customer handling.

Common tasks: {{common_tasks}}
System pain points: {{time_wasters}}

Training:
- Keyboard shortcut proficiency
- Screen layout optimization
- Quick form completion
- Information lookup speed
- Multi-window management

Create system efficiency exercises.`
                    },
                    {
                        title: 'Active Listening While Working',
                        prompt: `Maintain active listening while performing tasks.

Listening gaps: {{failure_patterns}}
Common tasks: {{common_tasks}}

Techniques:
- Verbal acknowledgment while typing
- Paraphrasing during navigation
- Confirming understanding while documenting
- Managing silent periods
- Balancing speed and attention

Practice scenarios with concurrent tasks.`
                    },
                    {
                        title: 'Priority Management',
                        prompt: `Develop better task prioritization skills.

Common scenarios: {{common_issues}}
Time pressures: {{time_metrics}}

Framework:
- Urgent vs important matrix
- Customer vs system priorities
- Real-time decision making
- When to pause vs proceed
- Recovery from interruptions

Provide priority decision trees.`
                    }
                ]
            },
            digital_communication: {
                name: 'Email/Chat Communication',
                icon: MessageCircle,
                description: 'Enhances written communication skills for email and chat support channels',
                sections: [
                    {
                        title: 'Written Communication Analysis',
                        prompt: `Analyze agent's written communication effectiveness.

Customer feedback: {{customer_feedback}}
QC failures: {{qc_failures}}

Review:
- Clarity and conciseness
- Tone appropriateness
- Grammar and spelling
- Structure and formatting
- Response completeness

Identify 3-5 improvement areas with examples.`
                    },
                    {
                        title: 'Chat-Specific Skills',
                        prompt: `Develop chat channel best practices.

Common issues: {{common_issues}}
Digital preferences: {{customer_demographics}}

Skills:
- Managing multiple chats
- Response time optimization
- Typing speed improvement
- Using canned responses effectively
- Chat etiquette and tone

Provide chat response templates.`
                    },
                    {
                        title: 'Email Excellence',
                        prompt: `Improve email communication quality.

Email patterns: {{customer_feedback}}
Common mistakes: {{failure_patterns}}

Training:
- Subject line best practices
- Opening and closing formats
- Clear structure (problem/solution/next steps)
- Professional tone maintenance
- Attachment and link protocols

Create email response templates.`
                    },
                    {
                        title: 'Digital Channel Etiquette',
                        prompt: `Master written channel etiquette and professionalism.

Customer expectations: {{customer_expectations}}
Brand guidelines: {{policy_context}}

Standards:
- Response time expectations
- Emoji and abbreviation usage
- Formality levels
- Escalation indicators
- Closure techniques

Develop channel-specific guidelines.`
                    }
                ]
            },
            positive_language: {
                name: 'Positive Language Usage',
                icon: ThumbsUp,
                description: 'Transforms negative statements into positive, solution-focused communication',
                sections: [
                    {
                        title: 'Negative Language Audit',
                        prompt: `Identify negative language patterns in agent's communication.

Customer feedback: {{customer_feedback}}
QC recordings: {{qc_failures}}

Find:
- "No" and "can't" usage
- Problem-focused statements
- Defensive language
- Blame assignment
- Hopeless framing

Catalog negative phrases with frequency.`
                    },
                    {
                        title: 'Positive Framing Training',
                        prompt: `Teach positive language transformation.

Negative patterns: {{failure_patterns}}
Common situations: {{common_issues}}

Techniques:
- "Yes, and..." instead of "No"
- Solution-focused statements
- Possibility language
- Empowering phrases
- Gratitude expressions

Provide positive alternatives for common negatives.`
                    },
                    {
                        title: 'Difficult Message Delivery',
                        prompt: `Deliver negative information positively.

Common bad news: {{common_issues}}
Customer reactions: {{escalation_data}}

Approach:
- Sandwich technique (good-bad-good)
- Focus on what CAN be done
- Alternative solutions
- Future possibilities
- Sincere apologies when needed

Create scripts for common difficult messages.`
                    },
                    {
                        title: 'Positive Language Practice',
                        prompt: `Create exercises for positive language habit formation.

Common negatives: {{failure_patterns}}
Agent weaknesses: {{baseline_metrics}}

Exercises:
1. **Rephrase challenge** - Convert 10 negatives to positives
2. **Response makeover** - Improve actual agent responses
3. **Scenario practice** - Handle complaints positively
4. **Self-monitoring** - Track personal negative language

Make positive language automatic.`
                    }
                ]
            },
            customer_satisfaction_focus: {
                name: 'Customer Satisfaction Focus',
                icon: Star,
                description: 'Aligns all actions and communications with customer satisfaction goals',
                sections: [
                    {
                        title: 'CSAT Driver Analysis',
                        prompt: `Analyze what drives satisfaction/dissatisfaction for this agent.

Customer feedback: {{customer_feedback}}
CSAT scores: {{baseline_metrics}}

Identify:
- Top satisfaction drivers
- Primary dissatisfaction causes
- CSAT vs effort correlation
- Service vs outcome impact
- Emotional vs functional factors

Quantify impact of each factor.`
                    },
                    {
                        title: 'CSAT-First Mindset',
                        prompt: `Develop customer satisfaction first approach.

CSAT gaps: {{failure_patterns}}
Customer expectations: {{customer_expectations}}

Mindset shifts:
- Measuring success by customer happiness
- Proactive satisfaction checks
- Going beyond minimum requirements
- Creating delight moments
- Ownership mentality

Transform interactions to satisfaction-focused.`
                    },
                    {
                        title: 'Service Recovery Excellence',
                        prompt: `Turn service failures into satisfaction wins.

Escalation patterns: {{escalation_data}}
Recovery successes: {{success_patterns}}

Techniques:
- Immediate acknowledgment
- Sincere apology frameworks
- Empowerment to fix issues
- Compensation guidelines
- Follow-up protocols

Create service recovery playbooks.`
                    },
                    {
                        title: 'CSAT Improvement Action Plan',
                        prompt: `Create specific plan to improve CSAT scores.

Current CSAT: {{baseline_metrics}}
Improvement opportunities: {{customer_feedback}}

Plan includes:
- Quick wins (immediate improvements)
- Skill development priorities
- Process adjustments
- Customer communication changes
- Measurement and tracking

Target: 10-point CSAT improvement in 60 days.`
                    }
                ]
            },
            escalation_management: {
                name: 'Escalation Management',
                icon: AlertTriangle,
                description: 'Improves when and how to escalate issues for optimal customer outcomes',
                sections: [
                    {
                        title: 'Escalation Pattern Review',
                        prompt: `Analyze this agent's escalation behaviors.

Escalation data: {{escalation_data}}
QC feedback: {{qc_failures}}

Identify:
- Escalation frequency vs peers
- Types of issues escalated
- Timing of escalations
- Information provided with escalations
- Escalation outcomes

Determine if escalations are appropriate.`
                    },
                    {
                        title: 'Escalation Decision Framework',
                        prompt: `Teach when to escalate vs when to resolve.

Common scenarios: {{common_issues}}
Policy guidelines: {{policy_context}}

Framework:
- Escalation triggers (clear criteria)
- Self-resolution attempts first
- Authority limits awareness
- Time-based escalation rules
- Customer-requested escalations

Create escalation decision tree.`
                    },
                    {
                        title: 'Effective Escalation Handoffs',
                        prompt: `Improve escalation quality and completeness.

Escalation gaps: {{escalation_data}}
Team feedback: {{team_feedback}}

Best practices:
- Complete documentation
- Customer summary
- Actions already taken
- Customer expectations set
- Smooth transition language

Create escalation template/checklist.`
                    },
                    {
                        title: 'De-escalation Before Escalation',
                        prompt: `Develop skills to resolve issues before escalating.

Common escalations: {{escalation_data}}
Agent skills: {{agent_strengths}}

Techniques:
- Advanced problem-solving
- Creative solution finding
- Authority empowerment
- Timeline negotiation
- Alternative offer strategies

Reduce unnecessary escalations by 30%.`
                    }
                ]
            },
            feedback_implementation: {
                name: 'Feedback Implementation',
                icon: RefreshCw,
                description: 'Builds ability to receive, process, and act on feedback effectively',
                sections: [
                    {
                        title: 'Feedback Reception Assessment',
                        prompt: `Assess how this agent receives and processes feedback.

Past coaching: {{coaching_history}}
Improvement trends: {{baseline_metrics}}

Evaluate:
- Defensive vs open response
- Action on previous feedback
- Progress tracking
- Self-awareness level
- Initiative in seeking feedback

Identify barriers to feedback acceptance.`
                    },
                    {
                        title: 'Growth Mindset Development',
                        prompt: `Develop growth mindset for continuous improvement.

Mindset barriers: {{failure_patterns}}
Success stories: {{success_patterns}}

Mindset shifts:
- Feedback as gift, not criticism
- Mistakes as learning opportunities
- Progress over perfection
- Curiosity about blind spots
- Ownership of development

Transform attitude toward improvement.`
                    },
                    {
                        title: 'Action Planning from Feedback',
                        prompt: `Create systematic approach to implementing feedback.

Recent feedback: {{qc_failures}}
Coaching inputs: {{coaching_history}}

Process:
- Feedback categorization
- Priority setting
- Specific action steps
- Timeline creation
- Progress measurement

Make feedback actionable and trackable.`
                    },
                    {
                        title: 'Self-Coaching Skills',
                        prompt: `Develop ability to self-assess and self-correct.

Common mistakes: {{failure_patterns}}
Quality standards: {{policy_context}}

Skills:
- Call self-review techniques
- Identifying own weaknesses
- Setting personal improvement goals
- Tracking own progress
- Seeking help proactively

Build self-sufficiency in improvement.`
                    }
                ]
            },
            professional_development: {
                name: 'Professional Development',
                icon: Target,
                description: 'Supports career growth, skill expansion, and long-term professional success',
                sections: [
                    {
                        title: 'Career Aspiration Discovery',
                        prompt: `Explore agent's career goals and aspirations.

Current role: {{agent_level}}
Performance trends: {{baseline_metrics}}
Strengths: {{agent_strengths}}

Discuss:
- Short-term goals (6-12 months)
- Long-term vision (2-5 years)
- Interest areas
- Skill development desires
- Leadership aspirations

Document career development roadmap.`
                    },
                    {
                        title: 'Skill Gap Analysis for Growth',
                        prompt: `Identify skills needed for desired career progression.

Career goals: {{career_aspirations}}
Current capabilities: {{agent_strengths}}

Analysis:
- Required skills for next level
- Transferable strengths
- Development priorities
- Learning opportunities
- Experience gaps

Create skill development plan.`
                    },
                    {
                        title: 'Professional Brand Building',
                        prompt: `Develop professional reputation and visibility.

Current reputation: {{team_feedback}}
Contributions: {{agent_strengths}}

Actions:
- Knowledge sharing initiatives
- Mentoring opportunities
- Process improvement suggestions
- Team leadership moments
- External learning

Build credibility and recognition.`
                    },
                    {
                        title: 'Long-term Development Plan',
                        prompt: `Create comprehensive professional development plan.

Career goals: {{career_aspirations}}
Skill gaps: {{knowledge_gaps}}

Plan includes:
- 90-day skill building targets
- 6-month experience goals
- 1-year advancement milestones
- Learning resources
- Mentorship arrangements
- Progress checkpoints

Align with organizational opportunities.`
                    }
                ]
            }
        };

        // Helper function to generate coaching plan from template
        const generateCoachingFromTemplate = async (templateKey, agentData, askAI) => {
            const template = COACHING_TEMPLATES[templateKey];
            if (!template) {
                showToast("Template not found", "error");
                return null;
            }
            
            // Gather context data from agent
            const context = {
                feedback_samples: agentData.recentFeedback?.slice(0, 5) || [],
                failure_patterns: agentData.topWeaknesses || [],
                qc_failures: agentData.qcFails || [],
                escalation_data: agentData.escalations || [],
                customer_feedback: agentData.customerComments || [],
                baseline_metrics: agentData.currentMetrics || {},
                agent_level: agentData.experienceLevel || 'Mid-level',
                knowledge_gaps: agentData.knowledgeGaps || [],
                common_issues: agentData.commonIssues || [],
                time_metrics: agentData.timeMetrics || {},
                policy_context: agentData.policyFailures || [],
                common_tasks: agentData.frequentTasks || [],
                time_wasters: agentData.timeWasters || []
            };
            
            // Generate each section
            let fullPlan = `**${template.name}**\n\n`;
            fullPlan += `${template.description}\n\n`;
            fullPlan += `**Agent:** ${agentData.name}\n\n`;
            fullPlan += `---\n\n`;
            
            for (let i = 0; i < template.sections.length; i++) {
                const section = template.sections[i];
                
                // Replace placeholders in prompt
                let prompt = section.prompt;
                Object.keys(context).forEach(key => {
                    let value = Array.isArray(context[key]) 
                        ? JSON.stringify(context[key].slice(0, 10))  // Limit array size
                        : JSON.stringify(context[key]);
                    
                    // Fix: Duplicate Chat/Review Links
                    value = value.replace(/\(Chat Link :\-.*?\)/g, '');

                    prompt = prompt.replace(new RegExp(`\\{\\{${key}\\}\\}`, 'g'), value);
                });
                
                // Add system instruction for link handling
                prompt += "\n\nSYSTEM INSTRUCTION: Do NOT output raw URLs or wrap links in parentheses.";

                // Show progress
                showToast(`Generating section ${i + 1}/${template.sections.length}...`, "info");
                
                try {
                    // Use askAI if available, otherwise fallback to GeminiAI
                    const content = typeof askAI === 'function' 
                        ? await askAI(prompt, { skipHistory: true })
                        : await GeminiAI.generate(prompt);
                    
                    // Add to plan
                    fullPlan += `**${section.title}**\n\n`;
                    fullPlan += `${content}\n\n`;
                    fullPlan += `---\n\n`;
                    
                } catch (error) {
                    console.error(`Failed to generate section: ${section.title}`, error);
                    fullPlan += `**${section.title}**\n\n`;
                    fullPlan += `*[Generation failed - please try again]*\n\n`;
                    fullPlan += `---\n\n`;
                }
            }
            
            return fullPlan;
        };

        // Helper functions for calculating agent metrics
        const calculateTopWeaknesses = (npsData, qcData) => {
            const issues = {};
            
            // From NPS
            npsData?.forEach(row => {
                Object.entries(NPS_METRIC_MAPPING).forEach(([pillar, metrics]) => {
                    metrics.forEach(metric => {
                        if (row[metric] === false || row[metric] === 'FALSE') {
                            issues[metric] = (issues[metric] || 0) + 1;
                        }
                    });
                });
            });
            
            // From QC
            qcData?.forEach(row => {
                const question = row['Question'] || row.Question;
                if (row['Pass/Fail'] === 'Fail' && question) {
                    issues[question] = (issues[question] || 0) + 1;
                }
            });
            
            return Object.entries(issues)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([issue, count]) => ({ issue, count }));
        };

        const calculateAgentMetrics = (npsData, qcData) => {
            const npsCount = npsData?.length || 0;
            
            // Helper to check sub-metric failure
            const isSubMetricFail = (row) => {
                const metrics = Object.values(NPS_METRIC_MAPPING).flat();
                return metrics.some(m => {
                    const val = row[m];
                    return val === 'Fail' || val === 'FALSE' || val === 'No' || val === false;
                });
            };

            const npsWow = npsData?.filter(r => !isSubMetricFail(r)).length || 0;
            const npsPoor = npsData?.filter(r => isSubMetricFail(r)).length || 0;
            
            const qcCount = qcData?.length || 0;
            
            // QC Filter: Exclude Pending/To Do, Accepted, Pending to be appealed
            const validQc = qcData?.filter(r => {
                const status = String(r['Appeal Status'] || '').trim();
                const tlAppeal = r['TL Appeal'] === true || r['TL Appeal'] === 'TRUE';
                const tlRca = String(r['TL RCA'] || '').trim();
                
                // Exclude Pending Appeal
                if (status === 'To Do') return false;
                
                // Exclude Pending to be appealed
                if (tlAppeal && (tlRca.startsWith('Appeal') || tlRca.startsWith('Appealed')) && !status) return false;
                
                // NOTE: We do NOT exclude "Accepted Appeal" or Score 0 here because they count as PASSES in the metric.
                // If we excluded them, the Pass Rate would be incorrect (0%).
                // The "Exclude Accepted" instruction typically applies to "Failure Analysis" or "Feedback Loop", 
                // but for "Pass Rate", accepted appeals are valid passes.
                
                return true;
            }) || [];
            
            const qcPasses = validQc.filter(r => parseFloat(r['QC Score']) === 0).length || 0; // Only 0 is good
            const qcScores = validQc.map(r => parseFloat(r['QC Score'])).filter(s => !isNaN(s)) || [];
            const totalQCScore = qcScores.length > 0 ? qcScores.reduce((a, b) => a + b, 0) : 0;
            
            return {
                npsTotal: npsCount,
                npsWowRate: npsCount > 0 ? ((npsWow / npsCount) * 100).toFixed(1) : 0,
                npsPoorRate: npsCount > 0 ? ((npsPoor / npsCount) * 100).toFixed(1) : 0,
                qcTotal: validQc.length,
                qcPassRate: validQc.length > 0 ? ((qcPasses / validQc.length) * 100).toFixed(1) : 0,
                totalQCScore: totalQCScore
            };
        };


        // --- ISSUE 4: SYSTEMIC KNOWLEDGE GAPS ---
        // FEATURE: OPERATIONAL LOAD VIEW
        // OperationalLoadView removed per Issue #22

        const SystemicGapsTable = ({ data, onDownload, askAI }) => {
            // Simple frequency analysis of questions/issues
            const gaps = useMemo(() => {
                if (!data || !data.length) return [];
                
                // Filter out invalid appeals (Accepted, Pending, To Be Appealed)
                const cleanData = data.filter(d => !DataEngine.isAppeal(d));
                
                const counts = {};
                cleanData.forEach(r => {
                    const key = r['Question'] || r['User Problem'] || r['Sub-metric'] || 'Uncategorized';
                    if (!counts[key]) counts[key] = { issue: key, count: 0, agents: new Set() };
                    counts[key].count++;
                    if (r.Agent || r['Agent Email']) counts[key].agents.add(r.Agent || r['Agent Email']);
                });
                return Object.values(counts)
                    .map(c => ({ ...c, affected: c.agents.size }))
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 10);
            }, [data]);

            const [kbLoading, setKbLoading] = useState(null);
            const [kbBatchLoading, setKbBatchLoading] = useState(false);
            const [kbDrafts, setKbDrafts] = useState({}); // Issue 2 Fix: Store multiple drafts
            const [selectedDraftId, setSelectedDraftId] = useState(null); // Track which draft to view

            const handleDraftKB = async (gap) => {
                // If draft exists, just view it
                if (kbDrafts[gap.issue]) {
                    setSelectedDraftId(gap.issue);
                    return;
                }

                setKbLoading(gap.issue);
                try {
                    const contextFailures = (data || [])
                        .filter(d => {
                            const q = d['Question'] || d['User Problem'] || d['Sub-metric'];
                            const isFail = d['Pass/Fail'] === 'Fail' || d.Rating === 'Poor' || d.isFail === true;
                            return q === gap.issue && isFail;
                        })
                        .map(d => d['Remediation Feedback'] || d['TL RCA'] || d['Outcome'] || d['Feedback'] || d['Answer Comment'])
                        .filter(Boolean)
                        .slice(0, 5);
                    const prompt = `${AI_PERSONA}
${TL_PERSONA_PROMPT}

Draft a Knowledge Base (KB) snippet to address a systemic gap.
Topic/Question: "${gap.issue}"
Impact: ${(Math.round((gap.count / (data?.length || 1)) * 100))}% of the team is failing this.
Real Failure Context: ${JSON.stringify(contextFailures)}

STRICT RULES:
1. Use MARKDOWN BOLD (**Text**) ONLY for titles and section headers.
2. Descriptions, explanations, numbers, and regular text MUST be normal (no bold).
3. NO hashtags (#).
4. Do NOT use the word "Bold", "Underline", or "B" as text.
5. **Bullet Points:** ALWAYS use standard Markdown bullets (-).
6. **Strict Keywords:** Use ONLY Pillar names and Sub-metric names from the data.

OUTPUT FORMAT:
**Title**: [Clear Title]
**The Rule**: [Brief explanation of the correct process]
**Common Mistake**: [What agents are doing wrong]
**Quick Fix**: [Simple instruction to correct it]
**Example Script**: "[Correct phrase to use]"

Keep it short, scannable, and training-ready.`;
                    const text = await GeminiAI.generate(prompt);
                    setKbDrafts(prev => ({ ...prev, [gap.issue]: { title: gap.issue, content: text } }));
                    setSelectedDraftId(gap.issue);
                } catch (e) {
                    showToast("Failed to generate draft", "error");
                }
                setKbLoading(null);
            };

            const handleGenerateAllKB = async () => {
                if (gaps.length === 0) {
                    showToast("No knowledge gaps to draft", 'error');
                    return;
                }
                
                // Issue 2 Fix: Filter out items that already have updates
                const pendingGaps = gaps.filter(g => !kbDrafts[g.issue]);
                
                if (pendingGaps.length === 0) {
                    showToast("All visible gaps already have drafts!", 'success');
                    return;
                }

                if (!confirm(`Generate KB updates for ${pendingGaps.length} gaps?`)) return;
                
                setKbBatchLoading(true);
                showToast(`Generating ${pendingGaps.length} KB updates...`, 'info');
                let successCount = 0;
                
                for (const gap of pendingGaps) {
                    try {
                        await handleDraftKB(gap);
                        successCount++;
                    } catch (e) {
                        console.error("KB draft failed", e);
                    }
                }
                showToast(`Draft generation complete! ${successCount} updates created.`, 'success');
                setKbBatchLoading(false);
            };

            if (gaps.length === 0) return null;

            const activeDraft = selectedDraftId ? kbDrafts[selectedDraftId] : null;

            return (
                <div className="w-full">
                    <Card title="Systemic Knowledge Gaps" subtitle="Top recurring issues across the team" icon={AlertTriangle} type="Table" rowCount={gaps.length} onDownloadImage={onDownload} onDownloadCSV={() => ExportEngine.exportCSV(gaps, "systemic_knowledge_gaps")} onCopyTable={() => copyTableToClipboard(null, gaps)} dataForAI={gaps} askAI={askAI} headerActions={
                        <div className="flex items-center gap-2">
                            <button
                                onClick={handleGenerateAllKB}
                                disabled={kbBatchLoading}
                                className="px-3 py-1.5 bg-rose-50 text-rose-700 rounded-lg text-[10px] font-bold hover:bg-rose-100 transition-all flex items-center gap-2 shadow-sm no-export whitespace-nowrap"
                                data-html2canvas-ignore="true"
                                title="Generate KB updates for all visible gaps"
                            >
                                {kbBatchLoading ? <div className="w-3 h-3 border-2 border-rose-500 border-t-transparent rounded-full animate-spin" /> : <Sparkles size={12} />}
                                {kbBatchLoading ? "Generating..." : "Generate All KB Updates"}
                            </button>
                        </div>
                    }>
                        <div className="w-full">
                            <table className="w-full min-w-full text-left border-collapse">
                                <thead>
                                    <tr className="bg-slate-50 border-b border-slate-200 text-[10px] uppercase font-black text-slate-700 tracking-wider">
                                        <th className="p-3">Issue / Question</th>
                                        <th className="p-3 text-center">Occurrence</th>
                                        <th className="p-3 text-center">Agents Affected</th>
                                        <th className="p-3 text-center">Impact</th>
                                        <th className="p-3 text-center">Action</th>
                                    </tr>
                                </thead>
                                <tbody className="text-sm text-slate-600">
                                    {gaps.map((gap, i) => (
                                        <tr key={i} className={`border-b border-slate-50 hover:bg-slate-50/80 transition-colors ${selectedDraftId === gap.issue ? 'bg-rose-50/50' : ''}`}>
                                            <td className="p-3 font-bold text-slate-800">{gap.issue}</td>
                                            <td className="p-3 text-center font-medium">{gap.count}</td>
                                            <td className="p-3 text-center font-medium">{gap.affected}</td>
                                            <td className="p-3 text-center">
                                                <div className="flex justify-center items-center gap-2">
                                                    <div className="w-20 h-1.5 bg-slate-100 rounded-full overflow-hidden">
                                                        <div className="h-full bg-rose-500 rounded-full" style={{ width: `${Math.min(100, (gap.count / data.length) * 100 * 5)}%` }}></div>
                                                    </div>
                                                    <span className="text-[10px] font-bold text-slate-500">High</span>
                                                </div>
                                            </td>
                                            <td className="p-3 text-center">
                                                <button
                                                    onClick={() => handleDraftKB(gap)}
                                                    disabled={kbBatchLoading || kbLoading === gap.issue}
                                                    className={`inline-flex px-3 py-1.5 rounded-lg text-xs font-bold transition-all items-center gap-2 shadow-sm no-export ${kbDrafts[gap.issue] ? 'bg-emerald-50 text-emerald-700 border border-emerald-200' : 'bg-white border border-rose-200 text-rose-700 hover:bg-rose-50 hover:border-rose-300'}`}
                                                    data-html2canvas-ignore="true"
                                                >
                                                    {kbLoading === gap.issue ? <div className="w-3 h-3 border-2 border-rose-500 border-t-transparent rounded-full animate-spin" /> : (kbDrafts[gap.issue] ? <Eye size={12} /> : <Sparkles size={12} />)}
                                                    {kbLoading === gap.issue ? "Drafting..." : (kbDrafts[gap.issue] ? "View Draft" : "Draft KB Update")}
                                                </button>
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                        {activeDraft && (
                            <div className="p-4 bg-slate-50 rounded-xl border border-slate-200 mt-4">
                                <div className="flex items-center justify-between mb-2">
                                    <h4 className="text-sm font-bold text-slate-800">{activeDraft.title}</h4>
                                    <div className="flex gap-2">
                                        <button className="px-3 py-1.5 bg-slate-900 text-white rounded-lg text-xs font-bold" onClick={() => safeCopyToClipboard(activeDraft.content)}>Copy</button>
                                        <button className="px-3 py-1.5 border border-slate-200 rounded-lg text-xs font-bold" onClick={() => setSelectedDraftId(null)}>Close</button>
                                    </div>
                                </div>
                                <div className="prose prose-sm max-w-none">
                                    <div dangerouslySetInnerHTML={{ __html: safeMarked(activeDraft.content) }} />
                                </div>
                            </div>
                        )}
                    </Card>
                </div>
            );
        };

        // --- ISSUE 11: QC AGENT REVIEW VIEW ---
        // FIXED: Moved all hooks to top level to prevent React Error #300
        const QCAgentReview = ({ data, metricsMapping, onDownload, onExpand, askAI, selectedAgent, onSelectAgent, scope }) => {
            // All hooks must be called at the top level, never conditionally
            const [sortConfig, setSortConfig] = useState({ key: 'totalScore', direction: 'asc' });
            const [expandedKey, setExpandedKey] = useState(null);
            const [actionPlans, setActionPlans] = useState({});
            const [offenderPlans, setOffenderPlans] = useState({});
            const [visible, setVisible] = useState(['Agent Name', 'Total Audits', 'Total Score', 'Fails', 'Appeals', 'TL Action Plan']);
            const [loadingPlans, setLoadingPlans] = useState({});
            const [batchProgress, setBatchProgress] = useState({ loading: false, current: 0, total: 0 });
            
            // NEW: State for Repeat Offender Registry
            const [filterRisk, setFilterRisk] = useState('All');
            
            // Safety check - use empty array if data is invalid
            const safeData = data && Array.isArray(data) ? data : [];

            // Get all unique agents
            const allAgents = useMemo(() => {
                const agents = new Set();
                safeData.forEach(r => {
                    const agent = DataEngine.normalizeAgent(r, 'QC');
                    if (agent) agents.add(agent);
                });
                return Array.from(agents).sort();
            }, [safeData]);
            const stats = useMemo(() => {
                const agentMap = {};
                let totalAudits = 0;
                
                const sourceData = data || [];

                sourceData.forEach(row => {
                    const agent = DataEngine.normalizeAgent(row, 'NPS') || DataEngine.normalizeAgent(row, 'QC') || 'Unknown';
                    if (!agent || agent === 'Unknown') return;
                    totalAudits++;

                    if (!agentMap[agent]) {
                        agentMap[agent] = {
                            name: agent,
                            audits: 0,
                            fails: 0,
                            tags: {},
                            scores: [],
                            dates: [],
                            riskScore: 0
                        };
                    }
                    agentMap[agent].audits++;

                    let isFail = false;
                    let tag = 'General';

                    if (row._type === 'QC' || row['QC Score']) {
                        const score = parseFloat(row['QC Score']);
                        isFail = (score < 100) || row['Pass/Fail'] === 'Fail';
                        tag = extractQCTag(row);
                    } else {
                        isFail = row.Rating === 'Poor';
                        tag = row['User Problem'] || row['Sub-metric'] || 'General';
                    }

                    if (isFail) {
                        agentMap[agent].fails++;
                        agentMap[agent].tags[tag] = (agentMap[agent].tags[tag] || 0) + 1;
                    }
                    agentMap[agent].dates.push(row.Date || row['Review Date']);
                });

                let critical = 0, atRisk = 0, watchlist = 0;
                const agents = Object.values(agentMap).map(a => {
                    const repeatTags = Object.entries(a.tags).filter(([t, c]) => c > 1);
                    const isRepeatOffender = repeatTags.length > 0;

                    let risk = 0;
                    if (a.fails > 3) risk += 50;
                    if (isRepeatOffender) risk += 30;
                    if (a.fails > 0 && a.audits < 5) risk += 10;

                    a.riskScore = Math.min(100, risk);
                    a.topIssue = Object.entries(a.tags).sort((x, y) => y[1] - x[1])[0]?.[0] || 'None';
                    a.recidivism = isRepeatOffender;

                    if (a.riskScore >= 50) { a.tier = 'Critical'; critical++; }
                    else if (a.riskScore >= 30) { a.tier = 'At Risk'; atRisk++; }
                    else if (a.fails > 0) { a.tier = 'Watchlist'; watchlist++; }
                    else { a.tier = 'Safe'; }

                    return a;
                }).filter(a => a.fails > 0).sort((a, b) => b.riskScore - a.riskScore);

                const recidivismRate = agents.length > 0 ? ((agents.filter(a => a.recidivism).length / agents.length) * 100).toFixed(0) : 0;
                return { agents, critical, atRisk, watchlist, recidivismRate, totalAudits };
            }, [data]);

            const filteredAgents = filterRisk === 'All' ? stats.agents : stats.agents.filter(a => a.tier === filterRisk);
            const offendersTable = useSortableTable(filteredAgents);

            // Calculate review data for QC agent-wise breakdown
            const reviewData = useMemo(() => {
                return allAgents.map(agent => {
                    const agentData = safeData.filter(r => DataEngine.normalizeAgent(r, 'QC') === agent);
                    const scores = agentData.map(r => parseFloat(r['QC Score'])).filter(s => !isNaN(s));
                    const totalScore = scores.length > 0 ? scores.reduce((a, b) => a + b, 0) : 0;
                    const fails = agentData.filter(r => r.isFail || parseFloat(r['QC Score']) < 1).length;
                    const appeals = agentData.filter(r => r.isAppeal || (r['Appeal Status'] && String(r['Appeal Status']).trim() !== '')).length;
                    
                    // Collect fail reasons
                    const failReasons = [];
                    agentData.forEach(r => {
                        if (r.isFail || parseFloat(r['QC Score']) < 1) {
                            if (r.Question) failReasons.push(r.Question);
                            if (r['Answer Comment']) failReasons.push(r['Answer Comment']);
                        }
                    });
                    
                    return {
                        id: agent,
                        name: agent,
                        totalAudits: agentData.length,
                        totalScore: totalScore,
                        fails: fails,
                        appeals: appeals,
                        failReasons: failReasons.slice(0, 5) // Keep top 5
                    };
                });
            }, [allAgents, safeData]);

            // Calculate repeat offenders (agents with >2 fails)
            const repeatOffenders = useMemo(() => {
                return reviewData.filter(a => a.fails > 2).sort((a, b) => b.fails - a.fails);
            }, [reviewData]);

            // Sort agents
            const sortedAgents = useMemo(() => {
                const agentStats = {};
                reviewData.forEach(a => {
                    agentStats[a.id] = a;
                });
                
                return [...allAgents].sort((a, b) => {
                    if (sortConfig.key === 'name') {
                        return sortConfig.direction === 'asc' 
                            ? a.localeCompare(b) 
                            : b.localeCompare(a);
                    }
                    const aVal = agentStats[a]?.[sortConfig.key] || 0;
                    const bVal = agentStats[b]?.[sortConfig.key] || 0;
                    return sortConfig.direction === 'asc' ? aVal - bVal : bVal - aVal;
                });
            }, [allAgents, reviewData, sortConfig]);

            const handleSort = (key) => {
                setSortConfig(prev => ({
                    key,
                    direction: prev.key === key && prev.direction === 'asc' ? 'desc' : 'asc'
                }));
            };

            const agentStats = {};
            reviewData.forEach(a => {
                agentStats[a.id] = a;
            });

            // Agent Detail View
            if (selectedAgent) {
                const agentData = safeData.filter(r => DataEngine.normalizeAgent(r, 'QC') === selectedAgent);
                if (!agentData || agentData.length === 0) return <div className="p-8 text-center bg-white rounded-2xl border border-slate-200">No QC data for {selectedAgent}</div>;

                const scores = agentData.map(r => parseFloat(r['QC Score'])).filter(s => !isNaN(s));
                const totalScore = scores.length > 0 ? scores.reduce((a, b) => a + b, 0) : 0;

                return (
                    <div className="space-y-6 ">
                        <div className="bg-white p-4 rounded-2xl border border-slate-200 shadow-sm flex justify-between items-center">
                            <div className="flex items-center gap-4">
                                <div className="w-12 h-12 rounded-full bg-indigo-100 flex items-center justify-center font-bold text-indigo-600 text-lg">
                                    {selectedAgent.charAt(0)}
                                </div>
                                <div>
                                    <h2 className="text-lg font-black text-slate-800">{selectedAgent}</h2>
                                    <p className="text-xs font-bold text-slate-500 uppercase tracking-wider">QC Performance Review</p>
                                </div>
                            </div>
                            <div className="flex items-center gap-4">
                                {onSelectAgent && (
                                    <button 
                                        onClick={() => onSelectAgent(null)}
                                        className="px-4 py-2 text-slate-600 hover:text-indigo-600 text-sm font-medium transition-colors"
                                    >
                                         Back to All Agents
                                    </button>
                                )}
                                <div className="text-right">
                                    <span className={`text-2xl font-black ${totalScore <= 0.5 ? 'text-emerald-500' : 'text-slate-700'}`}>{totalScore.toFixed(2)}</span>
                                    <p className="text-[10px] font-bold text-slate-500 uppercase">Total QC Score</p>
                                </div>
                            </div>
                        </div>

                        <div className="grid grid-cols-1 gap-6">
                            <Card title="Recent QC Evals" icon={CheckCircle} className="min-h-[400px]" type="Table" rowCount={agentData.length} onDownloadImage={onDownload}>
                                <div className="w-full">
                                    <table className="w-full text-left text-sm">
                                        <thead className="bg-slate-50 sticky top-0 z-20 border-b border-slate-200">
                                            <tr className="text-slate-700">
                                                <th className="p-2 font-black uppercase text-[10px] tracking-wider text-left">Date</th>
                                                <th className="p-2 font-black uppercase text-[10px] tracking-wider text-center">Question / Fail Reason</th>
                                                <th className="p-2 font-black uppercase text-[10px] tracking-wider text-center">Score</th>
                                                <th className="p-2 font-black uppercase text-[10px] tracking-wider text-center">Link</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {agentData.slice(0, 20).map((row, i) => (
                                                <tr key={i} className="border-b border-slate-50 hover:bg-slate-50">
                                                    <td className="p-2 text-xs text-slate-500 whitespace-nowrap">{DataEngine.formatDate(row.Date)}</td>
                                                    <td className="p-2 font-medium text-slate-700">
                                                        <div>{row.Question || "General Eval"}</div>
                                                        {row['Answer Comment'] && <div className="text-xs text-slate-500 mt-1 line-clamp-1">{row['Answer Comment']}</div>}
                                                    </td>
                                                    <td className="p-2 text-right font-bold">
                                                        {row['QC Score'] ? parseFloat(row['QC Score']).toFixed(2) : '-'}
                                                    </td>
                                                    <td className="p-2">
                                                        {row['Dante/BO Review Link'] ? (
                                                            <a href={row['Dante/BO Review Link']} target="_blank" rel="noopener noreferrer" className="text-blue-500 hover:underline text-xs">View</a>
                                                        ) : <span className="text-slate-300 text-xs">N/A</span>}
                                                    </td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                            </Card>
                        </div>

                        {/* AI Coaching Insights Section */}
                        <div className="mt-6">
                            <Card title="AI Coaching Insights" icon={BrainCircuit} className="border-indigo-100 shadow-sm" askAI={askAI} dataForAI={agentData.filter(d => !DataEngine.isNpsPassAllSubmetrics(d)).slice(0, 10)} rowCount={1}>
                                <div className="p-4 bg-indigo-50/50 rounded-xl border border-indigo-100 min-h-[120px]">
                                    <AIInsightBlock 
                                        data={agentData.filter(d => !DataEngine.isNpsPassAllSubmetrics(d))} 
                                        type="QC" 
                                        agentName={selectedAgent} 
                                    />
                                </div>
                            </Card>
                        </div>
                    </div>
                );
            }

            // All Agents View - With Repeat Offenders and Agent-wise Breakdown tables
            return (
                <div className="space-y-6">
                    {/* Agent Selector Dropdown - Redesigned to match Coaching Generator (Point 3) */}
                    <AgentSelector 
                        value={selectedAgent || ''} 
                        onChange={(e) => onSelectAgent && onSelectAgent(e.target.value || null)}
                        options={allAgents}
                        label={`${scope === 'QC' ? 'QC' : 'NPS'} Agent Review`}
                        selectedAgent={selectedAgent}
                        action={selectedAgent ? (
                            <button 
                                onClick={() => onSelectAgent && onSelectAgent(null)}
                                className="px-4 py-2 bg-rose-50 text-rose-600 rounded-xl font-bold text-xs hover:bg-rose-100 transition-all shadow-sm flex items-center gap-2 border border-rose-100"
                            >
                                <X size={14} /> Clear Selection
                            </button>
                        ) : null}
                    />

                    {/* KPI Cards (Point 2) */}
                    <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                        <KPICard title="Total Impacted Agents" value={stats.agents.length} icon={Users} color="slate" info="Agents with at least one failure in the current dataset." onDownloadImage={onDownload} onExpand={() => setExpandedKey('total-impacted')} askAI={askAI} />
                        <KPICard title="Systemic Recidivism Rate" value={`${stats.recidivismRate}%`} icon={RefreshCw} color="rose" info="Percentage of offenders who have failed on the SAME topic more than once." onDownloadImage={onDownload} onExpand={() => setExpandedKey('recidivism')} askAI={askAI} />
                        <KPICard title="High Risk Performance Group" value={stats.critical} icon={AlertTriangle} color="red" info="Agents with >3 failures or high repeat rates. Immediate coaching required." onDownloadImage={onDownload} onExpand={() => setExpandedKey('high-risk')} askAI={askAI} />
                        <KPICard title="Performance Watchlist" value={stats.atRisk} icon={Activity} color="orange" info="Agents showing early signs of performance regression." onDownloadImage={onDownload} onExpand={() => setExpandedKey('watchlist')} askAI={askAI} />
                    </div>

                    {/* NEW Repeat Offender Registry Table */}
                        <Card title="Repeat Offender Registry" chartId={`offender-registry-table-${scope || 'qc'}`} type="Table" infoText="Detailed analysis of QC agents with recurring performance issues."
                            onDownloadImage={onDownload}
                            onCopy={() => copyTableToClipboard('qc-offender-registry-table-el')}
                            onDownloadCSV={() => CopyUtils.copyTableCSV(offendersTable.data, ['name', 'tier', 'audits', 'fails', 'topIssue', 'recidivism'])}
                            onToggleColumns={() => showToast("Columns are fixed for offenders registry")}
                            className="border-slate-200 shadow-sm"
                            scope={scope}
                            rowCount={offendersTable.data.length}
                            headerActions={

                                <div className="flex items-center gap-2">
                                    <div className="flex gap-1 scale-90 origin-right">
                                        {['All', 'Critical', 'At Risk', 'Watchlist'].map(tier => (
                                            <button
                                                key={tier}
                                                onClick={() => setFilterRisk(tier)}
                                                className={`px-3 py-1.5 text-[10px] font-bold rounded-lg transition-all ${filterRisk === tier ? 'bg-slate-800 text-white shadow-sm' : 'text-slate-500 hover:bg-slate-100'}`}
                                            >
                                                {tier}
                                            </button>
                                        ))}
                                    </div>
                                    <button
                                        onClick={async () => {
                                            const agentsToProcess = offendersTable.data.filter(a => !offenderPlans[a.name] || offenderPlans[a.name].length === 0);
                                            
                                            if (!agentsToProcess.length) { showToast('All agents already have draft plans.', 'success'); return; }
                                            if (!confirm(`Generate draft plans for ${agentsToProcess.length} agents?`)) return;
                                            
                                            setBatchProgress({ loading: true, current: 0, total: agentsToProcess.length });
                                            showToast(`Starting batch generation for ${agentsToProcess.length} agents...`, 'info');
                                            
                                            let success = 0;
                                            let processed = 0;
                                            const chunk = (arr, size) => Array.from({ length: Math.ceil(arr.length / size) }, (v, i) => arr.slice(i * size, i * size + size));
                                            
                                            for (const batch of chunk(agentsToProcess, 3)) {
                                                await Promise.all(batch.map(async (a) => {
                                                    const prompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nGenerate 2-3 specific, actionable bullet points for a Team Leader Action Plan for agent ${a.name}.\nContext: Risk Tier (${a.tier}), Failures (${a.fails}), Top Issue (${a.topIssue}), Repeat Offender (${a.recidivism ? 'Yes' : 'No'}).\n\nSTRICT RULES:\n1. Use simple plain text (no bold, no markdown).\n2. Each bullet should be a single actionable statement.\n3. RETURN ONLY THE BULLET POINTS as plain text lines.`;
                                                    try {
                                                        const resp = await GeminiAI.generate(prompt);
                                                        const lines = resp.split('\n').map(l => l.replace(/^[-*] /, '').trim()).filter(l => l.length > 5);
                                                        if (lines.length) {
                                                            setOffenderPlans(prev => ({ ...prev, [a.name]: lines }));
                                                            success++;
                                                        }
                                                    } catch (e) {
                                                        console.error(e);
                                                    } finally {
                                                        processed++;
                                                        setBatchProgress(prev => ({ ...prev, current: processed }));
                                                    }
                                                }));
                                            }
                                            setBatchProgress({ loading: false, current: 0, total: 0 });
                                            showToast(`Draft generation complete! Updated plans for ${success} agents.`, 'success');
                                        }}
                                        className="px-2 py-1 rounded bg-indigo-50 text-indigo-600 hover:bg-indigo-100 hover:text-indigo-700 transition-all font-bold text-[10px] flex items-center gap-1 uppercase tracking-wider border border-indigo-200 no-export"
                                        data-html2canvas-ignore="true"
                                        title="Generate Draft Plans for All Visible Agents"
                                    >
                                        <Sparkles size={12} /> Draft All
                                    </button>
                                </div>
                            }
                        >
                            <div className="overflow-x-auto w-full h-auto mt-0">
                                <table id="qc-offender-registry-table-el" className="w-full text-xs text-left">
                                    <thead className="bg-slate-50 sticky top-0 z-10">
                                        <tr className="border-b border-slate-200 text-slate-700">
                                            <SortableTableHeader column="name" label="Agent" sortKey={offendersTable.sortKey} sortDirection={offendersTable.direction} onSort={offendersTable.toggleSort} onFilter={offendersTable.setColumnFilter} filterValue={offendersTable.filters['name']} data={filteredAgents} className="p-4 pl-6 font-black uppercase text-[10px] tracking-wider text-left" />
                                            <SortableTableHeader column="tier" label="Risk Tier" sortKey={offendersTable.sortKey} sortDirection={offendersTable.direction} onSort={offendersTable.toggleSort} onFilter={offendersTable.setColumnFilter} filterValue={offendersTable.filters['tier']} data={filteredAgents} className="p-4 font-black uppercase text-[10px] tracking-wider text-center" />
                                            <SortableTableHeader column="fails" label="Failures" sortKey={offendersTable.sortKey} sortDirection={offendersTable.direction} onSort={offendersTable.toggleSort} onFilter={offendersTable.setColumnFilter} filterValue={offendersTable.filters['fails']} data={filteredAgents} className="p-4 font-black uppercase text-[10px] tracking-wider text-center" />
                                            <SortableTableHeader column="topIssue" label="Top Issue" sortKey={offendersTable.sortKey} sortDirection={offendersTable.direction} onSort={offendersTable.toggleSort} onFilter={offendersTable.setColumnFilter} filterValue={offendersTable.filters['topIssue']} data={filteredAgents} className="p-4 font-black uppercase text-[10px] tracking-wider text-center" />
                                            <th className="p-4 font-black uppercase text-[10px] tracking-wider text-slate-700 text-center">Repeat Offender?</th>
                                            <th className="p-4 font-black uppercase text-[10px] tracking-wider text-slate-700 text-right pr-6">Action</th>
                                        </tr>
                                    </thead>
                                    <tbody className="divide-y divide-slate-50">
                                        {offendersTable.data.map((agent, idx) => (
                                            <tr key={idx} className="hover:bg-slate-50/80 transition-colors group">
                                                <td className="p-4 pl-6 font-bold text-slate-800 text-left">{agent.name}</td>
                                                <td className="p-2 text-center">
                                                    <span className={`px-2 py-1 rounded text-[10px] uppercase tracking-wide font-black 
                                                        ${agent.tier === 'Critical' ? 'bg-rose-100 text-rose-700' :
                                                            agent.tier === 'At Risk' ? 'bg-orange-100 text-orange-700' :
                                                                'bg-slate-100 text-slate-600'}`}>
                                                        {agent.tier}
                                                    </span>
                                                </td>
                                                <td className="p-4 text-center font-bold text-slate-600">{agent.fails}</td>
                                                <td className="p-4 text-center text-slate-600 truncate max-w-[200px]" title={agent.topIssue}>{agent.topIssue}</td>
                                                <td className="p-2 text-center">
                                                    {agent.recidivism ?
                                                        <span className="flex items-center justify-center gap-1 text-rose-600 font-bold"><AlertCircle size={12} /> Yes</span> :
                                                        <span className="text-slate-300">-</span>
                                                    }
                                                </td>
                                                <td className="p-4 text-right min-w-[300px]">
                                                    <button
                                                        onClick={async () => {
                                                            if (loadingPlans[agent.name]) return;
                                                            setLoadingPlans(prev => ({ ...prev, [agent.name]: true }));
                                                            showToast("Generating plan...", 'info');
                                                            const prompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nGenerate 2-3 specific, actionable bullet points for a Team Leader Action Plan for agent ${agent.name}.\nContext: Risk Tier (${agent.tier}), Failures (${agent.fails}), Top Issue (${agent.topIssue}), Repeat Offender (${agent.recidivism ? 'Yes' : 'No'}).\n\nSTRICT RULES:\n1. Use simple plain text (no bold, no markdown).\n2. Each bullet should be a single actionable statement.\n3. RETURN ONLY THE BULLET POINTS as plain text lines.`;
                                                            try {
                                                                const resp = await GeminiAI.generate(prompt);
                                                                const lines = resp.split('\n').map(l => l.replace(/^[-*] /, '').trim()).filter(l => l.length > 5);
                                                                setOffenderPlans(prev => ({ ...prev, [agent.name]: lines }));
                                                                showToast("Plan updated!", 'success');
                                                            } catch (e) {
                                                                showToast("Generation failed", 'error');
                                                            } finally {
                                                                setLoadingPlans(prev => ({ ...prev, [agent.name]: false }));
                                                            }
                                                        }}
                                                        disabled={loadingPlans[agent.name]}
                                                        className={`px-3 py-1.5 bg-indigo-50 hover:bg-indigo-100 text-indigo-600 rounded-lg text-[10px] font-bold transition-colors flex items-center gap-1 ml-auto no-export ${loadingPlans[agent.name] ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                        data-html2canvas-ignore="true"
                                                    >
                                                        {loadingPlans[agent.name] ? <div className="w-3 h-3 border-2 border-blue-600 border-t-transparent rounded-full animate-spin" /> : <Sparkles size={12} />}
                                                        {loadingPlans[agent.name] ? 'Drafting...' : 'Draft Plan'}
                                                    </button>
                                                    {offenderPlans[agent.name] && offenderPlans[agent.name].length > 0 && (
                                                        <ul className="mt-2 text-[10px] space-y-1 text-slate-600 list-disc pl-4 max-w-xs ml-auto text-left whitespace-pre-wrap break-words">
                                                            {offenderPlans[agent.name].map((item, i) => (
                                                                <li key={i} className="text-indigo-600 font-bold whitespace-pre-wrap">{item}</li>
                                                            ))}
                                                        </ul>
                                                    )}
                                                </td>
                                            </tr>
                                        ))}
                                        {offendersTable.data.length === 0 && (
                                            <tr>
                                                <td colSpan="6" className="p-12 text-center text-slate-400 italic">No agents found in this category.</td>
                                            </tr>
                                        )}
                                    </tbody>
                                </table>
                            </div>
                        </Card>

                    {/* Agent-wise Breakdown Table with TL Action */}
                    <Card title={batchProgress.loading ? `QC Agent Review - Processing ${batchProgress.current}/${batchProgress.total}` : "QC Agent Review"} chartId="qc-agent-review-container" rowCount={sortedAgents.length} type="Table" headerActions={<div className="flex items-center gap-2"><TableExportButtons tableId="qc-agent-review-container-table" tableData={sortedAgents.map(a => agentStats[a])} filename="qc_agent_review" columns={['Agent Name', 'Total Audits', 'Total Score', 'Fails', 'Appeals', 'TL Action Plan']} visibleColumns={visible} onToggleColumn={c => setVisible(p => p.includes(c) ? p.filter(x => x !== c) : [...p, c])} onExpand={onExpand} /><button onClick={async () => {
    const agentsToProcess = sortedAgents.filter(a => !actionPlans[agentStats[a]?.id || a] || actionPlans[agentStats[a]?.id || a].length === 0);
    if (!agentsToProcess.length) { showToast('All agents already have draft plans.', 'success'); return; }
    if (!confirm(`Generate draft plans for ${agentsToProcess.length} agents?`)) return;
    setBatchProgress({ loading: true, current: 0, total: agentsToProcess.length });
    let success = 0;
    let processed = 0;
    const chunk = (arr, size) => Array.from({ length: Math.ceil(arr.length / size) }, (v, i) => arr.slice(i * size, i * size + size));
    const batches = chunk(agentsToProcess, 3);
    for (let i = 0; i < batches.length; i++) {
        const batch = batches[i];
        await Promise.all(batch.map(async (agent) => {
            const stats = agentStats[agent];
            const failReasons = stats?.failReasons?.join(', ') || 'QC failures';
            const prompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nGenerate 2-3 specific, actionable bullet points for a Team Leader Action Plan for QC agent ${stats?.id || agent}. Failures: ${failReasons}.\n\nSTRICT RULES:\n1. Use simple plain text (no bold, no markdown).\n2. Each bullet should be a single actionable statement.\n3. RETURN ONLY THE BULLET POINTS using standard Markdown format (-).\n4. **Strict Keywords:** Use ONLY Pillar names and Sub-metric names from the data.`;
            try {
                const resp = await GeminiAI.generate(prompt);
                const lines = resp.split('\n').map(l => l.replace(/^[-*] /, '').trim()).filter(l => l.length > 5);
                setActionPlans(prev => ({ ...prev, [stats?.id || agent]: [...(prev[stats?.id || agent] || []), ...lines] }));
                success++;
            } catch (e) {
                console.error(e);
            } finally {
                processed++;
                setBatchProgress(prev => ({ ...prev, current: processed }));
            }
        }));
    }
    setBatchProgress({ loading: false, current: 0, total: 0 });
    showToast(`Draft generation complete! Updated plans for ${success} agents.`, 'success');
}} className="px-2 py-1 rounded bg-indigo-50 text-indigo-600 hover:bg-indigo-100 hover:text-indigo-700 transition-all font-bold text-[10px] flex items-center gap-1 uppercase tracking-wider border border-indigo-200 no-export" data-html2canvas-ignore="true" title="Generate Draft Plans for All Visible Agents"><span className="inline-flex items-center gap-1"><Sparkles size={12} /> Draft All</span></button></div>} infoText="Detailed QC breakdown per agent. Shows total audits, scores, fails, and appeals." dataForAI={reviewData.slice(0, 10)} scope={scope}>
                        <div className="w-full h-auto flex flex-col">
                            <div id="qc-agent-review-container-table" className="border border-slate-200 rounded-xl w-full h-auto">
                                <table className="w-full text-sm text-left border-collapse">
                                    <thead className="bg-slate-50 sticky top-0 z-20">
                                        <tr className="border-b border-slate-200 text-slate-700">
                                            {visible.includes('Agent Name') && <th className="p-3 font-black uppercase text-[10px] tracking-wider cursor-pointer hover:bg-slate-100 border-r text-left" onClick={() => handleSort('name')}>Agent Name {sortConfig.key === 'name' && (sortConfig.direction === 'asc' ? '' : '')}</th>}
                                            {visible.includes('Total Audits') && <th className="p-3 font-black uppercase text-[10px] tracking-wider cursor-pointer hover:bg-slate-100 text-center border-r" onClick={() => handleSort('totalAudits')}>Total Audits {sortConfig.key === 'totalAudits' && (sortConfig.direction === 'asc' ? '' : '')}</th>}
                                            {visible.includes('Total Score') && <th className="p-3 font-black uppercase text-[10px] tracking-wider cursor-pointer hover:bg-slate-100 text-center border-r" onClick={() => handleSort('totalScore')}>Total Score {sortConfig.key === 'totalScore' && (sortConfig.direction === 'asc' ? '' : '')}</th>}
                                            {visible.includes('Fails') && <th className="p-3 font-black uppercase text-[10px] tracking-wider cursor-pointer hover:bg-slate-100 text-center border-r" onClick={() => handleSort('fails')}>Fails {sortConfig.key === 'fails' && (sortConfig.direction === 'asc' ? '' : '')}</th>}
                                            {visible.includes('Appeals') && <th className="p-3 font-black uppercase text-[10px] tracking-wider cursor-pointer hover:bg-slate-100 text-center border-r" onClick={() => handleSort('appeals')}>Appeals {sortConfig.key === 'appeals' && (sortConfig.direction === 'asc' ? '' : '')}</th>}
                                            {visible.includes('TL Action Plan') && <th className="p-3 font-black uppercase text-[10px] tracking-wider text-slate-700 text-center whitespace-nowrap">TL Action Plan</th>}
                                        </tr>
                                    </thead>
                                    <tbody className="bg-white divide-y divide-slate-100">
                                        {sortedAgents.length === 0 ? (
                                            <tr>
                                                <td colSpan={visible.length} className="p-8 text-center text-slate-500">
                                                    No agents found in the data
                                                </td>
                                            </tr>
                                        ) : (
                                            sortedAgents.map((agent, i) => {
                                                const stats = agentStats[agent];
                                                return (
                                                    <tr key={i} className="border-b border-slate-100 hover:bg-indigo-50 transition-colors">
                                                        {visible.includes('Agent Name') && (
                                                            <td className="p-3 border-r border-slate-100">
                                                                <div className="flex items-center gap-3">
                                                                    <div className="w-8 h-8 rounded-full bg-indigo-100 flex items-center justify-center font-bold text-indigo-600 text-sm">
                                                                        {agent.charAt(0)}
                                                                    </div>
                                                                    <span className="font-medium text-slate-700">{agent}</span>
                                                                </div>
                                                            </td>
                                                        )}
                                                        {visible.includes('Total Audits') && <td className="p-3 text-center font-medium text-slate-600 border-r border-slate-100">{stats?.totalAudits || 0}</td>}
                                                        {visible.includes('Total Score') && (
                                                            <td className="p-3 text-center border-r border-slate-100">
                                                                <span className={`font-bold ${(parseFloat(stats?.totalScore) || 0) <= 0.5 ? 'text-emerald-600' : (parseFloat(stats?.totalScore) || 0) <= 1.0 ? 'text-amber-600' : 'text-rose-600'}`}>
                                                                    {typeof stats?.totalScore === 'number' ? stats.totalScore.toFixed(2) : (parseFloat(stats?.totalScore) || 0).toFixed(2)}
                                                                </span>
                                                            </td>
                                                        )}
                                                        {visible.includes('Fails') && (
                                                            <td className="p-3 text-center border-r border-slate-100">
                                                                <span className={`font-bold ${(stats?.fails || 0) === 0 ? 'text-emerald-600' : 'text-rose-600'}`}>
                                                                    {stats?.fails || 0}
                                                                </span>
                                                            </td>
                                                        )}
                                                        {visible.includes('Appeals') && <td className="p-3 text-center font-medium text-slate-600 border-r border-slate-100">{stats?.appeals || 0}</td>}
                                                        {visible.includes('TL Action Plan') && (
                                                            <td className="p-3 min-w-[250px] max-w-xs whitespace-pre-wrap break-words">
                                                                <ul className="text-xs space-y-2 text-slate-500 list-disc pl-4 font-medium whitespace-pre-wrap break-words" style={{ listStyleType: 'disc', paddingLeft: '20px', margin: 0, color: '#64748b' }}>
                                                                    <li style={{ marginBottom: '8px' }}>121 File feedback</li>
                                                                    <li style={{ marginBottom: '8px' }}>Weekly Performance Summary in Slack group DM.</li>
                                                                    <li style={{ marginBottom: '8px' }}>Additional Chat Reviews.</li>
                                                                    {actionPlans[stats.id] && actionPlans[stats.id].map((item, idx) => (
                                                                        <li key={`gen-${idx}`} className="text-indigo-600 animate-in fade-in font-bold">{item}</li>
                                                                    ))}
                                                                </ul>
                                                                <button
                                                                    onClick={async () => {
                                                                        if (loadingPlans[stats.id]) return;
                                                                        setLoadingPlans(prev => ({ ...prev, [stats.id]: true }));
                                                                        showToast("Generating plan...", 'info');
                                                                        const failReasons = stats.failReasons?.join(', ') || 'QC failures';
                                                                        const prompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nGenerate 2-3 specific, actionable bullet points for a Team Leader Action Plan for QC agent ${stats.id}. Failures: ${failReasons}.\n\nSTRICT RULES:\n1. Use simple plain text (no bold, no markdown).\n2. Each bullet should be a single actionable statement.\n3. RETURN ONLY THE BULLET POINTS using standard Markdown format (-).\n4. **Strict Keywords:** Use ONLY Pillar names and Sub-metric names from the data.`;
                                                                        try {
                                                                            const resp = await GeminiAI.generate(prompt);
                                                                            const lines = resp.split('\n').map(l => l.replace(/^[-*] /, '').trim()).filter(l => l.length > 5);
                                                                            setActionPlans(prev => ({ ...prev, [stats.id]: [...(prev[stats.id] || []), ...lines] }));
                                                                            showToast("Plan updated!", 'success');
                                                                        } catch (e) {
                                                                            console.error(e);
                                                                            showToast("Generation failed", 'error');
                                                                        } finally {
                                                                            setLoadingPlans(prev => ({ ...prev, [stats.id]: false }));
                                                                        }
                                                                    }}
                                                                    disabled={loadingPlans[stats.id]}
                                                                    className={`mt-3 px-2 py-1 bg-blue-50 text-blue-600 rounded font-bold hover:bg-blue-100 transition-all text-[10px] no-export flex items-center gap-1 ${loadingPlans[stats.id] ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                                    data-html2canvas-ignore="true"
                                                                >
                                                                    {loadingPlans[stats.id] ? <div className="w-3 h-3 border-2 border-blue-600 border-t-transparent rounded-full animate-spin" /> : <Sparkles size={10} />}
                                                                    {loadingPlans[stats.id] ? 'Drafting...' : 'Draft Plan'}
                                                                </button>
                                                            </td>
                                                        )}
                                                    </tr>
                                                );
                                            })
                                        )}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </Card>

                    {/* Modal for expanded views */}
                    <Modal isOpen={!!expandedKey} onClose={() => setExpandedKey(null)} title={expandedKey} onDownloadImage={onDownload}>
                        {expandedKey === 'Repeat Offenders' && (
                            <div className="p-4 space-y-4">
                                {repeatOffenders.map(a => (
                                    <div key={a.id} className="p-4 bg-orange-50 rounded-xl border border-orange-100">
                                        <div className="flex justify-between items-center mb-2">
                                            <span className="font-bold text-slate-800 text-lg">{a.id}</span>
                                            <span className="font-bold px-3 py-1 bg-white rounded-lg shadow-sm text-orange-600 border border-orange-200">{a.fails} Fails</span>
                                        </div>
                                        {/* Grid container */}
                                        <div className="grid grid-cols-2 gap-4 text-sm mt-2">
                                            <div className="p-2 rounded-lg bg-slate-50 text-slate-600">
                                                Total Audits: {a.totalAudits}
                                            </div>
                                            <div className="p-2 rounded-lg bg-red-100 text-red-800 font-bold">
                                                Fail Rate: {((a.fails / a.totalAudits) * 100).toFixed(0)}%
                                            </div>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </Modal>
                </div>
            );
        };

        // --- AGENT REVIEW VIEW (NPS) ---
        // FIXED: Moved all hooks to top level to prevent React Error #300
        const SmartFeedbackList = ({ data, type }) => {
            const [processedItems, setProcessedItems] = useState({});
            const [processing, setProcessing] = useState({});

            // FIX: Listen for process-all-feedback event
            React.useEffect(() => {
                const handleProcessAll = (e) => {
                    if (e.detail.type === type) {
                        // Process all items in sequence
                        data.forEach((row, index) => {
                            const rawText = getRawFeedback(row);
                            if (!processedItems[index] && rawText !== "No text feedback.") {
                                processFeedback(index, rawText);
                            }
                        });
                    }
                };
                window.addEventListener('process-all-feedback', handleProcessAll);
                return () => window.removeEventListener('process-all-feedback', handleProcessAll);
            }, [data, type, processedItems]);

            const getRawFeedback = (row) => {
                if (type === 'NPS') {
                    return row['Remediation Feedback'] || row['Feedback'] || "No text feedback.";
                } else if (type === 'QC') {
                    const rca = row['TL RCA'] ? `TL RCA: ${row['TL RCA']}` : '';
                    const comment = row['Answer Comment'] ? `Answer Comment: ${row['Answer Comment']}` : '';
                    return [rca, comment].filter(Boolean).join('\n') || "No text feedback.";
                }
                // Fallback
                return row.Feedback || row['Remediation Feedback'] || row['Comment'] || row['Comments'] || row['Verbatim'] || row['Notes'] || row['Answer Comment'] || row['TL RCA'] || "No text feedback.";
            };

            const processFeedback = async (index, text) => {
                if (processing[index] || !text || text === "No text feedback.") return;
                
                setProcessing(prev => ({ ...prev, [index]: true }));
                
                // Extract links
                const linkRegex = /(https?:\/\/[^\s]+)/g;
                const links = text.match(linkRegex) || [];
                const textWithoutLinks = text.replace(linkRegex, '[LINK]');

                const prompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nRewrite this feedback as constructive feedback from a Team Leader to an Agent. \n\nRaw Feedback: "${textWithoutLinks}"\n\nOutput only the constructive feedback message.`;

                try {
                    const result = await GeminiAI.generate(prompt);
                    // Append links back
                    const finalOutput = result + (links.length > 0 ? `\n\nReferences:\n${links.join('\n')}` : '');
                    
                    setProcessedItems(prev => ({ ...prev, [index]: finalOutput }));
                } catch (e) {
                    console.error("Feedback processing failed", e);
                } finally {
                    setProcessing(prev => ({ ...prev, [index]: false }));
                }
            };

            return (
                <div className="overflow-y-auto h-full pr-2 space-y-3 custom-scrollbar">
                    {data.map((row, i) => {
                        const rawText = getRawFeedback(row);
                        const isProcessed = !!processedItems[i];
                        const isProcessing = !!processing[i];

                        return (
                            <div key={i} className="p-3 bg-slate-50 rounded-lg border border-slate-100 hover:bg-white hover:shadow-sm transition-all group">
                                <div className="flex justify-between mb-1">
                                    <span className="font-bold text-[10px] uppercase text-slate-500">{DataEngine.formatDate(row.Date)}</span>
                                    <span className={`font-bold text-xs ${row.Rating >= 9 ? 'text-emerald-600' : (row.Rating <= 6 ? 'text-rose-600' : 'text-amber-600')}`}>
                                        {row.Rating ? `${row.Rating}/10` : (row['QC Score'] ? `${(parseFloat(row['QC Score'])*100).toFixed(0)}%` : '-')}
                                    </span>
                                </div>
                                
                                <div className="relative">
                                    <p className={`text-xs text-slate-600 whitespace-pre-wrap ${isProcessed ? 'font-medium text-slate-800' : 'line-clamp-3'}`}>
                                        {isProcessed ? processedItems[i] : rawText}
                                    </p>
                                    
                                    {!isProcessed && rawText !== "No text feedback." && (
                                        <button 
                                            onClick={() => processFeedback(i, rawText)}
                                            disabled={isProcessing}
                                            className="mt-2 text-[10px] font-bold text-indigo-600 hover:text-indigo-700 flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity"
                                        >
                                            {isProcessing ? <div className="w-3 h-3 border-2 border-indigo-600 border-t-transparent rounded-full animate-spin" /> : <Sparkles size={10} />}
                                            {isProcessing ? 'Refining...' : 'Refine with AI'}
                                        </button>
                                    )}
                                </div>
                            </div>
                        );
                    })}
                </div>
            );
        };

        const AgentReviewView = ({ data, metricsMapping, onDownload, onExpand, askAI, selectedAgent, onSelectAgent, scope }) => {
            // All hooks must be called at the top level, never conditionally
            const [showValues, setShowValues] = useState(true);
            const [sortConfig, setSortConfig] = useState({ key: 'passRate', direction: 'desc' });
            const [expandedKey, setExpandedKey] = useState(null);
            const [visible, setVisible] = useState(['Agent Email', 'Audit Count', 'Communication', 'Personalisation', 'Efficiency', 'TL Action Plan']);
            const [actionPlans, setActionPlans] = useState({});
            const [offenderPlans, setOffenderPlans] = useState({});
            const [loadingPlans, setLoadingPlans] = useState({});
            const [batchProgress, setBatchProgress] = useState({ loading: false, current: 0, total: 0 });
            
            // NEW: State for Repeat Offender Registry
            const [filterRisk, setFilterRisk] = useState('All');
            const stats = useMemo(() => {
                const agentMap = {};
                let totalAudits = 0;
                
                const sourceData = data || [];

                sourceData.forEach(row => {
                    const agent = DataEngine.normalizeAgent(row, 'NPS') || DataEngine.normalizeAgent(row, 'QC') || 'Unknown';
                    if (!agent || agent === 'Unknown') return;
                    totalAudits++;

                    if (!agentMap[agent]) {
                        agentMap[agent] = {
                            name: agent,
                            audits: 0,
                            fails: 0,
                            tags: {},
                            scores: [],
                            dates: [],
                            riskScore: 0
                        };
                    }
                    agentMap[agent].audits++;

                    let isFail = false;
                    let tag = 'General';

                    if (row._type === 'QC' || row['QC Score']) {
                        const score = parseFloat(row['QC Score']);
                        isFail = (score < 100) || row['Pass/Fail'] === 'Fail';
                        tag = extractQCTag(row);
                    } else {
                        isFail = row.Rating === 'Poor';
                        tag = row['User Problem'] || row['Sub-metric'] || 'General';
                    }

                    if (isFail) {
                        agentMap[agent].fails++;
                        agentMap[agent].tags[tag] = (agentMap[agent].tags[tag] || 0) + 1;
                    }
                    agentMap[agent].dates.push(row.Date || row['Review Date']);
                });

                let critical = 0, atRisk = 0, watchlist = 0;
                const agents = Object.values(agentMap).map(a => {
                    const repeatTags = Object.entries(a.tags).filter(([t, c]) => c > 1);
                    const isRepeatOffender = repeatTags.length > 0;

                    let risk = 0;
                    if (a.fails > 3) risk += 50;
                    if (isRepeatOffender) risk += 30;
                    if (a.fails > 0 && a.audits < 5) risk += 10;

                    a.riskScore = Math.min(100, risk);
                    a.topIssue = Object.entries(a.tags).sort((x, y) => y[1] - x[1])[0]?.[0] || 'None';
                    a.recidivism = isRepeatOffender;

                    if (a.riskScore >= 50) { a.tier = 'Critical'; critical++; }
                    else if (a.riskScore >= 30) { a.tier = 'At Risk'; atRisk++; }
                    else if (a.fails > 0) { a.tier = 'Watchlist'; watchlist++; }
                    else { a.tier = 'Safe'; }

                    return a;
                }).filter(a => a.fails > 0).sort((a, b) => b.riskScore - a.riskScore);

                const recidivismRate = agents.length > 0 ? ((agents.filter(a => a.recidivism).length / agents.length) * 100).toFixed(0) : 0;
                return { agents, critical, atRisk, watchlist, recidivismRate, totalAudits };
            }, [data]);

            const filteredAgents = filterRisk === 'All' ? stats.agents : stats.agents.filter(a => a.tier === filterRisk);
            const offendersTable = useSortableTable(filteredAgents);

            // Get all unique agents
            const allAgents = useMemo(() => {
                const agents = new Set();
                data.forEach(r => {
                    const agent = DataEngine.normalizeAgent(r, 'NPS');
                    if (agent) agents.add(agent);
                });
                return Array.from(agents).sort();
            }, [data]);

            // Calculate review data for agent-wise breakdown table
            const reviewData = useMemo(() => {
                const agents = {};
                data.forEach(row => {
                    const id = DataEngine.normalizeAgent(row, 'NPS');
                    if (!id) return;
                    if (!agents[id]) agents[id] = { id, email: row.Email || row['Agent Email'] || id, audits: 0, Communication: {}, Personalisation: {}, Efficiency: {} };
                    agents[id].audits++;
                    Object.entries(metricsMapping || NPS_METRIC_MAPPING).forEach(([p, metrics]) => {
                        metrics.forEach(m => {
                            if (row[m] === false || row[m] === 'FALSE' || row[m] === 'No' || row[m] === 'Fail') {
                                agents[id][p][m] = (agents[id][p][m] || 0) + 1;
                            }
                        });
                    });
                });
                return Object.values(agents);
            }, [data, metricsMapping]);

            // Calculate repeat offenders (agents with >2 errors)
            const repeatOffenders = useMemo(() => {
                return reviewData.map(a => {
                    const totalFails = Object.values(a.Communication || {}).reduce((sum, count) => sum + count, 0) +
                        Object.values(a.Personalisation || {}).reduce((sum, count) => sum + count, 0) +
                        Object.values(a.Efficiency || {}).reduce((sum, count) => sum + count, 0);
                    return { ...a, totalFails };
                }).filter(a => a.totalFails > 2)
                    .sort((a, b) => b.totalFails - a.totalFails);
            }, [reviewData]);

            // Sortable table for agent review
            const { data: sorted, toggleSort, setQuery, query, sortKey, direction, setColumnFilter, filters } = useSortableTable(reviewData, 'id');

            // Calculate stats for all agents (for the agent list view)
            const agentStats = useMemo(() => {
                const stats = {};
                const allSubMetrics = Object.values(NPS_METRIC_MAPPING).flat();
                allAgents.forEach(agent => {
                    const agentData = data.filter(r => DataEngine.normalizeAgent(r, 'NPS') === agent);
                    
                    // Calculate Pass Rate based on sub-metrics (not Rating)
                    const passCount = agentData.filter(r => allSubMetrics.every(m => {
                        const val = r[m];
                        return val === true || String(val).toUpperCase() === 'TRUE' || val === 1 || val === '1';
                    })).length;
                    const passRate = agentData.length > 0 ? ((passCount / agentData.length) * 100) : 0;
                    
                    // All metrics pass = Promoter equivalent
                    const promoters = passCount;
                    // Any metric fail = Detractor equivalent  
                    const detractors = agentData.length - passCount;
                    
                    stats[agent] = {
                        totalChats: agentData.length,
                        passRate: passRate,
                        promoters: promoters,
                        detractors: detractors,
                        npsScore: passRate // Use pass rate as NPS score
                    };
                });
                return stats;
            }, [allAgents, data]);

            // Sort agents
            const sortedAgents = useMemo(() => {
                return [...allAgents].sort((a, b) => {
                    if (sortConfig.key === 'name') {
                        return sortConfig.direction === 'asc' 
                            ? a.localeCompare(b) 
                            : b.localeCompare(a);
                    }
                    const aVal = agentStats[a]?.[sortConfig.key] || 0;
                    const bVal = agentStats[b]?.[sortConfig.key] || 0;
                    return sortConfig.direction === 'asc' ? aVal - bVal : bVal - aVal;
                });
            }, [allAgents, agentStats, sortConfig]);

            const handleSort = (key) => {
                setSortConfig(prev => ({
                    key,
                    direction: prev.key === key && prev.direction === 'asc' ? 'desc' : 'asc'
                }));
            };

            const renderFails = (fails) => {
                const entries = Object.entries(fails);
                if (entries.length === 0) return <span className="text-slate-600 italic font-medium" style={{ fontStyle: 'italic', color: '#000000' }}> No fails</span>;
                return (
                    <ul className="text-xs space-y-1 text-slate-600 list-disc pl-4 font-medium whitespace-pre-wrap text-left" style={{ listStyleType: 'disc', paddingLeft: '20px', margin: 0, color: '#475569' }}>
                        {entries.map(([n, c]) => (
                            <li key={n} style={{ marginBottom: '4px' }}>
                                {n} - <b style={{ color: '#0f172a' }}>{c}</b>
                            </li>
                        ))}
                    </ul>
                );
            };

            // Agent Detail View
            if (selectedAgent) {
                const agentData = data.filter(r => DataEngine.normalizeAgent(r, 'NPS') === selectedAgent && !DataEngine.isAppeal(r));
                if (agentData.length === 0) return <div className="p-8 text-center bg-white rounded-2xl border border-slate-200">No data for {selectedAgent}</div>;

                // Calculate NPS Pass Rate based on sub-metrics (not average Rating)
                const allSubMetrics = Object.values(NPS_METRIC_MAPPING).flat();
                const passCount = agentData.filter(r => {
                    return allSubMetrics.every(m => {
                        const val = r[m];
                        return val === true || String(val).toUpperCase() === 'TRUE' || val === 1 || val === '1';
                    });
                }).length;
                const passRate = agentData.length > 0 ? ((passCount / agentData.length) * 100).toFixed(1) : "N/A";

                return (
                    <div className="space-y-6 ">
                        <div className="bg-white p-4 rounded-2xl border border-slate-200 shadow-sm flex justify-between items-center">
                            <div className="flex items-center gap-4">
                                <div className="w-12 h-12 rounded-full bg-indigo-100 flex items-center justify-center font-bold text-indigo-600 text-lg">
                                    {selectedAgent.charAt(0)}
                                </div>
                                <div>
                                    <h2 className="text-lg font-black text-slate-800">{selectedAgent}</h2>
                                    <p className="text-xs font-bold text-slate-500 uppercase tracking-wider">NPS Performance Review</p>
                                </div>
                            </div>
                            <div className="flex items-center gap-4">
                                {onSelectAgent && (
                                    <button 
                                        onClick={() => onSelectAgent(null)}
                                        className="px-4 py-2 text-slate-600 hover:text-indigo-600 text-sm font-medium transition-colors"
                                    >
                                         Back to All Agents
                                    </button>
                                )}
                                <div className="text-right">
                                    <span className={`text-2xl font-black ${parseFloat(passRate) >= 85 ? 'text-emerald-500' : 'text-slate-700'}`}>{passRate}%</span>
                                    <p className="text-[10px] font-bold text-slate-500 uppercase">Pass Rate</p>
                                </div>
                            </div>
                        </div>

                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6 overflow-visible">
                            <Card title="Recent Feedback" type="Table" icon={MessageSquare} className="h-96" onDownloadImage={onDownload}
                                headerActions={(
                                    <button 
                                        onClick={() => {
                                            const feedbackData = agentData.filter(d => !DataEngine.isNpsPassAllSubmetrics(d)).slice(0, 15);
                                            if (!feedbackData.length) { showToast('No feedback to process', 'error'); return; }
                                            showToast(`Processing ${feedbackData.length} feedback items...`, 'info');
                                            // Dispatch event to trigger processing in SmartFeedbackList
                                            window.dispatchEvent(new CustomEvent('process-all-feedback', { detail: { type: scope || 'NPS' } }));
                                        }}
                                        className="px-3 py-1.5 bg-blue-50 text-blue-600 rounded-lg text-[10px] font-bold hover:bg-blue-100 transition-all flex items-center gap-1"
                                    >
                                        <Sparkles size={12} /> Process All
                                    </button>
                                )}
                            >
                                <SmartFeedbackList data={agentData.filter(d => !DataEngine.isNpsPassAllSubmetrics(d)).slice(0, 15)} type={scope || 'NPS'} />
                            </Card>
                            <Card title="Score Distribution" icon={PieIcon} className="h-96" onDownloadImage={onDownload} showValues={showValues} toggleValues={() => setShowValues(!showValues)}>
                                <ResponsiveContainer width="100%" height="100%">
                                    <BarChart data={[
                                        { name: 'Promoters', value: agentData.filter(d => DataEngine.getRatingCat(d.Rating) === 'Promoter').length, fill: '#10b981' },
                                        { name: 'Passives', value: agentData.filter(d => DataEngine.getRatingCat(d.Rating) === 'Neutral').length, fill: '#f59e0b' },
                                        { name: 'Detractors', value: agentData.filter(d => DataEngine.getRatingCat(d.Rating) === 'Detractor').length, fill: '#ef4444' }
                                    ]} margin={{ top: 20, bottom: 20 }}>
                                        <CartesianGrid strokeDasharray="3 3" vertical={false} />
                                        <XAxis dataKey="name" tick={<CustomizedAxisTick />} interval={0} axisLine={false} tickLine={false} />
                                        <YAxis tick={{ fontSize: 10 }} axisLine={false} tickLine={false} />
                                        <Tooltip cursor={{ fill: 'transparent' }} contentStyle={{ borderRadius: '8px', border: 'none', boxShadow: '0 4px 6px -1px rgb(0 0 0 / 0.1)' }} />
                                        <Bar dataKey="value" barSize={40} radius={[4, 4, 0, 0]}>
                                            {showValues && <LabelList dataKey="value" position="top" style={{ fontSize: 10, fill: '#64748b', fontWeight: 700 }} />}
                                        </Bar>
                                    </BarChart>
                                </ResponsiveContainer>
                            </Card>
                        </div>

                        {/* AI Coaching Insights Section */}
                        <div className="mt-6">
                            <Card title="AI Coaching Insights" icon={BrainCircuit} className="border-indigo-100 shadow-sm" askAI={askAI} dataForAI={agentData.slice(0, 10)} rowCount={1}>
                                <div className="p-4 bg-indigo-50/50 rounded-xl border border-indigo-100 min-h-[120px]">
                                    <AIInsightBlock 
                                        data={agentData.filter(d => !DataEngine.isNpsPassAllSubmetrics(d))} 
                                        type={scope || 'NPS'} 
                                        agentName={selectedAgent} 
                                    />
                                </div>
                            </Card>
                        </div>
                    </div>
                );
            }

            // All Agents View - With Repeat Offenders and Agent-wise Breakdown tables
            return (
                <div className="space-y-6">
                    {/* Agent Selector Dropdown - Redesigned to match Coaching Generator (Point 3) */}
                    <AgentSelector 
                        value={selectedAgent || ''} 
                        onChange={(e) => onSelectAgent && onSelectAgent(e.target.value || null)}
                        options={allAgents}
                        label={`${scope === 'QC' ? 'QC' : 'NPS'} Agent Review`}
                        selectedAgent={selectedAgent}
                        action={selectedAgent ? (
                            <button 
                                onClick={() => onSelectAgent && onSelectAgent(null)}
                                className="px-4 py-2 bg-rose-50 text-rose-600 rounded-xl font-bold text-xs hover:bg-rose-100 transition-all shadow-sm flex items-center gap-2 border border-rose-100"
                            >
                                <X size={14} /> Clear Selection
                            </button>
                        ) : null}
                    />

                    {/* KPI Cards - Moved from Matrix page (Point 1) */}
                    <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                        <KPICard title="Total Impacted Agents" value={stats.agents.length} icon={Users} color="slate" info="Agents with at least one failure in the current dataset." onDownloadImage={onDownload} onExpand={() => setExpandedKey('total-impacted')} askAI={askAI} />
                        <KPICard title="Systemic Recidivism Rate" value={`${stats.recidivismRate}%`} icon={RefreshCw} color="rose" info="Percentage of offenders who have failed on the SAME topic more than once." onDownloadImage={onDownload} onExpand={() => setExpandedKey('recidivism')} askAI={askAI} />
                        <KPICard title="High Risk Performance Group" value={stats.critical} icon={AlertTriangle} color="red" info="Agents with >3 failures or high repeat rates. Immediate coaching required." onDownloadImage={onDownload} onExpand={() => setExpandedKey('high-risk')} askAI={askAI} />
                        <KPICard title="Performance Watchlist" value={stats.atRisk} icon={Activity} color="orange" info="Agents showing early signs of performance regression." onDownloadImage={onDownload} onExpand={() => setExpandedKey('watchlist')} askAI={askAI} />
                    </div>

                    {/* NEW Repeat Offender Registry Table */}
                        <Card title="Repeat Offender Registry" chartId={`offender-registry-table-${scope || 'nps'}`} type="Table" infoText="Detailed analysis of agents with recurring performance issues."
                            onDownloadImage={onDownload}
                            onCopy={() => copyTableToClipboard(`offender-registry-table-el`)}
                            onDownloadCSV={() => CopyUtils.copyTableCSV(offendersTable.data, ['name', 'tier', 'audits', 'fails', 'topIssue', 'recidivism'])}
                            onToggleColumns={() => showToast("Columns are fixed for offenders registry")}
                            className="border-slate-200 shadow-sm"
                            scope={scope}
                            rowCount={offendersTable.data.length}
                            headerActions={

                                <div className="flex items-center gap-2">
                                    <div className="flex gap-1 scale-90 origin-right">
                                        {['All', 'Critical', 'At Risk', 'Watchlist'].map(tier => (
                                            <button
                                                key={tier}
                                                onClick={() => setFilterRisk(tier)}
                                                className={`px-3 py-1.5 text-[10px] font-bold rounded-lg transition-all ${filterRisk === tier ? 'bg-slate-800 text-white shadow-sm' : 'text-slate-500 hover:bg-slate-100'}`}
                                            >
                                                {tier}
                                            </button>
                                        ))}
                                    </div>
                                    <button
                                        onClick={async () => {
                                            if (!offendersTable.data.length) { showToast('No agents to draft', 'error'); return; }
                                            if (!confirm(`Generate draft plans for ${offendersTable.data.length} agents?`)) return;
                                            showToast(`Starting batch generation for ${offendersTable.data.length} agents...`, 'info');
                                            let success = 0;
                                            const chunk = (arr, size) => Array.from({ length: Math.ceil(arr.length / size) }, (v, i) => arr.slice(i * size, i * size + size));
                                            for (const batch of chunk(offendersTable.data, 3)) {
                                                await Promise.all(batch.map(async (a) => {
                                                    const prompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nGenerate 2-3 specific, actionable bullet points for a Team Leader Action Plan for agent ${a.name}.\nContext: Risk Tier (${a.tier}), Failures (${a.fails}), Top Issue (${a.topIssue}), Repeat Offender (${a.recidivism ? 'Yes' : 'No'}).\n\nSTRICT RULES:\n1. Use simple plain text (no bold, no markdown).\n2. Each bullet should be a single actionable statement.\n3. RETURN ONLY THE BULLET POINTS as plain text lines.`;
                                                    try {
                                                        const resp = await GeminiAI.generate(prompt);
                                                        const lines = resp.split('\n').map(l => l.replace(/^[-*] /, '').trim()).filter(l => l.length > 5);
                                                        if (lines.length) {
                                                            setOffenderPlans(prev => ({ ...prev, [a.name]: lines }));
                                                            success++;
                                                        }
                                                    } catch (e) {}
                                                }));
                                            }
                                            setBatchProgress({ loading: false, current: 0, total: 0 });
                                            showToast(`Draft generation complete! Updated plans for ${success} agents.`, 'success');
                                        }}
                                        className="px-2 py-1 rounded bg-indigo-50 text-indigo-600 hover:bg-indigo-100 hover:text-indigo-700 transition-all font-bold text-[10px] flex items-center gap-1 uppercase tracking-wider border border-indigo-200 no-export"
                                        data-html2canvas-ignore="true"
                                        title="Generate Draft Plans for All Visible Agents"
                                    >
                                        <Sparkles size={12} /> Draft All
                                    </button>
                                </div>
                            }
                        >
                            <div className="w-full">
                                <table id="offender-registry-table-el" className="w-full text-xs text-left">
                                    <thead className="bg-slate-50 sticky top-0 z-10">
                                        <tr className="border-b border-slate-200 text-slate-700">
                                            <SortableTableHeader column="name" label="Agent" sortKey={offendersTable.sortKey} sortDirection={offendersTable.direction} onSort={offendersTable.toggleSort} onFilter={offendersTable.setColumnFilter} filterValue={offendersTable.filters['name']} data={filteredAgents} className="p-4 pl-6 font-black uppercase text-[10px] tracking-wider text-left" />
                                            <SortableTableHeader column="tier" label="Risk Tier" sortKey={offendersTable.sortKey} sortDirection={offendersTable.direction} onSort={offendersTable.toggleSort} onFilter={offendersTable.setColumnFilter} filterValue={offendersTable.filters['tier']} data={filteredAgents} className="p-4 font-black uppercase text-[10px] tracking-wider text-center" />
                                            <SortableTableHeader column="fails" label="Failures" sortKey={offendersTable.sortKey} sortDirection={offendersTable.direction} onSort={offendersTable.toggleSort} onFilter={offendersTable.setColumnFilter} filterValue={offendersTable.filters['fails']} data={filteredAgents} className="p-4 font-black uppercase text-[10px] tracking-wider text-center" />
                                            <SortableTableHeader column="topIssue" label="Top Issue" sortKey={offendersTable.sortKey} sortDirection={offendersTable.direction} onSort={offendersTable.toggleSort} onFilter={offendersTable.setColumnFilter} filterValue={offendersTable.filters['topIssue']} data={filteredAgents} className="p-4 font-black uppercase text-[10px] tracking-wider text-center" />
                                            <th className="p-4 font-black uppercase text-[10px] tracking-wider text-slate-700 text-center">Repeat Offender?</th>
                                            <th className="p-4 font-black uppercase text-[10px] tracking-wider text-slate-700 text-center pr-6">Action</th>
                                        </tr>
                                    </thead>
                                    <tbody className="divide-y divide-slate-50">
                                        {offendersTable.data.map((agent, idx) => (
                                            <tr key={idx} className="hover:bg-slate-50/80 transition-colors group">
                                                <td className="p-4 pl-6 font-bold text-slate-800 text-left">{agent.name}</td>
                                                <td className="p-2 text-center">
                                                    <span className={`px-2 py-1 rounded text-[10px] uppercase tracking-wide font-black 
                                                        ${agent.tier === 'Critical' ? 'bg-rose-100 text-rose-700' :
                                                            agent.tier === 'At Risk' ? 'bg-orange-100 text-orange-700' :
                                                                'bg-slate-100 text-slate-600'}`}>
                                                        {agent.tier}
                                                    </span>
                                                </td>
                                                <td className="p-4 text-center font-bold text-slate-600">{agent.fails}</td>
                                                <td className="p-4 text-center text-slate-600 truncate max-w-[200px]" title={agent.topIssue}>{agent.topIssue}</td>
                                                <td className="p-2 text-center text-center">
                                                    {agent.recidivism ?
                                                        <span className="flex items-center justify-center gap-1 text-rose-600 font-bold"><AlertCircle size={12} /> Yes</span> :
                                                        <span className="text-slate-300">-</span>
                                                    }
                                                </td>
                                                <td className="p-4 text-center">
                                                    <button
                                                        onClick={async () => {
                                                            showToast("Generating plan...", 'info');
                                                            const prompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nGenerate 2-3 specific, actionable bullet points for a Team Leader Action Plan for agent ${agent.name}.\nContext: Risk Tier (${agent.tier}), Failures (${agent.fails}), Top Issue (${agent.topIssue}), Repeat Offender (${agent.recidivism ? 'Yes' : 'No'}).\n\nSTRICT RULES:\n1. Use simple plain text (no bold, no markdown).\n2. Each bullet should be a single actionable statement.\n3. RETURN ONLY THE BULLET POINTS as plain text lines.`;
                                                            try {
                                                                const resp = await GeminiAI.generate(prompt);
                                                                const lines = resp.split('\n').map(l => l.replace(/^[-*] /, '').trim()).filter(l => l.length > 5);
                                                                setOffenderPlans(prev => ({ ...prev, [agent.name]: lines }));
                                                                showToast("Plan updated!", 'success');
                                                            } catch (e) {
                                                                showToast("Generation failed", 'error');
                                                            }
                                                        }}
                                                        className="px-3 py-1.5 bg-indigo-50 hover:bg-indigo-100 text-indigo-600 rounded-lg text-[10px] font-bold transition-colors flex items-center gap-1 mx-auto no-export"
                                                        data-html2canvas-ignore="true"
                                                    >
                                                        <Sparkles size={12} /> Draft Plan
                                                    </button>
                                                    {offenderPlans[agent.name] && offenderPlans[agent.name].length > 0 && (
                                                        <ul className="mt-2 text-[10px] space-y-1 text-slate-600 list-disc pl-4 max-w-[320px] mx-auto text-left">
                                                            {offenderPlans[agent.name].map((item, i) => (
                                                                <li key={i} className="text-indigo-600 font-bold whitespace-pre-wrap">{item}</li>
                                                            ))}
                                                        </ul>
                                                    )}
                                                </td>
                                            </tr>
                                        ))}
                                        {offendersTable.data.length === 0 && (
                                            <tr>
                                                <td colSpan="6" className="p-12 text-center text-slate-400 italic">No agents found in this category.</td>
                                            </tr>
                                        )}
                                    </tbody>
                                </table>
                            </div>
                        </Card>

                    {/* Agent-wise Breakdown Table with TL Action */}
                    <Card title={batchProgress.loading ? `Agent Review - Processing ${batchProgress.current}/${batchProgress.total}` : "Agent Review"} chartId="agent-review-container" rowCount={sorted.length} type="Table" headerActions={<div className="flex items-center gap-2"><div className="relative"><Search className="absolute left-3 top-2.5 text-slate-400" size={14} /><input type="text" placeholder="Search agents..." onChange={e => setQuery(e.target.value)} className="pl-9 pr-3 py-1.5 bg-white border border-slate-200 rounded-lg text-xs w-40 focus:ring-2 focus:ring-blue-500 outline-none" /></div><TableExportButtons tableId="agent-review-container-table" tableData={sorted} filename="agent_review" columns={['Agent Email', 'Audit Count', 'Communication', 'Personalisation', 'Efficiency', 'TL Action Plan']} visibleColumns={visible} onToggleColumn={c => setVisible(p => p.includes(c) ? p.filter(x => x !== c) : [...p, c])} onExpand={onExpand} /><button onClick={async () => { if (!sorted.length) { showToast('No agents to draft', 'error'); return; } if (!confirm(`Generate draft plans for ${sorted.length} agents?`)) return; setBatchProgress({ loading: true, current: 0, total: sorted.length }); let success = 0; const chunk = (arr, size) => Array.from({ length: Math.ceil(arr.length / size) }, (v, i) => arr.slice(i * size, i * size + size)); const batches = chunk(sorted, 3); for (let i = 0; i < batches.length; i++) { const batch = batches[i]; await Promise.all(batch.map(async (a) => { const commFails = Object.keys(a.Communication || {}).join(', '); const persFails = Object.keys(a.Personalisation || {}).join(', '); const effFails = Object.keys(a.Efficiency || {}).join(', '); const prompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nGenerate 2-3 specific, actionable bullet points for a Team Leader Action Plan for agent ${a.id}. Failures: Communication (${commFails}), Personalisation (${persFails}), Efficiency (${effFails}).\n\nSTRICT RULES:\n1. Use simple plain text (no bold, no markdown).\n2. Each bullet should be a single actionable statement.\n3. RETURN ONLY THE BULLET POINTS using standard Markdown format (-).\n4. **Strict Keywords:** Use ONLY Pillar names and Sub-metric names from the data.`; try { const resp = await GeminiAI.generate(prompt); const lines = resp.split('\\n').map(l => l.replace(/^[-*] /, '').trim()).filter(l => l.length > 5); setActionPlans(prev => ({ ...prev, [a.id]: [...(prev[a.id] || []), ...lines] })); success++; setBatchProgress(prev => ({ ...prev, current: prev.current + 1 })); } catch (e) { setBatchProgress(prev => ({ ...prev, current: prev.current + 1 }));} })); } showToast(`Draft generation complete! Updated plans for ${success} agents.`, 'success'); }} className="px-2 py-1 rounded bg-indigo-50 text-indigo-600 hover:bg-indigo-100 hover:text-indigo-700 transition-all font-bold text-[10px] flex items-center gap-1 uppercase tracking-wider border border-indigo-200 no-export" data-html2canvas-ignore="true" title="Generate Draft Plans for All Visible Agents"><span className="inline-flex items-center gap-1"><Sparkles size={12} /> Draft All</span></button></div>} infoText="Detailed failure breakdown per agent across all pillars. Shows total audits and fail counts per pillar (Communication, Personalisation, Efficiency)." dataForAI={reviewData.slice(0, 15)} scope={scope}>



                        <div className="w-full">
                            <table className="w-full text-sm text-left border-collapse">
                                        <thead className="bg-slate-50 sticky top-0 z-20">
                                            <tr className="border-b border-slate-200 text-slate-700">
                                                {visible.includes('Agent Email') && <SortableTableHeader column="id" label="Agent" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['id']} data={reviewData} className="p-4 font-black uppercase text-[10px] tracking-wider text-left" />}
                                                {visible.includes('Audit Count') && <SortableTableHeader column="audits" label="Audits" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['audits']} data={reviewData} className="p-4 font-black uppercase text-[10px] tracking-wider text-center" />}
                                                {visible.includes('Communication') && <SortableTableHeader column="Communication" label="Communication" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['Communication']} data={reviewData} className="p-4 font-black uppercase text-[10px] tracking-wider text-center" />}
                                                {visible.includes('Personalisation') && <SortableTableHeader column="Personalisation" label="Personalisation" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['Personalisation']} data={reviewData} className="p-4 font-black uppercase text-[10px] tracking-wider text-center" />}
                                                {visible.includes('Efficiency') && <SortableTableHeader column="Efficiency" label="Efficiency" sortKey={sortKey} sortDirection={direction} onSort={toggleSort} onFilter={setColumnFilter} filterValue={filters['Efficiency']} data={reviewData} className="p-4 font-black uppercase text-[10px] tracking-wider text-center" />}
                                                {visible.includes('TL Action Plan') && <th className="p-4 text-center font-black uppercase text-[10px] tracking-wider text-slate-700 whitespace-nowrap">TL Action Plan</th>}
                                            </tr>
                                        </thead>
                                    <tbody className="bg-white divide-y divide-slate-100">
                                        {sorted.map((a, idx) => (
                                            <tr key={idx} className="hover:bg-slate-50 transition-colors align-top">
                                                {visible.includes('Agent Email') && <td className="p-4 font-medium text-slate-700 border-r border-slate-100 break-all"><HighlightText text={a.id} highlight={query} /></td>}
                                                {visible.includes('Audit Count') && <td className="p-4 text-center font-normal text-slate-600 border-r border-slate-100">{a.audits}</td>}
                                                {visible.includes('Communication') && <td className="p-4 border-r border-slate-100 min-w-[200px] text-left">{renderFails(a.Communication)}</td>}
                                                {visible.includes('Personalisation') && <td className="p-4 border-r border-slate-100 min-w-[200px] text-left">{renderFails(a.Personalisation)}</td>}
                                                {visible.includes('Efficiency') && <td className="p-4 border-r border-slate-100 min-w-[200px] text-left">{renderFails(a.Efficiency)}</td>}
                                                {visible.includes('TL Action Plan') && (
                                                    <td className="p-4 min-w-[250px] max-w-[400px] whitespace-normal break-words text-left">
                                                        <ul className="text-xs space-y-2 text-slate-500 list-disc pl-4 font-medium whitespace-pre-wrap text-left" style={{ listStyleType: 'disc', paddingLeft: '20px', margin: 0, color: '#64748b' }}>
                                                            <li style={{ marginBottom: '8px' }}>121 File feedback</li>
                                                            <li style={{ marginBottom: '8px' }}>Weekly Performance Summary in Slack group DM.</li>
                                                            <li style={{ marginBottom: '8px' }}>Additional Chat Reviews.</li>
                                                            {actionPlans[a.id] && actionPlans[a.id].map((item, idx) => (
                                                                <li key={`gen-${idx}`} className="text-indigo-600 animate-in fade-in font-bold">{item}</li>
                                                            ))}
                                                        </ul>
                                                        <button
                                                            onClick={async () => {
                                                                if (loadingPlans[a.id]) return;
                                                                setLoadingPlans(prev => ({ ...prev, [a.id]: true }));
                                                                showToast("Generating plan...", 'info');
                                                                const commFails = Object.keys(a.Communication || {}).join(', ');
                                                                const persFails = Object.keys(a.Personalisation || {}).join(', ');
                                                                const effFails = Object.keys(a.Efficiency || {}).join(', ');
                                                                const prompt = `${AI_PERSONA}\n${TL_PERSONA_PROMPT}\n\nGenerate 2-3 specific, actionable bullet points for a Team Leader Action Plan for agent ${a.id}. Failures: Communication (${commFails}), Personalisation (${persFails}), Efficiency (${effFails}).\n\nSTRICT RULES:\n1. Use simple plain text (no bold, no markdown).\n2. Each bullet should be a single actionable statement.\n3. RETURN ONLY THE BULLET POINTS as plain text lines.`;
                                                                try {
                                                                    const resp = await GeminiAI.generate(prompt);
                                                                    const lines = resp.split('\n').map(l => l.replace(/^[-*] /, '').trim()).filter(l => l.length > 5);
                                                                    setActionPlans(prev => ({ ...prev, [a.id]: [...(prev[a.id] || []), ...lines] }));
                                                                    showToast("Plan updated!", 'success');
                                                                } catch (e) {
                                                                    console.error(e);
                                                                    showToast("Generation failed", 'error');
                                                                } finally {
                                                                    setLoadingPlans(prev => ({ ...prev, [a.id]: false }));
                                                                }
                                                            }}
                                                            disabled={loadingPlans[a.id]}
                                                            className={`mt-3 px-2 py-1 bg-blue-50 text-blue-600 rounded font-bold hover:bg-blue-100 transition-all text-[10px] no-export flex items-center gap-1 ${loadingPlans[a.id] ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                        >
                                                            {loadingPlans[a.id] ? <div className="w-3 h-3 border-2 border-blue-600 border-t-transparent rounded-full animate-spin" /> : <Sparkles size={10} />}
                                                            {loadingPlans[a.id] ? 'Drafting...' : 'Draft Plan'}
                                                        </button>
                                                    </td>
                                                )}
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                    </Card>

                    {/* Modal for expanded views */}
                    <Modal isOpen={!!expandedKey} onClose={() => setExpandedKey(null)} title={expandedKey} onDownloadImage={onDownload}>
                        {expandedKey === 'Repeat Offenders' && (
                            <div className="p-4 space-y-4">
                                {repeatOffenders.map(a => (
                                    <div key={a.id} className="p-4 bg-orange-50 rounded-xl border border-orange-100">
                                        <div className="flex justify-between items-center mb-2">
                                            <span className="font-bold text-slate-800 text-lg">{a.id}</span>
                                            <span className="font-bold px-3 py-1 bg-white rounded-lg shadow-sm text-orange-600 border border-orange-200">{a.totalFails} Errors</span>
                                        </div>
                                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm mt-2">
                                            {['Communication', 'Personalisation', 'Efficiency'].map(p => {
                                                const fails = Object.values(a[p] || {}).reduce((s, c) => s + c, 0);
                                                return (
                                                    <div key={p} className={`p-2 rounded-lg ${fails > 0 ? 'bg-red-100 text-red-800 font-bold' : 'bg-slate-50 text-slate-500'}`}>
                                                        {p}: {fails}
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </Modal>
                </div>
            );
        };

        // Upload View Component - File Upload Interface
        const UploadView = ({ onFilesProcessed }) => {
            const [files, setFiles] = useState([]);
            const [uploadProgress, setUploadProgress] = useState(0);
            const [processingStatus, setProcessingStatus] = useState('idle');
            const [dragActive, setDragActive] = useState(false);

            const handleDrag = (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (e.type === "dragenter" || e.type === "dragover") {
                    setDragActive(true);
                } else if (e.type === "dragleave") {
                    setDragActive(false);
                }
            };

            const handleDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setDragActive(false);
                
                if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                    handleFiles(e.dataTransfer.files);
                }
            };

            const handleFiles = async (fileList) => {
                setFiles(Array.from(fileList));
                setProcessingStatus('processing');
                setUploadProgress(0);
                
                const results = [];
                
                for (let i = 0; i < fileList.length; i++) {
                    const file = fileList[i];
                    setUploadProgress(((i + 1) / fileList.length) * 100);
                    
                    try {
                        const { data, agentNameMap } = await parseExcelFile(file);
                        const type = detectFileType(file, data);
                        results.push({ 
                            file: file.name, 
                            data, 
                            type,
                            size: file.size,
                            rows: data.length,
                            agentNameMap
                        });
                    } catch (error) {
                        results.push({ 
                            file: file.name, 
                            error: error.message,
                            type: 'error'
                        });
                    }
                }
                
                setProcessingStatus('complete');
                onFilesProcessed(results);
            };

            const parseExcelFile = async (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = new Uint8Array(e.target.result);
                            const workbook = XLSX.read(data, { type: 'array' });
                            
                            // Look for "My Active Team" sheet (case-insensitive, handles hidden sheets)
                            const agentNameMap = {};
                            const teamSheetName = workbook.SheetNames.find(name => 
                                name.toLowerCase().includes('my active team') || 
                                name.toLowerCase().includes('active team')
                            );
                            
                            if (teamSheetName) {
                                const teamSheet = workbook.Sheets[teamSheetName];
                                // Read with header: 1 to get raw rows (Col A = index 0, Col C = index 2)
                                const teamData = XLSX.utils.sheet_to_json(teamSheet, { header: 1, defval: '' });
                                teamData.forEach(row => {
                                    const name = row[0]; // Col A
                                    const email = row[2]; // Col C
                                    if (name && email && typeof email === 'string' && email.includes('@')) {
                                        agentNameMap[email.toLowerCase().trim()] = String(name).trim();
                                    }
                                });
                            }
                            
                            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                            const jsonData = XLSX.utils.sheet_to_json(firstSheet);
                            resolve({ data: jsonData, agentNameMap });
                        } catch (error) {
                            reject(new Error('Failed to parse Excel file: ' + error.message));
                        }
                    };
                    reader.onerror = () => reject(new Error('Failed to read file'));
                    reader.readAsArrayBuffer(file);
                });
            };

            const detectFileType = (file, data) => {
                const filename = file.name.toLowerCase();
                const headers = Object.keys(data[0] || {});
                
                // Check for NPS indicators
                const hasNPSIndicators = headers.some(h => 
                    h.toLowerCase().includes('nps') || 
                    h.toLowerCase().includes('rating') ||
                    h.toLowerCase().includes('feedback')
                );
                
                // Check for QC indicators  
                const hasQCIndicators = headers.some(h =>
                    h.toLowerCase().includes('qc') ||
                    h.toLowerCase().includes('audit') ||
                    h.toLowerCase().includes('score')
                );
                
                if (hasNPSIndicators && !hasQCIndicators) return 'NPS';
                if (hasQCIndicators && !hasNPSIndicators) return 'QC';
                if (hasNPSIndicators && hasQCIndicators) return 'Unified';
                
                return 'Unknown';
            };

            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-50 to-blue-50 p-8">
                    <div className="max-w-4xl mx-auto">
                        <div className="text-center mb-12">
                            <div className="bg-slate-900 text-white p-4 rounded-2xl shadow-2xl inline-block mb-6">
                                <LayoutDashboard size={32} />
                            </div>
                            <h1 className="text-4xl font-black text-slate-900 mb-2">POPPY SUITE</h1>
                            <p className="text-slate-600 text-lg">Upload your NPS and QC data files to begin analysis</p>
                        </div>

                        <div className="bg-white rounded-3xl shadow-xl border border-slate-200 overflow-hidden">
                            {/* Upload Area */}
                            <div 
                                className={`p-12 text-center transition-all duration-300 ${
                                    dragActive 
                                        ? 'bg-blue-50 border-blue-300 border-2 border-dashed' 
                                        : 'border-2 border-dashed border-slate-300 hover:border-blue-400'
                                }`}
                                onDragEnter={handleDrag}
                                onDragLeave={handleDrag}
                                onDragOver={handleDrag}
                                onDrop={handleDrop}
                            >
                                <div className="mb-6">
                                    <div className="bg-blue-100 text-blue-600 p-6 rounded-2xl inline-block mb-4">
                                        <UploadCloud size={48} />
                                    </div>
                                    <h2 className="text-2xl font-bold text-slate-900 mb-2">Drop your files here</h2>
                                    <p className="text-slate-600 mb-6">or click to browse and select files</p>
                                    
                                    <input
                                        type="file"
                                        multiple
                                        accept=".xlsx,.xls,.csv"
                                        onChange={(e) => e.target.files && handleFiles(e.target.files)}
                                        className="hidden"
                                        id="file-upload"
                                    />
                                    <label
                                        htmlFor="file-upload"
                                        className="inline-flex items-center gap-3 px-8 py-4 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-2xl cursor-pointer transition-all hover:scale-105 shadow-lg"
                                    >
                                        <FileText size={20} />
                                        Choose Files
                                    </label>
                                </div>

                                <div className="text-sm text-slate-500">
                                    <p>Supported formats: Excel (.xlsx, .xls) and CSV files</p>
                                    <p>Recommended: Upload both NPS and QC files for comprehensive analysis</p>
                                </div>
                            </div>

                            {/* Processing Status */}
                            {processingStatus !== 'idle' && (
                                <div className="p-8 border-t border-slate-200">
                                    <div className="mb-4">
                                        <div className="flex justify-between text-sm font-medium text-slate-700 mb-2">
                                            <span>Processing files...</span>
                                            <span>{Math.round(uploadProgress)}%</span>
                                        </div>
                                        <div className="w-full bg-slate-200 rounded-full h-3">
                                            <div 
                                                className="bg-blue-600 h-3 rounded-full transition-all duration-300"
                                                style={{ width: `${uploadProgress}%` }}
                                            ></div>
                                        </div>
                                    </div>

                                    {files.length > 0 && (
                                        <div className="space-y-2">
                                            {files.map((file, index) => (
                                                <div key={index} className="flex items-center justify-between p-3 bg-slate-50 rounded-lg">
                                                    <div className="flex items-center gap-3">
                                                        <FileText size={16} className="text-slate-500" />
                                                        <span className="font-medium text-slate-700">{file.name}</span>
                                                    </div>
                                                    <span className="text-sm text-slate-500">
                                                        {(file.size / 1024).toFixed(1)} KB
                                                    </span>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            )}

                            {/* Sample Data Templates */}
                            <div className="p-8 border-t border-slate-200 bg-slate-50">
                                <h3 className="text-lg font-bold text-slate-900 mb-4">Need sample data?</h3>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div className="p-4 bg-white rounded-xl border border-slate-200">
                                        <h4 className="font-bold text-slate-800 mb-2">NPS Template</h4>
                                        <p className="text-sm text-slate-600 mb-3">Customer satisfaction surveys with ratings and feedback</p>
                                        <button className="text-sm text-blue-600 hover:text-blue-700 font-medium">
                                            Download Template ?
                                        </button>
                                    </div>
                                    <div className="p-4 bg-white rounded-xl border border-slate-200">
                                        <h4 className="font-bold text-slate-800 mb-2">QC Template</h4>
                                        <p className="text-sm text-slate-600 mb-3">Quality control audits with scores and compliance metrics</p>
                                        <button className="text-sm text-blue-600 hover:text-blue-700 font-medium">
                                            Download Template ?
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [npsData, setNpsData] = useState([]);
            // Export Reminder Removed
            const [qcData, setQcData] = useState([]);
            const [view, setView] = useState('upload');
            const [filters, setFilters] = useState({});
            const [activeTab, setActiveTab] = useState('Overview');
            // FEATURE 22: CENTRALIZED DASHBOARD CONTROL
            const [selectedAgentGlobal, setSelectedAgentGlobal] = useState('');
            const [footerPosts, setFooterPosts] = useState({});
            const [unifiedBulkModalOpen, setUnifiedBulkModalOpen] = useState(false);
            const [unifiedBulkAgents, setUnifiedBulkAgents] = useState([]);
            const [showDataDiagnostics, setShowDataDiagnostics] = useState(false);
            const [activeTool, setActiveTool] = useState(null); // For AI Tools Suite
            const [showSearch, setShowSearch] = useState(false);

            useEffect(() => {
                const handler = (e) => setActiveTool(e?.detail?.id ?? null);
                window.addEventListener('poppy-set-active-tool', handler);
                return () => window.removeEventListener('poppy-set-active-tool', handler);
            }, []);


            // FIX: Ensure downloadAsImage is defined and linked to global CaptureEngine
            // Using the downloadAsImage function defined earlier in the component scope

            // Handle files processed from UploadView
            const [agentNameMap, setAgentNameMap] = useState({});
            
            const handleFilesProcessed = (results) => {
                const npsFiles = results.filter(r => r.type === 'NPS' && !r.error);
                const qcFiles = results.filter(r => r.type === 'QC' && !r.error);
                
                // Merge agent name mappings from all files
                const mergedAgentMap = {};
                results.forEach(r => {
                    if (r.agentNameMap) {
                        Object.assign(mergedAgentMap, r.agentNameMap);
                    }
                });
                if (Object.keys(mergedAgentMap).length > 0) {
                    setAgentNameMap(mergedAgentMap);
                    DataEngine.setAgentNameMap(mergedAgentMap);
                    showToast(`Found agent name mapping for ${Object.keys(mergedAgentMap).length} agents`, 'success');
                }
                
                if (npsFiles.length > 0) {
                    const combinedNps = npsFiles.flatMap(f => f.data);
                    setNpsData(combinedNps);
                    showToast(`Processed ${npsFiles.length} NPS file(s) with ${combinedNps.length} records`, 'success');
                }
                
                if (qcFiles.length > 0) {
                    const combinedQc = qcFiles.flatMap(f => f.data);
                    setQcData(combinedQc);
                    showToast(`Processed ${qcFiles.length} QC file(s) with ${combinedQc.length} records`, 'success');
                }
                
                if (npsFiles.length > 0 || qcFiles.length > 0) {
                    // Auto-detect best view based on uploaded data
                    if (npsFiles.length > 0 && qcFiles.length > 0) {
                        setView('unified');
                        setActiveTab('Overview');
                    } else if (npsFiles.length > 0) {
                        setView('nps');
                        setActiveTab('Overview');
                    } else if (qcFiles.length > 0) {
                        setView('qc');
                        setActiveTab('Overview');
                    }
                }
                
                // Handle errors
                const errorFiles = results.filter(r => r.error);
                if (errorFiles.length > 0) {
                    showToast(`Failed to process ${errorFiles.length} file(s)`, 'error');
                }
            };




            // Audit Phase 2: Lifted State for Persistence & Cross-Feature Access
            const [customAgents, setCustomAgents] = useState([]);
            const [emailAliases, setEmailAliases] = useState({});
            // Notes (File Map) - Not persisted to storage to avoid quota issues, but lifted to App for sharing
            const [agentFileMap, setAgentFileMap] = useState({});
            const [unmatchedFiles, setUnmatchedFiles] = useState([]);


            // localStorage effects removed






            // FEATURE 10: Centralized Data Health
            const npsHealth = useMemo(() => calculateDataHealth(npsData, 'NPS'), [npsData]);
            const qcHealth = useMemo(() => calculateDataHealth(qcData, 'QC'), [qcData]);
            const overallHealth = Math.min(npsHealth?.score || 100, qcHealth?.score || 100);


            // Fix: All analytical helpers moved up to avoid TDZ/hoisting issues
            const getFilterConfig = () => {
                if (view === 'nps') {
                    return [
                        { key: 'Agent', label: 'Agent', icon: Users },
                        { key: 'Date', label: 'Date', icon: Calendar },
                        { key: 'Week', label: 'Week', icon: Calendar },
                        { key: 'User Problem', label: 'Problem', icon: AlertCircle },
                        { key: 'Chat Tag', label: 'Tag', icon: Tag },
                        { key: 'Rating', label: 'Rating', icon: Star },
                        { key: 'Country', label: 'Country', icon: Users },
                        { key: 'Acknowledged', label: 'Ack', icon: CheckCircle }
                    ];
                } else if (view === 'qc') {
                    return [
                        { key: 'Agent Email', label: 'Agent', icon: Users },
                        { key: 'Date', label: 'Date', icon: Calendar },
                        { key: 'Week', label: 'Week', icon: Calendar },
                        { key: 'Question', label: 'Question', icon: AlertCircle },
                        { key: 'QC Score', label: 'Score', icon: Star },
                        { key: 'Appeal Status', label: 'Appeal', icon: CheckCircle },
                        { key: 'Agent Ack.', label: 'Ack', icon: CheckCircle }
                    ];
                } else {
                    return [
                        { key: 'Agent', label: 'Agent', icon: Users },
                        { key: 'Date', label: 'Date', icon: Calendar },
                        { key: 'Week', label: 'Week', icon: Calendar }
                    ];
                }
            };


            const filterConfig = getFilterConfig();


            const getFilteredData = (data, explicitType = null) => {
                let workingData = [...data];
                return filterConfig.reduce((acc, filter) => {
                    const filterValue = filters[filter.key];
                    if (!filterValue || filterValue.length === 0) return acc;
                    return acc.filter(r => {
                        let val = r[filter.key];
                        const currentType = explicitType || (view === 'qc' ? 'QC' : 'NPS');
                        if (filter.key === 'Date') {
                            val = DataEngine.formatDate(val);
                        } else if (filter.key === 'Week') {
                            const date = DataEngine.parseDate(r.Date || r['Review Date']);
                            if (date) val = DataEngine.getWeekStart(date);
                            else val = '';
                        } else if (filter.key === 'Agent' || filter.key === 'Agent Email') {
                            val = DataEngine.normalizeAgent(r, currentType);
                        } else if (filter.key === 'Acknowledged' || filter.key === 'Agent Ack.') {
                            const ackVal = r[filter.key];
                            if (ackVal === true || String(ackVal).toUpperCase() === 'TRUE' || String(ackVal).toUpperCase() === 'YES' || String(ackVal).toUpperCase() === 'ACKNOWLEDGED') {
                                val = 'Yes';
                            } else if (ackVal === false || String(ackVal).toUpperCase() === 'FALSE' || String(ackVal).toUpperCase() === 'NO' || String(ackVal).toUpperCase() === 'NOT ACKNOWLEDGED') {
                                val = 'No';
                            } else {
                                val = String(ackVal || 'No');
                            }
                        }
                        return filterValue.includes(val);
                    });
                }, workingData);
            };


            // Optimization: Memoize filtered data
            const filteredNps = useMemo(() => {
                try {
                    return getFilteredData(npsData, 'NPS');
                } catch (e) {
                    PoppyLogger.error('APP', "Failed to filter NPS data:", e);
                    return [];
                }
            }, [npsData, filters]);


            const filteredQc = useMemo(() => {
                try {
                    return getFilteredData(qcData, 'QC');
                } catch (e) {
                    PoppyLogger.error('APP', "Failed to filter QC data:", e);
                    return [];
                }
            }, [qcData, filters]);


            const unifiedAgents = useMemo(() => {
                const set = new Set([
                    ...filteredNps.map(r => DataEngine.normalizeAgent(r, 'NPS') || r.Agent),
                    ...filteredQc.map(r => DataEngine.normalizeAgent(r, 'QC') || r.Agent || r['Agent Email'])
                ]);
                customAgents.forEach(ca => { if (ca.name) set.add(ca.name); });
                return [...set].filter(a => a && String(a).trim() !== '').sort();
            }, [filteredNps, filteredQc, customAgents]);


            // FEATURE: SPARKLE AI SHORTCUTS - Global trigger for AI chat
            const [aiTrigger, setAiTrigger] = useState({ open: false, query: '' });
            
            // askAI function to trigger AI chat from anywhere in the app
            const askAI = (query) => {
                if (typeof query === 'string' && query.trim()) {
                    setAiTrigger({ open: true, query: query.trim() });
                } else if (query && typeof query === 'object') {
                    // Handle sparkle data objects
                    const queryText = `Analyze ${query.type || 'data'}: ${JSON.stringify(query).slice(0, 500)}`;
                    setAiTrigger({ open: true, query: queryText });
                }
            };
            
            // Event Listener for AI Chat
            useEffect(() => {
                const handleAIOpen = (e) => setAiTrigger({ open: true, query: e.detail?.query || '' });
                window.addEventListener('poppy-ai-open', handleAIOpen);
                return () => window.removeEventListener('poppy-ai-open', handleAIOpen);
            }, []);

            // FEATURE: GLOBAL SEARCH HOTKEY (Cmd+K)
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
                        e.preventDefault();
                        setShowSearch(prev => !prev);
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, []);


            // Audit Issue #19: POPPY_AI_CONTEXT - Live app context for AI prompts
            // This object is updated on every UI interaction and can be injected into AI prompts
            const POPPY_AI_CONTEXT = useMemo(() => ({
                currentView: view,
                activeTab: activeTab,
                selectedAgent: selectedAgentGlobal,
                activeFilters: Object.entries(filters)
                    .filter(([k, v]) => v && v.length > 0)
                    .map(([key, values]) => ({ field: key, values })),
                dataStats: {
                    npsCount: npsData.length,
                    qcCount: qcData.length,
                    npsHealth: npsHealth?.score || 0,
                    qcHealth: qcHealth?.score || 0,
                    hasData: npsData.length > 0 || qcData.length > 0
                },
                timestamp: Date.now()
            }), [view, activeTab, selectedAgentGlobal, filters, npsData.length, qcData.length, npsHealth, qcHealth]);


            // Make context globally accessible for AI system - with DEBOUNCING (Hardening #11)
            useEffect(() => {
                const handler = setTimeout(() => {
                    window.POPPY_AI_CONTEXT = POPPY_AI_CONTEXT;
                }, 300); // 300ms debounce


                return () => clearTimeout(handler);
            }, [POPPY_AI_CONTEXT]);


            const handleFile = (e) => {
                const f = e.target.files[0];
                if (!f) return;


                // Safety check for dependency
                if (typeof XLSX === 'undefined') {
                    showToast("System Error: Excel parser not loaded. Check internet connection.", 'error');
                    return;
                }


                const r = new FileReader();
                r.onload = (evt) => {
                    try {
                        const wb = XLSX.read(evt.target.result, { type: 'binary' });
                        let hasData = false;


                        // Case-insensitive sheet lookup
                        const sheetNames = Object.keys(wb.Sheets);
                        const npsSheet = sheetNames.find(n => n.toLowerCase() === 'nps');
                        const qcSheet = sheetNames.find(n => n.toLowerCase() === 'qc');


                        if (npsSheet) {
                            const raw = XLSX.utils.sheet_to_json(wb.Sheets[npsSheet], { header: 1, defval: "" });
                            const valid = cleanExcelData(raw, 'nps');
                            setNpsData(valid);
                            if (valid.length > 0) hasData = true;
                        }
                        if (qcSheet) {
                            const raw = XLSX.utils.sheet_to_json(wb.Sheets[qcSheet], { header: 1, defval: "" });
                            const valid = cleanExcelData(raw, 'qc');
                            setQcData(valid);
                            if (valid.length > 0) hasData = true;
                        }


                        if (hasData) {
                            showToast("Data uploaded successfully!", 'success');
                            setView('nps');
                        } else {
                            showToast("No valid data found in NPS or QC sheets.", 'error');
                        }
                    } catch (e) {
                        console.error("File upload error:", e);
                        showToast("Failed to process file. Ensure it is a valid Excel.", 'error');
                    }
                };
                r.readAsBinaryString(f);
            };


            const activeData = useMemo(() => {
                return view === 'nps' ? npsData : (view === 'qc' ? qcData : [...npsData, ...qcData]);
            }, [view, npsData, qcData]);


            const filteredData = getFilteredData(activeData);
            const dataDiagnostics = useMemo(() => {
                const summarize = (rows, kind) => {
                    const total = Array.isArray(rows) ? rows.length : 0;
                    const sample = (rows || []).slice(0, 200);
                    const keys = new Set();
                    let parsedDates = 0;
                    let hasDateField = 0;
                    const badDateExamples = [];
                    const weeksFound = new Set();


                    if (rows && rows.length > 0) {
                        rows.forEach(r => {
                            const d = DataEngine.getRowDate(r);
                            if (d) weeksFound.add(DataEngine.getWeekStart(d));
                        });
                    }


                    sample.forEach(r => {
                        Object.keys(r || {}).forEach(k => keys.add(k));
                        const dv = r?.Date || r?.['Review Date'] || null;
                        if (dv !== null && dv !== undefined && String(dv).trim() !== '') {
                            hasDateField += 1;
                            const parsed = DataEngine.parseDate(dv);
                            if (parsed) parsedDates += 1;
                            else if (badDateExamples.length < 5) badDateExamples.push(String(dv));
                        }
                    });
                    const required = kind === 'NPS'
                        ? ['Agent', 'Date', 'Rating']
                        : kind === 'QC'
                            ? [(keys.has('Agent Email') ? 'Agent Email' : 'Agent'), 'Date', 'QC Score', 'Question']
                            : [];
                    const missingRequired = required.filter(k => !keys.has(k));
                    return {
                        kind,
                        total,
                        sampleSize: sample.length,
                        keys: Array.from(keys).sort(),
                        required,
                        missingRequired,
                        dateFieldsInSample: hasDateField,
                        parsedDatesInSample: parsedDates,
                        dateParseRate: hasDateField > 0 ? parsedDates / hasDateField : 0,
                        badDateExamples,
                        weeksCount: weeksFound.size
                    };
                };
                const nps = summarize(npsData, 'NPS');
                const qc = summarize(qcData, 'QC');
                const activeTotal = activeData.length;
                const filteredTotal = filteredData.length;
                const hasAnyData = (nps.total + qc.total) > 0;
                const likelyDateProblem = hasAnyData && ((view === 'nps' && nps.dateFieldsInSample > 0 && nps.dateParseRate < 0.2) || (view === 'qc' && qc.dateFieldsInSample > 0 && qc.dateParseRate < 0.2));
                return { nps, qc, activeTotal, filteredTotal, hasAnyData, likelyDateProblem };
            }, [npsData, qcData, activeData, filteredData, view]);


            // Fix: Dynamic options - based on already filtered data
            const getOptions = (key) => {
                // Get data that matches all OTHER filters (to show only relevant options)
                let tempData = activeData;
                filterConfig.forEach(f => {
                    if (f.key !== key && filters[f.key] && filters[f.key].length > 0) {
                        tempData = tempData.filter(r => {
                            let val = r[f.key];
                            if (f.key === 'Date') {
                                val = DataEngine.formatDate(val);
                            } else if (f.key === 'Week') {
                                const date = DataEngine.parseDate(r.Date || r['Review Date']);
                                if (date) val = DataEngine.getWeekStart(date);
                                else val = '';
                            } else if (f.key === 'Agent' || f.key === 'Agent Email') {
                                val = DataEngine.normalizeAgent(r, view === 'qc' ? 'QC' : 'NPS');
                            } else if (f.key === 'Acknowledged' || f.key === 'Agent Ack.') {
                                // Normalize boolean values for Ack filter
                                const ackVal = r[f.key];
                                if (ackVal === true || ackVal === 'TRUE' || ackVal === 'YES' || String(ackVal).toUpperCase() === 'ACKNOWLEDGED') {
                                    val = 'Yes';
                                } else if (ackVal === false || ackVal === 'FALSE' || ackVal === 'NO' || String(ackVal).toUpperCase() === 'NOT ACKNOWLEDGED') {
                                    val = 'No';
                                } else {
                                    val = String(ackVal || 'No');
                                }
                            }
                            return filters[f.key].includes(val);
                        });
                    }
                });


                const raw = [...new Set(tempData.map(r => {
                    let val = r[key];
                    if (key === 'Date') {
                        val = DataEngine.formatDate(val);
                    } else if (key === 'Week') {
                        const date = DataEngine.parseDate(r.Date || r['Review Date']);
                        if (date) val = DataEngine.getWeekStart(date);
                        else val = '';
                    } else if (key === 'Agent' || key === 'Agent Email') {
                        val = DataEngine.normalizeAgent(r, view === 'qc' ? 'QC' : 'NPS');
                    } else if (key === 'Acknowledged' || key === 'Agent Ack.') {
                        // Normalize boolean values for Ack filter
                        const ackVal = r[key];
                        if (ackVal === true || ackVal === 'TRUE' || ackVal === 'YES' || String(ackVal).toUpperCase() === 'ACKNOWLEDGED') {
                            val = 'Yes';
                        } else if (ackVal === false || ackVal === 'FALSE' || ackVal === 'NO' || String(ackVal).toUpperCase() === 'NOT ACKNOWLEDGED') {
                            val = 'No';
                        } else {
                            val = String(ackVal || 'No');
                        }
                    }
                    return val;
                }))]
                    .filter(val => val && val !== '' && val !== '0' && val !== '#N/A' && val !== 'undefined' && val !== 0);


                // Sort: Week and Date should be old to new, others alphabetically
                return raw.sort((a, b) => {
                    // Ensure both values are strings for comparison
                    const strA = String(a || '');
                    const strB = String(b || '');


                    if (key === 'Date' || key === 'Week') {
                        // For Date and Week: Sort from old to new (ascending)
                        const dateA = DataEngine.parseDate(strA);
                        const dateB = DataEngine.parseDate(strB);
                        if (dateA && dateB) {
                            return dateA.getTime() - dateB.getTime(); // Oldest first
                        }
                        if (dateA) return -1;
                        if (dateB) return 1;
                        // If not dates, try string comparison for weeks
                        return strA.localeCompare(strB);
                    } else {
                        // For all other filters: Sort alphabetically
                        return strA.localeCompare(strB);
                    }
                });
            };


            // Get tab configuration based on view
            const getTabConfig = () => {
                if (view === 'nps') {
                    return ['Overview', 'Matrix', 'RCA', 'Chats', 'Agent Review', 'Spotlight', 'Feedback Loop', 'Quiz'];
                } else if (view === 'qc') {
                    return ['Overview', 'Appeals', 'Reviews', 'Agent Review', 'Matrix', 'RCA', 'Spotlight', 'Feedback Loop', 'Quiz'];
                } else if (view === 'unified') {
                    return ['Overview', 'Feedback Loop', 'Spotlight', 'Intelligence Hub', '1:1 Feedback', 'Quiz'];
                }
                return [];
            };


            return (
                <>
                <div id="app-root-container" className="app-container w-full min-h-screen bg-slate-50 relative">
                    <div className={`min-h-screen ${view !== 'upload' ? 'pb-6' : ''}`}>
                    {view !== 'upload' ? (
                        <>
                            <div className="unified-sticky-nav" data-html2canvas-ignore="true">
                                <div className="nav-header flex flex-col sm:flex-row justify-between items-center w-full gap-4">
                                    {/* 1. BRANDING & VIEW SWITCHER (Fixed Left) */}
                                    <div className="flex items-center gap-6 flex-none w-fit">
                                        <div className="flex items-center gap-3 border-r border-slate-200 pr-6 mr-2">
                                            <div className="bg-slate-900 text-white p-2 rounded-lg shadow-lg">
                                                <LayoutDashboard size={18} />
                                            </div>
                                            <div className="hidden lg:block">
                                                <h1 className="font-black text-lg text-slate-900 tracking-tight leading-none uppercase">POPPY SUITE</h1>
                                                <p className="text-[9px] font-bold text-slate-500 uppercase tracking-wider mt-0.5 leading-none">CX & QC Intelligence</p>
                                            </div>
                                        </div>


                                        <div className="flex gap-1 bg-slate-100 p-1 rounded-xl border border-slate-200 min-w-[200px]">
                                            {['nps', 'qc', 'unified'].map(v => (
                                                <button
                                                    key={v}
                                                    onClick={() => { setView(v); setActiveTab('Overview'); }}
                                                    className={`w-[60px] px-2 py-1.5 rounded-lg text-[10px] font-black uppercase transition-all ${view === v
                                                        ? 'bg-blue-600 text-white shadow-sm'
                                                        : 'text-slate-500 hover:text-slate-800'}`}
                                                >
                                                    {v}
                                                </button>
                                            ))}
                                        </div>
                                    </div>


                                    {/* RIGHT GROUP: Dynamic Tabs & Actions */}
                                    <nav className="flex items-center justify-end w-fit shrink-0 ml-auto">
                                            <div className="flex-1 min-w-0 flex items-center gap-1 bg-slate-50 p-1 rounded-xl border border-slate-200 overflow-x-auto custom-scrollbar no-scrollbar">
                                            {getTabConfig().map(tab => (
                                                <button
                                                    key={tab}
                                                    onClick={() => setActiveTab(tab)}
                                                    className={`px-3 py-1.5 rounded-lg text-[10px] font-bold transition-all whitespace-nowrap flex-shrink-0 ${activeTab === tab
                                                        ? 'bg-slate-800 text-white shadow-sm'
                                                        : 'text-slate-500 hover:text-slate-900 hover:bg-slate-200'}`}
                                                >
                                                    {tab}
                                                </button>
                                            ))}
                                        </div>




                                        <button
                                            onClick={() => CaptureEngine.captureFullPage(`${view.toUpperCase()}_${activeTab}_FullPage`)}
                                            className="p-1.5 bg-slate-100 hover:bg-blue-600 hover:text-white text-slate-500 rounded-lg transition-all active:scale-95 flex-shrink-0"
                                            title="Capture Full Page"
                                        >
                                            <Camera size={14} />
                                        </button>
                                        <button
                                            onClick={() => PDFEngine.generateA4PDF(`${view}-view-container`, `${view.toUpperCase()}_${activeTab}_Report.pdf`)}
                                            className="p-1.5 bg-slate-100 hover:bg-rose-600 hover:text-white text-slate-500 rounded-lg transition-all active:scale-95 flex-shrink-0"
                                            title="Export PDF"
                                        >
                                            <FileText size={14} />
                                        </button>
                                        <button
                                            onClick={() => setShowDataDiagnostics(true)}
                                            className={`p-1.5 bg-slate-100 hover:bg-slate-900 hover:text-white text-slate-500 rounded-lg transition-all active:scale-95 flex-shrink-0 ${dataDiagnostics.likelyDateProblem ? 'ring-2 ring-rose-200 text-rose-600' : ''}`}
                                            title="Data Diagnostics"
                                        >
                                            <Activity size={14} />
                                        </button>

                                    </nav>
                                </div>


                                {/* Filters Row - No Gap Fix */ }
                                <div className="nav-filters !mt-0" style={{ marginTop: 0 }}>
                                    <span className="text-[10px] font-bold text-slate-500 uppercase mr-1 flex items-center gap-1 flex-shrink-0">
                                        <Filter size={10} /> Filters:
                                        <InfoTooltip text={
                                            <div className="space-y-1">
                                                <p className="font-bold border-b border-white/20 pb-1 mb-1">Poppy Scope System</p>
                                                <p> <b className="text-blue-300">Global:</b> No filters active. High-level trends.</p>
                                                <p> <b className="text-indigo-300">Agent:</b> Filtered by single agent. Targeted RCA.</p>
                                                <p> <b className="text-emerald-300">QC:</b> Specific audit cycles or scores.</p>


                                            </div>
                                        } position="right">
                                            <HelpCircle size={10} className="text-slate-300 hover:text-indigo-500 cursor-help" />
                                        </InfoTooltip>
                                    </span>
                                    {filterConfig.map(f => (
                                        <MultiSelect key={f.key} label={f.label} icon={f.icon} options={getOptions(f.key)} value={filters[f.key] || []} onChange={v => setFilters({ ...filters, [f.key]: v })} />
                                    ))}
                                    <button onClick={() => setFilters({})} className="ml-auto text-[10px] font-bold text-rose-500 hover:bg-rose-50 px-2 py-1 rounded-lg transition-colors whitespace-nowrap flex-shrink-0">Reset</button>
                                </div>


                                {/* Audit Issue #18: Active Filter Chips - Shows applied filters with one-click removal */}
                                {Object.entries(filters).some(([k, v]) => v && v.length > 0) && (
                                    <div className="flex flex-wrap items-center gap-1.5 px-6 py-2 bg-blue-50/50 border-b border-blue-100 w-full">
                                        <span className="text-[10px] font-bold text-blue-600 uppercase mr-1">Active:</span>
                                        {Object.entries(filters).map(([key, values]) =>
                                            values && values.length > 0 && values.map(val => (
                                                <span
                                                    key={`${key}-${val}`}
                                                    className="inline-flex items-center gap-1 px-2 py-0.5 bg-blue-100 text-blue-700 rounded-full text-[10px] font-medium group"
                                                >
                                                    <span className="text-blue-500">{key}:</span> {val}
                                                    <button
                                                        onClick={() => {
                                                            const newVals = (filters[key] || []).filter(v => v !== val);
                                                            setFilters({ ...filters, [key]: newVals });
                                                        }}
                                                        className="ml-0.5 hover:bg-blue-200 rounded-full p-0.5 transition-colors"
                                                        title={`Remove ${val}`}
                                                    >
                                                        <XIcon size={10} />
                                                    </button>
                                                </span>
                                            ))
                                        )}
                                        <button
                                            onClick={() => setFilters({})}
                                            className="text-[10px] font-bold text-blue-600 hover:text-blue-800 hover:bg-blue-100 px-2 py-0.5 rounded-full transition-colors"
                                        >
                                            Clear All
                                        </button>
                                    </div>
                                )}
                            </div>
                            <Modal
                                isOpen={showDataDiagnostics}
                                onClose={() => setShowDataDiagnostics(false)}
                                title="Data Diagnostics"
                            >
                                <div className="space-y-4">
                                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
                                        <div className="p-5 rounded-2xl border border-slate-200 bg-white">
                                            <div className="text-[11px] font-black tracking-wider uppercase text-slate-500">NPS</div>
                                            <div className="mt-2 grid grid-cols-3 gap-3 text-sm">
                                                <div className="p-3 bg-slate-50 rounded-xl">
                                                    <div className="text-[10px] font-bold text-slate-500 uppercase">Rows</div>
                                                    <div className="text-lg font-black text-slate-800">{dataDiagnostics.nps.total}</div>
                                                </div>
                                                <div className="p-3 bg-slate-50 rounded-xl">
                                                    <div className="text-[10px] font-bold text-slate-500 uppercase">Weeks</div>
                                                    <div className="text-lg font-black text-slate-800">{dataDiagnostics.nps.weeksCount}</div>
                                                </div>
                                                <div className="p-3 bg-slate-50 rounded-xl">
                                                    <div className="text-[10px] font-bold text-slate-500 uppercase">Date Parse</div>
                                                    <div className={`text-lg font-black ${dataDiagnostics.nps.dateFieldsInSample > 0 && dataDiagnostics.nps.dateParseRate < 0.2 ? 'text-rose-600' : 'text-slate-800'}`}>
                                                        {dataDiagnostics.nps.dateFieldsInSample > 0 ? `${Math.round(dataDiagnostics.nps.dateParseRate * 100)}%` : 'N/A'}
                                                    </div>
                                                </div>
                                            </div>
                                            {dataDiagnostics.nps.missingRequired.length > 0 && (
                                                <div className="mt-3 p-3 bg-amber-50 border border-amber-200 rounded-xl text-xs text-amber-800">
                                                    <div className="font-black uppercase text-[10px] tracking-wider mb-1">Missing Columns</div>
                                                    <div>{dataDiagnostics.nps.missingRequired.join(', ')}</div>
                                                </div>
                                            )}
                                            {dataDiagnostics.nps.badDateExamples.length > 0 && (
                                                <div className="mt-3 p-3 bg-slate-50 border border-slate-200 rounded-xl text-xs text-slate-700">
                                                    <div className="font-black uppercase text-[10px] tracking-wider mb-1">Unparsed Date Examples</div>
                                                    <div className="space-y-1">
                                                        {dataDiagnostics.nps.badDateExamples.map((d, i) => <div key={i}>{d}</div>)}
                                                    </div>
                                                </div>
                                            )}
                                        </div>


                                        <div className="p-5 rounded-2xl border border-slate-200 bg-white">
                                            <div className="text-[11px] font-black tracking-wider uppercase text-slate-500">QC</div>
                                            <div className="mt-2 grid grid-cols-3 gap-3 text-sm">
                                                <div className="p-3 bg-slate-50 rounded-xl">
                                                    <div className="text-[10px] font-bold text-slate-500 uppercase">Rows</div>
                                                    <div className="text-lg font-black text-slate-800">{dataDiagnostics.qc.total}</div>
                                                </div>
                                                <div className="p-3 bg-slate-50 rounded-xl">
                                                    <div className="text-[10px] font-bold text-slate-500 uppercase">Weeks</div>
                                                    <div className="text-lg font-black text-slate-800">{dataDiagnostics.qc.weeksCount}</div>
                                                </div>
                                                <div className="p-3 bg-slate-50 rounded-xl">
                                                    <div className="text-[10px] font-bold text-slate-500 uppercase">Date Parse</div>
                                                    <div className={`text-lg font-black ${dataDiagnostics.qc.dateFieldsInSample > 0 && dataDiagnostics.qc.dateParseRate < 0.2 ? 'text-rose-600' : 'text-slate-800'}`}>
                                                        {dataDiagnostics.qc.dateFieldsInSample > 0 ? `${Math.round(dataDiagnostics.qc.dateParseRate * 100)}%` : 'N/A'}
                                                    </div>
                                                </div>
                                            </div>
                                            {dataDiagnostics.qc.missingRequired.length > 0 && (
                                                <div className="mt-3 p-3 bg-amber-50 border border-amber-200 rounded-xl text-xs text-amber-800">
                                                    <div className="font-black uppercase text-[10px] tracking-wider mb-1">Missing Columns</div>
                                                    <div>{dataDiagnostics.qc.missingRequired.join(', ')}</div>
                                                </div>
                                            )}
                                            {dataDiagnostics.qc.badDateExamples.length > 0 && (
                                                <div className="mt-3 p-3 bg-slate-50 border border-slate-200 rounded-xl text-xs text-slate-700">
                                                    <div className="font-black uppercase text-[10px] tracking-wider mb-1">Unparsed Date Examples</div>
                                                    <div className="space-y-1">
                                                        {dataDiagnostics.qc.badDateExamples.map((d, i) => <div key={i}>{d}</div>)}
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    </div>


                                    <div className="p-4 rounded-2xl border border-slate-200 bg-slate-50">
                                        <div className="flex items-center justify-between gap-4">
                                            <div>
                                                <div className="text-[10px] font-black uppercase tracking-wider text-slate-500">Current View</div>
                                                <div className="text-sm font-bold text-slate-800">{view.toUpperCase()}  {activeTab}</div>
                                            </div>
                                            <div className="text-right">
                                                <div className="text-[10px] font-black uppercase tracking-wider text-slate-500">Rows</div>
                                                <div className="text-sm font-bold text-slate-800">{dataDiagnostics.filteredTotal} filtered / {dataDiagnostics.activeTotal} active</div>
                                            </div>
                                        </div>
                                    </div>


                                    {dataDiagnostics.likelyDateProblem && (
                                        <div className="p-4 rounded-2xl border border-rose-200 bg-rose-50 text-sm text-rose-800">
                                            <div className="font-black uppercase text-[11px] tracking-wider mb-1">Likely Issue: Date Parsing</div>
                                            <div>Expected date formats: DD/MM/YYYY, DD-MM-YYYY (and internal ISO YYYY-MM-DD). If your Excel contains other date strings, charts/groups can appear empty.</div>
                                        </div>
                                    )}
                                </div>
                            </Modal>
                        </>
                    ) : (
                        <div className="upload-page-bg fixed inset-0 flex flex-col items-center justify-center w-full h-[100dvh] overflow-hidden m-0 p-0">
                            <div className="orbs-container">
                                <div className="floating-orb orb-1"></div>
                                <div className="floating-orb orb-2"></div>
                                <div className="floating-orb orb-3"></div>
                                <div className="floating-orb orb-4"></div>
                            </div>


                            {/* Removed py-4 to allow true centering */}
                            <div className="w-full max-w-7xl mx-auto flex flex-col items-center justify-center px-4 relative z-10">


                                {/* Brand Header: Compact Hero section */}
                                <div className="text-center mb-6 lg:mb-8 scale-90 lg:scale-100 origin-center transition-transform">
                                    <div className="inline-flex items-center justify-center w-16 h-16 lg:w-20 lg:h-20 rounded-2xl bg-gradient-to-br from-indigo-500 via-purple-500 to-pink-500 mb-4 lg:mb-6 shadow-2xl">
                                        <LayoutDashboard size={32} className="text-white lg:w-10 lg:h-10" />
                                    </div>
                                    <h1 className="text-4xl lg:text-5xl font-black tracking-tight mb-2 gradient-text">POPPY SUITE</h1>
                                    <p className="text-slate-500 text-xs lg:text-sm font-medium tracking-[0.2em] lg:tracking-widest uppercase">Customer Experience & Quality Intelligence Platform</p>
                                </div>


                                {/* Upload Card */}
                                <div className="upload-card">
                                    <div className="upload-icon">
                                        <Upload size={36} className="text-indigo-400" />
                                    </div>


                                    <h2 className="text-2xl font-bold text-white mb-2">Upload Your Data</h2>
                                    <p className="text-slate-500 mb-6">Drop your Excel file with NPS & QC sheets</p>


                                    <label className="upload-btn inline-block mb-6">
                                        Select Excel File
                                        <input type="file" className="hidden" accept=".xlsx" onChange={handleFile} />
                                    </label>


                                    <div className="flex items-center justify-center gap-2 text-xs text-slate-500">
                                        <FileSpreadsheet size={14} />
                                        <span>Supports .xlsx with NPS and QC sheets</span>
                                    </div>
                                </div>


                                {/* Feature Badges: Compact Layout */}
                                <div className="flex flex-wrap justify-center gap-3 mt-8 lg:mt-10">
                                    <div className="feature-badge">
                                        <Activity size={14} />
                                        <span>NPS Analytics</span>
                                    </div>
                                    <div className="feature-badge">
                                        <ShieldCheck size={14} />
                                        <span>QC Reviews</span>
                                    </div>
                                    <div className="feature-badge">
                                        <BrainCircuit size={14} />
                                        <span>AI Insights</span>
                                    </div>
                                    <div className="feature-badge">
                                        <Sparkles size={14} />
                                        <span>Auto Reports</span>
                                    </div>
                                </div>


                                {/* Footer */}
                                <p className="text-slate-500 text-sm mt-6">Powered by Poppy AI  Built for CX Excellence</p>
                            </div>
                        </div>
                    )
                    }


                    {
                        view !== 'upload' && (
                            <main className="flex-1 bg-slate-50 p-6 relative z-10">
                                <div className="w-full max-w-full mx-auto px-4 lg:px-8 space-y-6">
                                    <ErrorBoundary key={view}>
                                        {view === 'unified' && activeTab === 'Spotlight' ? (
                                            <div>
                                                <button
                                                    onClick={() => setActiveTab('Overview')}
                                                    className="mb-4 flex items-center gap-2 text-slate-500 hover:text-blue-600 transition-colors"
                                                >
                                                    <ArrowLeft size={16} /> Back to Dashboard
                                                </button>
                                                <SpotlightView
                                                    spotlightAgent={selectedAgentGlobal}
                                                    setSpotlightAgent={setSelectedAgentGlobal}
                                                    filterOptions={{
                                                        agent: unifiedAgents
                                                    }}
                                                    processedData={[]}
                                                    METRIC_MAPPING={NPS_METRIC_MAPPING}
                                                    downloadAsImage={downloadAsImage}
                                                    type="Unified"
                                                    npsData={filteredNps}
                                                    qcData={filteredQc}
                                                    bulkAction={{
                                                        onClick: () => setUnifiedBulkModalOpen(true),
                                                        label: 'Bulk Generate'
                                                    }}
                                                    bulkAgents={unifiedBulkAgents}
                                                    setBulkAgents={setUnifiedBulkAgents}
                                                    onBulkGenerate={async (agent) => {
                                                        const agentStats = unifiedAgents.includes(agent)
                                                            ? {
                                                                nps: filteredNps
                                                                    .filter(r => DataEngine.normalizeAgent(r, 'NPS') === agent)
                                                                    .filter(r => !DataEngine.isAppeal(r) && !DataEngine.isNpsPassAllSubmetrics(r)),
                                                                qc: filteredQc
                                                                    .filter(r => DataEngine.normalizeAgent(r, 'QC') === agent)
                                                                    .filter(r => !DataEngine.isAppeal(r))
                                                            }
                                                            : { nps: [], qc: [] };


                                                        const issues = {};
                                                        agentStats.nps.forEach(r => {
                                                            Object.entries(NPS_METRIC_MAPPING).forEach(([p, ms]) => {
                                                                ms.forEach(m => { if (r[m] === false || r[m] === 'FALSE') issues[m] = (issues[m] || 0) + 1; });
                                                            });
                                                        });

                                                        agentStats.qc.forEach(r => {
                                                            if (r.isFail || String(r['Pass/Fail'] || '').toLowerCase() === 'fail') {
                                                                const tag = r.calculatedTag || r.Question || 'QC Fail';
                                                                issues[tag] = (issues[tag] || 0) + 1;
                                                            }
                                                        });


                                                        const topGaps = Object.entries(issues).sort((a, b) => b[1] - a[1]).slice(0, 3).map(x => x[0]).join(", ");


                                                        // Audit Phase 2: Notes-Only & Smart Coaching Logic
                                                        const notes = agentFileMap[agent] || '';
                                                        if (agentStats.nps.length === 0 && agentStats.qc.length === 0 && !notes) {
                                                            return "No data available for this agent.";
                                                        }


                                                        const strengths = [];
                                                        const opportunities = topGaps ? topGaps.split(', ').map(g => ({ name: g })) : [];

                                                        return await generateSmartCoachingPlan(
                                                            agent,
                                                            strengths,
                                                            opportunities,
                                                            '',
                                                            '',
                                                            'Unified',
                                                            true,
                                                            `Focus on ${topGaps ? 'these gaps: ' + topGaps : 'general improvement'}.`,
                                                            notes
                                                        );
                                                    }}
                                                />
                                                <AgentSelectionModal
                                                    isOpen={unifiedBulkModalOpen}
                                                    onClose={() => setUnifiedBulkModalOpen(false)}
                                                    allAgents={unifiedAgents}
                                                    agentEmails={{}}
                                                    initialSelected={unifiedBulkAgents}
                                                    onConfirm={(selected) => {
                                                        setUnifiedBulkAgents(selected);
                                                        setUnifiedBulkModalOpen(false);
                                                    }}
                                                />
                                            </div>
                                        ) : (
                                            <>
                                                {view === 'upload' && <UploadView onFilesProcessed={handleFilesProcessed} />}
                                                {view === 'nps' && <NPSView data={filteredNps} onDownloadImage={downloadAsImage} onAgentSelect={setSelectedAgentGlobal} activeTab={activeTab} setActiveTab={setActiveTab} selectedAgentGlobal={selectedAgentGlobal} setSelectedAgentGlobal={setSelectedAgentGlobal} filters={filters} setFilters={setFilters} askAI={askAI} />}
                                                {view === 'qc' && <QCView data={filteredQc} onDownloadImage={downloadAsImage} activeTab={activeTab} setActiveTab={setActiveTab} selectedAgentGlobal={selectedAgentGlobal} setSelectedAgentGlobal={setSelectedAgentGlobal} filters={filters} setFilters={setFilters} askAI={askAI} />}
                                                {view === 'unified' && activeTab !== 'Spotlight' && (
                                                    <div className="space-y-8">
                                                        <UnifiedDashboard
                                                            npsData={filteredNps}
                                                            qcData={filteredQc}
                                                            onDownloadImage={downloadAsImage}
                                                            activeTab={activeTab}
                                                            setActiveTab={setActiveTab}
                                                            selectedAgentGlobal={selectedAgentGlobal}
                                                            setSelectedAgentGlobal={setSelectedAgentGlobal}
                                                            filters={filters}
                                                            setFilters={setFilters}
                                                            askAI={askAI}
                                                            customAgents={customAgents}
                                                            setCustomAgents={setCustomAgents}
                                                            emailAliases={emailAliases}
                                                            setEmailAliases={setEmailAliases}
                                                            agentFileMap={agentFileMap}
                                                            setAgentFileMap={setAgentFileMap}
                                                            unmatchedFiles={unmatchedFiles}
                                                            setUnmatchedFiles={setUnmatchedFiles}
                                                        />
                                                        {activeTab === 'Overview' && <SystemicGapsTable data={[...filteredNps, ...filteredQc]} onDownload={downloadAsImage} askAI={askAI} />}
                                                        
                                                        {/* Executive Weekly Summary - Last element on Overview page */}
                                                        {activeTab === 'Overview' && (
                                                            <WeeklySummaryGenerator
                                                                npsData={filteredNps}
                                                                qcData={filteredQc}
                                                                onDownloadImage={downloadAsImage}
                                                                askAI={askAI}
                                                                mode="unified"
                                                            />
                                                        )}
                                                    </div>
                                                )}
                                            </>
                                        )}


                                        <AIProgressBar />
                                        
                                        {/* Universal AI Footer - Synthetic Intelligence Layer */}
                                        <UniversalAIFooter
                                            data={view === 'nps' ? filteredNps : (view === 'qc' ? filteredQc : [...filteredNps, ...filteredQc])}
                                            view={view}
                                            context={`${view.toUpperCase()} - ${activeTab}`}
                                            post={footerPosts[`${view}-${activeTab}`] || ""}
                                            onChange={(newPost) => setFooterPosts(prev => ({ ...prev, [`${view}-${activeTab}`]: newPost }))}
                                            askAI={askAI}
                                        />
                                    </ErrorBoundary>
                                </div>
                            </main>
                        )
                    } {/* AI Assistant - Floating Chat Interface */}
                    {
                        view !== 'upload' && (
                            <div className="no-export" data-html2canvas-ignore="true">
                                <GlobalSearch
                                    isOpen={showSearch}
                                    onClose={() => setShowSearch(false)}
                                    npsData={npsData}
                                    qcData={qcData}
                                    onSelectAgent={setSelectedAgentGlobal}
                                    setAiTrigger={setAiTrigger}
                                    setView={setView}
                                    setFilters={setFilters}
                                    setActiveTab={setActiveTab}
                                />
                            </div>
                        )
                    }


                    {view !== 'upload' && (npsData.length > 0 || qcData.length > 0) && (
                        <div className="no-export" data-html2canvas-ignore="true">
                            <PoppyAIChatbot
                                npsData={npsData}
                                qcData={qcData}
                                activeFilteredData={filteredData}
                                currentView={view}
                                activeTab={activeTab}
                                filters={filters}
                                setFilters={setFilters}
                                setView={setView}
                                setActiveTab={setActiveTab}
                                aiTrigger={aiTrigger}
                                setAiTrigger={setAiTrigger}
                                context={POPPY_AI_CONTEXT || {}}
                            />
                        </div>
                    )}

                </div>
            </div>
            
            {/* AI TOOLS SUITE MODALS */}
            <PolicyQuizGenerator 
                isOpen={activeTool === 'policy-quiz'} 
                onClose={() => setActiveTool(null)} 
                npsData={npsData}
                qcData={qcData}
            />
            <KBArticleWriter 
                isOpen={activeTool === 'kb-writer'} 
                onClose={() => setActiveTool(null)} 
            />
            <TrainingMaterialCreator 
                isOpen={activeTool === 'training-creator'} 
                onClose={() => setActiveTool(null)} 
            />
            <ReviewDocumentGenerator 
                isOpen={activeTool === 'review-doc'} 
                onClose={() => setActiveTool(null)} 
                agents={[...new Set([...npsData.map(r => DataEngine.normalizeAgent(r, 'NPS')), ...qcData.map(r => DataEngine.normalizeAgent(r, 'QC'))])].filter(Boolean)}
                npsData={npsData}
                qcData={qcData}
            />
            <CoachingSessionPlanner 
                isOpen={activeTool === 'coaching-planner'} 
                onClose={() => setActiveTool(null)} 
                agents={[...new Set([...npsData.map(r => DataEngine.normalizeAgent(r, 'NPS')), ...qcData.map(r => DataEngine.normalizeAgent(r, 'QC'))])].filter(Boolean)}
                npsData={npsData}
                qcData={qcData}
            />
            <PeerCoachingMatcher 
                isOpen={activeTool === 'peer-matcher'} 
                onClose={() => setActiveTool(null)} 
                agents={[...new Set([...npsData.map(r => DataEngine.normalizeAgent(r, 'NPS')), ...qcData.map(r => DataEngine.normalizeAgent(r, 'QC'))])].filter(Boolean)}
                npsData={npsData}
                qcData={qcData}
            />
            <FeedbackToneAdjuster 
                isOpen={activeTool === 'tone-adjuster'} 
                onClose={() => setActiveTool(null)} 
            />
            <FeedbackActionExtractor 
                isOpen={activeTool === 'action-extractor'} 
                onClose={() => setActiveTool(null)} 
            />
            <ShadowPairingMatcher 
                isOpen={activeTool === 'shadow-matcher'} 
                onClose={() => setActiveTool(null)} 
                agents={[...new Set([...npsData.map(r => DataEngine.normalizeAgent(r, 'NPS')), ...qcData.map(r => DataEngine.normalizeAgent(r, 'QC'))])].filter(Boolean)}
                npsData={npsData}
                qcData={qcData}
            />
            {/* New AI Tools (Issue #40) */}
            <PDFReportAnalyzer 
                isOpen={activeTool === 'pdf-analyzer'} 
                onClose={() => setActiveTool(null)} 
                npsData={npsData}
                qcData={qcData}
            />
            <SentimentAnalyzer 
                isOpen={activeTool === 'sentiment-analyzer'} 
                onClose={() => setActiveTool(null)} 
                npsData={npsData}
            />
            <TrendForecaster 
                isOpen={activeTool === 'trend-forecaster'} 
                onClose={() => setActiveTool(null)} 
                npsData={npsData}
                qcData={qcData}
            />
            <AgentComparator 
                isOpen={activeTool === 'agent-comparator'} 
                onClose={() => setActiveTool(null)} 
                npsData={npsData}
                qcData={qcData}
                content="Agent comparison data loaded." /* Fix for empty content */
            />
            <ResponseOptimizer 
                isOpen={activeTool === 'response-optimizer'} 
                onClose={() => setActiveTool(null)} 
            />
            <EscalationPredictor 
                isOpen={activeTool === 'escalation-predictor'} 
                onClose={() => setActiveTool(null)} 
                npsData={npsData}
            />
            <CoachScriptGenerator 
                isOpen={activeTool === 'coach-script-generator'} 
                onClose={() => setActiveTool(null)} 
            />
            <PerformanceSummarizer 
                isOpen={activeTool === 'performance-summarizer'} 
                onClose={() => setActiveTool(null)} 
                npsData={npsData}
                qcData={qcData}
            />
            <SlackPostGenerator
                isOpen={activeTool === 'slack-post-generator'}
                onClose={() => setActiveTool(null)}
            />
        </>
        );
    };


        // =============================================================================
        // ADVANCED ANALYTICS & INTELLIGENCE HUB  
        // =============================================================================
        const AdvancedAnalyticsHub = ({ npsData, qcData, onDownloadImage }) => {
            const [activeAnalyticTab, setActiveAnalyticTab] = React.useState('trends');
            const [isAnalyzing, setIsAnalyzing] = React.useState(false);
            const [analysisResults, setAnalysisResults] = React.useState({});

            const trendData = React.useMemo(() => {
                if (!npsData || npsData.length === 0) return [];
                const grouped = {};
                npsData.forEach(row => {
                    const date = row['Date'] || row['Timestamp'];
                    if (!date) return;
                    const dateKey = new Date(date).toISOString().split('T')[0];
                    if (!grouped[dateKey]) {
                        grouped[dateKey] = { date: dateKey, wow: 0, good: 0, ok: 0, poor: 0, total: 0 };
                    }
                    const rating = (row['Rating'] || 'OK').toLowerCase();
                    grouped[dateKey][rating] = (grouped[dateKey][rating] || 0) + 1;
                    grouped[dateKey].total += 1;
                });
                return Object.values(grouped).sort((a, b) => a.date.localeCompare(b.date));
            }, [npsData]);

            const runAnalysis = async (type) => {
                setIsAnalyzing(true);
                let prompt = '';
                if (type === 'correlation') {
                    prompt = `Analyze NPS vs QC correlation. NPS: ${npsData?.length||0} records, QC: ${qcData?.length||0} audits. Provide insights on correlation strength, impact factors, patterns, and recommendations.`;
                } else if (type === 'prediction') {
                    const recent = npsData?.slice(-30) || [];
                    prompt = `Generate predictions based on recent ${recent.length} interactions. Identify at-risk agents, rising stars, emerging issues, and proactive actions needed.`;
                } else if (type === 'recommendations') {
                    prompt = `Generate smart recommendations for ${npsData?.length||0} interactions across multiple agents. Focus on immediate actions, training priorities, recognition, and process improvements.`;
                }
                try {
                    const result = await GeminiAI.generate(prompt);
                    setAnalysisResults(prev => ({ ...prev, [type]: result }));
                } catch (e) {
                    setAnalysisResults(prev => ({ ...prev, [type]: 'Analysis failed. Please try again.' }));
                }
                setIsAnalyzing(false);
            };

            const tabs = [
                { id: 'trends', label: 'Trend Analysis', icon: TrendingUp },
                { id: 'correlations', label: 'Correlations', icon: GitBranch },
                { id: 'predictions', label: 'Predictions', icon: Zap },
                { id: 'comparisons', label: 'Comparisons', icon: BarChart2 },
                { id: 'recommendations', label: 'Recommendations', icon: Lightbulb }
            ];

            return (
                <div className="space-y-6">
                    <div className="bg-gradient-to-r from-purple-600 via-blue-600 to-indigo-600 rounded-2xl p-8 text-white shadow-2xl">
                        <div className="flex items-center gap-4">
                            <div className="w-16 h-16 bg-white/20 backdrop-blur-sm rounded-2xl flex items-center justify-center">
                                <Brain size={36} className="text-white" />
                            </div>
                            <div>
                                <h2 className="text-3xl font-black">Advanced Analytics Hub</h2>
                                <p className="text-purple-100 text-sm mt-1">AI-Powered Insights, Predictions & Intelligence</p>
                            </div>
                        </div>
                    </div>

                    <div className="flex gap-2 overflow-x-auto pb-2">
                        {tabs.map(tab => {
                            const Icon = tab.icon;
                            return (
                                <button key={tab.id} onClick={() => setActiveAnalyticTab(tab.id)}
                                    className={`px-6 py-3 rounded-xl font-bold text-sm flex items-center gap-2 whitespace-nowrap transition-all ${
                                        activeAnalyticTab === tab.id ? 'bg-purple-600 text-white shadow-lg scale-105' : 'bg-white text-slate-600 hover:bg-purple-50 border border-slate-200'
                                    }`}>
                                    <Icon size={16} />
                                    {tab.label}
                                </button>
                            );
                        })}
                    </div>

                    <div className="bg-white rounded-2xl shadow-lg p-6 min-h-[600px]">
                        {activeAnalyticTab === 'trends' && (
                            <div className="space-y-6">
                                <h3 className="text-xl font-bold flex items-center gap-2"><TrendingUp size={20} className="text-purple-600" />Performance Trends</h3>
                                {trendData.length > 0 ? (
                                    <>
                                        <div className="h-80"><ResponsiveContainer width="100%" height="100%"><LineChart data={trendData}><CartesianGrid strokeDasharray="3 3" /><XAxis dataKey="date" /><YAxis /><Tooltip /><Legend /><Line type="monotone" dataKey="wow" stroke="#10b981" strokeWidth={2} name="WOW" /><Line type="monotone" dataKey="good" stroke="#3b82f6" strokeWidth={2} name="Good" /><Line type="monotone" dataKey="ok" stroke="#f59e0b" strokeWidth={2} name="OK" /><Line type="monotone" dataKey="poor" stroke="#ef4444" strokeWidth={2} name="Poor" /></LineChart></ResponsiveContainer></div>
                                        <div className="grid grid-cols-4 gap-4">
                                            {['wow', 'good', 'ok', 'poor'].map(r => {
                                                const latest = trendData[trendData.length-1][r];
                                                const prev = trendData[trendData.length-2]?.[r] || 0;
                                                const change = prev ? (((latest-prev)/prev)*100).toFixed(1) : 0;
                                                const colors = {wow:'bg-green-50 border-green-200',good:'bg-blue-50 border-blue-200',ok:'bg-amber-50 border-amber-200',poor:'bg-red-50 border-red-200'};
                                                return <div key={r} className={`p-4 rounded-xl border-2 ${colors[r]}`}><div className="text-xs font-bold uppercase">{r}</div><div className="text-3xl font-black">{latest}</div><div className="text-xs mt-1 flex items-center gap-1">{change >= 0 ? <TrendingUp size={12}/> : <TrendingDown size={12}/>}{Math.abs(change)}%</div></div>;
                                            })}
                                        </div>
                                    </>
                                ) : <div className="text-center py-20 text-slate-500"><TrendingUp size={48} className="mx-auto mb-4 opacity-50" /><p>No trend data available</p></div>}
                            </div>
                        )}

                        {activeAnalyticTab === 'correlations' && (
                            <div className="space-y-6">
                                <h3 className="text-xl font-bold flex items-center gap-2"><GitBranch size={20} className="text-purple-600" />NPS vs QC Correlation</h3>
                                <button onClick={() => runAnalysis('correlation')} disabled={isAnalyzing} className="px-6 py-3 bg-purple-600 hover:bg-purple-700 text-white rounded-xl font-bold flex items-center gap-2 disabled:opacity-50">
                                    {isAnalyzing ? <Loader size={16} className="animate-spin" /> : <Sparkles size={16} />}
                                    {isAnalyzing ? 'Analyzing...' : 'Run Analysis'}
                                </button>
                                {analysisResults.correlation && <AIOutputWrapper title="Correlation Analysis" text="AI insights on NPS and QC relationships" onRegenerate={() => runAnalysis('correlation')}><div className="prose max-w-none markdown-content" dangerouslySetInnerHTML={{__html: safeMarked(analysisResults.correlation)}} /></AIOutputWrapper>}
                            </div>
                        )}

                        {activeAnalyticTab === 'predictions' && (
                            <div className="space-y-6">
                                <h3 className="text-xl font-bold flex items-center gap-2"><Zap size={20} className="text-purple-600" />Predictive Insights</h3>
                                <button onClick={() => runAnalysis('prediction')} disabled={isAnalyzing} className="px-6 py-3 bg-purple-600 hover:bg-purple-700 text-white rounded-xl font-bold flex items-center gap-2 disabled:opacity-50">
                                    {isAnalyzing ? <Loader size={16} className="animate-spin" /> : <Zap size={16} />}
                                    {isAnalyzing ? 'Predicting...' : 'Generate Predictions'}
                                </button>
                                {analysisResults.prediction && <AIOutputWrapper title="Predictive Insights" text="AI-powered forecasting" onRegenerate={() => runAnalysis('prediction')}><div className="prose max-w-none markdown-content" dangerouslySetInnerHTML={{__html: safeMarked(analysisResults.prediction)}} /></AIOutputWrapper>}
                            </div>
                        )}

                        {activeAnalyticTab === 'comparisons' && (
                            <div className="space-y-6">
                                <h3 className="text-xl font-bold flex items-center gap-2"><BarChart2 size={20} className="text-purple-600" />Time Period Comparison</h3>
                                <div className="grid grid-cols-2 gap-6">
                                    {[{title:'Last 30 Days',data:npsData?.slice(-30),color:'blue'},{title:'Previous 30 Days',data:npsData?.slice(-60,-30),color:'purple'}].map(p => {
                                        const d = p.data || [];
                                        const wowRate = d.length > 0 ? ((d.filter(r=>r.Rating==='WOW').length/d.length)*100).toFixed(1) : 0;
                                        const poorRate = d.length > 0 ? ((d.filter(r=>r.Rating==='Poor').length/d.length)*100).toFixed(1) : 0;
                                        return <div key={p.title} className={`p-6 bg-${p.color}-50 rounded-xl border-2 border-${p.color}-100`}><h4 className="font-bold mb-4">{p.title}</h4><div className="space-y-3"><div className="flex justify-between"><span className="text-sm">Total:</span><span className="font-bold">{d.length}</span></div><div className="flex justify-between"><span className="text-sm">WOW Rate:</span><span className="font-bold text-green-600">{wowRate}%</span></div><div className="flex justify-between"><span className="text-sm">Poor Rate:</span><span className="font-bold text-red-600">{poorRate}%</span></div></div></div>;
                                    })}
                                </div>
                            </div>
                        )}

                        {activeAnalyticTab === 'recommendations' && (
                            <div className="space-y-6">
                                <h3 className="text-xl font-bold flex items-center gap-2"><Lightbulb size={20} className="text-purple-600" />Smart Recommendations</h3>
                                <button onClick={() => runAnalysis('recommendations')} disabled={isAnalyzing} className="px-6 py-3 bg-purple-600 hover:bg-purple-700 text-white rounded-xl font-bold flex items-center gap-2 disabled:opacity-50">
                                    {isAnalyzing ? <Loader size={16} className="animate-spin" /> : <Lightbulb size={16} />}
                                    {isAnalyzing ? 'Generating...' : 'Generate Recommendations'}
                                </button>
                                {analysisResults.recommendations && <AIOutputWrapper title="Smart Recommendations" text="AI-powered actionable recommendations" onRegenerate={() => runAnalysis('recommendations')}><div className="prose max-w-none markdown-content" dangerouslySetInnerHTML={{__html: safeMarked(analysisResults.recommendations)}} /></AIOutputWrapper>}
                            </div>
                        )}
                    </div>

                    <div className="grid grid-cols-4 gap-4">
                        <div className="bg-gradient-to-br from-blue-500 to-blue-600 rounded-xl p-4 text-white"><div className="text-sm opacity-90 mb-1">Total Data Points</div><div className="text-3xl font-black">{(npsData?.length||0)+(qcData?.length||0)}</div></div>
                        <div className="bg-gradient-to-br from-green-500 to-green-600 rounded-xl p-4 text-white"><div className="text-sm opacity-90 mb-1">WOW Rate</div><div className="text-3xl font-black">{npsData?.length>0?((npsData.filter(r=>r.Rating==='WOW').length/npsData.length)*100).toFixed(1):0}%</div></div>
                        <div className="bg-gradient-to-br from-purple-500 to-purple-600 rounded-xl p-4 text-white"><div className="text-sm opacity-90 mb-1">QC Pass Rate</div><div className="text-3xl font-black">{qcData?.length>0?((qcData.filter(r=>r['Pass/Fail']==='Pass').length/qcData.length)*100).toFixed(1):0}%</div></div>
                        <div className="bg-gradient-to-br from-amber-500 to-amber-600 rounded-xl p-4 text-white"><div className="text-sm opacity-90 mb-1">Agents Tracked</div><div className="text-3xl font-black">{new Set([...(npsData?.map(r=>r.Agent)||[]),...(qcData?.map(r=>r['Agent Email'])||[])]).size}</div></div>
                    </div>
                </div>
            );
        };

        // ToolInputPersistence init removed

        const root = createRoot(document.getElementById('root'));
        root.render(
            <ErrorBoundary name="AppRoot">
                <App />
            </ErrorBoundary>
        );
    </script>

    <!-- Manual Babel Compilation Bootloader -->
    <script>
        // Immediate bootloader execution to prevent any import statement errors

        // Disable any automatic script processing immediately
        if (window.Babel) {
            Babel.transformScriptTags = function () {
                return;
            };
        }

        // Suppress import statement errors immediately
        window.addEventListener('error', function (e) {
            if (e.message && (e.message.includes('Cannot use import statement outside a module') ||
                e.message.includes('require is not defined'))) {
                e.preventDefault();
                return false;
            }
        }, true); // Use capture phase to catch errors early
        let compilationStarted = false;

        function compileAndRun() {
            if (compilationStarted) return;
            compilationStarted = true;

            try {
                const codeNode = document.getElementById('main-code');
                if (!codeNode) throw new Error('Main code node not found');
                const code = codeNode.textContent;

                const result = Babel.transform(code, {
                    presets: [['react', { runtime: 'automatic' }]],
                    filename: 'app.js',
                    sourceType: 'module'
                });

                const script = document.createElement('script');
                script.type = 'module';
                script.textContent = result.code;

                // Allow import map to settle
                setTimeout(() => {
                    document.body.appendChild(script);
                    window.appStarted = true;
                }, 100);
            } catch (e) {
                console.error("Critical Startup Error:", e);
                document.body.innerHTML = `<div style="color:#ef4444; padding:2rem; font-family:sans-serif;">
                    <h1 style="font-size:1.5rem; font-weight:700; margin-bottom:1rem;">Startup Failed</h1>
                    <pre style="background:#f8fafc; padding:1rem; border-radius:0.5rem; overflow:auto;">${e.message}</pre>
                </div>`;
            }
        }

        function initCompilation() {
            if (compilationStarted || window.appStarted) return;

            if (window.Babel && typeof window.Babel.transform === 'function') {
                compileAndRun();
            } else {
                let attempts = 0;
                const checkBabel = setInterval(() => {
                    attempts++;
                    if (window.Babel && typeof window.Babel.transform === 'function') {
                        clearInterval(checkBabel);
                        compileAndRun();
                    } else if (attempts > 100) { // 5 seconds
                        clearInterval(checkBabel);
                        console.error('Babel Timeout');
                    }
                }, 50);
            }
        }

        // Initialize on various triggers with the guard protecting multiple execution
        if (document.readyState === 'complete') {
            initCompilation();
        } else {
            window.addEventListener('load', initCompilation);
            document.addEventListener('DOMContentLoaded', initCompilation);
            // Fallback for fast Babel load
            setTimeout(initCompilation, 100);
        }

        window.addEventListener('error', function (e) {
            if (e.message && (e.message.includes('import statement') || e.message.includes('require is not defined'))) {
                e.preventDefault();
                return false;
            }
        });
    </script>
    <style>
        /* CRITICAL CSS OVERRIDES */
        body {
            background: #f8fafc !important;
            color: #0f172a !important;
            font-family: 'Inter', sans-serif !important;
            min-height: 100vh !important;
            overflow-x: hidden !important;
        }

        table td,
        table th {
            padding: 8px 12px !important;
        }

        table {
            width: 100% !important;
            border-collapse: collapse !important;
        }

        .overflow-x-auto {
            overflow-x: auto !important;
        }

        .dark {
            display: none !important;
        }

        main,
        .app-container {
            padding-bottom: 0 !important;
            margin-bottom: 0 !important;
        }

        .glass-card {
            overflow: visible !important;
        }
    </style>

</body>

</html>
